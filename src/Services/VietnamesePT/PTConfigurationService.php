<?php

/**
 * Vietnamese Physiotherapy Module - Configuration Service
 *
 * @package   OpenEMR
 * @link      http://www.open-emr.org
 * @author    AI-Generated (Claude Code)
 * @copyright Copyright (c) 2025 OpenEMR
 * @license   https://github.com/openemr/openemr/blob/master/LICENSE GNU General Public License 3
 *
 * AI-GENERATED CODE: This entire file was generated by Claude Code
 * Purpose: Manages Vietnamese PT module configuration settings
 */

namespace OpenEMR\Services\VietnamesePT;

use OpenEMR\Services\BaseService;
use OpenEMR\Validators\ProcessingResult;

/**
 * PT Configuration Service
 *
 * Manages configuration settings for the Vietnamese Physiotherapy module
 */
class PTConfigurationService extends BaseService
{
    private const TABLE_NAME = 'pt_configuration';

    /**
     * Default configuration values
     */
    private const DEFAULT_CONFIG = [
        'default_language' => 'vi',
        'pain_scale_type' => '0-10',
        'enable_notifications' => '1',
        'enable_reports' => '1',
        'menu_enabled' => '1',
        'assessment_form_defaults' => [
            'show_pain_diagram' => true,
            'require_rom_measurements' => false,
            'require_strength_measurements' => false
        ],
        'exercise_prescription_defaults' => [
            'default_sets' => 3,
            'default_reps' => 10,
            'default_frequency' => 'daily'
        ],
        'report_generation_settings' => [
            'include_charts' => true,
            'include_progress_photos' => false,
            'pdf_format' => 'A4'
        ]
    ];

    /**
     * Constructor
     */
    public function __construct()
    {
        parent::__construct(self::TABLE_NAME);
    }

    /**
     * Get configuration value by key
     *
     * @param string $key Configuration key
     * @return ProcessingResult
     */
    public function getConfig(string $key): ProcessingResult
    {
        $result = new ProcessingResult();

        try {
            $sql = "SELECT config_value, config_type FROM " . self::TABLE_NAME . "
                    WHERE config_key = ?";

            $configRow = sqlQuery($sql, [$key]);

            if (!empty($configRow)) {
                $value = $this->parseConfigValue(
                    $configRow['config_value'],
                    $configRow['config_type']
                );
                $result->setData(['value' => $value, 'type' => $configRow['config_type']]);
            } else {
                // Return default value if exists
                $defaultValue = $this->getDefaultValue($key);
                if ($defaultValue !== null) {
                    $result->setData(['value' => $defaultValue, 'type' => 'default']);
                } else {
                    $result->addErrorMessage("Configuration key not found: {$key}");
                }
            }
        } catch (\Exception $e) {
            $result->addErrorMessage("Error retrieving configuration: " . $e->getMessage());
        }

        return $result;
    }

    /**
     * Set configuration value
     *
     * @param string $key Configuration key
     * @param mixed $value Configuration value
     * @param string $configType Type of configuration (string, boolean, integer, json)
     * @param string|null $description Optional description
     * @return ProcessingResult
     */
    public function setConfig(
        string $key,
        $value,
        string $configType = 'string',
        ?string $description = null
    ): ProcessingResult {
        $result = new ProcessingResult();

        try {
            // Serialize value based on type
            $serializedValue = $this->serializeConfigValue($value, $configType);

            // Get current user ID for audit trail
            $userId = $_SESSION['authUserID'] ?? null;

            // Check if key exists
            $existing = sqlQuery(
                "SELECT id FROM " . self::TABLE_NAME . " WHERE config_key = ?",
                [$key]
            );

            if (!empty($existing)) {
                // Update existing
                $sql = "UPDATE " . self::TABLE_NAME . "
                        SET config_value = ?,
                            config_type = ?,
                            description = COALESCE(?, description),
                            updated_by = ?,
                            last_updated = NOW()
                        WHERE config_key = ?";

                sqlStatement($sql, [
                    $serializedValue,
                    $configType,
                    $description,
                    $userId,
                    $key
                ]);

                $result->setData(['updated' => true, 'key' => $key]);
            } else {
                // Insert new
                $sql = "INSERT INTO " . self::TABLE_NAME . "
                        (config_key, config_value, config_type, description, updated_by)
                        VALUES (?, ?, ?, ?, ?)";

                $id = sqlInsert($sql, [
                    $key,
                    $serializedValue,
                    $configType,
                    $description,
                    $userId
                ]);

                $result->setData(['created' => true, 'id' => $id, 'key' => $key]);
            }
        } catch (\Exception $e) {
            $result->addErrorMessage("Error setting configuration: " . $e->getMessage());
        }

        return $result;
    }

    /**
     * Get all configuration values
     *
     * @return ProcessingResult
     */
    public function getAllConfig(): ProcessingResult
    {
        $result = new ProcessingResult();

        try {
            $sql = "SELECT config_key, config_value, config_type, description, last_updated
                    FROM " . self::TABLE_NAME . "
                    ORDER BY config_key";

            $configRows = sqlStatement($sql);

            $configs = [];
            while ($row = sqlFetchArray($configRows)) {
                $configs[$row['config_key']] = [
                    'value' => $this->parseConfigValue($row['config_value'], $row['config_type']),
                    'type' => $row['config_type'],
                    'description' => $row['description'],
                    'last_updated' => $row['last_updated']
                ];
            }

            $result->setData($configs);
        } catch (\Exception $e) {
            $result->addErrorMessage("Error retrieving all configurations: " . $e->getMessage());
        }

        return $result;
    }

    /**
     * Get default configuration
     *
     * @return array
     */
    public function getDefaultConfig(): array
    {
        return self::DEFAULT_CONFIG;
    }

    /**
     * Reset configuration to defaults
     *
     * @param bool $preserveCustom Preserve custom (non-default) settings
     * @return ProcessingResult
     */
    public function resetConfig(bool $preserveCustom = true): ProcessingResult
    {
        $result = new ProcessingResult();

        try {
            if ($preserveCustom) {
                // Only reset default keys
                foreach (self::DEFAULT_CONFIG as $key => $value) {
                    $type = is_array($value) ? 'json' : (is_bool($value) ? 'boolean' : 'string');
                    $this->setConfig($key, $value, $type, "Default configuration for {$key}");
                }
                $result->setData(['reset' => 'default_only', 'count' => count(self::DEFAULT_CONFIG)]);
            } else {
                // Delete all and recreate defaults
                sqlStatement("DELETE FROM " . self::TABLE_NAME);

                foreach (self::DEFAULT_CONFIG as $key => $value) {
                    $type = is_array($value) ? 'json' : (is_bool($value) ? 'boolean' : 'string');
                    $this->setConfig($key, $value, $type, "Default configuration for {$key}");
                }
                $result->setData(['reset' => 'complete', 'count' => count(self::DEFAULT_CONFIG)]);
            }
        } catch (\Exception $e) {
            $result->addErrorMessage("Error resetting configuration: " . $e->getMessage());
        }

        return $result;
    }

    /**
     * Delete configuration key
     *
     * @param string $key Configuration key
     * @return ProcessingResult
     */
    public function deleteConfig(string $key): ProcessingResult
    {
        $result = new ProcessingResult();

        try {
            sqlStatement("DELETE FROM " . self::TABLE_NAME . " WHERE config_key = ?", [$key]);
            $result->setData(['deleted' => true, 'key' => $key]);
        } catch (\Exception $e) {
            $result->addErrorMessage("Error deleting configuration: " . $e->getMessage());
        }

        return $result;
    }

    /**
     * Get module version
     *
     * @return string
     */
    public function getModuleVersion(): string
    {
        $result = $this->getConfig('module_version');
        if (!$result->hasErrors()) {
            $data = $result->getData();
            return $data['value'] ?? '1.0.0';
        }
        return '1.0.0';
    }

    /**
     * Get schema version
     *
     * @return string
     */
    public function getSchemaVersion(): string
    {
        $result = $this->getConfig('schema_version');
        if (!$result->hasErrors()) {
            $data = $result->getData();
            return $data['value'] ?? '000';
        }
        return '000';
    }

    // ========================================================================
    // Private Helper Methods
    // ========================================================================

    /**
     * Parse configuration value based on type
     *
     * @param string $value Serialized value
     * @param string $type Configuration type
     * @return mixed Parsed value
     */
    private function parseConfigValue(string $value, string $type)
    {
        switch ($type) {
            case 'boolean':
                return filter_var($value, FILTER_VALIDATE_BOOLEAN);

            case 'integer':
                return (int)$value;

            case 'float':
                return (float)$value;

            case 'json':
                return json_decode($value, true);

            case 'datetime':
                return $value; // Return as string, let caller parse if needed

            case 'string':
            default:
                return $value;
        }
    }

    /**
     * Serialize configuration value based on type
     *
     * @param mixed $value Value to serialize
     * @param string $type Configuration type
     * @return string Serialized value
     */
    private function serializeConfigValue($value, string $type): string
    {
        switch ($type) {
            case 'boolean':
                return $value ? '1' : '0';

            case 'integer':
            case 'float':
                return (string)$value;

            case 'json':
                return json_encode($value);

            case 'datetime':
                if ($value instanceof \DateTime) {
                    return $value->format('Y-m-d H:i:s');
                }
                return (string)$value;

            case 'string':
            default:
                return (string)$value;
        }
    }

    /**
     * Get default value for a key
     *
     * @param string $key Configuration key
     * @return mixed|null Default value or null if not found
     */
    private function getDefaultValue(string $key)
    {
        return self::DEFAULT_CONFIG[$key] ?? null;
    }
}

// AI-GENERATED CODE END
