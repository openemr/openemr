# Automatically backports merged dependabot PRs to target branches
#
# This workflow:
# 1. Triggers when a PR is merged to master (automatic)
# 2. Can be manually triggered for any closed dependabot PR (manual)
# 3. Only runs for dependabot PRs
# 4. Attempts to backport via cherry-pick first
# 5. Falls back to package manager updates if cherry-pick fails (composer, npm)
# 6. Creates backport PRs with same labels plus 'backport'
# 7. Creates issues for failed backports
#
# Supported ecosystems: composer (PHP), npm (JavaScript), github-actions, docker-compose
# Note: github-actions and docker-compose rely on cherry-pick (no package manager fallback)
#
# To add more target branches, add them to the matrix.target_branch array below
# To manually trigger: Go to Actions tab → Dependabot Backport → Run workflow → Enter PR number

name: Dependabot Backport

on:
  pull_request_target:
    types: [closed]
    branches:
      - master
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number to backport (must be a merged dependabot PR)'
        required: true
        type: number

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  backport:
    runs-on: ubuntu-24.04
    strategy:
      fail-fast: false
      matrix:
        target_branch:
          - rel-704
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Fetch PR information (for workflow_dispatch)
        id: fetch-pr
        if: github.event_name == 'workflow_dispatch'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_NUMBER="${{ inputs.pr_number }}"
          echo "Fetching PR #${PR_NUMBER}..."
          
          # Fetch PR data using GitHub CLI
          PR_DATA=$(gh pr view "$PR_NUMBER" --json number,title,author,labels,mergeCommit,merged,body)
          
          # Check if PR was merged
          IS_MERGED=$(echo "$PR_DATA" | jq -r '.merged')
          if [[ "$IS_MERGED" != "true" ]]; then
            echo "::error::PR #${PR_NUMBER} is not merged. Only merged PRs can be backported."
            exit 1
          fi
          
          # Check if PR is from dependabot
          AUTHOR=$(echo "$PR_DATA" | jq -r '.author.login')
          if [[ "$AUTHOR" != "dependabot[bot]" ]]; then
            echo "::error::PR #${PR_NUMBER} is not from dependabot (author: ${AUTHOR}). Only dependabot PRs can be backported."
            exit 1
          fi
          
          echo "pr_data<<EOF" >> $GITHUB_OUTPUT
          echo "$PR_DATA" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Extract PR information
        id: pr-info
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Determine the source of PR data
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            # Use fetched PR data for manual trigger
            PR_DATA='${{ steps.fetch-pr.outputs.pr_data }}'
            
            PR_NUMBER=$(echo "$PR_DATA" | jq -r '.number')
            PR_TITLE=$(echo "$PR_DATA" | jq -r '.title')
            PR_BODY=$(echo "$PR_DATA" | jq -r '.body // ""')
            MERGE_COMMIT=$(echo "$PR_DATA" | jq -r '.mergeCommit.oid')
            AUTHOR=$(echo "$PR_DATA" | jq -r '.author.login')
            
            # Extract labels
            LABEL_NAMES=$(echo "$PR_DATA" | jq -r '.labels[].name' | tr '\n' ',' | sed 's/,$//')
          else
            # Use event data for automatic trigger
            # First check if PR was merged and is from dependabot
            if [[ "${{ github.event.pull_request.merged }}" != "true" ]]; then
              echo "::notice::PR was closed but not merged, skipping backport"
              exit 0
            fi
            
            AUTHOR="${{ github.event.pull_request.user.login }}"
            if [[ "$AUTHOR" != "dependabot[bot]" ]] && [[ "${{ github.actor }}" != "dependabot[bot]" ]]; then
              echo "::notice::PR is not from dependabot, skipping backport"
              exit 0
            fi
            
            PR_NUMBER="${{ github.event.pull_request.number }}"
            PR_TITLE="${{ github.event.pull_request.title }}"
            PR_BODY="${{ github.event.pull_request.body }}"
            MERGE_COMMIT="${{ github.event.pull_request.merge_commit_sha }}"
            
            # Extract labels from the original PR
            LABELS='${{ toJSON(github.event.pull_request.labels) }}'
            LABEL_NAMES=$(echo "$LABELS" | jq -r '.[].name' | tr '\n' ',' | sed 's/,$//')
          fi
          
          echo "labels=${LABEL_NAMES},backport" >> $GITHUB_OUTPUT
          echo "pr_number=${PR_NUMBER}" >> $GITHUB_OUTPUT
          echo "pr_title=${PR_TITLE}" >> $GITHUB_OUTPUT
          echo "merge_commit=${MERGE_COMMIT}" >> $GITHUB_OUTPUT
          echo "pr_author=${AUTHOR}" >> $GITHUB_OUTPUT
          
          # Store PR body for later use (escape for multiline)
          echo "pr_body<<EOF" >> $GITHUB_OUTPUT
          echo "$PR_BODY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          # Detect package ecosystem from labels
          if echo "$LABEL_NAMES" | grep -q "php"; then
            echo "ecosystem=composer" >> $GITHUB_OUTPUT
          elif echo "$LABEL_NAMES" | grep -q "javascript"; then
            echo "ecosystem=npm" >> $GITHUB_OUTPUT
          elif echo "$LABEL_NAMES" | grep -q "github-actions"; then
            echo "ecosystem=github-actions" >> $GITHUB_OUTPUT
          elif echo "$LABEL_NAMES" | grep -q "docker"; then
            echo "ecosystem=docker" >> $GITHUB_OUTPUT
          else
            echo "ecosystem=unknown" >> $GITHUB_OUTPUT
          fi

      - name: Create backport branch
        id: create-branch
        run: |
          BACKPORT_BRANCH="backport/pr-${{ steps.pr-info.outputs.pr_number }}-to-${{ matrix.target_branch }}"
          echo "branch_name=${BACKPORT_BRANCH}" >> $GITHUB_OUTPUT
          
          # Checkout the target branch and create backport branch
          git fetch origin ${{ matrix.target_branch }}
          git checkout -b ${BACKPORT_BRANCH} origin/${{ matrix.target_branch }}

      - name: Attempt cherry-pick
        id: cherry-pick
        continue-on-error: true
        run: |
          git cherry-pick ${{ steps.pr-info.outputs.merge_commit }}
          echo "success=true" >> $GITHUB_OUTPUT

      - name: Setup PHP (if needed for fallback)
        if: steps.cherry-pick.outcome == 'failure' && steps.pr-info.outputs.ecosystem == 'composer'
        uses: shivammathur/setup-php@v2
        with:
          php-version: '8.2'
          coverage: none

      - name: Setup Node.js (if needed for fallback)
        if: steps.cherry-pick.outcome == 'failure' && steps.pr-info.outputs.ecosystem == 'npm'
        uses: actions/setup-node@v6
        with:
          node-version: '22'

      - name: Fallback - Apply update via package manager
        id: package-manager-update
        if: steps.cherry-pick.outcome == 'failure'
        continue-on-error: true
        run: |
          # Reset the failed cherry-pick
          git cherry-pick --abort 2>/dev/null || true
          git reset --hard HEAD
          
          # Extract package and version information from the PR title
          PR_TITLE="${{ steps.pr-info.outputs.pr_title }}"
          ECOSYSTEM="${{ steps.pr-info.outputs.ecosystem }}"
          
          echo "PR Title: $PR_TITLE"
          echo "Ecosystem: $ECOSYSTEM"
          
          # Try to extract package updates from the dependabot PR
          # Dependabot PR titles follow patterns like:
          # "chore(deps): bump package-name from x.y.z to a.b.c"
          # "chore(deps): bump package-name from x.y.z to a.b.c in /directory"
          
          if [[ "$ECOSYSTEM" == "composer" ]]; then
            echo "Attempting composer update..."
            
            # Extract package name - handle various patterns including vendor/package
            # Pattern matches: bump <package> from <version> to <version>
            if [[ "$PR_TITLE" =~ bump\ ([^[:space:]]+)\ from\ ([^[:space:]]+)\ to\ ([^[:space:]]+) ]]; then
              PACKAGE="${BASH_REMATCH[1]}"
              VERSION="${BASH_REMATCH[3]}"
              
              echo "Extracted: Package=$PACKAGE, Version=$VERSION"
              echo "Updating $PACKAGE to $VERSION"
              composer require "$PACKAGE:$VERSION" --no-interaction --no-progress || exit 1
              git add composer.json composer.lock
              git commit -m "chore(deps): bump $PACKAGE to $VERSION (backport #${{ steps.pr-info.outputs.pr_number }})" || exit 1
              echo "success=true" >> $GITHUB_OUTPUT
            else
              echo "Could not extract package information from PR title: $PR_TITLE"
              exit 1
            fi
            
          elif [[ "$ECOSYSTEM" == "npm" ]]; then
            echo "Attempting npm update..."
            
            # Extract package name and version - handles scoped packages like @scope/package
            # Pattern matches: bump <package> from <version> to <version>
            if [[ "$PR_TITLE" =~ bump\ ([^[:space:]]+)\ from\ ([^[:space:]]+)\ to\ ([^[:space:]]+) ]]; then
              PACKAGE="${BASH_REMATCH[1]}"
              VERSION="${BASH_REMATCH[3]}"
              
              echo "Extracted: Package=$PACKAGE, Version=$VERSION"
              echo "Updating $PACKAGE to $VERSION"
              
              # Detect if it's a dev dependency by checking package.json with jq
              # This handles scoped packages correctly
              if jq -e --arg pkg "$PACKAGE" '.devDependencies[$pkg]' package.json > /dev/null 2>&1; then
                echo "Installing as dev dependency"
                npm install "$PACKAGE@$VERSION" --save-dev --save-exact || exit 1
              elif jq -e --arg pkg "$PACKAGE" '.dependencies[$pkg]' package.json > /dev/null 2>&1; then
                echo "Installing as regular dependency"
                npm install "$PACKAGE@$VERSION" --save-exact || exit 1
              else
                # If not found in package.json, try as regular dependency first
                echo "Package not found in package.json, trying as regular dependency"
                npm install "$PACKAGE@$VERSION" --save-exact 2>/dev/null || \
                npm install "$PACKAGE@$VERSION" --save-dev --save-exact || exit 1
              fi
              
              git add package.json package-lock.json
              git commit -m "chore(deps): bump $PACKAGE to $VERSION (backport #${{ steps.pr-info.outputs.pr_number }})" || exit 1
              echo "success=true" >> $GITHUB_OUTPUT
            else
              echo "Could not extract package information from PR title: $PR_TITLE"
              exit 1
            fi
            
          elif [[ "$ECOSYSTEM" == "github-actions" ]] || [[ "$ECOSYSTEM" == "docker" ]]; then
            echo "Ecosystem $ECOSYSTEM does not support package manager fallback"
            echo "GitHub Actions and Docker updates are typically simple file changes that should cherry-pick cleanly"
            echo "If cherry-pick failed, this likely requires manual intervention"
            exit 1
            
          else
            echo "Ecosystem $ECOSYSTEM is not recognized or not supported for automatic fallback"
            echo "Supported ecosystems: composer, npm, github-actions, docker"
            exit 1
          fi

      - name: Push backport branch
        if: steps.cherry-pick.outcome == 'success' || steps.package-manager-update.outcome == 'success'
        run: |
          git push origin ${{ steps.create-branch.outputs.branch_name }}

      - name: Create backport PR
        if: steps.cherry-pick.outcome == 'success' || steps.package-manager-update.outcome == 'success'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Determine the method used
          if [[ "${{ steps.cherry-pick.outcome }}" == "success" ]]; then
            METHOD="cherry-pick"
          else
            METHOD="package manager update"
          fi
          
          # Create PR body
          cat > /tmp/pr_body.md << EOF
          Automated backport of #${{ steps.pr-info.outputs.pr_number }} to \`${{ matrix.target_branch }}\`.
          
          **Original PR:** ${{ steps.pr-info.outputs.pr_title }}
          **Method:** ${METHOD}
          **Original Author:** @${{ steps.pr-info.outputs.pr_author }}
          ${{ github.event_name == 'workflow_dispatch' && '**Trigger:** Manual workflow dispatch' || '' }}
          
          ---
          
          ${{ steps.pr-info.outputs.pr_body }}
          EOF
          
          # Create the PR
          gh pr create \
            --base "${{ matrix.target_branch }}" \
            --head "${{ steps.create-branch.outputs.branch_name }}" \
            --title "[${{ matrix.target_branch }}] ${{ steps.pr-info.outputs.pr_title }}" \
            --body-file /tmp/pr_body.md \
            --label "${{ steps.pr-info.outputs.labels }}"

      - name: Report failure
        if: steps.cherry-pick.outcome == 'failure' && steps.package-manager-update.outcome == 'failure'
        run: |
          echo "::error::Failed to backport PR #${{ steps.pr-info.outputs.pr_number }} to ${{ matrix.target_branch }}"
          echo "::error::Cherry-pick failed and package manager update fallback also failed"
          echo "::error::Manual backport may be required"
          
          # Create an issue to track the failed backport
          PR_URL="https://github.com/${{ github.repository }}/pull/${{ steps.pr-info.outputs.pr_number }}"
          cat > /tmp/issue_body.md << EOF
          ## Failed Automatic Backport
          
          **Original PR:** #${{ steps.pr-info.outputs.pr_number }}
          **Target Branch:** \`${{ matrix.target_branch }}\`
          **PR Title:** ${{ steps.pr-info.outputs.pr_title }}
          ${{ github.event_name == 'workflow_dispatch' && '**Trigger:** Manual workflow dispatch' || '**Trigger:** Automatic on PR merge' }}
          
          The automated backport process failed for both:
          1. Cherry-pick method
          2. Package manager update fallback
          
          This likely requires manual intervention. Please review and manually backport if needed.
          
          **Original PR Link:** ${PR_URL}
          EOF
          
          if ! gh issue create \
            --title "Failed backport: ${{ steps.pr-info.outputs.pr_title }} to ${{ matrix.target_branch }}" \
            --body-file /tmp/issue_body.md \
            --label "backport,failed-automation"; then
            echo "::warning::Could not create GitHub issue for failed backport tracking. Please check permissions or rate limits."
          fi
          
          exit 1
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
