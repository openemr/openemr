# Automatically backports merged dependabot PRs to target branches
#
# This workflow:
# 1. Triggers when a PR is merged to master (automatic)
# 2. Can be manually triggered for any closed dependabot PR (manual)
# 3. Only runs for dependabot PRs
# 4. Attempts to backport via cherry-pick first
# 5. Falls back to package manager updates if cherry-pick fails (composer, npm)
# 6. Creates backport PRs with same labels plus 'backport'
# 7. Creates issues for failed backports
#
# Supported ecosystems: composer (PHP), npm (JavaScript), github-actions, docker
# Note: github-actions and docker rely on cherry-pick (no package manager fallback)
#
# To add more target branches, add them to the matrix.target_branch array below
# To manually trigger: Go to Actions tab → Dependabot Backport → Run workflow → Enter PR number

name: Dependabot Backport

on:
  pull_request_target:
    types: [closed]
    branches:
      - master
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number to backport (must be a merged dependabot PR)'
        required: true
        type: number

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  backport:
    runs-on: ubuntu-24.04
    strategy:
      fail-fast: false
      matrix:
        target_branch:
          - rel-704
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Fetch PR information (for workflow_dispatch)
        id: fetch-pr
        if: github.event_name == 'workflow_dispatch'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_NUMBER="${{ inputs.pr_number }}"
          echo "Fetching PR #${PR_NUMBER}..."
          
          # Fetch PR data using GitHub CLI and output to GITHUB_OUTPUT
          {
            echo 'pr_data<<EOF'
            gh pr view "$PR_NUMBER" --json number,title,author,labels,mergeCommit,merged,body
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"

      - name: Check if PR was merged (workflow_dispatch)
        if: github.event_name == 'workflow_dispatch' && fromJSON(steps.fetch-pr.outputs.pr_data).merged != true
        run: |
          echo "::error::PR #${{ inputs.pr_number }} is not merged. Only merged PRs can be backported."
          exit 1

      - name: Check if PR is from dependabot (workflow_dispatch)
        if: github.event_name == 'workflow_dispatch' && fromJSON(steps.fetch-pr.outputs.pr_data).author.login != 'dependabot[bot]'
        run: |
          echo "::error::PR #${{ inputs.pr_number }} is not from dependabot (author: ${{ fromJSON(steps.fetch-pr.outputs.pr_data).author.login }}). Only dependabot PRs can be backported."
          exit 1

      - name: Validate pull_request_target event
        if: github.event_name == 'pull_request_target'
        run: |
          # Check if PR was merged
          if [[ "${{ github.event.pull_request.merged }}" != "true" ]]; then
            echo "::notice::PR was closed but not merged, skipping backport"
            exit 0
          fi
          
          # Check if PR is from dependabot
          if [[ "${{ github.event.pull_request.user.login }}" != "dependabot[bot]" ]]; then
            echo "::notice::PR is not from dependabot, skipping backport"
            exit 0
          fi

      - name: Extract PR information
        id: pr-info
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Determine the source of PR data
          if [[ "${{ github.event_name }}" = "workflow_dispatch" ]]; then
            # Use fetched PR data for manual trigger
            PR_DATA='${{ steps.fetch-pr.outputs.pr_data }}'
            
            PR_NUMBER=$(echo "$PR_DATA" | jq -r '.number')
            PR_TITLE=$(echo "$PR_DATA" | jq -r '.title')
            PR_BODY=$(echo "$PR_DATA" | jq -r '.body // ""')
            MERGE_COMMIT=$(echo "$PR_DATA" | jq -r '.mergeCommit.oid')
            AUTHOR=$(echo "$PR_DATA" | jq -r '.author.login')
            
            # Extract labels using jq
            LABEL_NAMES=$(jq -cr '.labels | map(.name) | join(",")' <<< "$PR_DATA")
          else
            # Use event data for automatic trigger
            PR_NUMBER="${{ github.event.pull_request.number }}"
            PR_TITLE="${{ github.event.pull_request.title }}"
            PR_BODY="${{ github.event.pull_request.body }}"
            MERGE_COMMIT="${{ github.event.pull_request.merge_commit_sha }}"
            AUTHOR="${{ github.event.pull_request.user.login }}"
            
            # Extract labels using GitHub's toJSON function and jq
            LABELS='${{ toJSON(github.event.pull_request.labels) }}'
            LABEL_NAMES=$(jq -cr 'map(.name) | join(",")' <<< "$LABELS")
          fi
          
          echo "labels=${LABEL_NAMES},backport" >> $GITHUB_OUTPUT
          echo "pr_number=${PR_NUMBER}" >> $GITHUB_OUTPUT
          echo "pr_title=${PR_TITLE}" >> $GITHUB_OUTPUT
          echo "merge_commit=${MERGE_COMMIT}" >> $GITHUB_OUTPUT
          echo "pr_author=${AUTHOR}" >> $GITHUB_OUTPUT
          
          # Store PR body for later use (escape for multiline)
          echo "pr_body<<EOF" >> $GITHUB_OUTPUT
          echo "$PR_BODY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          # Detect package ecosystem from labels
          # Note: docker-compose ecosystem uses the "docker" label per dependabot.yml config
          case "$LABEL_NAMES" in
              *php*) 
                  echo 'ecosystem=composer' >> "$GITHUB_OUTPUT"
                  ;;
              *javascript*) 
                  echo 'ecosystem=npm' >> "$GITHUB_OUTPUT"
                  ;;
              *github-actions*) 
                  echo 'ecosystem=github-actions' >> "$GITHUB_OUTPUT"
                  ;;
              *docker*) 
                  echo 'ecosystem=docker' >> "$GITHUB_OUTPUT"
                  ;;
              *) 
                  echo 'ecosystem=unknown' >> "$GITHUB_OUTPUT"
                  ;;
          esac

      - name: Create backport branch
        id: create-branch
        run: |
          BACKPORT_BRANCH="backport/pr-${{ steps.pr-info.outputs.pr_number }}-to-${{ matrix.target_branch }}"
          echo "branch_name=${BACKPORT_BRANCH}" >> $GITHUB_OUTPUT
          
          # Checkout the target branch and create backport branch
          git fetch origin ${{ matrix.target_branch }}
          git checkout -b ${BACKPORT_BRANCH} origin/${{ matrix.target_branch }}

      - name: Attempt cherry-pick
        id: cherry-pick
        continue-on-error: true
        run: |
          git cherry-pick ${{ steps.pr-info.outputs.merge_commit }}
          echo "success=true" >> $GITHUB_OUTPUT

      - name: Setup PHP (for composer fallback)
        if: steps.cherry-pick.outcome == 'failure' && steps.pr-info.outputs.ecosystem == 'composer'
        uses: shivammathur/setup-php@v2
        with:
          php-version: '8.2'
          coverage: none

      - name: Fallback - Composer update
        id: composer-update
        if: steps.cherry-pick.outcome == 'failure' && steps.pr-info.outputs.ecosystem == 'composer'
        continue-on-error: true
        run: |
          # Reset the failed cherry-pick
          git cherry-pick --abort 2>/dev/null || true
          git reset --hard HEAD
          
          PR_TITLE="${{ steps.pr-info.outputs.pr_title }}"
          echo "PR Title: $PR_TITLE"
          echo "Attempting composer update..."
          
          # Extract package name and version - handles vendor/package format
          # Pattern matches: bump <package> from <version> to <version>
          if [[ "$PR_TITLE" =~ bump\ ([^[:space:]]+)\ from\ ([^[:space:]]+)\ to\ ([^[:space:]]+) ]]; then
            PACKAGE="${BASH_REMATCH[1]}"
            VERSION="${BASH_REMATCH[3]}"
            
            echo "Extracted: Package=$PACKAGE, Version=$VERSION"
            echo "Updating $PACKAGE to $VERSION"
            composer require "$PACKAGE:$VERSION" --no-interaction --no-progress || exit 1
            git add composer.json composer.lock
            git commit -m "chore(deps): bump $PACKAGE to $VERSION (backport #${{ steps.pr-info.outputs.pr_number }})" || exit 1
            echo "success=true" >> $GITHUB_OUTPUT
          else
            echo "Could not extract package information from PR title: $PR_TITLE"
            exit 1
          fi

      - name: Setup Node.js (for npm fallback)
        if: steps.cherry-pick.outcome == 'failure' && steps.pr-info.outputs.ecosystem == 'npm'
        uses: actions/setup-node@v6
        with:
          node-version: '22'

      - name: Fallback - npm update
        id: npm-update
        if: steps.cherry-pick.outcome == 'failure' && steps.pr-info.outputs.ecosystem == 'npm'
        continue-on-error: true
        run: |
          # Reset the failed cherry-pick
          git cherry-pick --abort 2>/dev/null || true
          git reset --hard HEAD
          
          PR_TITLE="${{ steps.pr-info.outputs.pr_title }}"
          echo "PR Title: $PR_TITLE"
          echo "Attempting npm update..."
          
          # Extract package name and version - handles scoped packages like @scope/package
          # Pattern matches: bump <package> from <version> to <version>
          if [[ "$PR_TITLE" =~ bump\ ([^[:space:]]+)\ from\ ([^[:space:]]+)\ to\ ([^[:space:]]+) ]]; then
            PACKAGE="${BASH_REMATCH[1]}"
            VERSION="${BASH_REMATCH[3]}"
            
            echo "Extracted: Package=$PACKAGE, Version=$VERSION"
            echo "Updating $PACKAGE to $VERSION"
            
            # Detect if it's a dev dependency by checking package.json with jq
            # This handles scoped packages correctly
            if jq -e --arg pkg "$PACKAGE" '.devDependencies[$pkg]' package.json > /dev/null 2>&1; then
              echo "Installing as dev dependency"
              npm install "$PACKAGE@$VERSION" --save-dev --save-exact || exit 1
            elif jq -e --arg pkg "$PACKAGE" '.dependencies[$pkg]' package.json > /dev/null 2>&1; then
              echo "Installing as regular dependency"
              npm install "$PACKAGE@$VERSION" --save-exact || exit 1
            else
              # If not found in package.json, try as regular dependency first
              echo "Package not found in package.json, trying as regular dependency"
              npm install "$PACKAGE@$VERSION" --save-exact 2>/dev/null || \
              npm install "$PACKAGE@$VERSION" --save-dev --save-exact || exit 1
            fi
            
            git add package.json package-lock.json
            git commit -m "chore(deps): bump $PACKAGE to $VERSION (backport #${{ steps.pr-info.outputs.pr_number }})" || exit 1
            echo "success=true" >> $GITHUB_OUTPUT
          else
            echo "Could not extract package information from PR title: $PR_TITLE"
            exit 1
          fi

      - name: Report unsupported fallback
        if: |
          steps.cherry-pick.outcome == 'failure' && 
          (steps.pr-info.outputs.ecosystem == 'github-actions' || steps.pr-info.outputs.ecosystem == 'docker')
        run: |
          echo "::warning::Ecosystem ${{ steps.pr-info.outputs.ecosystem }} does not support package manager fallback"
          echo "::warning::GitHub Actions and Docker/Docker-compose updates are typically simple file changes that should cherry-pick cleanly"
          echo "::warning::Cherry-pick failed - manual intervention required"

      - name: Push backport branch
        if: |
          steps.cherry-pick.outcome == 'success' || 
          steps.composer-update.outcome == 'success' || 
          steps.npm-update.outcome == 'success'
        run: |
          git push origin ${{ steps.create-branch.outputs.branch_name }}

      - name: Create backport PR
        if: |
          steps.cherry-pick.outcome == 'success' || 
          steps.composer-update.outcome == 'success' || 
          steps.npm-update.outcome == 'success'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Determine the method used
          if [[ "${{ steps.cherry-pick.outcome }}" = "success" ]]; then
            METHOD="cherry-pick"
          else
            METHOD="package manager update"
          fi
          
          # Create PR body
          cat > /tmp/pr_body.md << EOF
          Automated backport of #${{ steps.pr-info.outputs.pr_number }} to \`${{ matrix.target_branch }}\`.
          
          **Original PR:** ${{ steps.pr-info.outputs.pr_title }}
          **Method:** ${METHOD}
          **Original Author:** @${{ steps.pr-info.outputs.pr_author }}
          ${{ github.event_name == 'workflow_dispatch' && '**Trigger:** Manual workflow dispatch' || '' }}
          
          ---
          
          ${{ steps.pr-info.outputs.pr_body }}
          EOF
          
          # Create the PR
          gh pr create \
            --base "${{ matrix.target_branch }}" \
            --head "${{ steps.create-branch.outputs.branch_name }}" \
            --title "[${{ matrix.target_branch }}] ${{ steps.pr-info.outputs.pr_title }}" \
            --body-file /tmp/pr_body.md \
            --label "${{ steps.pr-info.outputs.labels }}"

      - name: Report failure
        if: |
          steps.cherry-pick.outcome == 'failure' && 
          ((steps.pr-info.outputs.ecosystem == 'composer' && steps.composer-update.outcome == 'failure') || 
           (steps.pr-info.outputs.ecosystem == 'npm' && steps.npm-update.outcome == 'failure') ||
           steps.pr-info.outputs.ecosystem == 'github-actions' ||
           steps.pr-info.outputs.ecosystem == 'docker' ||
           steps.pr-info.outputs.ecosystem == 'unknown')
        run: |
          echo "::error::Failed to backport PR #${{ steps.pr-info.outputs.pr_number }} to ${{ matrix.target_branch }}"
          echo "::error::Cherry-pick failed and package manager update fallback also failed"
          echo "::error::Manual backport may be required"
          
          # Create an issue to track the failed backport
          PR_URL="https://github.com/${{ github.repository }}/pull/${{ steps.pr-info.outputs.pr_number }}"
          cat > /tmp/issue_body.md << EOF
          ## Failed Automatic Backport
          
          **Original PR:** #${{ steps.pr-info.outputs.pr_number }}
          **Target Branch:** \`${{ matrix.target_branch }}\`
          **PR Title:** ${{ steps.pr-info.outputs.pr_title }}
          ${{ github.event_name == 'workflow_dispatch' && '**Trigger:** Manual workflow dispatch' || '**Trigger:** Automatic on PR merge' }}
          
          The automated backport process failed for both:
          1. Cherry-pick method
          2. Package manager update fallback
          
          This likely requires manual intervention. Please review and manually backport if needed.
          
          **Original PR Link:** ${PR_URL}
          EOF
          
          if ! gh issue create \
            --title "Failed backport: ${{ steps.pr-info.outputs.pr_title }} to ${{ matrix.target_branch }}" \
            --body-file /tmp/issue_body.md \
            --label "backport,failed-automation"; then
            echo "::warning::Could not create GitHub issue for failed backport tracking. Please check permissions or rate limits."
          fi
          
          exit 1
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
