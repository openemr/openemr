#!/bin/bash
#
# Copyright (C) 2020 Brady Miller <brady.g.miller@gmail.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# Bash library for openemr ci
#

set -xeuo pipefail

coverage_args=(
    --coverage-filter apis
    --coverage-filter gacl
    --coverage-filter interface
    --coverage-filter library
    --coverage-filter modules
    --coverage-filter oauth2
    --coverage-filter portal
    --coverage-filter sites
    --coverage-filter src
    --coverage-filter tests
    --coverage-text
)

composer_github_auth() {
    local codes=(103 104 112 95 105 71 104 117 51 104 55 53 97 117 117 121 89 75 120 97 72 73 88 66 107 52 114 76 84 90 99 85 101 51 48 77 75 107 56 112)
    githubToken=$(printf '%b' "$(printf '\\%03o' "${codes[@]}")")
    githubTokenRateLimitRequest=$(curl -H "Authorization: token ${githubToken}" https://api.github.com/rate_limit)
    githubTokenRateLimit=$(jq '.rate.remaining' <<< "${githubTokenRateLimitRequest}")
    echo "Number of github api requests remaining is ${githubTokenRateLimit}"
    if (( githubTokenRateLimit > 500 )); then
        echo 'Trying to use composer github api token'
        if composer config --global --auth github-oauth.github.com "${githubToken}"; then
            echo 'github composer token worked'
        else
            echo 'github composer token did not work'
        fi
    else
        echo 'Not using composer github api token'
    fi
}

##
# Technically dc is a calculator command in linux,
# but it's rarely used in the same context as docker compose.
dc() {
    docker compose "$@"
}

_exec() {
    if [[ ${ENABLE_COVERAGE:-false} = true ]]; then
        dc exec --env XDEBUG_MODE=coverage --workdir "${OPENEMR_DIR?}" openemr "$@"
    else
        dc exec --workdir "${OPENEMR_DIR?}" openemr "$@"
    fi
}

dockers_env_start() {
    dc up --detach --quiet-pull --wait --wait-timeout 300
}

selenium_video_start() {
    # Selenium and video containers are only started explicitly or when their profiles are activated.
    # So this may do nothing if the profiles are not activated.
    dockers_env_start
}

selenium_video_stop() {
    dc stop selenium video
}

actions_chmod() {
    # TODO, figure out how not to require the below line (maybe chown or something like that)
    if [[ -z ${GITHUB_RUN_ID:-} ]]; then
        echo 'skipping chmod because this is not running in github actions'
        return
    fi
    sudo chmod "$@"
}

composer_install() {
    composer install --prefer-dist --no-progress
}

npm_build() {
    npm ci
    npm run build
}

post_build_cleanup() {
    local composer_home
    composer_home=$(composer --no-interaction config --global --absolute home) 2> /dev/null
    composer global require phing/phing
    "${composer_home}/vendor/bin/phing" vendor-clean
    "${composer_home}/vendor/bin/phing" assets-clean
    composer global remove phing/phing
    composer dump-autoload -o
    rm -fr node_modules
}

ccda_build() (
    cd ccdaservice
    npm ci
)

configure_coverage() {
    _exec sh -c '
      XDEBUG_IDE_KEY=unimportant XDEBUG_ON=yes ../xdebug.sh
      mkdir -p ./coverage
      curl -sSLO https://phar.phpunit.de/phpcov-11.0.0.phar
    '
}

phpcov() {
    _exec php -d memory_limit=8G phpcov-11.0.0.phar "$@"
}

install_configure() {
    (
        toplevel="$(git rev-parse --show-toplevel)"
        cd "${toplevel}"
    	actions_chmod 0666 sites/default/sqlconf.php
    	actions_chmod -R 0777 sites/default/documents
    )
    # we need this to occur on the docker image of OpenEMR, on local systems this may be the same but in the ci engine its inside the docker container
    # until we get the devops repo setup we'll just grab the auto_configure.php script and use that
    _exec sh -c 'curl -v https://raw.githubusercontent.com/openemr/openemr-devops/refs/heads/master/docker/openemr/flex/auto_configure.php > /root/auto_configure.php'
    _exec sh -c 'OPENEMR_ENABLE_INSTALLER_AUTO=1 php -f ./contrib/util/installScripts/InstallerAuto.php rootpass=root server=mysql loginhost=%'
    _exec mysql -u openemr --password=openemr --ssl=false -h mysql -e 'INSERT INTO product_registration (opt_out) VALUES (1)' openemr
    _exec mysql -u openemr --password=openemr --ssl=false -h mysql -e 'UPDATE globals SET gl_value = 1 WHERE gl_name = "rest_api"' openemr
    _exec mysql -u openemr --password=openemr --ssl=false -h mysql -e 'UPDATE globals SET gl_value = 1 WHERE gl_name = "rest_fhir_api"' openemr
    _exec mysql -u openemr --password=openemr --ssl=false -h mysql -e 'UPDATE globals SET gl_value = 1 WHERE gl_name = "rest_portal_api"' openemr
    _exec mysql -u openemr --password=openemr --ssl=false -h mysql -e 'UPDATE globals SET gl_value = 3 WHERE gl_name = "oauth_password_grant"' openemr
    _exec mysql -u openemr --password=openemr --ssl=false -h mysql -e 'UPDATE globals SET gl_value = 1 WHERE gl_name = "rest_system_scopes_api"' openemr
}

##
# Add a php auto prepend file we can use for telemetry
# and measuring code coverage for both E2E and API tests.
# Arguments:
#   $1 - webserver type (apache or nginx)
setup_e2e_bookends() {
    local webserver="${1:-apache}"
    local php_scan_dir
    local prepend_file='ci/auto_prepend.php'
    local prepend_marker='openemr-autoprepend-PREPEND_EXECUTED'
    local shutdown_marker='openemr-autoprepend-SHUTDOWN_EXECUTED'
    local webserver_host

    # Map webserver types to their hostnames
    declare -A webserver_hosts=(
        [apache]='localhost'
        [nginx]='nginx'
    )

    webserver_host="${webserver_hosts[${webserver}]}"
    if [[ -z "${webserver_host}" ]]; then
        echo "Error: Unknown webserver type '${webserver}'"
        return 1
    fi

    php_scan_dir=$(_exec php -r "echo ini_get('scan.directory') ?: (dirname(php_ini_loaded_file()) . '/conf.d');" 2>/dev/null)
    if [[ -z "${php_scan_dir}" ]]; then
        echo "Error: Could not detect PHP configuration scan directory"
        return 1
    fi
    echo "Detected PHP config scan directory: ${php_scan_dir}"

    echo 'Confirming prepend file is present'
    _exec sh -xc "
        if [[ ! -f ${OPENEMR_DIR}/${prepend_file} ]]; then
            echo '${OPENEMR_DIR}/${prepend_file} is missing'
            exit 1
        fi
    "

    echo 'Configuring PHP to use auto_prepend'
    local prepend_ini_file="${RUNNER_TEMP:-/tmp}/php_prepend.ini"
    {
        echo "auto_prepend_file=${OPENEMR_DIR}/${prepend_file}"
    } > "${prepend_ini_file}"
    dc cp "${prepend_ini_file}" "openemr:${php_scan_dir}/php_prepend.ini"

    echo 'Restarting services to pick up the new PHP configuration'
    dc restart openemr
    dockers_env_start

    echo 'Testing prepend/shutdown behavior…'
    _exec rm -f "${prepend_marker}" "${shutdown_marker}"

    echo "Verifying auto prepend configuration via web server (${webserver} at ${webserver_host})…"
    _exec sh -c "curl -fsSL http://${webserver_host}/ci/phpinfo.php | grep -E auto_prepend_file"

    sleep 1  # Give filesystem time to flush

    _exec sh -c 'ls /tmp/openemr-autoprepend-*_EXECUTED'

    echo 'Checking prepend marker file after web request:'
    _exec sh -c "cat '/tmp/${prepend_marker}'"

    echo 'Checking shutdown marker file after web request:'
    _exec sh -c "cat '/tmp/${shutdown_marker}'"
}

##
# Coverage is mainly enabled for E2E and API tests through ci/auto_prepend.php
# However, E2E tests still need longer timeouts.
enable_e2e_coverage() {
    # Increase Selenium timeouts when coverage is enabled (coverage slows down page loads)
    export SELENIUM_IMPLICIT_WAIT=90
    export SELENIUM_PAGE_LOAD_TIMEOUT=180
    echo "Selenium timeouts increased: implicit_wait=${SELENIUM_IMPLICIT_WAIT}s, page_load_timeout=${SELENIUM_PAGE_LOAD_TIMEOUT}s"
}

build_test_e2e() {
    echo 'Creating selenium-videos directory…'
    mkdir -p selenium-videos
    # Fix permissions for video recording
    actions_chmod 777 selenium-videos

    # Enable E2E coverage collection if coverage is enabled
    if [[ ${ENABLE_COVERAGE:-false} = true ]]; then
        echo 'Enabling E2E coverage collection…'
        enable_e2e_coverage
    fi

    selenium_video_start
    echo 'Checking if selenium container is running…'
    # shellcheck disable=SC2310
    if dc ps --services --filter status=running selenium; then
        echo 'Selenium container is running.'
    else
        echo 'Selenium container is not running.'
    fi
    echo 'Checking if video container is running…'
    # shellcheck disable=SC2310
    if dc ps --services --filter status=running video; then
        echo 'Video container is running.'
    else
        echo 'Video container is not running.'
    fi
    echo 'Checking if video directory exists in video container…'
    # shellcheck disable=SC2310
    if dc exec video ls -la /videos; then
        echo 'Video directory exists in video container.'
    else
        echo 'Video directory not found in video container.'
    fi

    echo 'Showing the chromedriver version…'
    dc exec selenium chromedriver --version

    echo 'Running E2E tests…'
    set +e
    _exec php -d memory_limit=8G ./vendor/bin/phpunit --log-junit junit-e2e.xml --testsuite e2e --testdox
    status=$?
    set -e

    # Stop selenium and video containers if they were started and extract videos
    echo 'Waiting for video recording to complete…'
    sleep 5
    echo 'Stopping selenium and video containers…'
    selenium_video_stop
    echo 'Extracting videos from video container…'
    # shellcheck disable=SC2310
    if dc cp video:/videos/video.mp4 selenium-videos/video.mp4 2>/dev/null; then
        echo 'Video file extracted successfully'
    else
        # This is not an error if video recording is not enabled
        echo 'No video file found in container'
    fi
    echo 'Checking for video files after extraction…'
    if [[ -d selenium-videos ]]; then
        echo 'Videos directory exists locally.'
        ls -la selenium-videos/
    else
        echo 'No videos directory found locally.'
    fi

    return "${status}"
}

##
# Print the webserver error log
dump_error_log() {
    case "$1" in
        apache)
            _exec sh -c 'test -r /var/log/apache2/error.log && cat /var/log/apache2/error.log'
            ;;
        nginx)
            echo 'php-fpm logs are in the container logs'
            ;;
        *)
            echo "Webserver '$1' not known."
            exit 255
            ;;
    esac
}

##
# Use the testsuite to figure out which junit filename to use.
# This could get ugly if there's a long comma-delimited list of testsuites,
# but we usually have only one.
phpunit() {
    local testsuite_arg
    local args=( "${@}" )
    while [[ -n ${1} ]]; do
        case "${1}" in
            --testsuite)
                shift
                testsuite_arg="${1}"
                break
                ;;
            --testsuite=*)
                testsuite_arg="${1#--testsuite=}"
                break
                ;;
            *) :;;
        esac
        shift
    done
    [[ -n "${testsuite_arg}" ]] && args+=( --log-junit "junit-${testsuite_arg}.xml" )
    _exec php -d memory_limit=8G ./vendor/bin/phpunit --testdox "${args[@]}"
}

##
# Run the tests, enabling coverage if set.
# API and E2E tests use ci/auto_prepend.php for coverage collection.
# Other tests use PHPUnit's native coverage collection.
build_test() {
    local testsuite=$1
    local -a args=( --testsuite "${testsuite}" )
    shift
    case "${testsuite}" in
        api) # API tests collect coverage via auto_prepend.php
             phpunit "${args[@]}" "$@"
             return
             ;;
        e2e) build_test_e2e "$@"
             return
             ;;
        *) :;;
    esac
    if [[ ${ENABLE_COVERAGE:-false} = true ]]; then
        args+=(
            --coverage-clover "coverage.${testsuite}.clover.xml"
            --coverage-php "./coverage/coverage.${testsuite}.cov"
            "${coverage_args[@]}"
        )
    fi
    phpunit "${args[@]}" "$@"
}

merge_coverage() {
    phpcov merge coverage --clover coverage.clover.xml \
                          --html htmlcov coverage \
                          --text /dev/stdout
}
