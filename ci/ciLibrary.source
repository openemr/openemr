#!/bin/bash
#
# Copyright (C) 2020 Brady Miller <brady.g.miller@gmail.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# Bash library for openemr ci
#

set -xeuo pipefail

coverage_args=(
    --coverage-filter apis
    --coverage-filter gacl
    --coverage-filter interface
    --coverage-filter library
    --coverage-filter modules
    --coverage-filter oauth2
    --coverage-filter portal
    --coverage-filter sites
    --coverage-filter src
    --coverage-filter tests
    --coverage-text
)

composer_github_auth() {
    githubToken=$(base64 --decode <<< MjE2OTcwOGE2MmM5ZWRiMzA3NGFmNGVjMmZkOGE0MWY2YzVkMDJhZgo=)
    githubTokenRateLimitRequest=$(curl -H "Authorization: token ${githubToken}" https://api.github.com/rate_limit)
    githubTokenRateLimit=$(jq '.rate.remaining' <<< "${githubTokenRateLimitRequest}")
    echo "Number of github api requests remaining is ${githubTokenRateLimit}"
    if (( githubTokenRateLimit > 500 )); then
        echo 'Trying to use composer github api token'
        if composer config --global --auth github-oauth.github.com "${githubToken}"; then
            echo 'github composer token worked'
        else
            echo 'github composer token did not work'
        fi
    else
        echo 'Not using composer github api token'
    fi
}

##
# Technically dc is a calculator command in linux,
# but it's rarely used in the same context as docker compose.
dc() {
    docker compose "$@"
}

_exec() {
    if [[ ${ENABLE_COVERAGE:-false} = true ]]; then
        dc exec --env XDEBUG_MODE=coverage --workdir "${OPENEMR_DIR?}" openemr "$@"
    else
        dc exec --workdir "${OPENEMR_DIR?}" openemr "$@"
    fi
}

dockers_env_start() {
    dc up --detach --quiet-pull --wait --wait-timeout 300
}

selenium_video_start() {
    # Selenium and video containers are only started explicitly or when their profiles are activated.
    # So this may do nothing if the profiles are not activated.
    dockers_env_start
}

selenium_video_stop() {
    dc stop selenium video
    dc logs selenium
    dc logs video
}

actions_chmod() {
    # TODO, figure out how not to require the below line (maybe chown or something like that)
    if [[ -z ${GITHUB_RUN_ID:-} ]]; then
        echo 'skipping chmod because this is not running in github actions'
        return
    fi
    sudo chmod "$@"
}

main_build() {
    actions_chmod -R 0777 .
    local composer_home
    composer_home=$(composer --no-interaction config --global --absolute home) 2> /dev/null
    composer install --prefer-dist --no-progress
    npm ci
    npm run build
    composer global require phing/phing
    "${composer_home}/vendor/bin/phing" vendor-clean
    "${composer_home}/vendor/bin/phing" assets-clean
    composer global remove phing/phing
    composer dump-autoload -o
    rm -fr node_modules
}

ccda_build() (
    cd ccdaservice
    npm ci
)

configure_coverage() {
    _exec sh -c '
      XDEBUG_IDE_KEY=unimportant XDEBUG_ON=yes ../xdebug.sh
      mkdir -p ./coverage/e2e
      curl -sSLO https://phar.phpunit.de/phpcov-11.0.0.phar
    '
}

phpcov() {
    _exec php -d memory_limit=8G phpcov-11.0.0.phar "$@"
}

install_configure() {
    (
        toplevel="$(git rev-parse --show-toplevel)"
        cd "${toplevel}"
    	actions_chmod 0666 sites/default/sqlconf.php
    	actions_chmod -R 0777 sites/default/documents
    )
    # we need this to occur on the docker image of OpenEMR, on local systems this may be the same but in the ci engine its inside the docker container
    # until we get the devops repo setup we'll just grab the auto_configure.php script and use that
    _exec sh -c 'curl -v https://raw.githubusercontent.com/openemr/openemr-devops/refs/heads/master/docker/openemr/flex/auto_configure.php > /root/auto_configure.php'
    _exec sh -c 'OPENEMR_ENABLE_INSTALLER_AUTO=1 php -f ./contrib/util/installScripts/InstallerAuto.php rootpass=root server=mysql loginhost=%'
    _exec mysql -u openemr --password=openemr --ssl=false -h mysql -e 'INSERT INTO product_registration (opt_out) VALUES (1)' openemr
    _exec mysql -u openemr --password=openemr --ssl=false -h mysql -e 'UPDATE globals SET gl_value = 1 WHERE gl_name = "rest_api"' openemr
    _exec mysql -u openemr --password=openemr --ssl=false -h mysql -e 'UPDATE globals SET gl_value = 1 WHERE gl_name = "rest_fhir_api"' openemr
    _exec mysql -u openemr --password=openemr --ssl=false -h mysql -e 'UPDATE globals SET gl_value = 1 WHERE gl_name = "rest_portal_api"' openemr
    _exec mysql -u openemr --password=openemr --ssl=false -h mysql -e 'UPDATE globals SET gl_value = 3 WHERE gl_name = "oauth_password_grant"' openemr
    _exec mysql -u openemr --password=openemr --ssl=false -h mysql -e 'UPDATE globals SET gl_value = 1 WHERE gl_name = "rest_system_scopes_api"' openemr
}

enable_e2e_coverage() {
    # Detect the PHP configuration scan directory dynamically
    local php_scan_dir
    local coverage_prepend_file="${OPENEMR_DIR}/ci/coverage-prepend.php"
    local coverage_append_file="${OPENEMR_DIR}/ci/coverage-append.php"
    php_scan_dir=$(_exec php -r "echo ini_get('scan.directory') ?: (dirname(php_ini_loaded_file()) . '/conf.d');" 2>/dev/null)
    if [[ -z "${php_scan_dir}" ]]; then
        echo "Error: Could not detect PHP configuration scan directory"
        return 1
    fi
    echo "Detected PHP config scan directory: ${php_scan_dir}"

    echo 'Confirming coverage prepend and append files are present'
    _exec sh -xc "
        if [[ ! -f ${coverage_prepend_file} ]]; then
            echo '${coverage_prepend_file} is missing'
            exit 1
        fi
        if [[ ! -f ${coverage_append_file} ]]; then
            echo '${coverage_append_file} is missing'
            exit 1
        fi
    "

    echo 'Configuring PHP to use auto_prepend and auto_append for coverage'
    {
        echo "auto_prepend_file=${OPENEMR_DIR}/ci/coverage-prepend.php"
        echo "auto_append_file=${OPENEMR_DIR}/ci/coverage-append.php"
        echo 'xdebug.mode=coverage'
    } > coverage.ini
    dc cp coverage.ini "openemr:${php_scan_dir}/coverage.ini"

    echo 'Restarting services to pick up the new PHP configuration'
    dc restart openemr
    dockers_env_start

    # Verify the configuration was applied correctly via web request (not CLI)
    echo 'Verifying E2E coverage configuration via web server…'
    dc exec openemr sh -c "curl -s http://localhost/ci/phpinfo.php | grep -E 'auto_prepend_file|auto_append_file|xdebug.mode' | head -20"

    # Test if auto_append actually executes via a simple web request
    echo 'Testing if auto_append executes via web request…'
    _exec rm -f ./coverage/PREPEND_EXECUTED ./coverage/APPEND_EXECUTED
    echo 'Output from test-append.php:'
    dc exec openemr sh -c "curl -s http://localhost/ci/test-append.php"
    sleep 1  # Give filesystem time to flush
    echo 'Checking marker files after web request:'
    _exec sh -c 'ls -la ./coverage/PREPEND_EXECUTED ./coverage/APPEND_EXECUTED 2>&1 || echo "Marker files missing!"'
    echo 'Checking error log for coverage debug messages:'
    dc exec openemr tail -20 /var/log/apache2/error_log 2>/dev/null || echo "Could not read error log"
}

disable_e2e_coverage() {
    # Detect the PHP configuration scan directory dynamically
    local php_scan_dir
    php_scan_dir=$(_exec php -r "echo ini_get('cfg_file_path') ?: dirname(php_ini_loaded_file());" 2>/dev/null)
    if [[ -z "${php_scan_dir}" ]]; then
        echo "Error: Could not detect PHP configuration directory"
        return 1
    fi

    # Remove the coverage configuration
    _exec sh -c "rm -f ${php_scan_dir}/conf.d/coverage.ini"

    # Restart Apache/FPM to pick up the removed configuration
    dc exec openemr sh <<'EOF'
if command -v apachectl > /dev/null 2>&1; then
    apachectl graceful
elif command -v nginx > /dev/null 2>&1; then
    pkill -USR2 php-fpm
fi
EOF
}

build_test_e2e() {
    echo 'Creating selenium-videos directory…'
    mkdir -p selenium-videos
    # Fix permissions for video recording
    actions_chmod 777 selenium-videos

    # Enable E2E coverage collection if coverage is enabled
    if [[ ${ENABLE_COVERAGE:-false} = true ]]; then
        echo 'Enabling E2E coverage collection…'
        enable_e2e_coverage

        # Increase Selenium timeouts when coverage is enabled (coverage slows down page loads)
        export SELENIUM_IMPLICIT_WAIT=90
        export SELENIUM_PAGE_LOAD_TIMEOUT=180
        echo "Selenium timeouts increased: implicit_wait=${SELENIUM_IMPLICIT_WAIT}s, page_load_timeout=${SELENIUM_PAGE_LOAD_TIMEOUT}s"
    fi

    selenium_video_start
    echo 'Checking if selenium container is running…'
    # shellcheck disable=SC2310
    if dc ps --services --filter status=running selenium; then
        echo 'Selenium container is running.'
    else
        echo 'Selenium container is not running.'
    fi
    echo 'Checking if video container is running…'
    # shellcheck disable=SC2310
    if dc ps --services --filter status=running video; then
        echo 'Video container is running.'
    else
        echo 'Video container is not running.'
    fi
    echo 'Checking if video directory exists in video container…'
    # shellcheck disable=SC2310
    if dc exec video ls -la /videos; then
        echo 'Video directory exists in video container.'
    else
        echo 'Video directory not found in video container.'
    fi

    echo 'Showing the chromedriver version…'
    dc exec selenium chromedriver --version

    # If coverage is enabled, run a quick test to verify coverage files are being created
    if [[ ${ENABLE_COVERAGE:-false} = true ]]; then
        echo 'Running quick coverage verification test…'
        set +e
        _exec php -d memory_limit=8G ./vendor/bin/phpunit --filter testLoginAuthorized --testsuite e2e
        set -e

        echo 'Checking if coverage files were created…'
        _exec sh -exc '
            ls -lah ./coverage/e2e/
            echo "Files found:"
            ls -1 ./coverage/e2e/*.cov 2>/dev/null | wc -l
        '

        coverage_file_count=$(_exec sh -c 'ls -1 ./coverage/e2e/*.cov 2>/dev/null | wc -l' | tr -d '[:space:]')
        if (( "${coverage_file_count}" > 0 )); then
            echo "✓ Coverage collection is working! Found ${coverage_file_count} coverage file(s)"
        else
            echo "✗ WARNING: No coverage files found after test run!"
            echo "Checking coverage directory and PHP configuration…"
            _exec sh -exc '
                ls -la ./coverage/
                php -i | grep -E "auto_prepend|auto_append|xdebug"
            '
        fi
    fi

    echo 'Running E2E tests…'
    set +e
    _exec php -d memory_limit=8G ./vendor/bin/phpunit --log-junit junit-e2e.xml --testsuite e2e --testdox
    status=$?
    set -e

    # Disable E2E coverage collection and merge coverage files
    if [[ ${ENABLE_COVERAGE:-false} = true ]]; then
        echo 'Disabling E2E coverage collection…'
        disable_e2e_coverage

        echo 'Merging E2E coverage files…'
        # Check if E2E coverage files exist and merge them
        shopt -s nullglob
        e2e_coverage_files=( ./coverage/e2e/*.cov )
        if (( ${#e2e_coverage_files[@]} == 0 )); then
            echo 'Error: No E2E coverage files found to merge'
            return 1
        fi
        phpcov merge coverage/e2e --cov coverage/coverage.e2e.cov

        echo 'Generating E2E clover report…'
        phpcov merge coverage/e2e --clover coverage.e2e.clover.xml
    fi

    # Stop selenium and video containers if they were started and extract videos
    echo 'Waiting for video recording to complete…'
    sleep 5
    echo 'Stopping selenium and video containers…'
    selenium_video_stop
    echo 'Extracting videos from video container…'
    # shellcheck disable=SC2310
    if dc cp video:/videos/video.mp4 selenium-videos/video.mp4 2>/dev/null; then
        echo 'Video file extracted successfully'
    else
        # This is not an error if video recording is not enabled
        echo 'No video file found in container'
    fi
    echo 'Checking for video files after extraction…'
    if [[ -d selenium-videos ]]; then
        echo 'Videos directory exists locally.'
        ls -la selenium-videos/
    else
        echo 'No videos directory found locally.'
    fi

    return "${status}"
}

##
# Use the testsuite to figure out which junit filename to use.
# This could get ugly if there's a long comma-delimited list of testsuites,
# but we usually have only one.
phpunit() {
    local testsuite_arg
    local args=( "${@}" )
    while [[ -n ${1} ]]; do
        case "${1}" in
            --testsuite)
                shift
                testsuite_arg="${1}"
                break
                ;;
            --testsuite=*)
                testsuite_arg="${1#--testsuite=}"
                break
                ;;
            *) :;;
        esac
        shift
    done
    [[ -n "${testsuite_arg}" ]] && args+=( --log-junit "junit-${testsuite_arg}.xml" )
    _exec php -d memory_limit=8G ./vendor/bin/phpunit --testdox "${args[@]}"
}

##
# Run the tests, enabling coverage if set.
# Coverage is not handled for api tests.
# E2E test coverage is handled separately via auto_prepend/auto_append files.
build_test() {
    local testsuite=$1
    local -a args=( --testsuite "${testsuite}" )
    shift
    case "${testsuite}" in
        api) phpunit "${args[@]}" "$@"
             return
             ;;
        e2e) build_test_e2e "$@"
             return
             ;;
        *) :;;
    esac
    if [[ ${ENABLE_COVERAGE:-false} = true ]]; then
        args+=(
            --coverage-clover "coverage.${testsuite}.clover.xml"
            --coverage-php "./coverage/coverage.${testsuite}.cov"
            "${coverage_args[@]}"
        )
    fi
    phpunit "${args[@]}" "$@"
}

merge_coverage() {
    phpcov merge coverage --clover coverage.clover.xml \
                          --html htmlcov coverage \
                          --text /dev/stdout
}
