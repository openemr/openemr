{"version":3,"file":"lformsFHIR.min.js","mappings":"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A,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,gBACA,eACA,eACA,eACA,iBACA,gBACA,eACA,eACA,eACA,eACA,iBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,gBACA,gBACA,iBACA,eACA,eACA,eACA,eACA,eACA,iBACA,kBACA,iBACA,eACA,eACA,gBACA,eACA,gBACA,eACA,eACA,eACA,eACA,eACA,eACA,iBACA,gBACA,gBACA,gBACA,gBACA,eACA,iBACA,eACA,gBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,iBACA,eACA,iBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,eACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,iBACA,eACA,iBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,gBACA,gBACA,kBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,iBACA,eACA,iBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,gBACA,oBACA,iBACA,kBACA,iBACA,iBACA,gBACA,eACA,eACA,eACA,eACA,gBACA,eACA,kBACA,iBACA,iBACA,kBACA,mBACA,iBACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,kBACA,kBACA,mBACA,eACA,eACA,gBACA,gBACA,eACA,eACA,eACA,eACA,iBACA,eACA,eACA,eACA,gBACA,gBACA,gBACA,eACA,eACA,eACA,gBACA,gBACA,e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","sources":["webpack://lforms/./node_modules/antlr4/src/antlr4/BufferedTokenStream.js","webpack://lforms/./node_modules/antlr4/src/antlr4/CommonTokenFactory.js","webpack://lforms/./node_modules/antlr4/src/antlr4/CommonTokenStream.js","webpack://lforms/./node_modules/antlr4/src/antlr4/InputStream.js","webpack://lforms/./node_modules/antlr4/src/antlr4/IntervalSet.js","webpack://lforms/./node_modules/antlr4/src/antlr4/LL1Analyzer.js","webpack://lforms/./node_modules/antlr4/src/antlr4/Lexer.js","webpack://lforms/./node_modules/antlr4/src/antlr4/Parser.js","webpack://lforms/./node_modules/antlr4/src/antlr4/ParserRuleContext.js","webpack://lforms/./node_modules/antlr4/src/antlr4/PredictionContext.js","webpack://lforms/./node_modules/antlr4/src/antlr4/Recognizer.js","webpack://lforms/./node_modules/antlr4/src/antlr4/RuleContext.js","webpack://lforms/./node_modules/antlr4/src/antlr4/Token.js","webpack://lforms/./node_modules/antlr4/src/antlr4/Utils.js","webpack://lforms/./node_modules/antlr4/src/antlr4/atn/ATN.js","webpack://lforms/./node_modules/antlr4/src/antlr4/atn/ATNConfig.js","webpack://lforms/./node_modules/antlr4/src/antlr4/atn/ATNConfigSet.js","webpack://lforms/./node_modules/antlr4/src/antlr4/atn/ATNDeserializationOptions.js","webpack://lforms/./node_modules/antlr4/src/antlr4/atn/ATNDeserializer.js","webpack://lforms/./node_modules/antlr4/src/antlr4/atn/ATNSimulator.js","webpack://lforms/./node_modules/antlr4/src/antlr4/atn/ATNState.js","webpack://lforms/./node_modules/antlr4/src/antlr4/atn/ATNType.js","webpack://lforms/./node_modules/antlr4/src/antlr4/atn/LexerATNSimulator.js","webpack://lforms/./node_modules/antlr4/src/antlr4/atn/LexerAction.js","webpack://lforms/./node_modules/antlr4/src/antlr4/atn/LexerActionExecutor.js","webpack://lforms/./node_modules/antlr4/src/antlr4/atn/ParserATNSimulator.js","webpack://lforms/./node_modules/antlr4/src/antlr4/atn/PredictionMode.js","webpack://lforms/./node_modules/antlr4/src/antlr4/atn/SemanticContext.js","webpack://lforms/./node_modules/antlr4/src/antlr4/atn/Transition.js","webpack://lforms/./node_modules/antlr4/src/antlr4/atn/index.js","webpack://lforms/./node_modules/antlr4/src/antlr4/dfa/DFA.js","webpack://lforms/./node_modules/antlr4/src/antlr4/dfa/DFASerializer.js","webpack://lforms/./node_modules/antlr4/src/antlr4/dfa/DFAState.js","webpack://lforms/./node_modules/antlr4/src/antlr4/dfa/index.js","webpack://lforms/./node_modules/antlr4/src/antlr4/error/DiagnosticErrorListener.js","webpack://lforms/./node_modules/antlr4/src/antlr4/error/ErrorListener.js","webpack://lforms/./node_modules/antlr4/src/antlr4/error/ErrorStrategy.js","webpack://lforms/./node_modules/antlr4/src/antlr4/error/Errors.js","webpack://lforms/./node_modules/antlr4/src/antlr4/error/index.js","webpack://lforms/./node_modules/antlr4/src/antlr4/polyfills/codepointat.js","webpack://lforms/./node_modules/antlr4/src/antlr4/polyfills/fromcodepoint.js","webpack://lforms/./node_modules/antlr4/src/antlr4/tree/Tree.js","webpack://lforms/./node_modules/antlr4/src/antlr4/tree/Trees.js","webpack://lforms/./node_modules/antlr4/src/antlr4/tree/index.js","webpack://lforms/./node_modules/date-fns/_lib/getTimezoneOffsetInMilliseconds/index.js","webpack://lforms/./node_modules/date-fns/add_days/index.js","webpack://lforms/./node_modules/date-fns/add_hours/index.js","webpack://lforms/./node_modules/date-fns/add_milliseconds/index.js","webpack://lforms/./node_modules/date-fns/add_minutes/index.js","webpack://lforms/./node_modules/date-fns/add_months/index.js","webpack://lforms/./node_modules/date-fns/add_seconds/index.js","webpack://lforms/./node_modules/date-fns/add_weeks/index.js","webpack://lforms/./node_modules/date-fns/add_years/index.js","webpack://lforms/./node_modules/date-fns/get_days_in_month/index.js","webpack://lforms/./node_modules/date-fns/is_date/index.js","webpack://lforms/./node_modules/date-fns/parse/index.js","webpack://lforms/./node_modules/fast-deep-equal/index.js","webpack://lforms/./node_modules/fhirpath/fhir-context/stu3/index.js","webpack://lforms/./node_modules/fhirpath/src/aggregate.js","webpack://lforms/./node_modules/fhirpath/src/collections.js","webpack://lforms/./node_modules/fhirpath/src/combining.js","webpack://lforms/./node_modules/fhirpath/src/constants.js","webpack://lforms/./node_modules/fhirpath/src/datetime.js","webpack://lforms/./node_modules/fhirpath/src/deep-equal.js","webpack://lforms/./node_modules/fhirpath/src/equality.js","webpack://lforms/./node_modules/fhirpath/src/existence.js","webpack://lforms/./node_modules/fhirpath/src/fhirpath.js","webpack://lforms/./node_modules/fhirpath/src/filtering.js","webpack://lforms/./node_modules/fhirpath/src/hash-object.js","webpack://lforms/./node_modules/fhirpath/src/logic.js","webpack://lforms/./node_modules/fhirpath/src/math.js","webpack://lforms/./node_modules/fhirpath/src/misc.js","webpack://lforms/./node_modules/fhirpath/src/navigation.js","webpack://lforms/./node_modules/fhirpath/src/numbers.js","webpack://lforms/./node_modules/fhirpath/src/parser/antlr4-index.js","webpack://lforms/./node_modules/fhirpath/src/parser/generated/FHIRPathLexer.js","webpack://lforms/./node_modules/fhirpath/src/parser/generated/FHIRPathListener.js","webpack://lforms/./node_modules/fhirpath/src/parser/generated/FHIRPathParser.js","webpack://lforms/./node_modules/fhirpath/src/parser/index.js","webpack://lforms/./node_modules/fhirpath/src/polyfill.js","webpack://lforms/./node_modules/fhirpath/src/strings.js","webpack://lforms/./node_modules/fhirpath/src/types.js","webpack://lforms/./node_modules/fhirpath/src/utilities.js","webpack://lforms/external \"LForms.ucumPkg\"","webpack://lforms/webpack/bootstrap","webpack://lforms/./src/fhir/fhir-common.js","webpack://lforms/./src/fhir/diagnostic-report.js","webpack://lforms/./src/fhir/export-common.js","webpack://lforms/./src/fhir/STU3/export.js","webpack://lforms/./src/fhir/STU3/sdc-export.js","webpack://lforms/./src/fhir/sdc-export-common.js","webpack://lforms/./src/fhir/STU3/sdc-import.js","webpack://lforms/./src/fhir/obs-prepop.mjs","webpack://lforms/./src/fhir/sdc-common.js","webpack://lforms/./src/fhir/sdc-import-common.js","webpack://lforms/./src/fhir/extensions/rendering-style.js","webpack://lforms/./src/fhir/expression-processor.js","webpack://lforms/./src/fhir/runtime-common.js","webpack://lforms/./src/fhir/STU3/fhirRequire.js"],"sourcesContent":["/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Token} = require('./Token');\nconst Lexer = require('./Lexer');\nconst {Interval} = require('./IntervalSet');\n\n// this is just to keep meaningful parameter types to Parser\nclass TokenStream {}\n\n/**\n * This implementation of {@link TokenStream} loads tokens from a\n * {@link TokenSource} on-demand, and places the tokens in a buffer to provide\n * access to any previous token by index.\n *\n * <p>\n * This token stream ignores the value of {@link Token//getChannel}. If your\n * parser requires the token stream filter tokens to only those on a particular\n * channel, such as {@link Token//DEFAULT_CHANNEL} or\n * {@link Token//HIDDEN_CHANNEL}, use a filtering token stream such a\n * {@link CommonTokenStream}.</p>\n */\nclass BufferedTokenStream extends TokenStream {\n\tconstructor(tokenSource) {\n\n\t\tsuper();\n\t\t// The {@link TokenSource} from which tokens for this stream are fetched.\n\t\tthis.tokenSource = tokenSource;\n\t\t/**\n\t\t * A collection of all tokens fetched from the token source. The list is\n\t\t * considered a complete view of the input once {@link //fetchedEOF} is set\n\t\t * to {@code true}.\n\t\t */\n\t\tthis.tokens = [];\n\n\t\t/**\n\t\t * The index into {@link //tokens} of the current token (next token to\n\t\t * {@link //consume}). {@link //tokens}{@code [}{@link //p}{@code ]} should\n\t\t * be\n\t\t * {@link //LT LT(1)}.\n\t\t *\n\t\t * <p>This field is set to -1 when the stream is first constructed or when\n\t\t * {@link //setTokenSource} is called, indicating that the first token has\n\t\t * not yet been fetched from the token source. For additional information,\n\t\t * see the documentation of {@link IntStream} for a description of\n\t\t * Initializing Methods.</p>\n\t\t */\n\t\tthis.index = -1;\n\n\t\t/**\n\t\t * Indicates whether the {@link Token//EOF} token has been fetched from\n\t\t * {@link //tokenSource} and added to {@link //tokens}. This field improves\n\t\t * performance for the following cases:\n\t\t *\n\t\t * <ul>\n\t\t * <li>{@link //consume}: The lookahead check in {@link //consume} to\n\t\t * prevent\n\t\t * consuming the EOF symbol is optimized by checking the values of\n\t\t * {@link //fetchedEOF} and {@link //p} instead of calling {@link\n\t\t * //LA}.</li>\n\t\t * <li>{@link //fetch}: The check to prevent adding multiple EOF symbols\n\t\t * into\n\t\t * {@link //tokens} is trivial with this field.</li>\n\t\t * <ul>\n\t\t */\n\t\tthis.fetchedEOF = false;\n\t}\n\n\tmark() {\n\t\treturn 0;\n\t}\n\n\trelease(marker) {\n\t\t// no resources to release\n\t}\n\n\treset() {\n\t\tthis.seek(0);\n\t}\n\n\tseek(index) {\n\t\tthis.lazyInit();\n\t\tthis.index = this.adjustSeekIndex(index);\n\t}\n\n\tget(index) {\n\t\tthis.lazyInit();\n\t\treturn this.tokens[index];\n\t}\n\n\tconsume() {\n\t\tlet skipEofCheck = false;\n\t\tif (this.index >= 0) {\n\t\t\tif (this.fetchedEOF) {\n\t\t\t\t// the last token in tokens is EOF. skip check if p indexes any\n\t\t\t\t// fetched token except the last.\n\t\t\t\tskipEofCheck = this.index < this.tokens.length - 1;\n\t\t\t} else {\n\t\t\t\t// no EOF token in tokens. skip check if p indexes a fetched token.\n\t\t\t\tskipEofCheck = this.index < this.tokens.length;\n\t\t\t}\n\t\t} else {\n\t\t\t// not yet initialized\n\t\t\tskipEofCheck = false;\n\t\t}\n\t\tif (!skipEofCheck && this.LA(1) === Token.EOF) {\n\t\t\tthrow \"cannot consume EOF\";\n\t\t}\n\t\tif (this.sync(this.index + 1)) {\n\t\t\tthis.index = this.adjustSeekIndex(this.index + 1);\n\t\t}\n\t}\n\n\t/**\n\t * Make sure index {@code i} in tokens has a token.\n\t *\n\t * @return {Boolean} {@code true} if a token is located at index {@code i}, otherwise\n\t * {@code false}.\n\t * @see //get(int i)\n\t */\n\tsync(i) {\n\t\tconst n = i - this.tokens.length + 1; // how many more elements we need?\n\t\tif (n > 0) {\n\t\t\tconst fetched = this.fetch(n);\n\t\t\treturn fetched >= n;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Add {@code n} elements to buffer.\n\t *\n\t * @return {Number} The actual number of elements added to the buffer.\n\t */\n\tfetch(n) {\n\t\tif (this.fetchedEOF) {\n\t\t\treturn 0;\n\t\t}\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tconst t = this.tokenSource.nextToken();\n\t\t\tt.tokenIndex = this.tokens.length;\n\t\t\tthis.tokens.push(t);\n\t\t\tif (t.type === Token.EOF) {\n\t\t\t\tthis.fetchedEOF = true;\n\t\t\t\treturn i + 1;\n\t\t\t}\n\t\t}\n\t\treturn n;\n\t}\n\n// Get all tokens from start..stop inclusively///\n\tgetTokens(start, stop, types) {\n\t\tif (types === undefined) {\n\t\t\ttypes = null;\n\t\t}\n\t\tif (start < 0 || stop < 0) {\n\t\t\treturn null;\n\t\t}\n\t\tthis.lazyInit();\n\t\tconst subset = [];\n\t\tif (stop >= this.tokens.length) {\n\t\t\tstop = this.tokens.length - 1;\n\t\t}\n\t\tfor (let i = start; i < stop; i++) {\n\t\t\tconst t = this.tokens[i];\n\t\t\tif (t.type === Token.EOF) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (types === null || types.contains(t.type)) {\n\t\t\t\tsubset.push(t);\n\t\t\t}\n\t\t}\n\t\treturn subset;\n\t}\n\n\tLA(i) {\n\t\treturn this.LT(i).type;\n\t}\n\n\tLB(k) {\n\t\tif (this.index - k < 0) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this.tokens[this.index - k];\n\t}\n\n\tLT(k) {\n\t\tthis.lazyInit();\n\t\tif (k === 0) {\n\t\t\treturn null;\n\t\t}\n\t\tif (k < 0) {\n\t\t\treturn this.LB(-k);\n\t\t}\n\t\tconst i = this.index + k - 1;\n\t\tthis.sync(i);\n\t\tif (i >= this.tokens.length) { // return EOF token\n\t\t\t// EOF must be last token\n\t\t\treturn this.tokens[this.tokens.length - 1];\n\t\t}\n\t\treturn this.tokens[i];\n\t}\n\n\t/**\n\t * Allowed derived classes to modify the behavior of operations which change\n\t * the current stream position by adjusting the target token index of a seek\n\t * operation. The default implementation simply returns {@code i}. If an\n\t * exception is thrown in this method, the current stream index should not be\n\t * changed.\n\t *\n\t * <p>For example, {@link CommonTokenStream} overrides this method to ensure\n\t * that\n\t * the seek target is always an on-channel token.</p>\n\t *\n\t * @param {Number} i The target token index.\n\t * @return {Number} The adjusted target token index.\n\t */\n\tadjustSeekIndex(i) {\n\t\treturn i;\n\t}\n\n\tlazyInit() {\n\t\tif (this.index === -1) {\n\t\t\tthis.setup();\n\t\t}\n\t}\n\n\tsetup() {\n\t\tthis.sync(0);\n\t\tthis.index = this.adjustSeekIndex(0);\n\t}\n\n// Reset this token stream by setting its token source.///\n\tsetTokenSource(tokenSource) {\n\t\tthis.tokenSource = tokenSource;\n\t\tthis.tokens = [];\n\t\tthis.index = -1;\n\t\tthis.fetchedEOF = false;\n\t}\n\n\t/**\n\t * Given a starting index, return the index of the next token on channel.\n\t * Return i if tokens[i] is on channel. Return -1 if there are no tokens\n\t * on channel between i and EOF.\n\t */\n\tnextTokenOnChannel(i, channel) {\n\t\tthis.sync(i);\n\t\tif (i >= this.tokens.length) {\n\t\t\treturn -1;\n\t\t}\n\t\tlet token = this.tokens[i];\n\t\twhile (token.channel !== this.channel) {\n\t\t\tif (token.type === Token.EOF) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\ti += 1;\n\t\t\tthis.sync(i);\n\t\t\ttoken = this.tokens[i];\n\t\t}\n\t\treturn i;\n\t}\n\n\t/**\n\t * Given a starting index, return the index of the previous token on channel.\n\t * Return i if tokens[i] is on channel. Return -1 if there are no tokens\n\t * on channel between i and 0.\n\t */\n\tpreviousTokenOnChannel(i, channel) {\n\t\twhile (i >= 0 && this.tokens[i].channel !== channel) {\n\t\t\ti -= 1;\n\t\t}\n\t\treturn i;\n\t}\n\n\t/**\n\t * Collect all tokens on specified channel to the right of\n\t * the current token up until we see a token on DEFAULT_TOKEN_CHANNEL or\n\t * EOF. If channel is -1, find any non default channel token.\n\t */\n\tgetHiddenTokensToRight(tokenIndex,\n\t\t\tchannel) {\n\t\tif (channel === undefined) {\n\t\t\tchannel = -1;\n\t\t}\n\t\tthis.lazyInit();\n\t\tif (tokenIndex < 0 || tokenIndex >= this.tokens.length) {\n\t\t\tthrow \"\" + tokenIndex + \" not in 0..\" + this.tokens.length - 1;\n\t\t}\n\t\tconst nextOnChannel = this.nextTokenOnChannel(tokenIndex + 1, Lexer.DEFAULT_TOKEN_CHANNEL);\n\t\tconst from_ = tokenIndex + 1;\n\t\t// if none onchannel to right, nextOnChannel=-1 so set to = last token\n\t\tconst to = nextOnChannel === -1 ? this.tokens.length - 1 : nextOnChannel;\n\t\treturn this.filterForChannel(from_, to, channel);\n\t}\n\n\t/**\n\t * Collect all tokens on specified channel to the left of\n\t * the current token up until we see a token on DEFAULT_TOKEN_CHANNEL.\n\t * If channel is -1, find any non default channel token.\n\t */\n\tgetHiddenTokensToLeft(tokenIndex,\n\t\t\tchannel) {\n\t\tif (channel === undefined) {\n\t\t\tchannel = -1;\n\t\t}\n\t\tthis.lazyInit();\n\t\tif (tokenIndex < 0 || tokenIndex >= this.tokens.length) {\n\t\t\tthrow \"\" + tokenIndex + \" not in 0..\" + this.tokens.length - 1;\n\t\t}\n\t\tconst prevOnChannel = this.previousTokenOnChannel(tokenIndex - 1, Lexer.DEFAULT_TOKEN_CHANNEL);\n\t\tif (prevOnChannel === tokenIndex - 1) {\n\t\t\treturn null;\n\t\t}\n\t\t// if none on channel to left, prevOnChannel=-1 then from=0\n\t\tconst from_ = prevOnChannel + 1;\n\t\tconst to = tokenIndex - 1;\n\t\treturn this.filterForChannel(from_, to, channel);\n\t}\n\n\tfilterForChannel(left, right, channel) {\n\t\tconst hidden = [];\n\t\tfor (let i = left; i < right + 1; i++) {\n\t\t\tconst t = this.tokens[i];\n\t\t\tif (channel === -1) {\n\t\t\t\tif (t.channel !== Lexer.DEFAULT_TOKEN_CHANNEL) {\n\t\t\t\t\thidden.push(t);\n\t\t\t\t}\n\t\t\t} else if (t.channel === channel) {\n\t\t\t\thidden.push(t);\n\t\t\t}\n\t\t}\n\t\tif (hidden.length === 0) {\n\t\t\treturn null;\n\t\t}\n\t\treturn hidden;\n\t}\n\n\tgetSourceName() {\n\t\treturn this.tokenSource.getSourceName();\n\t}\n\n// Get the text of all tokens in this buffer.///\n\tgetText(interval) {\n\t\tthis.lazyInit();\n\t\tthis.fill();\n\t\tif (interval === undefined || interval === null) {\n\t\t\tinterval = new Interval(0, this.tokens.length - 1);\n\t\t}\n\t\tlet start = interval.start;\n\t\tif (start instanceof Token) {\n\t\t\tstart = start.tokenIndex;\n\t\t}\n\t\tlet stop = interval.stop;\n\t\tif (stop instanceof Token) {\n\t\t\tstop = stop.tokenIndex;\n\t\t}\n\t\tif (start === null || stop === null || start < 0 || stop < 0) {\n\t\t\treturn \"\";\n\t\t}\n\t\tif (stop >= this.tokens.length) {\n\t\t\tstop = this.tokens.length - 1;\n\t\t}\n\t\tlet s = \"\";\n\t\tfor (let i = start; i < stop + 1; i++) {\n\t\t\tconst t = this.tokens[i];\n\t\t\tif (t.type === Token.EOF) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ts = s + t.text;\n\t\t}\n\t\treturn s;\n\t}\n\n// Get all tokens from lexer until EOF///\n\tfill() {\n\t\tthis.lazyInit();\n\t\twhile (this.fetch(1000) === 1000) {\n\t\t\tcontinue;\n\t\t}\n\t}\n}\n\n\nmodule.exports = BufferedTokenStream;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst CommonToken = require('./Token').CommonToken;\n\nclass TokenFactory {}\n\n/**\n * This default implementation of {@link TokenFactory} creates\n * {@link CommonToken} objects.\n */\nclass CommonTokenFactory extends TokenFactory {\n    constructor(copyText) {\n        super();\n        /**\n         * Indicates whether {@link CommonToken//setText} should be called after\n         * constructing tokens to explicitly set the text. This is useful for cases\n         * where the input stream might not be able to provide arbitrary substrings\n         * of text from the input after the lexer creates a token (e.g. the\n         * implementation of {@link CharStream//getText} in\n         * {@link UnbufferedCharStream} throws an\n         * {@link UnsupportedOperationException}). Explicitly setting the token text\n         * allows {@link Token//getText} to be called at any time regardless of the\n         * input stream implementation.\n         *\n         * <p>\n         * The default value is {@code false} to avoid the performance and memory\n         * overhead of copying text for every token unless explicitly requested.</p>\n         */\n        this.copyText = copyText===undefined ? false : copyText;\n    }\n\n    create(source, type, text, channel, start, stop, line, column) {\n        const t = new CommonToken(source, type, channel, start, stop);\n        t.line = line;\n        t.column = column;\n        if (text !==null) {\n            t.text = text;\n        } else if (this.copyText && source[1] !==null) {\n            t.text = source[1].getText(start,stop);\n        }\n        return t;\n    }\n\n    createThin(type, text) {\n        const t = new CommonToken(null, type);\n        t.text = text;\n        return t;\n    }\n}\n\n/**\n * The default {@link CommonTokenFactory} instance.\n *\n * <p>\n * This token factory does not explicitly copy token text when constructing\n * tokens.</p>\n */\nCommonTokenFactory.DEFAULT = new CommonTokenFactory();\n\nmodule.exports = CommonTokenFactory;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\n\nconst Token = require('./Token').Token;\nconst BufferedTokenStream = require('./BufferedTokenStream');\n\n/**\n * This class extends {@link BufferedTokenStream} with functionality to filter\n * token streams to tokens on a particular channel (tokens where\n * {@link Token//getChannel} returns a particular value).\n *\n * <p>\n * This token stream provides access to all tokens by index or when calling\n * methods like {@link //getText}. The channel filtering is only used for code\n * accessing tokens via the lookahead methods {@link //LA}, {@link //LT}, and\n * {@link //LB}.</p>\n *\n * <p>\n * By default, tokens are placed on the default channel\n * ({@link Token//DEFAULT_CHANNEL}), but may be reassigned by using the\n * {@code ->channel(HIDDEN)} lexer command, or by using an embedded action to\n * call {@link Lexer//setChannel}.\n * </p>\n *\n * <p>\n * Note: lexer rules which use the {@code ->skip} lexer command or call\n * {@link Lexer//skip} do not produce tokens at all, so input text matched by\n * such a rule will not be available as part of the token stream, regardless of\n * channel.</p>\n */\nclass CommonTokenStream extends BufferedTokenStream {\n    constructor(lexer, channel) {\n        super(lexer);\n        this.channel = channel===undefined ? Token.DEFAULT_CHANNEL : channel;\n    }\n\n    adjustSeekIndex(i) {\n        return this.nextTokenOnChannel(i, this.channel);\n    }\n\n    LB(k) {\n        if (k===0 || this.index-k<0) {\n            return null;\n        }\n        let i = this.index;\n        let n = 1;\n        // find k good tokens looking backwards\n        while (n <= k) {\n            // skip off-channel tokens\n            i = this.previousTokenOnChannel(i - 1, this.channel);\n            n += 1;\n        }\n        if (i < 0) {\n            return null;\n        }\n        return this.tokens[i];\n    }\n\n    LT(k) {\n        this.lazyInit();\n        if (k === 0) {\n            return null;\n        }\n        if (k < 0) {\n            return this.LB(-k);\n        }\n        let i = this.index;\n        let n = 1; // we know tokens[pos] is a good one\n        // find k good tokens\n        while (n < k) {\n            // skip off-channel tokens, but make sure to not look past EOF\n            if (this.sync(i + 1)) {\n                i = this.nextTokenOnChannel(i + 1, this.channel);\n            }\n            n += 1;\n        }\n        return this.tokens[i];\n    }\n\n    // Count EOF just once.\n    getNumberOfOnChannelTokens() {\n        let n = 0;\n        this.fill();\n        for (let i =0; i< this.tokens.length;i++) {\n            const t = this.tokens[i];\n            if( t.channel===this.channel) {\n                n += 1;\n            }\n            if( t.type===Token.EOF) {\n                break;\n            }\n        }\n        return n;\n    }\n}\n\nmodule.exports = CommonTokenStream;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Token} = require('./Token');\nrequire('./polyfills/codepointat');\nrequire('./polyfills/fromcodepoint');\n\n/**\n * If decodeToUnicodeCodePoints is true, the input is treated\n * as a series of Unicode code points.\n *\n * Otherwise, the input is treated as a series of 16-bit UTF-16 code\n * units.\n */\nclass InputStream {\n\tconstructor(data, decodeToUnicodeCodePoints) {\n\t\tthis.name = \"<empty>\";\n\t\tthis.strdata = data;\n\t\tthis.decodeToUnicodeCodePoints = decodeToUnicodeCodePoints || false;\n\t\t// _loadString - Vacuum all input from a string and then treat it like a buffer.\n\t\tthis._index = 0;\n\t\tthis.data = [];\n\t\tif (this.decodeToUnicodeCodePoints) {\n\t\t\tfor (let i = 0; i < this.strdata.length; ) {\n\t\t\t\tconst codePoint = this.strdata.codePointAt(i);\n\t\t\t\tthis.data.push(codePoint);\n\t\t\t\ti += codePoint <= 0xFFFF ? 1 : 2;\n\t\t\t}\n\t\t} else {\n\t\t\tthis.data = new Array(this.strdata.length);\n\t\t\tfor (let i = 0; i < this.strdata.length; i++) {\n\t\t\t\tconst codeUnit = this.strdata.charCodeAt(i);\n\t\t\t\tthis.data[i] = codeUnit;\n\t\t\t}\n\t\t}\n\t\tthis._size = this.data.length;\n\t}\n\n\t/**\n\t * Reset the stream so that it's in the same state it was\n\t * when the object was created *except* the data array is not\n\t * touched.\n\t */\n\treset() {\n\t\tthis._index = 0;\n\t}\n\n\tconsume() {\n\t\tif (this._index >= this._size) {\n\t\t\t// assert this.LA(1) == Token.EOF\n\t\t\tthrow (\"cannot consume EOF\");\n\t\t}\n\t\tthis._index += 1;\n\t}\n\n\tLA(offset) {\n\t\tif (offset === 0) {\n\t\t\treturn 0; // undefined\n\t\t}\n\t\tif (offset < 0) {\n\t\t\toffset += 1; // e.g., translate LA(-1) to use offset=0\n\t\t}\n\t\tconst pos = this._index + offset - 1;\n\t\tif (pos < 0 || pos >= this._size) { // invalid\n\t\t\treturn Token.EOF;\n\t\t}\n\t\treturn this.data[pos];\n\t}\n\n\tLT(offset) {\n\t\treturn this.LA(offset);\n\t}\n\n// mark/release do nothing; we have entire buffer\n\tmark() {\n\t\treturn -1;\n\t}\n\n\trelease(marker) {\n\t}\n\n\t/**\n\t * consume() ahead until p==_index; can't just set p=_index as we must\n\t * update line and column. If we seek backwards, just set p\n\t */\n\tseek(_index) {\n\t\tif (_index <= this._index) {\n\t\t\tthis._index = _index; // just jump; don't update stream state (line,\n\t\t\t\t\t\t\t\t\t// ...)\n\t\t\treturn;\n\t\t}\n\t\t// seek forward\n\t\tthis._index = Math.min(_index, this._size);\n\t}\n\n\tgetText(start, stop) {\n\t\tif (stop >= this._size) {\n\t\t\tstop = this._size - 1;\n\t\t}\n\t\tif (start >= this._size) {\n\t\t\treturn \"\";\n\t\t} else {\n\t\t\tif (this.decodeToUnicodeCodePoints) {\n\t\t\t\tlet result = \"\";\n\t\t\t\tfor (let i = start; i <= stop; i++) {\n\t\t\t\t\tresult += String.fromCodePoint(this.data[i]);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this.strdata.slice(start, stop + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn this.strdata;\n\t}\n\n\tget index(){\n\t\treturn this._index;\n\t}\n\n\tget size(){\n\t\treturn this._size;\n\t}\n}\n\n\nmodule.exports = InputStream;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Token} = require('./Token');\n\n/* stop is not included! */\nclass Interval {\n\n\tconstructor(start, stop) {\n\t\tthis.start = start;\n\t\tthis.stop = stop;\n\t}\n\n\tclone() {\n\t\treturn new Interval(this.start, this.stop);\n\t}\n\n\tcontains(item) {\n\t\treturn item >= this.start && item < this.stop;\n\t}\n\n\ttoString() {\n\t\tif(this.start===this.stop-1) {\n\t\t\treturn this.start.toString();\n\t\t} else {\n\t\t\treturn this.start.toString() + \"..\" + (this.stop-1).toString();\n\t\t}\n\t}\n\n\tget length(){\n\t\treturn this.stop - this.start;\n\t}\n}\n\n\nclass IntervalSet {\n\tconstructor() {\n\t\tthis.intervals = null;\n\t\tthis.readOnly = false;\n\t}\n\n\tfirst(v) {\n\t\tif (this.intervals === null || this.intervals.length===0) {\n\t\t\treturn Token.INVALID_TYPE;\n\t\t} else {\n\t\t\treturn this.intervals[0].start;\n\t\t}\n\t}\n\n\taddOne(v) {\n\t\tthis.addInterval(new Interval(v, v + 1));\n\t}\n\n\taddRange(l, h) {\n\t\tthis.addInterval(new Interval(l, h + 1));\n\t}\n\n\taddInterval(toAdd) {\n\t\tif (this.intervals === null) {\n\t\t\tthis.intervals = [];\n\t\t\tthis.intervals.push(toAdd.clone());\n\t\t} else {\n\t\t\t// find insert pos\n\t\t\tfor (let pos = 0; pos < this.intervals.length; pos++) {\n\t\t\t\tconst existing = this.intervals[pos];\n\t\t\t\t// distinct range -> insert\n\t\t\t\tif (toAdd.stop < existing.start) {\n\t\t\t\t\tthis.intervals.splice(pos, 0, toAdd);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// contiguous range -> adjust\n\t\t\t\telse if (toAdd.stop === existing.start) {\n\t\t\t\t\tthis.intervals[pos] = new Interval(toAdd.start, existing.stop)\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// overlapping range -> adjust and reduce\n\t\t\t\telse if (toAdd.start <= existing.stop) {\n\t\t\t\t\tthis.intervals[pos] = new Interval(Math.min(existing.start, toAdd.start), Math.max(existing.stop, toAdd.stop));\n\t\t\t\t\tthis.reduce(pos);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// greater than any existing\n\t\t\tthis.intervals.push(toAdd.clone());\n\t\t}\n\t}\n\n\taddSet(other) {\n\t\tif (other.intervals !== null) {\n\t\t\tother.intervals.forEach( toAdd => this.addInterval(toAdd), this);\n\t\t}\n\t\treturn this;\n\t}\n\n\treduce(pos) {\n\t\t// only need to reduce if pos is not the last\n\t\tif (pos < this.intervals.length - 1) {\n\t\t\tconst current = this.intervals[pos];\n\t\t\tconst next = this.intervals[pos + 1];\n\t\t\t// if next contained in current\n\t\t\tif (current.stop >= next.stop) {\n\t\t\t\tthis.intervals.splice(pos + 1, 1);\n\t\t\t\tthis.reduce(pos);\n\t\t\t} else if (current.stop >= next.start) {\n\t\t\t\tthis.intervals[pos] = new Interval(current.start, next.stop);\n\t\t\t\tthis.intervals.splice(pos + 1, 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tcomplement(start, stop) {\n\t\tconst result = new IntervalSet();\n\t\tresult.addInterval(new Interval(start, stop + 1));\n\t\tif(this.intervals !== null)\n\t\t\tthis.intervals.forEach(toRemove => result.removeRange(toRemove));\n\t\treturn result;\n\t}\n\n\tcontains(item) {\n\t\tif (this.intervals === null) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\tfor (let k = 0; k < this.intervals.length; k++) {\n\t\t\t\tif(this.intervals[k].contains(item)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tremoveRange(toRemove) {\n\t\tif(toRemove.start===toRemove.stop-1) {\n\t\t\tthis.removeOne(toRemove.start);\n\t\t} else if (this.intervals !== null) {\n\t\t\tlet pos = 0;\n\t\t\tfor(let n=0; n<this.intervals.length; n++) {\n\t\t\t\tconst existing = this.intervals[pos];\n\t\t\t\t// intervals are ordered\n\t\t\t\tif (toRemove.stop<=existing.start) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// check for including range, split it\n\t\t\t\telse if(toRemove.start>existing.start && toRemove.stop<existing.stop) {\n\t\t\t\t\tthis.intervals[pos] = new Interval(existing.start, toRemove.start);\n\t\t\t\t\tconst x = new Interval(toRemove.stop, existing.stop);\n\t\t\t\t\tthis.intervals.splice(pos, 0, x);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// check for included range, remove it\n\t\t\t\telse if(toRemove.start<=existing.start && toRemove.stop>=existing.stop) {\n\t\t\t\t\tthis.intervals.splice(pos, 1);\n\t\t\t\t\tpos = pos - 1; // need another pass\n\t\t\t\t}\n\t\t\t\t// check for lower boundary\n\t\t\t\telse if(toRemove.start<existing.stop) {\n\t\t\t\t\tthis.intervals[pos] = new Interval(existing.start, toRemove.start);\n\t\t\t\t}\n\t\t\t\t// check for upper boundary\n\t\t\t\telse if(toRemove.stop<existing.stop) {\n\t\t\t\t\tthis.intervals[pos] = new Interval(toRemove.stop, existing.stop);\n\t\t\t\t}\n\t\t\t\tpos += 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tremoveOne(value) {\n\t\tif (this.intervals !== null) {\n\t\t\tfor (let i = 0; i < this.intervals.length; i++) {\n\t\t\t\tconst existing = this.intervals[i];\n\t\t\t\t// intervals are ordered\n\t\t\t\tif (value < existing.start) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// check for single value range\n\t\t\t\telse if (value === existing.start && value === existing.stop - 1) {\n\t\t\t\t\tthis.intervals.splice(i, 1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// check for lower boundary\n\t\t\t\telse if (value === existing.start) {\n\t\t\t\t\tthis.intervals[i] = new Interval(existing.start + 1, existing.stop);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// check for upper boundary\n\t\t\t\telse if (value === existing.stop - 1) {\n\t\t\t\t\tthis.intervals[i] = new Interval(existing.start, existing.stop - 1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// split existing range\n\t\t\t\telse if (value < existing.stop - 1) {\n\t\t\t\t\tconst replace = new Interval(existing.start, value);\n\t\t\t\t\texisting.start = value + 1;\n\t\t\t\t\tthis.intervals.splice(i, 0, replace);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\ttoString(literalNames, symbolicNames, elemsAreChar) {\n\t\tliteralNames = literalNames || null;\n\t\tsymbolicNames = symbolicNames || null;\n\t\telemsAreChar = elemsAreChar || false;\n\t\tif (this.intervals === null) {\n\t\t\treturn \"{}\";\n\t\t} else if(literalNames!==null || symbolicNames!==null) {\n\t\t\treturn this.toTokenString(literalNames, symbolicNames);\n\t\t} else if(elemsAreChar) {\n\t\t\treturn this.toCharString();\n\t\t} else {\n\t\t\treturn this.toIndexString();\n\t\t}\n\t}\n\n\ttoCharString() {\n\t\tconst names = [];\n\t\tfor (let i = 0; i < this.intervals.length; i++) {\n\t\t\tconst existing = this.intervals[i];\n\t\t\tif(existing.stop===existing.start+1) {\n\t\t\t\tif ( existing.start===Token.EOF ) {\n\t\t\t\t\tnames.push(\"<EOF>\");\n\t\t\t\t} else {\n\t\t\t\t\tnames.push(\"'\" + String.fromCharCode(existing.start) + \"'\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnames.push(\"'\" + String.fromCharCode(existing.start) + \"'..'\" + String.fromCharCode(existing.stop-1) + \"'\");\n\t\t\t}\n\t\t}\n\t\tif (names.length > 1) {\n\t\t\treturn \"{\" + names.join(\", \") + \"}\";\n\t\t} else {\n\t\t\treturn names[0];\n\t\t}\n\t}\n\n\ttoIndexString() {\n\t\tconst names = [];\n\t\tfor (let i = 0; i < this.intervals.length; i++) {\n\t\t\tconst existing = this.intervals[i];\n\t\t\tif(existing.stop===existing.start+1) {\n\t\t\t\tif ( existing.start===Token.EOF ) {\n\t\t\t\t\tnames.push(\"<EOF>\");\n\t\t\t\t} else {\n\t\t\t\t\tnames.push(existing.start.toString());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnames.push(existing.start.toString() + \"..\" + (existing.stop-1).toString());\n\t\t\t}\n\t\t}\n\t\tif (names.length > 1) {\n\t\t\treturn \"{\" + names.join(\", \") + \"}\";\n\t\t} else {\n\t\t\treturn names[0];\n\t\t}\n\t}\n\n\ttoTokenString(literalNames, symbolicNames) {\n\t\tconst names = [];\n\t\tfor (let i = 0; i < this.intervals.length; i++) {\n\t\t\tconst existing = this.intervals[i];\n\t\t\tfor (let j = existing.start; j < existing.stop; j++) {\n\t\t\t\tnames.push(this.elementName(literalNames, symbolicNames, j));\n\t\t\t}\n\t\t}\n\t\tif (names.length > 1) {\n\t\t\treturn \"{\" + names.join(\", \") + \"}\";\n\t\t} else {\n\t\t\treturn names[0];\n\t\t}\n\t}\n\n\telementName(literalNames, symbolicNames, token) {\n\t\tif (token === Token.EOF) {\n\t\t\treturn \"<EOF>\";\n\t\t} else if (token === Token.EPSILON) {\n\t\t\treturn \"<EPSILON>\";\n\t\t} else {\n\t\t\treturn literalNames[token] || symbolicNames[token];\n\t\t}\n\t}\n\n\tget length(){\n\t\treturn this.intervals.map( interval => interval.length ).reduce((acc, val) => acc + val);\n\t}\n}\n\nmodule.exports = {\n\tInterval,\n\tIntervalSet\n};\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Set, BitSet} = require('./Utils');\nconst {Token} = require('./Token');\nconst {ATNConfig} = require('./atn/ATNConfig');\nconst {IntervalSet} = require('./IntervalSet');\nconst {RuleStopState} = require('./atn/ATNState');\nconst {RuleTransition, NotSetTransition, WildcardTransition, AbstractPredicateTransition} = require('./atn/Transition');\nconst {predictionContextFromRuleContext, PredictionContext, SingletonPredictionContext} = require('./PredictionContext');\n\nclass LL1Analyzer {\n    constructor(atn) {\n        this.atn = atn;\n    }\n\n    /**\n     * Calculates the SLL(1) expected lookahead set for each outgoing transition\n     * of an {@link ATNState}. The returned array has one element for each\n     * outgoing transition in {@code s}. If the closure from transition\n     * <em>i</em> leads to a semantic predicate before matching a symbol, the\n     * element at index <em>i</em> of the result will be {@code null}.\n     *\n     * @param s the ATN state\n     * @return the expected symbols for each outgoing transition of {@code s}.\n     */\n    getDecisionLookahead(s) {\n        if (s === null) {\n            return null;\n        }\n        const count = s.transitions.length;\n        const look = [];\n        for(let alt=0; alt< count; alt++) {\n            look[alt] = new IntervalSet();\n            const lookBusy = new Set();\n            const seeThruPreds = false; // fail to get lookahead upon pred\n            this._LOOK(s.transition(alt).target, null, PredictionContext.EMPTY,\n                  look[alt], lookBusy, new BitSet(), seeThruPreds, false);\n            // Wipe out lookahead for this alternative if we found nothing\n            // or we had a predicate when we !seeThruPreds\n            if (look[alt].length===0 || look[alt].contains(LL1Analyzer.HIT_PRED)) {\n                look[alt] = null;\n            }\n        }\n        return look;\n    }\n\n    /**\n     * Compute set of tokens that can follow {@code s} in the ATN in the\n     * specified {@code ctx}.\n     *\n     * <p>If {@code ctx} is {@code null} and the end of the rule containing\n     * {@code s} is reached, {@link Token//EPSILON} is added to the result set.\n     * If {@code ctx} is not {@code null} and the end of the outermost rule is\n     * reached, {@link Token//EOF} is added to the result set.</p>\n     *\n     * @param s the ATN state\n     * @param stopState the ATN state to stop at. This can be a\n     * {@link BlockEndState} to detect epsilon paths through a closure.\n     * @param ctx the complete parser context, or {@code null} if the context\n     * should be ignored\n     *\n     * @return The set of tokens that can follow {@code s} in the ATN in the\n     * specified {@code ctx}.\n     */\n    LOOK(s, stopState, ctx) {\n        const r = new IntervalSet();\n        const seeThruPreds = true; // ignore preds; get all lookahead\n        ctx = ctx || null;\n        const lookContext = ctx!==null ? predictionContextFromRuleContext(s.atn, ctx) : null;\n        this._LOOK(s, stopState, lookContext, r, new Set(), new BitSet(), seeThruPreds, true);\n        return r;\n    }\n\n    /**\n     * Compute set of tokens that can follow {@code s} in the ATN in the\n     * specified {@code ctx}.\n     *\n     * <p>If {@code ctx} is {@code null} and {@code stopState} or the end of the\n     * rule containing {@code s} is reached, {@link Token//EPSILON} is added to\n     * the result set. If {@code ctx} is not {@code null} and {@code addEOF} is\n     * {@code true} and {@code stopState} or the end of the outermost rule is\n     * reached, {@link Token//EOF} is added to the result set.</p>\n     *\n     * @param s the ATN state.\n     * @param stopState the ATN state to stop at. This can be a\n     * {@link BlockEndState} to detect epsilon paths through a closure.\n     * @param ctx The outer context, or {@code null} if the outer context should\n     * not be used.\n     * @param look The result lookahead set.\n     * @param lookBusy A set used for preventing epsilon closures in the ATN\n     * from causing a stack overflow. Outside code should pass\n     * {@code new Set<ATNConfig>} for this argument.\n     * @param calledRuleStack A set used for preventing left recursion in the\n     * ATN from causing a stack overflow. Outside code should pass\n     * {@code new BitSet()} for this argument.\n     * @param seeThruPreds {@code true} to true semantic predicates as\n     * implicitly {@code true} and \"see through them\", otherwise {@code false}\n     * to treat semantic predicates as opaque and add {@link //HIT_PRED} to the\n     * result if one is encountered.\n     * @param addEOF Add {@link Token//EOF} to the result if the end of the\n     * outermost context is reached. This parameter has no effect if {@code ctx}\n     * is {@code null}.\n     */\n    _LOOK(s, stopState , ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF) {\n        const c = new ATNConfig({state:s, alt:0, context: ctx}, null);\n        if (lookBusy.contains(c)) {\n            return;\n        }\n        lookBusy.add(c);\n        if (s === stopState) {\n            if (ctx ===null) {\n                look.addOne(Token.EPSILON);\n                return;\n            } else if (ctx.isEmpty() && addEOF) {\n                look.addOne(Token.EOF);\n                return;\n            }\n        }\n        if (s instanceof RuleStopState ) {\n            if (ctx ===null) {\n                look.addOne(Token.EPSILON);\n                return;\n            } else if (ctx.isEmpty() && addEOF) {\n                look.addOne(Token.EOF);\n                return;\n            }\n            if (ctx !== PredictionContext.EMPTY) {\n                const removed = calledRuleStack.contains(s.ruleIndex);\n                try {\n                    calledRuleStack.remove(s.ruleIndex);\n                    // run thru all possible stack tops in ctx\n                    for (let i = 0; i < ctx.length; i++) {\n                        const returnState = this.atn.states[ctx.getReturnState(i)];\n                        this._LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n                    }\n                }finally {\n                    if (removed) {\n                        calledRuleStack.add(s.ruleIndex);\n                    }\n                }\n                return;\n            }\n        }\n        for(let j=0; j<s.transitions.length; j++) {\n            const t = s.transitions[j];\n            if (t.constructor === RuleTransition) {\n                if (calledRuleStack.contains(t.target.ruleIndex)) {\n                    continue;\n                }\n                const newContext = SingletonPredictionContext.create(ctx, t.followState.stateNumber);\n                try {\n                    calledRuleStack.add(t.target.ruleIndex);\n                    this._LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n                } finally {\n                    calledRuleStack.remove(t.target.ruleIndex);\n                }\n            } else if (t instanceof AbstractPredicateTransition ) {\n                if (seeThruPreds) {\n                    this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n                } else {\n                    look.addOne(LL1Analyzer.HIT_PRED);\n                }\n            } else if( t.isEpsilon) {\n                this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n            } else if (t.constructor === WildcardTransition) {\n                look.addRange( Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType );\n            } else {\n                let set = t.label;\n                if (set !== null) {\n                    if (t instanceof NotSetTransition) {\n                        set = set.complement(Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType);\n                    }\n                    look.addSet(set);\n                }\n            }\n        }\n    }\n}\n\n/**\n * Special value added to the lookahead sets to indicate that we hit\n * a predicate during analysis if {@code seeThruPreds==false}.\n */\nLL1Analyzer.HIT_PRED = Token.INVALID_TYPE;\n\nmodule.exports = LL1Analyzer;\n\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Token} = require('./Token');\nconst Recognizer = require('./Recognizer');\nconst CommonTokenFactory = require('./CommonTokenFactory');\nconst {RecognitionException} = require('./error/Errors');\nconst {LexerNoViableAltException} = require('./error/Errors');\n\nclass TokenSource {}\n\n/**\n * A lexer is recognizer that draws input symbols from a character stream.\n * lexer grammars result in a subclass of this object. A Lexer object\n * uses simplified match() and error recovery mechanisms in the interest of speed.\n */\nclass Lexer extends Recognizer {\n\tconstructor(input) {\n\t\tsuper();\n\t\tthis._input = input;\n\t\tthis._factory = CommonTokenFactory.DEFAULT;\n\t\tthis._tokenFactorySourcePair = [ this, input ];\n\n\t\tthis._interp = null; // child classes must populate this\n\n\t\t/**\n\t\t * The goal of all lexer rules/methods is to create a token object.\n\t\t * this is an instance variable as multiple rules may collaborate to\n\t\t * create a single token. nextToken will return this object after\n\t\t * matching lexer rule(s). If you subclass to allow multiple token\n\t\t * emissions, then set this to the last token to be matched or\n\t\t * something nonnull so that the auto token emit mechanism will not\n\t\t * emit another token.\n\t\t */\n\t\tthis._token = null;\n\n\t\t/**\n\t\t * What character index in the stream did the current token start at?\n\t\t * Needed, for example, to get the text for current token. Set at\n\t\t * the start of nextToken.\n\t\t */\n\t\tthis._tokenStartCharIndex = -1;\n\n\t\t// The line on which the first character of the token resides///\n\t\tthis._tokenStartLine = -1;\n\n\t\t// The character position of first character within the line///\n\t\tthis._tokenStartColumn = -1;\n\n\t\t// Once we see EOF on char stream, next token will be EOF.\n\t\t// If you have DONE : EOF ; then you see DONE EOF.\n\t\tthis._hitEOF = false;\n\n\t\t// The channel number for the current token///\n\t\tthis._channel = Token.DEFAULT_CHANNEL;\n\n\t\t// The token type for the current token///\n\t\tthis._type = Token.INVALID_TYPE;\n\n\t\tthis._modeStack = [];\n\t\tthis._mode = Lexer.DEFAULT_MODE;\n\n\t\t/**\n\t\t * You can set the text for the current token to override what is in\n\t\t * the input char buffer. Use setText() or can set this instance var.\n\t\t */\n\t\tthis._text = null;\n\t}\n\n\treset() {\n\t\t// wack Lexer state variables\n\t\tif (this._input !== null) {\n\t\t\tthis._input.seek(0); // rewind the input\n\t\t}\n\t\tthis._token = null;\n\t\tthis._type = Token.INVALID_TYPE;\n\t\tthis._channel = Token.DEFAULT_CHANNEL;\n\t\tthis._tokenStartCharIndex = -1;\n\t\tthis._tokenStartColumn = -1;\n\t\tthis._tokenStartLine = -1;\n\t\tthis._text = null;\n\n\t\tthis._hitEOF = false;\n\t\tthis._mode = Lexer.DEFAULT_MODE;\n\t\tthis._modeStack = [];\n\n\t\tthis._interp.reset();\n\t}\n\n// Return a token from this source; i.e., match a token on the char stream.\n\tnextToken() {\n\t\tif (this._input === null) {\n\t\t\tthrow \"nextToken requires a non-null input stream.\";\n\t\t}\n\n\t\t/**\n\t\t * Mark start location in char stream so unbuffered streams are\n\t\t * guaranteed at least have text of current token\n\t\t */\n\t\tconst tokenStartMarker = this._input.mark();\n\t\ttry {\n\t\t\twhile (true) {\n\t\t\t\tif (this._hitEOF) {\n\t\t\t\t\tthis.emitEOF();\n\t\t\t\t\treturn this._token;\n\t\t\t\t}\n\t\t\t\tthis._token = null;\n\t\t\t\tthis._channel = Token.DEFAULT_CHANNEL;\n\t\t\t\tthis._tokenStartCharIndex = this._input.index;\n\t\t\t\tthis._tokenStartColumn = this._interp.column;\n\t\t\t\tthis._tokenStartLine = this._interp.line;\n\t\t\t\tthis._text = null;\n\t\t\t\tlet continueOuter = false;\n\t\t\t\twhile (true) {\n\t\t\t\t\tthis._type = Token.INVALID_TYPE;\n\t\t\t\t\tlet ttype = Lexer.SKIP;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tttype = this._interp.match(this._input, this._mode);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tif(e instanceof RecognitionException) {\n\t\t\t\t\t\t\tthis.notifyListeners(e); // report error\n\t\t\t\t\t\t\tthis.recover(e);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconsole.log(e.stack);\n\t\t\t\t\t\t\tthrow e;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (this._input.LA(1) === Token.EOF) {\n\t\t\t\t\t\tthis._hitEOF = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (this._type === Token.INVALID_TYPE) {\n\t\t\t\t\t\tthis._type = ttype;\n\t\t\t\t\t}\n\t\t\t\t\tif (this._type === Lexer.SKIP) {\n\t\t\t\t\t\tcontinueOuter = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (this._type !== Lexer.MORE) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (continueOuter) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (this._token === null) {\n\t\t\t\t\tthis.emit();\n\t\t\t\t}\n\t\t\t\treturn this._token;\n\t\t\t}\n\t\t} finally {\n\t\t\t// make sure we release marker after match or\n\t\t\t// unbuffered char stream will keep buffering\n\t\t\tthis._input.release(tokenStartMarker);\n\t\t}\n\t}\n\n\t/**\n\t * Instruct the lexer to skip creating a token for current lexer rule\n\t * and look for another token. nextToken() knows to keep looking when\n\t * a lexer rule finishes with token set to SKIP_TOKEN. Recall that\n\t * if token==null at end of any token rule, it creates one for you\n\t * and emits it.\n\t */\n\tskip() {\n\t\tthis._type = Lexer.SKIP;\n\t}\n\n\tmore() {\n\t\tthis._type = Lexer.MORE;\n\t}\n\n\tmode(m) {\n\t\tthis._mode = m;\n\t}\n\n\tpushMode(m) {\n\t\tif (this._interp.debug) {\n\t\t\tconsole.log(\"pushMode \" + m);\n\t\t}\n\t\tthis._modeStack.push(this._mode);\n\t\tthis.mode(m);\n\t}\n\n\tpopMode() {\n\t\tif (this._modeStack.length === 0) {\n\t\t\tthrow \"Empty Stack\";\n\t\t}\n\t\tif (this._interp.debug) {\n\t\t\tconsole.log(\"popMode back to \" + this._modeStack.slice(0, -1));\n\t\t}\n\t\tthis.mode(this._modeStack.pop());\n\t\treturn this._mode;\n\t}\n\n\t/**\n\t * By default does not support multiple emits per nextToken invocation\n\t * for efficiency reasons. Subclass and override this method, nextToken,\n\t * and getToken (to push tokens into a list and pull from that list\n\t * rather than a single variable as this implementation does).\n\t */\n\temitToken(token) {\n\t\tthis._token = token;\n\t}\n\n\t/**\n\t * The standard method called to automatically emit a token at the\n\t * outermost lexical rule. The token object should point into the\n\t * char buffer start..stop. If there is a text override in 'text',\n\t * use that to set the token's text. Override this method to emit\n\t * custom Token objects or provide a new factory.\n\t */\n\temit() {\n\t\tconst t = this._factory.create(this._tokenFactorySourcePair, this._type,\n\t\t\t\tthis._text, this._channel, this._tokenStartCharIndex, this\n\t\t\t\t\t\t.getCharIndex() - 1, this._tokenStartLine,\n\t\t\t\tthis._tokenStartColumn);\n\t\tthis.emitToken(t);\n\t\treturn t;\n\t}\n\n\temitEOF() {\n\t\tconst cpos = this.column;\n\t\tconst lpos = this.line;\n\t\tconst eof = this._factory.create(this._tokenFactorySourcePair, Token.EOF,\n\t\t\t\tnull, Token.DEFAULT_CHANNEL, this._input.index,\n\t\t\t\tthis._input.index - 1, lpos, cpos);\n\t\tthis.emitToken(eof);\n\t\treturn eof;\n\t}\n\n// What is the index of the current character of lookahead?///\n\tgetCharIndex() {\n\t\treturn this._input.index;\n\t}\n\n\t/**\n\t * Return a list of all Token objects in input char stream.\n\t * Forces load of all tokens. Does not include EOF token.\n\t */\n\tgetAllTokens() {\n\t\tconst tokens = [];\n\t\tlet t = this.nextToken();\n\t\twhile (t.type !== Token.EOF) {\n\t\t\ttokens.push(t);\n\t\t\tt = this.nextToken();\n\t\t}\n\t\treturn tokens;\n\t}\n\n\tnotifyListeners(e) {\n\t\tconst start = this._tokenStartCharIndex;\n\t\tconst stop = this._input.index;\n\t\tconst text = this._input.getText(start, stop);\n\t\tconst msg = \"token recognition error at: '\" + this.getErrorDisplay(text) + \"'\";\n\t\tconst listener = this.getErrorListenerDispatch();\n\t\tlistener.syntaxError(this, null, this._tokenStartLine,\n\t\t\t\tthis._tokenStartColumn, msg, e);\n\t}\n\n\tgetErrorDisplay(s) {\n\t\tconst d = [];\n\t\tfor (let i = 0; i < s.length; i++) {\n\t\t\td.push(s[i]);\n\t\t}\n\t\treturn d.join('');\n\t}\n\n\tgetErrorDisplayForChar(c) {\n\t\tif (c.charCodeAt(0) === Token.EOF) {\n\t\t\treturn \"<EOF>\";\n\t\t} else if (c === '\\n') {\n\t\t\treturn \"\\\\n\";\n\t\t} else if (c === '\\t') {\n\t\t\treturn \"\\\\t\";\n\t\t} else if (c === '\\r') {\n\t\t\treturn \"\\\\r\";\n\t\t} else {\n\t\t\treturn c;\n\t\t}\n\t}\n\n\tgetCharErrorDisplay(c) {\n\t\treturn \"'\" + this.getErrorDisplayForChar(c) + \"'\";\n\t}\n\n\t/**\n\t * Lexers can normally match any char in it's vocabulary after matching\n\t * a token, so do the easy thing and just kill a character and hope\n\t * it all works out. You can instead use the rule invocation stack\n\t * to do sophisticated error recovery if you are in a fragment rule.\n\t */\n\trecover(re) {\n\t\tif (this._input.LA(1) !== Token.EOF) {\n\t\t\tif (re instanceof LexerNoViableAltException) {\n\t\t\t\t// skip a char and try again\n\t\t\t\tthis._interp.consume(this._input);\n\t\t\t} else {\n\t\t\t\t// TODO: Do we lose character or line position information?\n\t\t\t\tthis._input.consume();\n\t\t\t}\n\t\t}\n\t}\n\n\tget inputStream(){\n\t\treturn this._input;\n\t}\n\n\tset inputStream(input) {\n\t\tthis._input = null;\n\t\tthis._tokenFactorySourcePair = [ this, this._input ];\n\t\tthis.reset();\n\t\tthis._input = input;\n\t\tthis._tokenFactorySourcePair = [ this, this._input ];\n\t}\n\n\tget sourceName(){\n\t\treturn this._input.sourceName;\n\t}\n\n\tget type(){\n\t\treturn this._type;\n\t}\n\n\tset type(type) {\n\t\tthis._type = type;\n\t}\n\n\tget line(){\n\t\treturn this._interp.line;\n\t}\n\n\tset line(line) {\n\t\tthis._interp.line = line;\n\t}\n\n\tget column(){\n\t\treturn this._interp.column;\n\t}\n\n\tset column(column) {\n\t\tthis._interp.column = column;\n\t}\n\n\tget text(){\n\t\tif (this._text !== null) {\n\t\t\treturn this._text;\n\t\t} else {\n\t\t\treturn this._interp.getText(this._input);\n\t\t}\n\t}\n\n\tset text(text) {\n\t\tthis._text = text;\n\t}\n}\n\n\n\n\nLexer.DEFAULT_MODE = 0;\nLexer.MORE = -2;\nLexer.SKIP = -3;\n\nLexer.DEFAULT_TOKEN_CHANNEL = Token.DEFAULT_CHANNEL;\nLexer.HIDDEN = Token.HIDDEN_CHANNEL;\nLexer.MIN_CHAR_VALUE = 0x0000;\nLexer.MAX_CHAR_VALUE = 0x10FFFF;\n\n// Set the char stream and reset the lexer\n\n\nmodule.exports = Lexer;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Token} = require('./Token');\nconst {ParseTreeListener, TerminalNode, ErrorNode} = require('./tree/Tree');\nconst Recognizer = require('./Recognizer');\nconst {DefaultErrorStrategy} = require('./error/ErrorStrategy');\nconst ATNDeserializer = require('./atn/ATNDeserializer');\nconst ATNDeserializationOptions = require('./atn/ATNDeserializationOptions');\nconst Lexer = require('./Lexer');\n\nclass TraceListener extends ParseTreeListener {\n\tconstructor(parser) {\n\t\tsuper();\n\t\tthis.parser = parser;\n\t}\n\n\tenterEveryRule(ctx) {\n\t\tconsole.log(\"enter   \" + this.parser.ruleNames[ctx.ruleIndex] + \", LT(1)=\" + this.parser._input.LT(1).text);\n\t}\n\n\tvisitTerminal(node) {\n\t\tconsole.log(\"consume \" + node.symbol + \" rule \" + this.parser.ruleNames[this.parser._ctx.ruleIndex]);\n\t}\n\n\texitEveryRule(ctx) {\n\t\tconsole.log(\"exit    \" + this.parser.ruleNames[ctx.ruleIndex] + \", LT(1)=\" + this.parser._input.LT(1).text);\n\t}\n}\n\nclass Parser extends Recognizer {\n\t/**\n\t * this is all the parsing support code essentially; most of it is error\n\t * recovery stuff.\n\t */\n\tconstructor(input) {\n\t\tsuper();\n\t\t// The input stream.\n\t\tthis._input = null;\n\t\t/**\n\t\t * The error handling strategy for the parser. The default value is a new\n\t\t * instance of {@link DefaultErrorStrategy}.\n\t\t */\n\t\tthis._errHandler = new DefaultErrorStrategy();\n\t\tthis._precedenceStack = [];\n\t\tthis._precedenceStack.push(0);\n\t\t/**\n\t\t * The {@link ParserRuleContext} object for the currently executing rule.\n\t\t * this is always non-null during the parsing process.\n\t\t */\n\t\tthis._ctx = null;\n\t\t/**\n\t\t * Specifies whether or not the parser should construct a parse tree during\n\t\t * the parsing process. The default value is {@code true}.\n\t\t */\n\t\tthis.buildParseTrees = true;\n\t\t/**\n\t\t * When {@link //setTrace}{@code (true)} is called, a reference to the\n\t\t * {@link TraceListener} is stored here so it can be easily removed in a\n\t\t * later call to {@link //setTrace}{@code (false)}. The listener itself is\n\t\t * implemented as a parser listener so this field is not directly used by\n\t\t * other parser methods.\n\t\t */\n\t\tthis._tracer = null;\n\t\t/**\n\t\t * The list of {@link ParseTreeListener} listeners registered to receive\n\t\t * events during the parse.\n\t\t */\n\t\tthis._parseListeners = null;\n\t\t/**\n\t\t * The number of syntax errors reported during parsing. this value is\n\t\t * incremented each time {@link //notifyErrorListeners} is called.\n\t\t */\n\t\tthis._syntaxErrors = 0;\n\t\tthis.setInputStream(input);\n\t}\n\n\t// reset the parser's state\n\treset() {\n\t\tif (this._input !== null) {\n\t\t\tthis._input.seek(0);\n\t\t}\n\t\tthis._errHandler.reset(this);\n\t\tthis._ctx = null;\n\t\tthis._syntaxErrors = 0;\n\t\tthis.setTrace(false);\n\t\tthis._precedenceStack = [];\n\t\tthis._precedenceStack.push(0);\n\t\tif (this._interp !== null) {\n\t\t\tthis._interp.reset();\n\t\t}\n\t}\n\n\t/**\n\t * Match current input symbol against {@code ttype}. If the symbol type\n\t * matches, {@link ANTLRErrorStrategy//reportMatch} and {@link //consume} are\n\t * called to complete the match process.\n\t *\n\t * <p>If the symbol type does not match,\n\t * {@link ANTLRErrorStrategy//recoverInline} is called on the current error\n\t * strategy to attempt recovery. If {@link //getBuildParseTree} is\n\t * {@code true} and the token index of the symbol returned by\n\t * {@link ANTLRErrorStrategy//recoverInline} is -1, the symbol is added to\n\t * the parse tree by calling {@link ParserRuleContext//addErrorNode}.</p>\n\t *\n\t * @param ttype the token type to match\n\t * @return the matched symbol\n\t * @throws RecognitionException if the current input symbol did not match\n\t * {@code ttype} and the error strategy could not recover from the\n\t * mismatched symbol\n\t */\n\tmatch(ttype) {\n\t\tlet t = this.getCurrentToken();\n\t\tif (t.type === ttype) {\n\t\t\tthis._errHandler.reportMatch(this);\n\t\t\tthis.consume();\n\t\t} else {\n\t\t\tt = this._errHandler.recoverInline(this);\n\t\t\tif (this.buildParseTrees && t.tokenIndex === -1) {\n\t\t\t\t// we must have conjured up a new token during single token\n\t\t\t\t// insertion\n\t\t\t\t// if it's not the current symbol\n\t\t\t\tthis._ctx.addErrorNode(t);\n\t\t\t}\n\t\t}\n\t\treturn t;\n\t}\n\n\t/**\n\t * Match current input symbol as a wildcard. If the symbol type matches\n\t * (i.e. has a value greater than 0), {@link ANTLRErrorStrategy//reportMatch}\n\t * and {@link //consume} are called to complete the match process.\n\t *\n\t * <p>If the symbol type does not match,\n\t * {@link ANTLRErrorStrategy//recoverInline} is called on the current error\n\t * strategy to attempt recovery. If {@link //getBuildParseTree} is\n\t * {@code true} and the token index of the symbol returned by\n\t * {@link ANTLRErrorStrategy//recoverInline} is -1, the symbol is added to\n\t * the parse tree by calling {@link ParserRuleContext//addErrorNode}.</p>\n\t *\n\t * @return the matched symbol\n\t * @throws RecognitionException if the current input symbol did not match\n\t * a wildcard and the error strategy could not recover from the mismatched\n\t * symbol\n\t */\n\tmatchWildcard() {\n\t\tlet t = this.getCurrentToken();\n\t\tif (t.type > 0) {\n\t\t\tthis._errHandler.reportMatch(this);\n\t\t\tthis.consume();\n\t\t} else {\n\t\t\tt = this._errHandler.recoverInline(this);\n\t\t\tif (this._buildParseTrees && t.tokenIndex === -1) {\n\t\t\t\t// we must have conjured up a new token during single token\n\t\t\t\t// insertion\n\t\t\t\t// if it's not the current symbol\n\t\t\t\tthis._ctx.addErrorNode(t);\n\t\t\t}\n\t\t}\n\t\treturn t;\n\t}\n\n\tgetParseListeners() {\n\t\treturn this._parseListeners || [];\n\t}\n\n\t/**\n\t * Registers {@code listener} to receive events during the parsing process.\n\t *\n\t * <p>To support output-preserving grammar transformations (including but not\n\t * limited to left-recursion removal, automated left-factoring, and\n\t * optimized code generation), calls to listener methods during the parse\n\t * may differ substantially from calls made by\n\t * {@link ParseTreeWalker//DEFAULT} used after the parse is complete. In\n\t * particular, rule entry and exit events may occur in a different order\n\t * during the parse than after the parser. In addition, calls to certain\n\t * rule entry methods may be omitted.</p>\n\t *\n\t * <p>With the following specific exceptions, calls to listener events are\n\t * <em>deterministic</em>, i.e. for identical input the calls to listener\n\t * methods will be the same.</p>\n\t *\n\t * <ul>\n\t * <li>Alterations to the grammar used to generate code may change the\n\t * behavior of the listener calls.</li>\n\t * <li>Alterations to the command line options passed to ANTLR 4 when\n\t * generating the parser may change the behavior of the listener calls.</li>\n\t * <li>Changing the version of the ANTLR Tool used to generate the parser\n\t * may change the behavior of the listener calls.</li>\n\t * </ul>\n\t *\n\t * @param listener the listener to add\n\t *\n\t * @throws NullPointerException if {@code} listener is {@code null}\n\t */\n\taddParseListener(listener) {\n\t\tif (listener === null) {\n\t\t\tthrow \"listener\";\n\t\t}\n\t\tif (this._parseListeners === null) {\n\t\t\tthis._parseListeners = [];\n\t\t}\n\t\tthis._parseListeners.push(listener);\n\t}\n\n\t/**\n\t * Remove {@code listener} from the list of parse listeners.\n\t *\n\t * <p>If {@code listener} is {@code null} or has not been added as a parse\n\t * listener, this method does nothing.</p>\n\t * @param listener the listener to remove\n\t */\n\tremoveParseListener(listener) {\n\t\tif (this._parseListeners !== null) {\n\t\t\tconst idx = this._parseListeners.indexOf(listener);\n\t\t\tif (idx >= 0) {\n\t\t\t\tthis._parseListeners.splice(idx, 1);\n\t\t\t}\n\t\t\tif (this._parseListeners.length === 0) {\n\t\t\t\tthis._parseListeners = null;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove all parse listeners.\n\tremoveParseListeners() {\n\t\tthis._parseListeners = null;\n\t}\n\n\t// Notify any parse listeners of an enter rule event.\n\ttriggerEnterRuleEvent() {\n\t\tif (this._parseListeners !== null) {\n\t\t\tconst ctx = this._ctx;\n\t\t\tthis._parseListeners.forEach(function(listener) {\n\t\t\t\tlistener.enterEveryRule(ctx);\n\t\t\t\tctx.enterRule(listener);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Notify any parse listeners of an exit rule event.\n\t * @see //addParseListener\n\t */\n\ttriggerExitRuleEvent() {\n\t\tif (this._parseListeners !== null) {\n\t\t\t// reverse order walk of listeners\n\t\t\tconst ctx = this._ctx;\n\t\t\tthis._parseListeners.slice(0).reverse().forEach(function(listener) {\n\t\t\t\tctx.exitRule(listener);\n\t\t\t\tlistener.exitEveryRule(ctx);\n\t\t\t});\n\t\t}\n\t}\n\n\tgetTokenFactory() {\n\t\treturn this._input.tokenSource._factory;\n\t}\n\n\t// Tell our token source and error strategy about a new way to create tokens.\n\tsetTokenFactory(factory) {\n\t\tthis._input.tokenSource._factory = factory;\n\t}\n\n\t/**\n\t * The ATN with bypass alternatives is expensive to create so we create it\n\t * lazily.\n\t *\n\t * @throws UnsupportedOperationException if the current parser does not\n\t * implement the {@link //getSerializedATN()} method.\n\t */\n\tgetATNWithBypassAlts() {\n\t\tconst serializedAtn = this.getSerializedATN();\n\t\tif (serializedAtn === null) {\n\t\t\tthrow \"The current parser does not support an ATN with bypass alternatives.\";\n\t\t}\n\t\tlet result = this.bypassAltsAtnCache[serializedAtn];\n\t\tif (result === null) {\n\t\t\tconst deserializationOptions = new ATNDeserializationOptions();\n\t\t\tdeserializationOptions.generateRuleBypassTransitions = true;\n\t\t\tresult = new ATNDeserializer(deserializationOptions)\n\t\t\t\t\t.deserialize(serializedAtn);\n\t\t\tthis.bypassAltsAtnCache[serializedAtn] = result;\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * The preferred method of getting a tree pattern. For example, here's a\n\t * sample use:\n\t *\n\t * <pre>\n\t * ParseTree t = parser.expr();\n\t * ParseTreePattern p = parser.compileParseTreePattern(\"&lt;ID&gt;+0\",\n\t * MyParser.RULE_expr);\n\t * ParseTreeMatch m = p.match(t);\n\t * String id = m.get(\"ID\");\n\t * </pre>\n\t */\n\tcompileParseTreePattern(pattern, patternRuleIndex, lexer) {\n\t\tlexer = lexer || null;\n\t\tif (lexer === null) {\n\t\t\tif (this.getTokenStream() !== null) {\n\t\t\t\tconst tokenSource = this.getTokenStream().tokenSource;\n\t\t\t\tif (tokenSource instanceof Lexer) {\n\t\t\t\t\tlexer = tokenSource;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (lexer === null) {\n\t\t\tthrow \"Parser can't discover a lexer to use\";\n\t\t}\n\t\tconst m = new ParseTreePatternMatcher(lexer, this);\n\t\treturn m.compile(pattern, patternRuleIndex);\n\t}\n\n\tgetInputStream() {\n\t\treturn this.getTokenStream();\n\t}\n\n\tsetInputStream(input) {\n\t\tthis.setTokenStream(input);\n\t}\n\n\tgetTokenStream() {\n\t\treturn this._input;\n\t}\n\n\t// Set the token stream and reset the parser.\n\tsetTokenStream(input) {\n\t\tthis._input = null;\n\t\tthis.reset();\n\t\tthis._input = input;\n\t}\n\n\t/**\n\t * Match needs to return the current input symbol, which gets put\n\t * into the label for the associated token ref; e.g., x=ID.\n\t */\n\tgetCurrentToken() {\n\t\treturn this._input.LT(1);\n\t}\n\n\tnotifyErrorListeners(msg, offendingToken, err) {\n\t\toffendingToken = offendingToken || null;\n\t\terr = err || null;\n\t\tif (offendingToken === null) {\n\t\t\toffendingToken = this.getCurrentToken();\n\t\t}\n\t\tthis._syntaxErrors += 1;\n\t\tconst line = offendingToken.line;\n\t\tconst column = offendingToken.column;\n\t\tconst listener = this.getErrorListenerDispatch();\n\t\tlistener.syntaxError(this, offendingToken, line, column, msg, err);\n\t}\n\n\t/**\n\t * Consume and return the {@linkplain //getCurrentToken current symbol}.\n\t *\n\t * <p>E.g., given the following input with {@code A} being the current\n\t * lookahead symbol, this function moves the cursor to {@code B} and returns\n\t * {@code A}.</p>\n\t *\n\t * <pre>\n\t * A B\n\t * ^\n\t * </pre>\n\t *\n\t * If the parser is not in error recovery mode, the consumed symbol is added\n\t * to the parse tree using {@link ParserRuleContext//addChild(Token)}, and\n\t * {@link ParseTreeListener//visitTerminal} is called on any parse listeners.\n\t * If the parser <em>is</em> in error recovery mode, the consumed symbol is\n\t * added to the parse tree using\n\t * {@link ParserRuleContext//addErrorNode(Token)}, and\n\t * {@link ParseTreeListener//visitErrorNode} is called on any parse\n\t * listeners.\n\t */\n\tconsume() {\n\t\tconst o = this.getCurrentToken();\n\t\tif (o.type !== Token.EOF) {\n\t\t\tthis.getInputStream().consume();\n\t\t}\n\t\tconst hasListener = this._parseListeners !== null && this._parseListeners.length > 0;\n\t\tif (this.buildParseTrees || hasListener) {\n\t\t\tlet node;\n\t\t\tif (this._errHandler.inErrorRecoveryMode(this)) {\n\t\t\t\tnode = this._ctx.addErrorNode(o);\n\t\t\t} else {\n\t\t\t\tnode = this._ctx.addTokenNode(o);\n\t\t\t}\n\t\t\tnode.invokingState = this.state;\n\t\t\tif (hasListener) {\n\t\t\t\tthis._parseListeners.forEach(function(listener) {\n\t\t\t\t\tif (node instanceof ErrorNode || (node.isErrorNode !== undefined && node.isErrorNode())) {\n\t\t\t\t\t\tlistener.visitErrorNode(node);\n\t\t\t\t\t} else if (node instanceof TerminalNode) {\n\t\t\t\t\t\tlistener.visitTerminal(node);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn o;\n\t}\n\n\taddContextToParseTree() {\n\t\t// add current context to parent if we have a parent\n\t\tif (this._ctx.parentCtx !== null) {\n\t\t\tthis._ctx.parentCtx.addChild(this._ctx);\n\t\t}\n\t}\n\n\t/**\n\t * Always called by generated parsers upon entry to a rule. Access field\n\t * {@link //_ctx} get the current context.\n\t */\n\tenterRule(localctx, state, ruleIndex) {\n\t\tthis.state = state;\n\t\tthis._ctx = localctx;\n\t\tthis._ctx.start = this._input.LT(1);\n\t\tif (this.buildParseTrees) {\n\t\t\tthis.addContextToParseTree();\n\t\t}\n\t\tthis.triggerEnterRuleEvent();\n\t}\n\n\texitRule() {\n\t\tthis._ctx.stop = this._input.LT(-1);\n\t\t// trigger event on _ctx, before it reverts to parent\n\t\tthis.triggerExitRuleEvent();\n\t\tthis.state = this._ctx.invokingState;\n\t\tthis._ctx = this._ctx.parentCtx;\n\t}\n\n\tenterOuterAlt(localctx, altNum) {\n\t\tlocalctx.setAltNumber(altNum);\n\t\t// if we have new localctx, make sure we replace existing ctx\n\t\t// that is previous child of parse tree\n\t\tif (this.buildParseTrees && this._ctx !== localctx) {\n\t\t\tif (this._ctx.parentCtx !== null) {\n\t\t\t\tthis._ctx.parentCtx.removeLastChild();\n\t\t\t\tthis._ctx.parentCtx.addChild(localctx);\n\t\t\t}\n\t\t}\n\t\tthis._ctx = localctx;\n\t}\n\n\t/**\n\t * Get the precedence level for the top-most precedence rule.\n\t *\n\t * @return The precedence level for the top-most precedence rule, or -1 if\n\t * the parser context is not nested within a precedence rule.\n\t */\n\tgetPrecedence() {\n\t\tif (this._precedenceStack.length === 0) {\n\t\t\treturn -1;\n\t\t} else {\n\t\t\treturn this._precedenceStack[this._precedenceStack.length-1];\n\t\t}\n\t}\n\n\tenterRecursionRule(localctx, state, ruleIndex, precedence) {\n\t   this.state = state;\n\t   this._precedenceStack.push(precedence);\n\t   this._ctx = localctx;\n\t   this._ctx.start = this._input.LT(1);\n\t   this.triggerEnterRuleEvent(); // simulates rule entry for left-recursive rules\n   }\n\n\t// Like {@link //enterRule} but for recursive rules.\n\tpushNewRecursionContext(localctx, state, ruleIndex) {\n\t\tconst previous = this._ctx;\n\t\tprevious.parentCtx = localctx;\n\t\tprevious.invokingState = state;\n\t\tprevious.stop = this._input.LT(-1);\n\n\t\tthis._ctx = localctx;\n\t\tthis._ctx.start = previous.start;\n\t\tif (this.buildParseTrees) {\n\t\t\tthis._ctx.addChild(previous);\n\t\t}\n\t\tthis.triggerEnterRuleEvent(); // simulates rule entry for left-recursive rules\n\t}\n\n\tunrollRecursionContexts(parentCtx) {\n\t\tthis._precedenceStack.pop();\n\t\tthis._ctx.stop = this._input.LT(-1);\n\t\tconst retCtx = this._ctx; // save current ctx (return value)\n\t\t// unroll so _ctx is as it was before call to recursive method\n\t\tconst parseListeners = this.getParseListeners();\n\t\tif (parseListeners !== null && parseListeners.length > 0) {\n\t\t\twhile (this._ctx !== parentCtx) {\n\t\t\t\tthis.triggerExitRuleEvent();\n\t\t\t\tthis._ctx = this._ctx.parentCtx;\n\t\t\t}\n\t\t} else {\n\t\t\tthis._ctx = parentCtx;\n\t\t}\n\t\t// hook into tree\n\t\tretCtx.parentCtx = parentCtx;\n\t\tif (this.buildParseTrees && parentCtx !== null) {\n\t\t\t// add return ctx into invoking rule's tree\n\t\t\tparentCtx.addChild(retCtx);\n\t\t}\n\t}\n\n\tgetInvokingContext(ruleIndex) {\n\t\tlet ctx = this._ctx;\n\t\twhile (ctx !== null) {\n\t\t\tif (ctx.ruleIndex === ruleIndex) {\n\t\t\t\treturn ctx;\n\t\t\t}\n\t\t\tctx = ctx.parentCtx;\n\t\t}\n\t\treturn null;\n\t}\n\n\tprecpred(localctx, precedence) {\n\t\treturn precedence >= this._precedenceStack[this._precedenceStack.length-1];\n\t}\n\n\tinContext(context) {\n\t\t// TODO: useful in parser?\n\t\treturn false;\n\t}\n\n\t/**\n\t * Checks whether or not {@code symbol} can follow the current state in the\n\t * ATN. The behavior of this method is equivalent to the following, but is\n\t * implemented such that the complete context-sensitive follow set does not\n\t * need to be explicitly constructed.\n\t *\n\t * <pre>\n\t * return getExpectedTokens().contains(symbol);\n\t * </pre>\n\t *\n\t * @param symbol the symbol type to check\n\t * @return {@code true} if {@code symbol} can follow the current state in\n\t * the ATN, otherwise {@code false}.\n\t */\n\tisExpectedToken(symbol) {\n\t\tconst atn = this._interp.atn;\n\t\tlet ctx = this._ctx;\n\t\tconst s = atn.states[this.state];\n\t\tlet following = atn.nextTokens(s);\n\t\tif (following.contains(symbol)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!following.contains(Token.EPSILON)) {\n\t\t\treturn false;\n\t\t}\n\t\twhile (ctx !== null && ctx.invokingState >= 0 && following.contains(Token.EPSILON)) {\n\t\t\tconst invokingState = atn.states[ctx.invokingState];\n\t\t\tconst rt = invokingState.transitions[0];\n\t\t\tfollowing = atn.nextTokens(rt.followState);\n\t\t\tif (following.contains(symbol)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tctx = ctx.parentCtx;\n\t\t}\n\t\tif (following.contains(Token.EPSILON) && symbol === Token.EOF) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Computes the set of input symbols which could follow the current parser\n\t * state and context, as given by {@link //getState} and {@link //getContext},\n\t * respectively.\n\t *\n\t * @see ATN//getExpectedTokens(int, RuleContext)\n\t */\n\tgetExpectedTokens() {\n\t\treturn this._interp.atn.getExpectedTokens(this.state, this._ctx);\n\t}\n\n\tgetExpectedTokensWithinCurrentRule() {\n\t\tconst atn = this._interp.atn;\n\t\tconst s = atn.states[this.state];\n\t\treturn atn.nextTokens(s);\n\t}\n\n\t// Get a rule's index (i.e., {@code RULE_ruleName} field) or -1 if not found.\n\tgetRuleIndex(ruleName) {\n\t\tconst ruleIndex = this.getRuleIndexMap()[ruleName];\n\t\tif (ruleIndex !== null) {\n\t\t\treturn ruleIndex;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/**\n\t * Return List&lt;String&gt; of the rule names in your parser instance\n\t * leading up to a call to the current rule. You could override if\n\t * you want more details such as the file/line info of where\n\t * in the ATN a rule is invoked.\n\t *\n\t * this is very useful for error messages.\n\t */\n\tgetRuleInvocationStack(p) {\n\t\tp = p || null;\n\t\tif (p === null) {\n\t\t\tp = this._ctx;\n\t\t}\n\t\tconst stack = [];\n\t\twhile (p !== null) {\n\t\t\t// compute what follows who invoked us\n\t\t\tconst ruleIndex = p.ruleIndex;\n\t\t\tif (ruleIndex < 0) {\n\t\t\t\tstack.push(\"n/a\");\n\t\t\t} else {\n\t\t\t\tstack.push(this.ruleNames[ruleIndex]);\n\t\t\t}\n\t\t\tp = p.parentCtx;\n\t\t}\n\t\treturn stack;\n\t}\n\n\t// For debugging and other purposes.\n\tgetDFAStrings() {\n\t\treturn this._interp.decisionToDFA.toString();\n\t}\n\n\t// For debugging and other purposes.\n\tdumpDFA() {\n\t\tlet seenOne = false;\n\t\tfor (let i = 0; i < this._interp.decisionToDFA.length; i++) {\n\t\t\tconst dfa = this._interp.decisionToDFA[i];\n\t\t\tif (dfa.states.length > 0) {\n\t\t\t\tif (seenOne) {\n\t\t\t\t\tconsole.log();\n\t\t\t\t}\n\t\t\t\tthis.printer.println(\"Decision \" + dfa.decision + \":\");\n\t\t\t\tthis.printer.print(dfa.toString(this.literalNames, this.symbolicNames));\n\t\t\t\tseenOne = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t\t\"\t\t\tprinter = function() {\\r\\n\" +\n\t\t\"\t\t\t\tthis.println = function(s) { document.getElementById('output') += s + '\\\\n'; }\\r\\n\" +\n\t\t\"\t\t\t\tthis.print = function(s) { document.getElementById('output') += s; }\\r\\n\" +\n\t\t\"\t\t\t};\\r\\n\" +\n\t\t*/\n\tgetSourceName() {\n\t\treturn this._input.sourceName;\n\t}\n\n\t/**\n\t * During a parse is sometimes useful to listen in on the rule entry and exit\n\t * events as well as token matches. this is for quick and dirty debugging.\n\t */\n\tsetTrace(trace) {\n\t\tif (!trace) {\n\t\t\tthis.removeParseListener(this._tracer);\n\t\t\tthis._tracer = null;\n\t\t} else {\n\t\t\tif (this._tracer !== null) {\n\t\t\t\tthis.removeParseListener(this._tracer);\n\t\t\t}\n\t\t\tthis._tracer = new TraceListener(this);\n\t\t\tthis.addParseListener(this._tracer);\n\t\t}\n\t}\n}\n\n/**\n * this field maps from the serialized ATN string to the deserialized {@link\n * ATN} with\n * bypass alternatives.\n *\n * @see ATNDeserializationOptions//isGenerateRuleBypassTransitions()\n */\nParser.bypassAltsAtnCache = {};\n\nmodule.exports = Parser;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst RuleContext = require('./RuleContext');\nconst Tree = require('./tree/Tree');\nconst INVALID_INTERVAL = Tree.INVALID_INTERVAL;\nconst TerminalNode = Tree.TerminalNode;\nconst TerminalNodeImpl = Tree.TerminalNodeImpl;\nconst ErrorNodeImpl = Tree.ErrorNodeImpl;\nconst Interval = require(\"./IntervalSet\").Interval;\n\n/**\n * A rule invocation record for parsing.\n *\n *  Contains all of the information about the current rule not stored in the\n *  RuleContext. It handles parse tree children list, Any ATN state\n *  tracing, and the default values available for rule indications:\n *  start, stop, rule index, current alt number, current\n *  ATN state.\n *\n *  Subclasses made for each rule and grammar track the parameters,\n *  return values, locals, and labels specific to that rule. These\n *  are the objects that are returned from rules.\n *\n *  Note text is not an actual field of a rule return value; it is computed\n *  from start and stop using the input stream's toString() method.  I\n *  could add a ctor to this so that we can pass in and store the input\n *  stream, but I'm not sure we want to do that.  It would seem to be undefined\n *  to get the .text property anyway if the rule matches tokens from multiple\n *  input streams.\n *\n *  I do not use getters for fields of objects that are used simply to\n *  group values such as this aggregate.  The getters/setters are there to\n *  satisfy the superclass interface.\n */\nclass ParserRuleContext extends RuleContext {\n\tconstructor(parent, invokingStateNumber) {\n\t\tparent = parent || null;\n\t\tinvokingStateNumber = invokingStateNumber || null;\n\t\tsuper(parent, invokingStateNumber);\n\t\tthis.ruleIndex = -1;\n\t\t/**\n\t\t * If we are debugging or building a parse tree for a visitor,\n\t\t * we need to track all of the tokens and rule invocations associated\n\t\t * with this rule's context. This is empty for parsing w/o tree constr.\n\t\t * operation because we don't the need to track the details about\n\t\t * how we parse this rule.\n\t\t */\n\t\tthis.children = null;\n\t\tthis.start = null;\n\t\tthis.stop = null;\n\t\t/**\n\t\t * The exception that forced this rule to return. If the rule successfully\n\t\t * completed, this is {@code null}.\n\t\t */\n\t\tthis.exception = null;\n\t}\n\n\t// COPY a ctx (I'm deliberately not using copy constructor)\n\tcopyFrom(ctx) {\n\t\t// from RuleContext\n\t\tthis.parentCtx = ctx.parentCtx;\n\t\tthis.invokingState = ctx.invokingState;\n\t\tthis.children = null;\n\t\tthis.start = ctx.start;\n\t\tthis.stop = ctx.stop;\n\t\t// copy any error nodes to alt label node\n\t\tif(ctx.children) {\n\t\t\tthis.children = [];\n\t\t\t// reset parent pointer for any error nodes\n\t\t\tctx.children.map(function(child) {\n\t\t\t\tif (child instanceof ErrorNodeImpl) {\n\t\t\t\t\tthis.children.push(child);\n\t\t\t\t\tchild.parentCtx = this;\n\t\t\t\t}\n\t\t\t}, this);\n\t\t}\n\t}\n\n\t// Double dispatch methods for listeners\n\tenterRule(listener) {\n\t}\n\n\texitRule(listener) {\n\t}\n\n\t// Does not set parent link; other add methods do that\n\taddChild(child) {\n\t\tif (this.children === null) {\n\t\t\tthis.children = [];\n\t\t}\n\t\tthis.children.push(child);\n\t\treturn child;\n\t}\n\n\t/** Used by enterOuterAlt to toss out a RuleContext previously added as\n\t * we entered a rule. If we have // label, we will need to remove\n\t * generic ruleContext object.\n\t */\n\tremoveLastChild() {\n\t\tif (this.children !== null) {\n\t\t\tthis.children.pop();\n\t\t}\n\t}\n\n\taddTokenNode(token) {\n\t\tconst node = new TerminalNodeImpl(token);\n\t\tthis.addChild(node);\n\t\tnode.parentCtx = this;\n\t\treturn node;\n\t}\n\n\taddErrorNode(badToken) {\n\t\tconst node = new ErrorNodeImpl(badToken);\n\t\tthis.addChild(node);\n\t\tnode.parentCtx = this;\n\t\treturn node;\n\t}\n\n\tgetChild(i, type) {\n\t\ttype = type || null;\n\t\tif (this.children === null || i < 0 || i >= this.children.length) {\n\t\t\treturn null;\n\t\t}\n\t\tif (type === null) {\n\t\t\treturn this.children[i];\n\t\t} else {\n\t\t\tfor(let j=0; j<this.children.length; j++) {\n\t\t\t\tconst child = this.children[j];\n\t\t\t\tif(child instanceof type) {\n\t\t\t\t\tif(i===0) {\n\t\t\t\t\t\treturn child;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ti -= 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tgetToken(ttype, i) {\n\t\tif (this.children === null || i < 0 || i >= this.children.length) {\n\t\t\treturn null;\n\t\t}\n\t\tfor(let j=0; j<this.children.length; j++) {\n\t\t\tconst child = this.children[j];\n\t\t\tif (child instanceof TerminalNode) {\n\t\t\t\tif (child.symbol.type === ttype) {\n\t\t\t\t\tif(i===0) {\n\t\t\t\t\t\treturn child;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ti -= 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tgetTokens(ttype ) {\n\t\tif (this.children=== null) {\n\t\t\treturn [];\n\t\t} else {\n\t\t\tconst tokens = [];\n\t\t\tfor(let j=0; j<this.children.length; j++) {\n\t\t\t\tconst child = this.children[j];\n\t\t\t\tif (child instanceof TerminalNode) {\n\t\t\t\t\tif (child.symbol.type === ttype) {\n\t\t\t\t\t\ttokens.push(child);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokens;\n\t\t}\n\t}\n\n\tgetTypedRuleContext(ctxType, i) {\n\t\treturn this.getChild(i, ctxType);\n\t}\n\n\tgetTypedRuleContexts(ctxType) {\n\t\tif (this.children=== null) {\n\t\t\treturn [];\n\t\t} else {\n\t\t\tconst contexts = [];\n\t\t\tfor(let j=0; j<this.children.length; j++) {\n\t\t\t\tconst child = this.children[j];\n\t\t\t\tif (child instanceof ctxType) {\n\t\t\t\t\tcontexts.push(child);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn contexts;\n\t\t}\n\t}\n\n\tgetChildCount() {\n\t\tif (this.children=== null) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn this.children.length;\n\t\t}\n\t}\n\n\tgetSourceInterval() {\n\t\tif( this.start === null || this.stop === null) {\n\t\t\treturn INVALID_INTERVAL;\n\t\t} else {\n\t\t\treturn new Interval(this.start.tokenIndex, this.stop.tokenIndex);\n\t\t}\n\t}\n}\n\nRuleContext.EMPTY = new ParserRuleContext();\n\nclass InterpreterRuleContext extends ParserRuleContext {\n\tconstructor(parent, invokingStateNumber, ruleIndex) {\n\t\tsuper(parent, invokingStateNumber);\n\t\tthis.ruleIndex = ruleIndex;\n\t}\n}\n\nmodule.exports = ParserRuleContext;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst RuleContext = require('./RuleContext');\nconst {Hash, Map, equalArrays} = require('./Utils');\n\nclass PredictionContext {\n\n\tconstructor(cachedHashCode) {\n\t\tthis.cachedHashCode = cachedHashCode;\n\t}\n\n\t/**\n\t * Stores the computed hash code of this {@link PredictionContext}. The hash\n\t * code is computed in parts to match the following reference algorithm.\n\t *\n\t * <pre>\n\t * private int referenceHashCode() {\n\t * int hash = {@link MurmurHash//initialize MurmurHash.initialize}({@link\n\t * //INITIAL_HASH});\n\t *\n\t * for (int i = 0; i &lt; {@link //size()}; i++) {\n\t * hash = {@link MurmurHash//update MurmurHash.update}(hash, {@link //getParent\n\t * getParent}(i));\n\t * }\n\t *\n\t * for (int i = 0; i &lt; {@link //size()}; i++) {\n\t * hash = {@link MurmurHash//update MurmurHash.update}(hash, {@link\n\t * //getReturnState getReturnState}(i));\n\t * }\n\t *\n\t * hash = {@link MurmurHash//finish MurmurHash.finish}(hash, 2// {@link\n\t * //size()});\n\t * return hash;\n\t * }\n\t * </pre>\n\t * This means only the {@link //EMPTY} context is in set.\n\t */\n\tisEmpty() {\n\t\treturn this === PredictionContext.EMPTY;\n\t}\n\n\thasEmptyPath() {\n\t\treturn this.getReturnState(this.length - 1) === PredictionContext.EMPTY_RETURN_STATE;\n\t}\n\n\thashCode() {\n\t\treturn this.cachedHashCode;\n\t}\n\n\tupdateHashCode(hash) {\n\t\thash.update(this.cachedHashCode);\n\t}\n}\n\n/**\n * Represents {@code $} in local context prediction, which means wildcard.\n * {@code//+x =//}.\n */\nPredictionContext.EMPTY = null;\n\n/**\n * Represents {@code $} in an array in full context mode, when {@code $}\n * doesn't mean wildcard: {@code $ + x = [$,x]}. Here,\n * {@code $} = {@link //EMPTY_RETURN_STATE}.\n */\nPredictionContext.EMPTY_RETURN_STATE = 0x7FFFFFFF;\n\nPredictionContext.globalNodeCount = 1;\nPredictionContext.id = PredictionContext.globalNodeCount;\n\n\n/*\nfunction calculateHashString(parent, returnState) {\n\treturn \"\" + parent + returnState;\n}\n*/\n\n/**\n * Used to cache {@link PredictionContext} objects. Its used for the shared\n * context cash associated with contexts in DFA states. This cache\n * can be used for both lexers and parsers.\n */\nclass PredictionContextCache {\n\n\tconstructor() {\n\t\tthis.cache = new Map();\n\t}\n\n\t/**\n\t * Add a context to the cache and return it. If the context already exists,\n\t * return that one instead and do not add a new context to the cache.\n\t * Protect shared cache from unsafe thread access.\n\t */\n\tadd(ctx) {\n\t\tif (ctx === PredictionContext.EMPTY) {\n\t\t\treturn PredictionContext.EMPTY;\n\t\t}\n\t\tconst existing = this.cache.get(ctx) || null;\n\t\tif (existing !== null) {\n\t\t\treturn existing;\n\t\t}\n\t\tthis.cache.put(ctx, ctx);\n\t\treturn ctx;\n\t}\n\n\tget(ctx) {\n\t\treturn this.cache.get(ctx) || null;\n\t}\n\n\tget length(){\n\t\treturn this.cache.length;\n\t}\n}\n\n\nclass SingletonPredictionContext extends PredictionContext {\n\n\tconstructor(parent, returnState) {\n\t\tlet hashCode = 0;\n\t\tconst hash = new Hash();\n\t\tif(parent !== null) {\n\t\t\thash.update(parent, returnState);\n\t\t} else {\n\t\t\thash.update(1);\n\t\t}\n\t\thashCode = hash.finish();\n\t\tsuper(hashCode);\n\t\tthis.parentCtx = parent;\n\t\tthis.returnState = returnState;\n\t}\n\n\tgetParent(index) {\n\t\treturn this.parentCtx;\n\t}\n\n\tgetReturnState(index) {\n\t\treturn this.returnState;\n\t}\n\n\tequals(other) {\n\t\tif (this === other) {\n\t\t\treturn true;\n\t\t} else if (!(other instanceof SingletonPredictionContext)) {\n\t\t\treturn false;\n\t\t} else if (this.hashCode() !== other.hashCode()) {\n\t\t\treturn false; // can't be same if hash is different\n\t\t} else {\n\t\t\tif(this.returnState !== other.returnState)\n\t\t\t\treturn false;\n\t\t\telse if(this.parentCtx==null)\n\t\t\t\treturn other.parentCtx==null\n\t\t\telse\n\t\t\t\treturn this.parentCtx.equals(other.parentCtx);\n\t\t}\n\t}\n\n\ttoString() {\n\t\tconst up = this.parentCtx === null ? \"\" : this.parentCtx.toString();\n\t\tif (up.length === 0) {\n\t\t\tif (this.returnState === PredictionContext.EMPTY_RETURN_STATE) {\n\t\t\t\treturn \"$\";\n\t\t\t} else {\n\t\t\t\treturn \"\" + this.returnState;\n\t\t\t}\n\t\t} else {\n\t\t\treturn \"\" + this.returnState + \" \" + up;\n\t\t}\n\t}\n\n\tget length(){\n\t\treturn 1;\n\t}\n\n\tstatic create(parent, returnState) {\n\t\tif (returnState === PredictionContext.EMPTY_RETURN_STATE && parent === null) {\n\t\t\t// someone can pass in the bits of an array ctx that mean $\n\t\t\treturn PredictionContext.EMPTY;\n\t\t} else {\n\t\t\treturn new SingletonPredictionContext(parent, returnState);\n\t\t}\n\t}\n}\n\nclass EmptyPredictionContext extends SingletonPredictionContext {\n\n\tconstructor() {\n\t\tsuper(null, PredictionContext.EMPTY_RETURN_STATE);\n\t}\n\n\tisEmpty() {\n\t\treturn true;\n\t}\n\n\tgetParent(index) {\n\t\treturn null;\n\t}\n\n\tgetReturnState(index) {\n\t\treturn this.returnState;\n\t}\n\n\tequals(other) {\n\t\treturn this === other;\n\t}\n\n\ttoString() {\n\t\treturn \"$\";\n\t}\n}\n\n\nPredictionContext.EMPTY = new EmptyPredictionContext();\n\nclass ArrayPredictionContext extends PredictionContext {\n\n\tconstructor(parents, returnStates) {\n\t\t/**\n\t\t * Parent can be null only if full ctx mode and we make an array\n\t\t * from {@link //EMPTY} and non-empty. We merge {@link //EMPTY} by using\n\t\t * null parent and\n\t\t * returnState == {@link //EMPTY_RETURN_STATE}.\n\t\t */\n\t\tconst h = new Hash();\n\t\th.update(parents, returnStates);\n\t\tconst hashCode = h.finish();\n\t\tsuper(hashCode);\n\t\tthis.parents = parents;\n\t\tthis.returnStates = returnStates;\n\t\treturn this;\n\t}\n\n\tisEmpty() {\n\t\t// since EMPTY_RETURN_STATE can only appear in the last position, we\n\t\t// don't need to verify that size==1\n\t\treturn this.returnStates[0] === PredictionContext.EMPTY_RETURN_STATE;\n\t}\n\n\tgetParent(index) {\n\t\treturn this.parents[index];\n\t}\n\n\tgetReturnState(index) {\n\t\treturn this.returnStates[index];\n\t}\n\n\tequals(other) {\n\t\tif (this === other) {\n\t\t\treturn true;\n\t\t} else if (!(other instanceof ArrayPredictionContext)) {\n\t\t\treturn false;\n\t\t} else if (this.hashCode() !== other.hashCode()) {\n\t\t\treturn false; // can't be same if hash is different\n\t\t} else {\n\t\t\treturn equalArrays(this.returnStates, other.returnStates) &&\n\t\t\t\tequalArrays(this.parents, other.parents);\n\t\t}\n\t}\n\n\ttoString() {\n\t\tif (this.isEmpty()) {\n\t\t\treturn \"[]\";\n\t\t} else {\n\t\t\tlet s = \"[\";\n\t\t\tfor (let i = 0; i < this.returnStates.length; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\ts = s + \", \";\n\t\t\t\t}\n\t\t\t\tif (this.returnStates[i] === PredictionContext.EMPTY_RETURN_STATE) {\n\t\t\t\t\ts = s + \"$\";\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ts = s + this.returnStates[i];\n\t\t\t\tif (this.parents[i] !== null) {\n\t\t\t\t\ts = s + \" \" + this.parents[i];\n\t\t\t\t} else {\n\t\t\t\t\ts = s + \"null\";\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn s + \"]\";\n\t\t}\n\t}\n\n\tget length(){\n\t\treturn this.returnStates.length;\n\t}\n}\n\n\n/**\n * Convert a {@link RuleContext} tree to a {@link PredictionContext} graph.\n * Return {@link //EMPTY} if {@code outerContext} is empty or null.\n */\nfunction predictionContextFromRuleContext(atn, outerContext) {\n\tif (outerContext === undefined || outerContext === null) {\n\t\touterContext = RuleContext.EMPTY;\n\t}\n\t// if we are in RuleContext of start rule, s, then PredictionContext\n\t// is EMPTY. Nobody called us. (if we are empty, return empty)\n\tif (outerContext.parentCtx === null || outerContext === RuleContext.EMPTY) {\n\t\treturn PredictionContext.EMPTY;\n\t}\n\t// If we have a parent, convert it to a PredictionContext graph\n\tconst parent = predictionContextFromRuleContext(atn, outerContext.parentCtx);\n\tconst state = atn.states[outerContext.invokingState];\n\tconst transition = state.transitions[0];\n\treturn SingletonPredictionContext.create(parent, transition.followState.stateNumber);\n}\n/*\nfunction calculateListsHashString(parents, returnStates) {\n\tconst s = \"\";\n\tparents.map(function(p) {\n\t\ts = s + p;\n\t});\n\treturnStates.map(function(r) {\n\t\ts = s + r;\n\t});\n\treturn s;\n}\n*/\nfunction merge(a, b, rootIsWildcard, mergeCache) {\n\t// share same graph if both same\n\tif (a === b) {\n\t\treturn a;\n\t}\n\tif (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {\n\t\treturn mergeSingletons(a, b, rootIsWildcard, mergeCache);\n\t}\n\t// At least one of a or b is array\n\t// If one is $ and rootIsWildcard, return $ as// wildcard\n\tif (rootIsWildcard) {\n\t\tif (a instanceof EmptyPredictionContext) {\n\t\t\treturn a;\n\t\t}\n\t\tif (b instanceof EmptyPredictionContext) {\n\t\t\treturn b;\n\t\t}\n\t}\n\t// convert singleton so both are arrays to normalize\n\tif (a instanceof SingletonPredictionContext) {\n\t\ta = new ArrayPredictionContext([a.getParent()], [a.returnState]);\n\t}\n\tif (b instanceof SingletonPredictionContext) {\n\t\tb = new ArrayPredictionContext([b.getParent()], [b.returnState]);\n\t}\n\treturn mergeArrays(a, b, rootIsWildcard, mergeCache);\n}\n\n/**\n * Merge two {@link SingletonPredictionContext} instances.\n *\n * <p>Stack tops equal, parents merge is same; return left graph.<br>\n * <embed src=\"images/SingletonMerge_SameRootSamePar.svg\"\n * type=\"image/svg+xml\"/></p>\n *\n * <p>Same stack top, parents differ; merge parents giving array node, then\n * remainders of those graphs. A new root node is created to point to the\n * merged parents.<br>\n * <embed src=\"images/SingletonMerge_SameRootDiffPar.svg\"\n * type=\"image/svg+xml\"/></p>\n *\n * <p>Different stack tops pointing to same parent. Make array node for the\n * root where both element in the root point to the same (original)\n * parent.<br>\n * <embed src=\"images/SingletonMerge_DiffRootSamePar.svg\"\n * type=\"image/svg+xml\"/></p>\n *\n * <p>Different stack tops pointing to different parents. Make array node for\n * the root where each element points to the corresponding original\n * parent.<br>\n * <embed src=\"images/SingletonMerge_DiffRootDiffPar.svg\"\n * type=\"image/svg+xml\"/></p>\n *\n * @param a the first {@link SingletonPredictionContext}\n * @param b the second {@link SingletonPredictionContext}\n * @param rootIsWildcard {@code true} if this is a local-context merge,\n * otherwise false to indicate a full-context merge\n * @param mergeCache\n */\nfunction mergeSingletons(a, b, rootIsWildcard, mergeCache) {\n\tif (mergeCache !== null) {\n\t\tlet previous = mergeCache.get(a, b);\n\t\tif (previous !== null) {\n\t\t\treturn previous;\n\t\t}\n\t\tprevious = mergeCache.get(b, a);\n\t\tif (previous !== null) {\n\t\t\treturn previous;\n\t\t}\n\t}\n\n\tconst rootMerge = mergeRoot(a, b, rootIsWildcard);\n\tif (rootMerge !== null) {\n\t\tif (mergeCache !== null) {\n\t\t\tmergeCache.set(a, b, rootMerge);\n\t\t}\n\t\treturn rootMerge;\n\t}\n\tif (a.returnState === b.returnState) {\n\t\tconst parent = merge(a.parentCtx, b.parentCtx, rootIsWildcard, mergeCache);\n\t\t// if parent is same as existing a or b parent or reduced to a parent,\n\t\t// return it\n\t\tif (parent === a.parentCtx) {\n\t\t\treturn a; // ax + bx = ax, if a=b\n\t\t}\n\t\tif (parent === b.parentCtx) {\n\t\t\treturn b; // ax + bx = bx, if a=b\n\t\t}\n\t\t// else: ax + ay = a'[x,y]\n\t\t// merge parents x and y, giving array node with x,y then remainders\n\t\t// of those graphs. dup a, a' points at merged array\n\t\t// new joined parent so create new singleton pointing to it, a'\n\t\tconst spc = SingletonPredictionContext.create(parent, a.returnState);\n\t\tif (mergeCache !== null) {\n\t\t\tmergeCache.set(a, b, spc);\n\t\t}\n\t\treturn spc;\n\t} else { // a != b payloads differ\n\t\t// see if we can collapse parents due to $+x parents if local ctx\n\t\tlet singleParent = null;\n\t\tif (a === b || (a.parentCtx !== null && a.parentCtx === b.parentCtx)) { // ax +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// bx =\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// [a,b]x\n\t\t\tsingleParent = a.parentCtx;\n\t\t}\n\t\tif (singleParent !== null) { // parents are same\n\t\t\t// sort payloads and use same parent\n\t\t\tconst payloads = [ a.returnState, b.returnState ];\n\t\t\tif (a.returnState > b.returnState) {\n\t\t\t\tpayloads[0] = b.returnState;\n\t\t\t\tpayloads[1] = a.returnState;\n\t\t\t}\n\t\t\tconst parents = [ singleParent, singleParent ];\n\t\t\tconst apc = new ArrayPredictionContext(parents, payloads);\n\t\t\tif (mergeCache !== null) {\n\t\t\t\tmergeCache.set(a, b, apc);\n\t\t\t}\n\t\t\treturn apc;\n\t\t}\n\t\t// parents differ and can't merge them. Just pack together\n\t\t// into array; can't merge.\n\t\t// ax + by = [ax,by]\n\t\tconst payloads = [ a.returnState, b.returnState ];\n\t\tlet parents = [ a.parentCtx, b.parentCtx ];\n\t\tif (a.returnState > b.returnState) { // sort by payload\n\t\t\tpayloads[0] = b.returnState;\n\t\t\tpayloads[1] = a.returnState;\n\t\t\tparents = [ b.parentCtx, a.parentCtx ];\n\t\t}\n\t\tconst a_ = new ArrayPredictionContext(parents, payloads);\n\t\tif (mergeCache !== null) {\n\t\t\tmergeCache.set(a, b, a_);\n\t\t}\n\t\treturn a_;\n\t}\n}\n\n/**\n * Handle case where at least one of {@code a} or {@code b} is\n * {@link //EMPTY}. In the following diagrams, the symbol {@code $} is used\n * to represent {@link //EMPTY}.\n *\n * <h2>Local-Context Merges</h2>\n *\n * <p>These local-context merge operations are used when {@code rootIsWildcard}\n * is true.</p>\n *\n * <p>{@link //EMPTY} is superset of any graph; return {@link //EMPTY}.<br>\n * <embed src=\"images/LocalMerge_EmptyRoot.svg\" type=\"image/svg+xml\"/></p>\n *\n * <p>{@link //EMPTY} and anything is {@code //EMPTY}, so merged parent is\n * {@code //EMPTY}; return left graph.<br>\n * <embed src=\"images/LocalMerge_EmptyParent.svg\" type=\"image/svg+xml\"/></p>\n *\n * <p>Special case of last merge if local context.<br>\n * <embed src=\"images/LocalMerge_DiffRoots.svg\" type=\"image/svg+xml\"/></p>\n *\n * <h2>Full-Context Merges</h2>\n *\n * <p>These full-context merge operations are used when {@code rootIsWildcard}\n * is false.</p>\n *\n * <p><embed src=\"images/FullMerge_EmptyRoots.svg\" type=\"image/svg+xml\"/></p>\n *\n * <p>Must keep all contexts; {@link //EMPTY} in array is a special value (and\n * null parent).<br>\n * <embed src=\"images/FullMerge_EmptyRoot.svg\" type=\"image/svg+xml\"/></p>\n *\n * <p><embed src=\"images/FullMerge_SameRoot.svg\" type=\"image/svg+xml\"/></p>\n *\n * @param a the first {@link SingletonPredictionContext}\n * @param b the second {@link SingletonPredictionContext}\n * @param rootIsWildcard {@code true} if this is a local-context merge,\n * otherwise false to indicate a full-context merge\n */\nfunction mergeRoot(a, b, rootIsWildcard) {\n\tif (rootIsWildcard) {\n\t\tif (a === PredictionContext.EMPTY) {\n\t\t\treturn PredictionContext.EMPTY; // // + b =//\n\t\t}\n\t\tif (b === PredictionContext.EMPTY) {\n\t\t\treturn PredictionContext.EMPTY; // a +// =//\n\t\t}\n\t} else {\n\t\tif (a === PredictionContext.EMPTY && b === PredictionContext.EMPTY) {\n\t\t\treturn PredictionContext.EMPTY; // $ + $ = $\n\t\t} else if (a === PredictionContext.EMPTY) { // $ + x = [$,x]\n\t\t\tconst payloads = [ b.returnState,\n\t\t\t\t\tPredictionContext.EMPTY_RETURN_STATE ];\n\t\t\tconst parents = [ b.parentCtx, null ];\n\t\t\treturn new ArrayPredictionContext(parents, payloads);\n\t\t} else if (b === PredictionContext.EMPTY) { // x + $ = [$,x] ($ is always first if present)\n\t\t\tconst payloads = [ a.returnState, PredictionContext.EMPTY_RETURN_STATE ];\n\t\t\tconst parents = [ a.parentCtx, null ];\n\t\t\treturn new ArrayPredictionContext(parents, payloads);\n\t\t}\n\t}\n\treturn null;\n}\n\n/**\n * Merge two {@link ArrayPredictionContext} instances.\n *\n * <p>Different tops, different parents.<br>\n * <embed src=\"images/ArrayMerge_DiffTopDiffPar.svg\" type=\"image/svg+xml\"/></p>\n *\n * <p>Shared top, same parents.<br>\n * <embed src=\"images/ArrayMerge_ShareTopSamePar.svg\" type=\"image/svg+xml\"/></p>\n *\n * <p>Shared top, different parents.<br>\n * <embed src=\"images/ArrayMerge_ShareTopDiffPar.svg\" type=\"image/svg+xml\"/></p>\n *\n * <p>Shared top, all shared parents.<br>\n * <embed src=\"images/ArrayMerge_ShareTopSharePar.svg\"\n * type=\"image/svg+xml\"/></p>\n *\n * <p>Equal tops, merge parents and reduce top to\n * {@link SingletonPredictionContext}.<br>\n * <embed src=\"images/ArrayMerge_EqualTop.svg\" type=\"image/svg+xml\"/></p>\n */\nfunction mergeArrays(a, b, rootIsWildcard, mergeCache) {\n\tif (mergeCache !== null) {\n\t\tlet previous = mergeCache.get(a, b);\n\t\tif (previous !== null) {\n\t\t\treturn previous;\n\t\t}\n\t\tprevious = mergeCache.get(b, a);\n\t\tif (previous !== null) {\n\t\t\treturn previous;\n\t\t}\n\t}\n\t// merge sorted payloads a + b => M\n\tlet i = 0; // walks a\n\tlet j = 0; // walks b\n\tlet k = 0; // walks target M array\n\n\tlet mergedReturnStates = [];\n\tlet mergedParents = [];\n\t// walk and merge to yield mergedParents, mergedReturnStates\n\twhile (i < a.returnStates.length && j < b.returnStates.length) {\n\t\tconst a_parent = a.parents[i];\n\t\tconst b_parent = b.parents[j];\n\t\tif (a.returnStates[i] === b.returnStates[j]) {\n\t\t\t// same payload (stack tops are equal), must yield merged singleton\n\t\t\tconst payload = a.returnStates[i];\n\t\t\t// $+$ = $\n\t\t\tconst bothDollars = payload === PredictionContext.EMPTY_RETURN_STATE &&\n\t\t\t\t\ta_parent === null && b_parent === null;\n\t\t\tconst ax_ax = (a_parent !== null && b_parent !== null && a_parent === b_parent); // ax+ax\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// ->\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// ax\n\t\t\tif (bothDollars || ax_ax) {\n\t\t\t\tmergedParents[k] = a_parent; // choose left\n\t\t\t\tmergedReturnStates[k] = payload;\n\t\t\t} else { // ax+ay -> a'[x,y]\n\t\t\t\tmergedParents[k] = merge(a_parent, b_parent, rootIsWildcard, mergeCache);\n\t\t\t\tmergedReturnStates[k] = payload;\n\t\t\t}\n\t\t\ti += 1; // hop over left one as usual\n\t\t\tj += 1; // but also skip one in right side since we merge\n\t\t} else if (a.returnStates[i] < b.returnStates[j]) { // copy a[i] to M\n\t\t\tmergedParents[k] = a_parent;\n\t\t\tmergedReturnStates[k] = a.returnStates[i];\n\t\t\ti += 1;\n\t\t} else { // b > a, copy b[j] to M\n\t\t\tmergedParents[k] = b_parent;\n\t\t\tmergedReturnStates[k] = b.returnStates[j];\n\t\t\tj += 1;\n\t\t}\n\t\tk += 1;\n\t}\n\t// copy over any payloads remaining in either array\n\tif (i < a.returnStates.length) {\n\t\tfor (let p = i; p < a.returnStates.length; p++) {\n\t\t\tmergedParents[k] = a.parents[p];\n\t\t\tmergedReturnStates[k] = a.returnStates[p];\n\t\t\tk += 1;\n\t\t}\n\t} else {\n\t\tfor (let p = j; p < b.returnStates.length; p++) {\n\t\t\tmergedParents[k] = b.parents[p];\n\t\t\tmergedReturnStates[k] = b.returnStates[p];\n\t\t\tk += 1;\n\t\t}\n\t}\n\t// trim merged if we combined a few that had same stack tops\n\tif (k < mergedParents.length) { // write index < last position; trim\n\t\tif (k === 1) { // for just one merged element, return singleton top\n\t\t\tconst a_ = SingletonPredictionContext.create(mergedParents[0],\n\t\t\t\t\tmergedReturnStates[0]);\n\t\t\tif (mergeCache !== null) {\n\t\t\t\tmergeCache.set(a, b, a_);\n\t\t\t}\n\t\t\treturn a_;\n\t\t}\n\t\tmergedParents = mergedParents.slice(0, k);\n\t\tmergedReturnStates = mergedReturnStates.slice(0, k);\n\t}\n\n\tconst M = new ArrayPredictionContext(mergedParents, mergedReturnStates);\n\n\t// if we created same array as a or b, return that instead\n\t// TODO: track whether this is possible above during merge sort for speed\n\tif (M === a) {\n\t\tif (mergeCache !== null) {\n\t\t\tmergeCache.set(a, b, a);\n\t\t}\n\t\treturn a;\n\t}\n\tif (M === b) {\n\t\tif (mergeCache !== null) {\n\t\t\tmergeCache.set(a, b, b);\n\t\t}\n\t\treturn b;\n\t}\n\tcombineCommonParents(mergedParents);\n\n\tif (mergeCache !== null) {\n\t\tmergeCache.set(a, b, M);\n\t}\n\treturn M;\n}\n\n/**\n * Make pass over all <em>M</em> {@code parents}; merge any {@code equals()}\n * ones.\n */\nfunction combineCommonParents(parents) {\n\tconst uniqueParents = new Map();\n\n\tfor (let p = 0; p < parents.length; p++) {\n\t\tconst parent = parents[p];\n\t\tif (!(uniqueParents.containsKey(parent))) {\n\t\t\tuniqueParents.put(parent, parent);\n\t\t}\n\t}\n\tfor (let q = 0; q < parents.length; q++) {\n\t\tparents[q] = uniqueParents.get(parents[q]);\n\t}\n}\n\nfunction getCachedPredictionContext(context, contextCache, visited) {\n\tif (context.isEmpty()) {\n\t\treturn context;\n\t}\n\tlet existing = visited.get(context) || null;\n\tif (existing !== null) {\n\t\treturn existing;\n\t}\n\texisting = contextCache.get(context);\n\tif (existing !== null) {\n\t\tvisited.put(context, existing);\n\t\treturn existing;\n\t}\n\tlet changed = false;\n\tlet parents = [];\n\tfor (let i = 0; i < parents.length; i++) {\n\t\tconst parent = getCachedPredictionContext(context.getParent(i), contextCache, visited);\n\t\tif (changed || parent !== context.getParent(i)) {\n\t\t\tif (!changed) {\n\t\t\t\tparents = [];\n\t\t\t\tfor (let j = 0; j < context.length; j++) {\n\t\t\t\t\tparents[j] = context.getParent(j);\n\t\t\t\t}\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t\tparents[i] = parent;\n\t\t}\n\t}\n\tif (!changed) {\n\t\tcontextCache.add(context);\n\t\tvisited.put(context, context);\n\t\treturn context;\n\t}\n\tlet updated = null;\n\tif (parents.length === 0) {\n\t\tupdated = PredictionContext.EMPTY;\n\t} else if (parents.length === 1) {\n\t\tupdated = SingletonPredictionContext.create(parents[0], context\n\t\t\t\t.getReturnState(0));\n\t} else {\n\t\tupdated = new ArrayPredictionContext(parents, context.returnStates);\n\t}\n\tcontextCache.add(updated);\n\tvisited.put(updated, updated);\n\tvisited.put(context, updated);\n\n\treturn updated;\n}\n\n// ter's recursive version of Sam's getAllNodes()\nfunction getAllContextNodes(context, nodes, visited) {\n\tif (nodes === null) {\n\t\tnodes = [];\n\t\treturn getAllContextNodes(context, nodes, visited);\n\t} else if (visited === null) {\n\t\tvisited = new Map();\n\t\treturn getAllContextNodes(context, nodes, visited);\n\t} else {\n\t\tif (context === null || visited.containsKey(context)) {\n\t\t\treturn nodes;\n\t\t}\n\t\tvisited.put(context, context);\n\t\tnodes.push(context);\n\t\tfor (let i = 0; i < context.length; i++) {\n\t\t\tgetAllContextNodes(context.getParent(i), nodes, visited);\n\t\t}\n\t\treturn nodes;\n\t}\n}\n\nmodule.exports = {\n\tmerge,\n\tPredictionContext,\n\tPredictionContextCache,\n\tSingletonPredictionContext,\n\tpredictionContextFromRuleContext,\n\tgetCachedPredictionContext\n}\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Token} = require('./Token');\nconst {ConsoleErrorListener} = require('./error/ErrorListener');\nconst {ProxyErrorListener} = require('./error/ErrorListener');\n\nclass Recognizer {\n    constructor() {\n        this._listeners = [ ConsoleErrorListener.INSTANCE ];\n        this._interp = null;\n        this._stateNumber = -1;\n    }\n\n    checkVersion(toolVersion) {\n        const runtimeVersion = \"4.9.3\";\n        if (runtimeVersion!==toolVersion) {\n            console.log(\"ANTLR runtime and generated code versions disagree: \"+runtimeVersion+\"!=\"+toolVersion);\n        }\n    }\n\n    addErrorListener(listener) {\n        this._listeners.push(listener);\n    }\n\n    removeErrorListeners() {\n        this._listeners = [];\n    }\n\n    getLiteralNames() {\n        return Object.getPrototypeOf(this).constructor.literalNames || [];\n    }\n\n    getSymbolicNames() {\n        return Object.getPrototypeOf(this).constructor.symbolicNames || [];\n    }\n\n    getTokenNames() {\n        if(!this.tokenNames) {\n            const literalNames = this.getLiteralNames();\n            const symbolicNames = this.getSymbolicNames();\n            const length = literalNames.length > symbolicNames.length ? literalNames.length : symbolicNames.length;\n            this.tokenNames = [];\n            for(let i=0; i<length; i++) {\n                this.tokenNames[i] = literalNames[i] || symbolicNames[i] || \"<INVALID\";\n            }\n        }\n        return this.tokenNames;\n    }\n\n    getTokenTypeMap() {\n        const tokenNames = this.getTokenNames();\n        if (tokenNames===null) {\n            throw(\"The current recognizer does not provide a list of token names.\");\n        }\n        let result = this.tokenTypeMapCache[tokenNames];\n        if(result===undefined) {\n            result = tokenNames.reduce(function(o, k, i) { o[k] = i; });\n            result.EOF = Token.EOF;\n            this.tokenTypeMapCache[tokenNames] = result;\n        }\n        return result;\n    }\n\n    /**\n     * Get a map from rule names to rule indexes.\n     * <p>Used for XPath and tree pattern compilation.</p>\n     */\n    getRuleIndexMap() {\n        const ruleNames = this.ruleNames;\n        if (ruleNames===null) {\n            throw(\"The current recognizer does not provide a list of rule names.\");\n        }\n        let result = this.ruleIndexMapCache[ruleNames]; // todo: should it be Recognizer.ruleIndexMapCache ?\n        if(result===undefined) {\n            result = ruleNames.reduce(function(o, k, i) { o[k] = i; });\n            this.ruleIndexMapCache[ruleNames] = result;\n        }\n        return result;\n    }\n\n    getTokenType(tokenName) {\n        const ttype = this.getTokenTypeMap()[tokenName];\n        if (ttype !==undefined) {\n            return ttype;\n        } else {\n            return Token.INVALID_TYPE;\n        }\n    }\n\n    // What is the error header, normally line/character position information?\n    getErrorHeader(e) {\n        const line = e.getOffendingToken().line;\n        const column = e.getOffendingToken().column;\n        return \"line \" + line + \":\" + column;\n    }\n\n    /**\n     * How should a token be displayed in an error message? The default\n     * is to display just the text, but during development you might\n     * want to have a lot of information spit out.  Override in that case\n     * to use t.toString() (which, for CommonToken, dumps everything about\n     * the token). This is better than forcing you to override a method in\n     * your token objects because you don't have to go modify your lexer\n     * so that it creates a new Java type.\n     *\n     * @deprecated This method is not called by the ANTLR 4 Runtime. Specific\n     * implementations of {@link ANTLRErrorStrategy} may provide a similar\n     * feature when necessary. For example, see\n     * {@link DefaultErrorStrategy//getTokenErrorDisplay}.*/\n    getTokenErrorDisplay(t) {\n        if (t===null) {\n            return \"<no token>\";\n        }\n        let s = t.text;\n        if (s===null) {\n            if (t.type===Token.EOF) {\n                s = \"<EOF>\";\n            } else {\n                s = \"<\" + t.type + \">\";\n            }\n        }\n        s = s.replace(\"\\n\",\"\\\\n\").replace(\"\\r\",\"\\\\r\").replace(\"\\t\",\"\\\\t\");\n        return \"'\" + s + \"'\";\n    }\n\n    getErrorListenerDispatch() {\n        return new ProxyErrorListener(this._listeners);\n    }\n\n    /**\n     * subclass needs to override these if there are sempreds or actions\n     * that the ATN interp needs to execute\n     */\n    sempred(localctx, ruleIndex, actionIndex) {\n        return true;\n    }\n\n    precpred(localctx , precedence) {\n        return true;\n    }\n\n    get state(){\n        return this._stateNumber;\n    }\n\n    set state(state) {\n        this._stateNumber = state;\n    }\n}\n\nRecognizer.tokenTypeMapCache = {};\nRecognizer.ruleIndexMapCache = {};\n\nmodule.exports = Recognizer;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {RuleNode} = require('./tree/Tree');\nconst {INVALID_INTERVAL} = require('./tree/Tree');\nconst Trees = require('./tree/Trees');\n\nclass RuleContext extends RuleNode {\n\t/** A rule context is a record of a single rule invocation. It knows\n\t * which context invoked it, if any. If there is no parent context, then\n\t * naturally the invoking state is not valid.  The parent link\n\t * provides a chain upwards from the current rule invocation to the root\n\t * of the invocation tree, forming a stack. We actually carry no\n\t * information about the rule associated with this context (except\n\t * when parsing). We keep only the state number of the invoking state from\n\t * the ATN submachine that invoked this. Contrast this with the s\n\t * pointer inside ParserRuleContext that tracks the current state\n\t * being \"executed\" for the current rule.\n\t *\n\t * The parent contexts are useful for computing lookahead sets and\n\t * getting error information.\n\t *\n\t * These objects are used during parsing and prediction.\n\t * For the special case of parsers, we use the subclass\n\t * ParserRuleContext.\n\t *\n\t * @see ParserRuleContext\n\t */\n\tconstructor(parent, invokingState) {\n\t\t// What context invoked this rule?\n\t\tsuper();\n\t\tthis.parentCtx = parent || null;\n\t\t/**\n\t\t * What state invoked the rule associated with this context?\n\t\t * The \"return address\" is the followState of invokingState\n\t\t * If parent is null, this should be -1.\n\t\t */\n\t\tthis.invokingState = invokingState || -1;\n\t}\n\n\tdepth() {\n\t\tlet n = 0;\n\t\tlet p = this;\n\t\twhile (p !== null) {\n\t\t\tp = p.parentCtx;\n\t\t\tn += 1;\n\t\t}\n\t\treturn n;\n\t}\n\n\t/**\n\t * A context is empty if there is no invoking state; meaning nobody call\n\t * current context.\n\t */\n\tisEmpty() {\n\t\treturn this.invokingState === -1;\n\t}\n\n// satisfy the ParseTree / SyntaxTree interface\n\tgetSourceInterval() {\n\t\treturn INVALID_INTERVAL;\n\t}\n\n\tgetRuleContext() {\n\t\treturn this;\n\t}\n\n\tgetPayload() {\n\t\treturn this;\n\t}\n\n\t/**\n\t * Return the combined text of all child nodes. This method only considers\n\t * tokens which have been added to the parse tree.\n\t * <p>\n\t * Since tokens on hidden channels (e.g. whitespace or comments) are not\n\t * added to the parse trees, they will not appear in the output of this\n\t * method.\n\t */\n\tgetText() {\n\t\tif (this.getChildCount() === 0) {\n\t\t\treturn \"\";\n\t\t} else {\n\t\t\treturn this.children.map(function(child) {\n\t\t\t\treturn child.getText();\n\t\t\t}).join(\"\");\n\t\t}\n\t}\n\n\t/**\n\t * For rule associated with this parse tree internal node, return\n\t * the outer alternative number used to match the input. Default\n\t * implementation does not compute nor store this alt num. Create\n\t * a subclass of ParserRuleContext with backing field and set\n\t * option contextSuperClass.\n\t * to set it.\n\t */\n\tgetAltNumber() {\n\t    // use constant value of ATN.INVALID_ALT_NUMBER to avoid circular dependency\n\t    return 0;\n    }\n\n\t/**\n\t * Set the outer alternative number for this context node. Default\n\t * implementation does nothing to avoid backing field overhead for\n\t * trees that don't need it.  Create\n\t * a subclass of ParserRuleContext with backing field and set\n\t * option contextSuperClass.\n\t */\n\tsetAltNumber(altNumber) { }\n\n\tgetChild(i) {\n\t\treturn null;\n\t}\n\n\tgetChildCount() {\n\t\treturn 0;\n\t}\n\n\taccept(visitor) {\n\t\treturn visitor.visitChildren(this);\n\t}\n\n\t/**\n\t * Print out a whole tree, not just a node, in LISP format\n\t * (root child1 .. childN). Print just a node if this is a leaf.\n\t */\n\ttoStringTree(ruleNames, recog) {\n\t\treturn Trees.toStringTree(this, ruleNames, recog);\n\t}\n\n\ttoString(ruleNames, stop) {\n\t\truleNames = ruleNames || null;\n\t\tstop = stop || null;\n\t\tlet p = this;\n\t\tlet s = \"[\";\n\t\twhile (p !== null && p !== stop) {\n\t\t\tif (ruleNames === null) {\n\t\t\t\tif (!p.isEmpty()) {\n\t\t\t\t\ts += p.invokingState;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst ri = p.ruleIndex;\n\t\t\t\tconst ruleName = (ri >= 0 && ri < ruleNames.length) ? ruleNames[ri]\n\t\t\t\t\t\t: \"\" + ri;\n\t\t\t\ts += ruleName;\n\t\t\t}\n\t\t\tif (p.parentCtx !== null && (ruleNames !== null || !p.parentCtx.isEmpty())) {\n\t\t\t\ts += \" \";\n\t\t\t}\n\t\t\tp = p.parentCtx;\n\t\t}\n\t\ts += \"]\";\n\t\treturn s;\n\t}\n}\n\nmodule.exports = RuleContext;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\n/**\n * A token has properties: text, type, line, character position in the line\n * (so we can ignore tabs), token channel, index, and source from which\n * we obtained this token.\n */\nclass Token {\n\tconstructor() {\n\t\tthis.source = null;\n\t\tthis.type = null; // token type of the token\n\t\tthis.channel = null; // The parser ignores everything not on DEFAULT_CHANNEL\n\t\tthis.start = null; // optional; return -1 if not implemented.\n\t\tthis.stop = null; // optional; return -1 if not implemented.\n\t\tthis.tokenIndex = null; // from 0..n-1 of the token object in the input stream\n\t\tthis.line = null; // line=1..n of the 1st character\n\t\tthis.column = null; // beginning of the line at which it occurs, 0..n-1\n\t\tthis._text = null; // text of the token.\n\t}\n\n\tgetTokenSource() {\n\t\treturn this.source[0];\n\t}\n\n\tgetInputStream() {\n\t\treturn this.source[1];\n\t}\n\n\tget text(){\n\t\treturn this._text;\n\t}\n\n\tset text(text) {\n\t\tthis._text = text;\n\t}\n}\n\nToken.INVALID_TYPE = 0;\n\n/**\n * During lookahead operations, this \"token\" signifies we hit rule end ATN state\n * and did not follow it despite needing to.\n */\nToken.EPSILON = -2;\n\nToken.MIN_USER_TOKEN_TYPE = 1;\n\nToken.EOF = -1;\n\n/**\n * All tokens go to the parser (unless skip() is called in that rule)\n * on a particular \"channel\". The parser tunes to a particular channel\n * so that whitespace etc... can go to the parser on a \"hidden\" channel.\n */\nToken.DEFAULT_CHANNEL = 0;\n\n/**\n * Anything on different channel than DEFAULT_CHANNEL is not parsed\n * by parser.\n */\nToken.HIDDEN_CHANNEL = 1;\n\n\nclass CommonToken extends Token {\n\tconstructor(source, type, channel, start, stop) {\n\t\tsuper();\n\t\tthis.source = source !== undefined ? source : CommonToken.EMPTY_SOURCE;\n\t\tthis.type = type !== undefined ? type : null;\n\t\tthis.channel = channel !== undefined ? channel : Token.DEFAULT_CHANNEL;\n\t\tthis.start = start !== undefined ? start : -1;\n\t\tthis.stop = stop !== undefined ? stop : -1;\n\t\tthis.tokenIndex = -1;\n\t\tif (this.source[0] !== null) {\n\t\t\tthis.line = source[0].line;\n\t\t\tthis.column = source[0].column;\n\t\t} else {\n\t\t\tthis.column = -1;\n\t\t}\n\t}\n\n\t/**\n\t * Constructs a new {@link CommonToken} as a copy of another {@link Token}.\n\t *\n\t * <p>\n\t * If {@code oldToken} is also a {@link CommonToken} instance, the newly\n\t * constructed token will share a reference to the {@link //text} field and\n\t * the {@link Pair} stored in {@link //source}. Otherwise, {@link //text} will\n\t * be assigned the result of calling {@link //getText}, and {@link //source}\n\t * will be constructed from the result of {@link Token//getTokenSource} and\n\t * {@link Token//getInputStream}.</p>\n\t *\n\t * @param oldToken The token to copy.\n\t */\n\tclone() {\n\t\tconst t = new CommonToken(this.source, this.type, this.channel, this.start, this.stop);\n\t\tt.tokenIndex = this.tokenIndex;\n\t\tt.line = this.line;\n\t\tt.column = this.column;\n\t\tt.text = this.text;\n\t\treturn t;\n\t}\n\n\ttoString() {\n\t\tlet txt = this.text;\n\t\tif (txt !== null) {\n\t\t\ttxt = txt.replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/\\t/g, \"\\\\t\");\n\t\t} else {\n\t\t\ttxt = \"<no text>\";\n\t\t}\n\t\treturn \"[@\" + this.tokenIndex + \",\" + this.start + \":\" + this.stop + \"='\" +\n\t\t\t\ttxt + \"',<\" + this.type + \">\" +\n\t\t\t\t(this.channel > 0 ? \",channel=\" + this.channel : \"\") + \",\" +\n\t\t\t\tthis.line + \":\" + this.column + \"]\";\n\t}\n\n\tget text(){\n\t\tif (this._text !== null) {\n\t\t\treturn this._text;\n\t\t}\n\t\tconst input = this.getInputStream();\n\t\tif (input === null) {\n\t\t\treturn null;\n\t\t}\n\t\tconst n = input.size;\n\t\tif (this.start < n && this.stop < n) {\n\t\t\treturn input.getText(this.start, this.stop);\n\t\t} else {\n\t\t\treturn \"<EOF>\";\n\t\t}\n\t}\n\n\tset text(text) {\n\t\tthis._text = text;\n\t}\n}\n\n/**\n * An empty {@link Pair} which is used as the default value of\n * {@link //source} for tokens that do not have a source.\n */\nCommonToken.EMPTY_SOURCE = [ null, null ];\n\nmodule.exports = {\n\tToken,\n\tCommonToken\n}\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nfunction valueToString(v) {\n    return v === null ? \"null\" : v;\n}\n\nfunction arrayToString(a) {\n    return Array.isArray(a) ? (\"[\" + a.map(valueToString).join(\", \") + \"]\") : \"null\";\n}\n\nString.prototype.seed = String.prototype.seed || Math.round(Math.random() * Math.pow(2, 32));\n\nString.prototype.hashCode = function () {\n    const key = this.toString();\n    let h1b, k1;\n\n    const remainder = key.length & 3; // key.length % 4\n    const bytes = key.length - remainder;\n    let h1 = String.prototype.seed;\n    const c1 = 0xcc9e2d51;\n    const c2 = 0x1b873593;\n    let i = 0;\n\n    while (i < bytes) {\n        k1 =\n            ((key.charCodeAt(i) & 0xff)) |\n            ((key.charCodeAt(++i) & 0xff) << 8) |\n            ((key.charCodeAt(++i) & 0xff) << 16) |\n            ((key.charCodeAt(++i) & 0xff) << 24);\n        ++i;\n\n        k1 = ((((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16))) & 0xffffffff;\n        k1 = (k1 << 15) | (k1 >>> 17);\n        k1 = ((((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16))) & 0xffffffff;\n\n        h1 ^= k1;\n        h1 = (h1 << 13) | (h1 >>> 19);\n        h1b = ((((h1 & 0xffff) * 5) + ((((h1 >>> 16) * 5) & 0xffff) << 16))) & 0xffffffff;\n        h1 = (((h1b & 0xffff) + 0x6b64) + ((((h1b >>> 16) + 0xe654) & 0xffff) << 16));\n    }\n\n    k1 = 0;\n\n    switch (remainder) {\n        case 3:\n            k1 ^= (key.charCodeAt(i + 2) & 0xff) << 16;\n        case 2:\n            k1 ^= (key.charCodeAt(i + 1) & 0xff) << 8;\n        case 1:\n            k1 ^= (key.charCodeAt(i) & 0xff);\n\n            k1 = (((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16)) & 0xffffffff;\n            k1 = (k1 << 15) | (k1 >>> 17);\n            k1 = (((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16)) & 0xffffffff;\n            h1 ^= k1;\n    }\n\n    h1 ^= key.length;\n\n    h1 ^= h1 >>> 16;\n    h1 = (((h1 & 0xffff) * 0x85ebca6b) + ((((h1 >>> 16) * 0x85ebca6b) & 0xffff) << 16)) & 0xffffffff;\n    h1 ^= h1 >>> 13;\n    h1 = ((((h1 & 0xffff) * 0xc2b2ae35) + ((((h1 >>> 16) * 0xc2b2ae35) & 0xffff) << 16))) & 0xffffffff;\n    h1 ^= h1 >>> 16;\n\n    return h1 >>> 0;\n};\n\nfunction standardEqualsFunction(a, b) {\n    return a ? a.equals(b) : a==b;\n}\n\nfunction standardHashCodeFunction(a) {\n    return a ? a.hashCode() : -1;\n}\n\nclass Set {\n    constructor(hashFunction, equalsFunction) {\n        this.data = {};\n        this.hashFunction = hashFunction || standardHashCodeFunction;\n        this.equalsFunction = equalsFunction || standardEqualsFunction;\n    }\n\n    add(value) {\n        const hash = this.hashFunction(value);\n        const key = \"hash_\" + hash;\n        if (key in this.data) {\n            const values = this.data[key];\n            for (let i = 0; i < values.length; i++) {\n                if (this.equalsFunction(value, values[i])) {\n                    return values[i];\n                }\n            }\n            values.push(value);\n            return value;\n        } else {\n            this.data[key] = [value];\n            return value;\n        }\n    }\n\n    contains(value) {\n        return this.get(value) != null;\n    }\n\n    get(value) {\n        const hash = this.hashFunction(value);\n        const key = \"hash_\" + hash;\n        if (key in this.data) {\n            const values = this.data[key];\n            for (let i = 0; i < values.length; i++) {\n                if (this.equalsFunction(value, values[i])) {\n                    return values[i];\n                }\n            }\n        }\n        return null;\n    }\n\n    values() {\n        let l = [];\n        for (const key in this.data) {\n            if (key.indexOf(\"hash_\") === 0) {\n                l = l.concat(this.data[key]);\n            }\n        }\n        return l;\n    }\n\n    toString() {\n        return arrayToString(this.values());\n    }\n\n    get length(){\n        let l = 0;\n        for (const key in this.data) {\n            if (key.indexOf(\"hash_\") === 0) {\n                l = l + this.data[key].length;\n            }\n        }\n        return l;\n    }\n}\n\n\nclass BitSet {\n    constructor() {\n        this.data = [];\n    }\n\n    add(value) {\n        this.data[value] = true;\n    }\n\n    or(set) {\n        const bits = this;\n        Object.keys(set.data).map(function (alt) {\n            bits.add(alt);\n        });\n    }\n\n    remove(value) {\n        delete this.data[value];\n    }\n\n    contains(value) {\n        return this.data[value] === true;\n    }\n\n    values() {\n        return Object.keys(this.data);\n    }\n\n    minValue() {\n        return Math.min.apply(null, this.values());\n    }\n\n    hashCode() {\n        const hash = new Hash();\n        hash.update(this.values());\n        return hash.finish();\n    }\n\n    equals(other) {\n        if (!(other instanceof BitSet)) {\n            return false;\n        }\n        return this.hashCode() === other.hashCode();\n    }\n\n    toString() {\n        return \"{\" + this.values().join(\", \") + \"}\";\n    }\n\n    get length(){\n        return this.values().length;\n    }\n}\n\n\nclass Map {\n    constructor(hashFunction, equalsFunction) {\n        this.data = {};\n        this.hashFunction = hashFunction || standardHashCodeFunction;\n        this.equalsFunction = equalsFunction || standardEqualsFunction;\n    }\n\n    put(key, value) {\n        const hashKey = \"hash_\" + this.hashFunction(key);\n        if (hashKey in this.data) {\n            const entries = this.data[hashKey];\n            for (let i = 0; i < entries.length; i++) {\n                const entry = entries[i];\n                if (this.equalsFunction(key, entry.key)) {\n                    const oldValue = entry.value;\n                    entry.value = value;\n                    return oldValue;\n                }\n            }\n            entries.push({key:key, value:value});\n            return value;\n        } else {\n            this.data[hashKey] = [{key:key, value:value}];\n            return value;\n        }\n    }\n\n    containsKey(key) {\n        const hashKey = \"hash_\" + this.hashFunction(key);\n        if(hashKey in this.data) {\n            const entries = this.data[hashKey];\n            for (let i = 0; i < entries.length; i++) {\n                const entry = entries[i];\n                if (this.equalsFunction(key, entry.key))\n                    return true;\n            }\n        }\n        return false;\n    }\n\n    get(key) {\n        const hashKey = \"hash_\" + this.hashFunction(key);\n        if(hashKey in this.data) {\n            const entries = this.data[hashKey];\n            for (let i = 0; i < entries.length; i++) {\n                const entry = entries[i];\n                if (this.equalsFunction(key, entry.key))\n                    return entry.value;\n            }\n        }\n        return null;\n    }\n\n    entries() {\n        let l = [];\n        for (const key in this.data) {\n            if (key.indexOf(\"hash_\") === 0) {\n                l = l.concat(this.data[key]);\n            }\n        }\n        return l;\n    }\n\n    getKeys() {\n        return this.entries().map(function(e) {\n            return e.key;\n        });\n    }\n\n    getValues() {\n        return this.entries().map(function(e) {\n                return e.value;\n        });\n    }\n\n    toString() {\n        const ss = this.entries().map(function(entry) {\n            return '{' + entry.key + ':' + entry.value + '}';\n        });\n        return '[' + ss.join(\", \") + ']';\n    }\n\n    get length(){\n        let l = 0;\n        for (const hashKey in this.data) {\n            if (hashKey.indexOf(\"hash_\") === 0) {\n                l = l + this.data[hashKey].length;\n            }\n        }\n        return l;\n    }\n}\n\n\nclass AltDict {\n    constructor() {\n        this.data = {};\n    }\n\n    get(key) {\n        key = \"k-\" + key;\n        if (key in this.data) {\n            return this.data[key];\n        } else {\n            return null;\n        }\n    }\n\n    put(key, value) {\n        key = \"k-\" + key;\n        this.data[key] = value;\n    }\n\n    values() {\n        const data = this.data;\n        const keys = Object.keys(this.data);\n        return keys.map(function (key) {\n            return data[key];\n        });\n    }\n}\n\n\nclass DoubleDict {\n    constructor(defaultMapCtor) {\n        this.defaultMapCtor = defaultMapCtor || Map;\n        this.cacheMap = new this.defaultMapCtor();\n    }\n\n    get(a, b) {\n        const d = this.cacheMap.get(a) || null;\n        return d === null ? null : (d.get(b) || null);\n    }\n\n    set(a, b, o) {\n        let d = this.cacheMap.get(a) || null;\n        if (d === null) {\n            d = new this.defaultMapCtor();\n            this.cacheMap.put(a, d);\n        }\n        d.put(b, o);\n    }\n}\n\nclass Hash {\n    constructor() {\n        this.count = 0;\n        this.hash = 0;\n    }\n\n    update() {\n        for(let i=0;i<arguments.length;i++) {\n            const value = arguments[i];\n            if (value == null)\n                continue;\n            if(Array.isArray(value))\n                this.update.apply(this, value);\n            else {\n                let k = 0;\n                switch (typeof(value)) {\n                    case 'undefined':\n                    case 'function':\n                        continue;\n                    case 'number':\n                    case 'boolean':\n                        k = value;\n                        break;\n                    case 'string':\n                        k = value.hashCode();\n                        break;\n                    default:\n                        if(value.updateHashCode)\n                            value.updateHashCode(this);\n                        else\n                            console.log(\"No updateHashCode for \" + value.toString())\n                        continue;\n                }\n                k = k * 0xCC9E2D51;\n                k = (k << 15) | (k >>> (32 - 15));\n                k = k * 0x1B873593;\n                this.count = this.count + 1;\n                let hash = this.hash ^ k;\n                hash = (hash << 13) | (hash >>> (32 - 13));\n                hash = hash * 5 + 0xE6546B64;\n                this.hash = hash;\n            }\n        }\n    }\n\n    finish() {\n        let hash = this.hash ^ (this.count * 4);\n        hash = hash ^ (hash >>> 16);\n        hash = hash * 0x85EBCA6B;\n        hash = hash ^ (hash >>> 13);\n        hash = hash * 0xC2B2AE35;\n        hash = hash ^ (hash >>> 16);\n        return hash;\n    }\n}\n\nfunction hashStuff() {\n    const hash = new Hash();\n    hash.update.apply(hash, arguments);\n    return hash.finish();\n}\n\n\nfunction escapeWhitespace(s, escapeSpaces) {\n    s = s.replace(/\\t/g, \"\\\\t\")\n         .replace(/\\n/g, \"\\\\n\")\n         .replace(/\\r/g, \"\\\\r\");\n    if (escapeSpaces) {\n        s = s.replace(/ /g, \"\\u00B7\");\n    }\n    return s;\n}\n\nfunction titleCase(str) {\n    return str.replace(/\\w\\S*/g, function (txt) {\n        return txt.charAt(0).toUpperCase() + txt.substr(1);\n    });\n}\n\nfunction equalArrays(a, b) {\n    if (!Array.isArray(a) || !Array.isArray(b))\n        return false;\n    if (a === b)\n        return true;\n    if (a.length !== b.length)\n        return false;\n    for (let i = 0; i < a.length; i++) {\n        if (a[i] === b[i])\n            continue;\n        if (!a[i].equals || !a[i].equals(b[i]))\n            return false;\n    }\n    return true;\n}\n\nmodule.exports = {\n    Hash,\n    Set,\n    Map,\n    BitSet,\n    AltDict,\n    DoubleDict,\n    hashStuff,\n    escapeWhitespace,\n    arrayToString,\n    titleCase,\n    equalArrays\n}\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst LL1Analyzer = require('./../LL1Analyzer');\nconst {IntervalSet} = require('./../IntervalSet');\nconst {Token} = require('./../Token');\n\nclass ATN {\n\n    constructor(grammarType , maxTokenType) {\n        /**\n         * Used for runtime deserialization of ATNs from strings\n         * The type of the ATN.\n        */\n        this.grammarType = grammarType;\n        // The maximum value for any symbol recognized by a transition in the ATN.\n        this.maxTokenType = maxTokenType;\n        this.states = [];\n        /**\n         * Each subrule/rule is a decision point and we must track them so we\n         * can go back later and build DFA predictors for them.  This includes\n         * all the rules, subrules, optional blocks, ()+, ()* etc...\n         */\n        this.decisionToState = [];\n        // Maps from rule index to starting state number.\n        this.ruleToStartState = [];\n        // Maps from rule index to stop state number.\n        this.ruleToStopState = null;\n        this.modeNameToStartState = {};\n        /**\n         * For lexer ATNs, this maps the rule index to the resulting token type.\n         * For parser ATNs, this maps the rule index to the generated bypass token\n         * type if the {@link ATNDeserializationOptions//isGenerateRuleBypassTransitions}\n         * deserialization option was specified; otherwise, this is {@code null}\n         */\n        this.ruleToTokenType = null;\n        /**\n         * For lexer ATNs, this is an array of {@link LexerAction} objects which may\n         * be referenced by action transitions in the ATN\n         */\n        this.lexerActions = null;\n        this.modeToStartState = [];\n    }\n\n    /**\n     * Compute the set of valid tokens that can occur starting in state {@code s}.\n     * If {@code ctx} is null, the set of tokens will not include what can follow\n     * the rule surrounding {@code s}. In other words, the set will be\n     * restricted to tokens reachable staying within {@code s}'s rule\n     */\n    nextTokensInContext(s, ctx) {\n        const anal = new LL1Analyzer(this);\n        return anal.LOOK(s, null, ctx);\n    }\n\n    /**\n     * Compute the set of valid tokens that can occur starting in {@code s} and\n     * staying in same rule. {@link Token//EPSILON} is in set if we reach end of\n     * rule\n     */\n    nextTokensNoContext(s) {\n        if (s.nextTokenWithinRule !== null ) {\n            return s.nextTokenWithinRule;\n        }\n        s.nextTokenWithinRule = this.nextTokensInContext(s, null);\n        s.nextTokenWithinRule.readOnly = true;\n        return s.nextTokenWithinRule;\n    }\n\n    nextTokens(s, ctx) {\n        if ( ctx===undefined ) {\n            return this.nextTokensNoContext(s);\n        } else {\n            return this.nextTokensInContext(s, ctx);\n        }\n    }\n\n    addState(state) {\n        if ( state !== null ) {\n            state.atn = this;\n            state.stateNumber = this.states.length;\n        }\n        this.states.push(state);\n    }\n\n    removeState(state) {\n        this.states[state.stateNumber] = null; // just free mem, don't shift states in list\n    }\n\n    defineDecisionState(s) {\n        this.decisionToState.push(s);\n        s.decision = this.decisionToState.length-1;\n        return s.decision;\n    }\n\n    getDecisionState(decision) {\n        if (this.decisionToState.length===0) {\n            return null;\n        } else {\n            return this.decisionToState[decision];\n        }\n    }\n\n    /**\n     * Computes the set of input symbols which could follow ATN state number\n     * {@code stateNumber} in the specified full {@code context}. This method\n     * considers the complete parser context, but does not evaluate semantic\n     * predicates (i.e. all predicates encountered during the calculation are\n     * assumed true). If a path in the ATN exists from the starting state to the\n     * {@link RuleStopState} of the outermost context without matching any\n     * symbols, {@link Token//EOF} is added to the returned set.\n     *\n     * <p>If {@code context} is {@code null}, it is treated as\n     * {@link ParserRuleContext//EMPTY}.</p>\n     *\n     * @param stateNumber the ATN state number\n     * @param ctx the full parse context\n     *\n     * @return {IntervalSet} The set of potentially valid input symbols which could follow the\n     * specified state in the specified context.\n     *\n     * @throws IllegalArgumentException if the ATN does not contain a state with\n     * number {@code stateNumber}\n     */\n    getExpectedTokens(stateNumber, ctx ) {\n        if ( stateNumber < 0 || stateNumber >= this.states.length ) {\n            throw(\"Invalid state number.\");\n        }\n        const s = this.states[stateNumber];\n        let following = this.nextTokens(s);\n        if (!following.contains(Token.EPSILON)) {\n            return following;\n        }\n        const expected = new IntervalSet();\n        expected.addSet(following);\n        expected.removeOne(Token.EPSILON);\n        while (ctx !== null && ctx.invokingState >= 0 && following.contains(Token.EPSILON)) {\n            const invokingState = this.states[ctx.invokingState];\n            const rt = invokingState.transitions[0];\n            following = this.nextTokens(rt.followState);\n            expected.addSet(following);\n            expected.removeOne(Token.EPSILON);\n            ctx = ctx.parentCtx;\n        }\n        if (following.contains(Token.EPSILON)) {\n            expected.addOne(Token.EOF);\n        }\n        return expected;\n    }\n}\n\nATN.INVALID_ALT_NUMBER = 0;\n\nmodule.exports = ATN;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {DecisionState} = require('./ATNState');\nconst {SemanticContext} = require('./SemanticContext');\nconst {Hash} = require(\"../Utils\");\n\n\nfunction checkParams(params, isCfg) {\n\tif(params===null) {\n\t\tconst result = { state:null, alt:null, context:null, semanticContext:null };\n\t\tif(isCfg) {\n\t\t\tresult.reachesIntoOuterContext = 0;\n\t\t}\n\t\treturn result;\n\t} else {\n\t\tconst props = {};\n\t\tprops.state = params.state || null;\n\t\tprops.alt = (params.alt === undefined) ? null : params.alt;\n\t\tprops.context = params.context || null;\n\t\tprops.semanticContext = params.semanticContext || null;\n\t\tif(isCfg) {\n\t\t\tprops.reachesIntoOuterContext = params.reachesIntoOuterContext || 0;\n\t\t\tprops.precedenceFilterSuppressed = params.precedenceFilterSuppressed || false;\n\t\t}\n\t\treturn props;\n\t}\n}\n\nclass ATNConfig {\n    /**\n     * @param {Object} params A tuple: (ATN state, predicted alt, syntactic, semantic context).\n     * The syntactic context is a graph-structured stack node whose\n     * path(s) to the root is the rule invocation(s)\n     * chain used to arrive at the state.  The semantic context is\n     * the tree of semantic predicates encountered before reaching\n     * an ATN state\n     */\n    constructor(params, config) {\n        this.checkContext(params, config);\n        params = checkParams(params);\n        config = checkParams(config, true);\n        // The ATN state associated with this configuration///\n        this.state = params.state!==null ? params.state : config.state;\n        // What alt (or lexer rule) is predicted by this configuration///\n        this.alt = params.alt!==null ? params.alt : config.alt;\n        /**\n         * The stack of invoking states leading to the rule/states associated\n         * with this config.  We track only those contexts pushed during\n         * execution of the ATN simulator\n         */\n        this.context = params.context!==null ? params.context : config.context;\n        this.semanticContext = params.semanticContext!==null ? params.semanticContext :\n            (config.semanticContext!==null ? config.semanticContext : SemanticContext.NONE);\n        // TODO: make it a boolean then\n        /**\n         * We cannot execute predicates dependent upon local context unless\n         * we know for sure we are in the correct context. Because there is\n         * no way to do this efficiently, we simply cannot evaluate\n         * dependent predicates unless we are in the rule that initially\n         * invokes the ATN simulator.\n         * closure() tracks the depth of how far we dip into the\n         * outer context: depth &gt; 0.  Note that it may not be totally\n         * accurate depth since I don't ever decrement\n         */\n        this.reachesIntoOuterContext = config.reachesIntoOuterContext;\n        this.precedenceFilterSuppressed = config.precedenceFilterSuppressed;\n    }\n\n    checkContext(params, config) {\n        if((params.context===null || params.context===undefined) &&\n                (config===null || config.context===null || config.context===undefined)) {\n            this.context = null;\n        }\n    }\n\n    hashCode() {\n        const hash = new Hash();\n        this.updateHashCode(hash);\n        return hash.finish();\n    }\n\n    updateHashCode(hash) {\n        hash.update(this.state.stateNumber, this.alt, this.context, this.semanticContext);\n    }\n\n    /**\n     * An ATN configuration is equal to another if both have\n     * the same state, they predict the same alternative, and\n     * syntactic/semantic contexts are the same\n     */\n    equals(other) {\n        if (this === other) {\n            return true;\n        } else if (! (other instanceof ATNConfig)) {\n            return false;\n        } else {\n            return this.state.stateNumber===other.state.stateNumber &&\n                this.alt===other.alt &&\n                (this.context===null ? other.context===null : this.context.equals(other.context)) &&\n                this.semanticContext.equals(other.semanticContext) &&\n                this.precedenceFilterSuppressed===other.precedenceFilterSuppressed;\n        }\n    }\n\n    hashCodeForConfigSet() {\n        const hash = new Hash();\n        hash.update(this.state.stateNumber, this.alt, this.semanticContext);\n        return hash.finish();\n    }\n\n    equalsForConfigSet(other) {\n        if (this === other) {\n            return true;\n        } else if (! (other instanceof ATNConfig)) {\n            return false;\n        } else {\n            return this.state.stateNumber===other.state.stateNumber &&\n                this.alt===other.alt &&\n                this.semanticContext.equals(other.semanticContext);\n        }\n    }\n\n    toString() {\n        return \"(\" + this.state + \",\" + this.alt +\n            (this.context!==null ? \",[\" + this.context.toString() + \"]\" : \"\") +\n            (this.semanticContext !== SemanticContext.NONE ?\n                    (\",\" + this.semanticContext.toString())\n                    : \"\") +\n            (this.reachesIntoOuterContext>0 ?\n                    (\",up=\" + this.reachesIntoOuterContext)\n                    : \"\") + \")\";\n    }\n}\n\n\nclass LexerATNConfig extends ATNConfig {\n    constructor(params, config) {\n        super(params, config);\n\n        // This is the backing field for {@link //getLexerActionExecutor}.\n        const lexerActionExecutor = params.lexerActionExecutor || null;\n        this.lexerActionExecutor = lexerActionExecutor || (config!==null ? config.lexerActionExecutor : null);\n        this.passedThroughNonGreedyDecision = config!==null ? this.checkNonGreedyDecision(config, this.state) : false;\n        this.hashCodeForConfigSet = LexerATNConfig.prototype.hashCode;\n        this.equalsForConfigSet = LexerATNConfig.prototype.equals;\n        return this;\n    }\n\n    updateHashCode(hash) {\n        hash.update(this.state.stateNumber, this.alt, this.context, this.semanticContext, this.passedThroughNonGreedyDecision, this.lexerActionExecutor);\n    }\n\n    equals(other) {\n        return this === other ||\n                (other instanceof LexerATNConfig &&\n                this.passedThroughNonGreedyDecision === other.passedThroughNonGreedyDecision &&\n                (this.lexerActionExecutor ? this.lexerActionExecutor.equals(other.lexerActionExecutor) : !other.lexerActionExecutor) &&\n                super.equals(other));\n    }\n\n    checkNonGreedyDecision(source, target) {\n        return source.passedThroughNonGreedyDecision ||\n            (target instanceof DecisionState) && target.nonGreedy;\n    }\n}\n\n\nmodule.exports.ATNConfig = ATNConfig;\nmodule.exports.LexerATNConfig = LexerATNConfig;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst ATN = require('./ATN');\nconst Utils = require('./../Utils');\nconst {SemanticContext} = require('./SemanticContext');\nconst {merge} = require('./../PredictionContext');\n\nfunction hashATNConfig(c) {\n\treturn c.hashCodeForConfigSet();\n}\n\nfunction equalATNConfigs(a, b) {\n\tif ( a===b ) {\n\t\treturn true;\n\t} else if ( a===null || b===null ) {\n\t\treturn false;\n\t} else\n       return a.equalsForConfigSet(b);\n }\n\n/**\n * Specialized {@link Set}{@code <}{@link ATNConfig}{@code >} that can track\n * info about the set, with support for combining similar configurations using a\n * graph-structured stack\n */\nclass ATNConfigSet {\n\tconstructor(fullCtx) {\n\t\t/**\n\t\t * The reason that we need this is because we don't want the hash map to use\n\t\t * the standard hash code and equals. We need all configurations with the\n\t\t * same\n\t\t * {@code (s,i,_,semctx)} to be equal. Unfortunately, this key effectively\n\t\t * doubles\n\t\t * the number of objects associated with ATNConfigs. The other solution is\n\t\t * to\n\t\t * use a hash table that lets us specify the equals/hashcode operation.\n\t\t * All configs but hashed by (s, i, _, pi) not including context. Wiped out\n\t\t * when we go readonly as this set becomes a DFA state\n\t\t */\n\t\tthis.configLookup = new Utils.Set(hashATNConfig, equalATNConfigs);\n\t\t/**\n\t\t * Indicates that this configuration set is part of a full context\n\t\t * LL prediction. It will be used to determine how to merge $. With SLL\n\t\t * it's a wildcard whereas it is not for LL context merge\n\t\t */\n\t\tthis.fullCtx = fullCtx === undefined ? true : fullCtx;\n\t\t/**\n\t\t * Indicates that the set of configurations is read-only. Do not\n\t\t * allow any code to manipulate the set; DFA states will point at\n\t\t * the sets and they must not change. This does not protect the other\n\t\t * fields; in particular, conflictingAlts is set after\n\t\t * we've made this readonly\n\t\t */\n\t\tthis.readOnly = false;\n\t\t// Track the elements as they are added to the set; supports get(i)///\n\t\tthis.configs = [];\n\n\t\t// TODO: these fields make me pretty uncomfortable but nice to pack up info\n\t\t// together, saves recomputation\n\t\t// TODO: can we track conflicts as they are added to save scanning configs\n\t\t// later?\n\t\tthis.uniqueAlt = 0;\n\t\tthis.conflictingAlts = null;\n\n\t\t/**\n\t\t * Used in parser and lexer. In lexer, it indicates we hit a pred\n\t\t * while computing a closure operation. Don't make a DFA state from this\n\t\t */\n\t\tthis.hasSemanticContext = false;\n\t\tthis.dipsIntoOuterContext = false;\n\n\t\tthis.cachedHashCode = -1;\n\t}\n\n\t/**\n\t * Adding a new config means merging contexts with existing configs for\n\t * {@code (s, i, pi, _)}, where {@code s} is the\n\t * {@link ATNConfig//state}, {@code i} is the {@link ATNConfig//alt}, and\n\t * {@code pi} is the {@link ATNConfig//semanticContext}. We use\n\t * {@code (s,i,pi)} as key.\n\t *\n\t * <p>This method updates {@link //dipsIntoOuterContext} and\n\t * {@link //hasSemanticContext} when necessary.</p>\n\t */\n\tadd(config, mergeCache) {\n\t\tif (mergeCache === undefined) {\n\t\t\tmergeCache = null;\n\t\t}\n\t\tif (this.readOnly) {\n\t\t\tthrow \"This set is readonly\";\n\t\t}\n\t\tif (config.semanticContext !== SemanticContext.NONE) {\n\t\t\tthis.hasSemanticContext = true;\n\t\t}\n\t\tif (config.reachesIntoOuterContext > 0) {\n\t\t\tthis.dipsIntoOuterContext = true;\n\t\t}\n\t\tconst existing = this.configLookup.add(config);\n\t\tif (existing === config) {\n\t\t\tthis.cachedHashCode = -1;\n\t\t\tthis.configs.push(config); // track order here\n\t\t\treturn true;\n\t\t}\n\t\t// a previous (s,i,pi,_), merge with it and save result\n\t\tconst rootIsWildcard = !this.fullCtx;\n\t\tconst merged = merge(existing.context, config.context, rootIsWildcard, mergeCache);\n\t\t/**\n\t\t * no need to check for existing.context, config.context in cache\n\t\t * since only way to create new graphs is \"call rule\" and here. We\n\t\t * cache at both places\n\t\t */\n\t\texisting.reachesIntoOuterContext = Math.max( existing.reachesIntoOuterContext, config.reachesIntoOuterContext);\n\t\t// make sure to preserve the precedence filter suppression during the merge\n\t\tif (config.precedenceFilterSuppressed) {\n\t\t\texisting.precedenceFilterSuppressed = true;\n\t\t}\n\t\texisting.context = merged; // replace context; no need to alt mapping\n\t\treturn true;\n\t}\n\n\tgetStates() {\n\t\tconst states = new Utils.Set();\n\t\tfor (let i = 0; i < this.configs.length; i++) {\n\t\t\tstates.add(this.configs[i].state);\n\t\t}\n\t\treturn states;\n\t}\n\n\tgetPredicates() {\n\t\tconst preds = [];\n\t\tfor (let i = 0; i < this.configs.length; i++) {\n\t\t\tconst c = this.configs[i].semanticContext;\n\t\t\tif (c !== SemanticContext.NONE) {\n\t\t\t\tpreds.push(c.semanticContext);\n\t\t\t}\n\t\t}\n\t\treturn preds;\n\t}\n\n\toptimizeConfigs(interpreter) {\n\t\tif (this.readOnly) {\n\t\t\tthrow \"This set is readonly\";\n\t\t}\n\t\tif (this.configLookup.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tfor (let i = 0; i < this.configs.length; i++) {\n\t\t\tconst config = this.configs[i];\n\t\t\tconfig.context = interpreter.getCachedContext(config.context);\n\t\t}\n\t}\n\n\taddAll(coll) {\n\t\tfor (let i = 0; i < coll.length; i++) {\n\t\t\tthis.add(coll[i]);\n\t\t}\n\t\treturn false;\n\t}\n\n\tequals(other) {\n\t\treturn this === other ||\n\t\t\t(other instanceof ATNConfigSet &&\n\t\t\tUtils.equalArrays(this.configs, other.configs) &&\n\t\t\tthis.fullCtx === other.fullCtx &&\n\t\t\tthis.uniqueAlt === other.uniqueAlt &&\n\t\t\tthis.conflictingAlts === other.conflictingAlts &&\n\t\t\tthis.hasSemanticContext === other.hasSemanticContext &&\n\t\t\tthis.dipsIntoOuterContext === other.dipsIntoOuterContext);\n\t}\n\n\thashCode() {\n\t\tconst hash = new Utils.Hash();\n\t\thash.update(this.configs);\n\t\treturn hash.finish();\n\t}\n\n\tupdateHashCode(hash) {\n\t\tif (this.readOnly) {\n\t\t\tif (this.cachedHashCode === -1) {\n\t\t\t\tthis.cachedHashCode = this.hashCode();\n\t\t\t}\n\t\t\thash.update(this.cachedHashCode);\n\t\t} else {\n\t\t\thash.update(this.hashCode());\n\t\t}\n\t}\n\n\tisEmpty() {\n\t\treturn this.configs.length === 0;\n\t}\n\n\tcontains(item) {\n\t\tif (this.configLookup === null) {\n\t\t\tthrow \"This method is not implemented for readonly sets.\";\n\t\t}\n\t\treturn this.configLookup.contains(item);\n\t}\n\n\tcontainsFast(item) {\n\t\tif (this.configLookup === null) {\n\t\t\tthrow \"This method is not implemented for readonly sets.\";\n\t\t}\n\t\treturn this.configLookup.containsFast(item);\n\t}\n\n\tclear() {\n\t\tif (this.readOnly) {\n\t\t\tthrow \"This set is readonly\";\n\t\t}\n\t\tthis.configs = [];\n\t\tthis.cachedHashCode = -1;\n\t\tthis.configLookup = new Utils.Set();\n\t}\n\n\tsetReadonly(readOnly) {\n\t\tthis.readOnly = readOnly;\n\t\tif (readOnly) {\n\t\t\tthis.configLookup = null; // can't mod, no need for lookup cache\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn Utils.arrayToString(this.configs) +\n\t\t\t(this.hasSemanticContext ? \",hasSemanticContext=\" + this.hasSemanticContext : \"\") +\n\t\t\t(this.uniqueAlt !== ATN.INVALID_ALT_NUMBER ? \",uniqueAlt=\" + this.uniqueAlt : \"\") +\n\t\t\t(this.conflictingAlts !== null ? \",conflictingAlts=\" + this.conflictingAlts : \"\") +\n\t\t\t(this.dipsIntoOuterContext ? \",dipsIntoOuterContext\" : \"\");\n\t}\n\n\tget items(){\n\t\treturn this.configs;\n\t}\n\n\tget length(){\n\t\treturn this.configs.length;\n\t}\n}\n\n\nclass OrderedATNConfigSet extends ATNConfigSet {\n\tconstructor() {\n\t\tsuper();\n\t\tthis.configLookup = new Utils.Set();\n\t}\n}\n\nmodule.exports = {\n\tATNConfigSet,\n\tOrderedATNConfigSet\n}\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nclass ATNDeserializationOptions {\n\tconstructor(copyFrom) {\n\t\tif(copyFrom===undefined) {\n\t\t\tcopyFrom = null;\n\t\t}\n\t\tthis.readOnly = false;\n\t\tthis.verifyATN = copyFrom===null ? true : copyFrom.verifyATN;\n\t\tthis.generateRuleBypassTransitions = copyFrom===null ? false : copyFrom.generateRuleBypassTransitions;\n\t}\n}\n\nATNDeserializationOptions.defaultOptions = new ATNDeserializationOptions();\nATNDeserializationOptions.defaultOptions.readOnly = true;\n\n//    def __setattr__(self, key, value):\n//        if key!=\"readOnly\" and self.readOnly:\n//            raise Exception(\"The object is read only.\")\n//        super(type(self), self).__setattr__(key,value)\n\nmodule.exports = ATNDeserializationOptions\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Token} = require('./../Token');\nconst ATN = require('./ATN');\nconst ATNType = require('./ATNType');\n\nconst {\n    ATNState,\n    BasicState,\n    DecisionState,\n    BlockStartState,\n    BlockEndState,\n    LoopEndState,\n    RuleStartState,\n    RuleStopState,\n    TokensStartState,\n    PlusLoopbackState,\n    StarLoopbackState,\n    StarLoopEntryState,\n    PlusBlockStartState,\n    StarBlockStartState,\n    BasicBlockStartState\n} = require('./ATNState');\n\nconst {\n    Transition,\n    AtomTransition,\n    SetTransition,\n    NotSetTransition,\n    RuleTransition,\n    RangeTransition,\n    ActionTransition,\n    EpsilonTransition,\n    WildcardTransition,\n    PredicateTransition,\n    PrecedencePredicateTransition\n} = require('./Transition')\n\nconst {IntervalSet} = require('./../IntervalSet');\nconst ATNDeserializationOptions = require('./ATNDeserializationOptions');\n\nconst {\n    LexerActionType,\n    LexerSkipAction,\n    LexerChannelAction,\n    LexerCustomAction,\n    LexerMoreAction,\n    LexerTypeAction,\n    LexerPushModeAction,\n    LexerPopModeAction,\n    LexerModeAction,\n} = require('./LexerAction');\n\n// This is the earliest supported serialized UUID.\n// stick to serialized version for now, we don't need a UUID instance\nconst BASE_SERIALIZED_UUID = \"AADB8D7E-AEEF-4415-AD2B-8204D6CF042E\";\n\n//\n// This UUID indicates the serialized ATN contains two sets of\n// IntervalSets, where the second set's values are encoded as\n// 32-bit integers to support the full Unicode SMP range up to U+10FFFF.\n//\nconst ADDED_UNICODE_SMP = \"59627784-3BE5-417A-B9EB-8131A7286089\";\n\n// This list contains all of the currently supported UUIDs, ordered by when\n// the feature first appeared in this branch.\nconst SUPPORTED_UUIDS = [ BASE_SERIALIZED_UUID, ADDED_UNICODE_SMP ];\n\nconst SERIALIZED_VERSION = 3;\n\n// This is the current serialized UUID.\nconst SERIALIZED_UUID = ADDED_UNICODE_SMP;\n\nfunction initArray( length, value) {\n\tconst tmp = [];\n\ttmp[length-1] = value;\n\treturn tmp.map(function(i) {return value;});\n}\n\nclass ATNDeserializer {\n    constructor(options) {\n\n        if ( options=== undefined || options === null ) {\n            options = ATNDeserializationOptions.defaultOptions;\n        }\n        this.deserializationOptions = options;\n        this.stateFactories = null;\n        this.actionFactories = null;\n    }\n\n    /**\n     * Determines if a particular serialized representation of an ATN supports\n     * a particular feature, identified by the {@link UUID} used for serializing\n     * the ATN at the time the feature was first introduced.\n     *\n     * @param feature The {@link UUID} marking the first time the feature was\n     * supported in the serialized ATN.\n     * @param actualUuid The {@link UUID} of the actual serialized ATN which is\n     * currently being deserialized.\n     * @return {@code true} if the {@code actualUuid} value represents a\n     * serialized ATN at or after the feature identified by {@code feature} was\n     * introduced; otherwise, {@code false}.\n    */\n    isFeatureSupported(feature, actualUuid) {\n        const idx1 = SUPPORTED_UUIDS.indexOf(feature);\n        if (idx1<0) {\n            return false;\n        }\n        const idx2 = SUPPORTED_UUIDS.indexOf(actualUuid);\n        return idx2 >= idx1;\n    }\n\n    deserialize(data) {\n        this.reset(data);\n        this.checkVersion();\n        this.checkUUID();\n        const atn = this.readATN();\n        this.readStates(atn);\n        this.readRules(atn);\n        this.readModes(atn);\n        const sets = [];\n        // First, deserialize sets with 16-bit arguments <= U+FFFF.\n        this.readSets(atn, sets, this.readInt.bind(this));\n        // Next, if the ATN was serialized with the Unicode SMP feature,\n        // deserialize sets with 32-bit arguments <= U+10FFFF.\n        if (this.isFeatureSupported(ADDED_UNICODE_SMP, this.uuid)) {\n            this.readSets(atn, sets, this.readInt32.bind(this));\n        }\n        this.readEdges(atn, sets);\n        this.readDecisions(atn);\n        this.readLexerActions(atn);\n        this.markPrecedenceDecisions(atn);\n        this.verifyATN(atn);\n        if (this.deserializationOptions.generateRuleBypassTransitions && atn.grammarType === ATNType.PARSER ) {\n            this.generateRuleBypassTransitions(atn);\n            // re-verify after modification\n            this.verifyATN(atn);\n        }\n        return atn;\n    }\n\n    reset(data) {\n        const adjust = function(c) {\n            const v = c.charCodeAt(0);\n            return v>1  ? v-2 : v + 65534;\n        };\n        const temp = data.split(\"\").map(adjust);\n        // don't adjust the first value since that's the version number\n        temp[0] = data.charCodeAt(0);\n        this.data = temp;\n        this.pos = 0;\n    }\n\n    checkVersion() {\n        const version = this.readInt();\n        if ( version !== SERIALIZED_VERSION ) {\n            throw (\"Could not deserialize ATN with version \" + version + \" (expected \" + SERIALIZED_VERSION + \").\");\n        }\n    }\n\n    checkUUID() {\n        const uuid = this.readUUID();\n        if (SUPPORTED_UUIDS.indexOf(uuid)<0) {\n            throw (\"Could not deserialize ATN with UUID: \" + uuid +\n                            \" (expected \" + SERIALIZED_UUID + \" or a legacy UUID).\", uuid, SERIALIZED_UUID);\n        }\n        this.uuid = uuid;\n    }\n\n    readATN() {\n        const grammarType = this.readInt();\n        const maxTokenType = this.readInt();\n        return new ATN(grammarType, maxTokenType);\n    }\n\n    readStates(atn) {\n        let j, pair, stateNumber;\n        const  loopBackStateNumbers = [];\n        const  endStateNumbers = [];\n        const  nstates = this.readInt();\n        for(let i=0; i<nstates; i++) {\n            const  stype = this.readInt();\n            // ignore bad type of states\n            if (stype===ATNState.INVALID_TYPE) {\n                atn.addState(null);\n                continue;\n            }\n            let ruleIndex = this.readInt();\n            if (ruleIndex === 0xFFFF) {\n                ruleIndex = -1;\n            }\n            const  s = this.stateFactory(stype, ruleIndex);\n            if (stype === ATNState.LOOP_END) { // special case\n                const  loopBackStateNumber = this.readInt();\n                loopBackStateNumbers.push([s, loopBackStateNumber]);\n            } else if(s instanceof BlockStartState) {\n                const  endStateNumber = this.readInt();\n                endStateNumbers.push([s, endStateNumber]);\n            }\n            atn.addState(s);\n        }\n        // delay the assignment of loop back and end states until we know all the\n        // state instances have been initialized\n        for (j=0; j<loopBackStateNumbers.length; j++) {\n            pair = loopBackStateNumbers[j];\n            pair[0].loopBackState = atn.states[pair[1]];\n        }\n\n        for (j=0; j<endStateNumbers.length; j++) {\n            pair = endStateNumbers[j];\n            pair[0].endState = atn.states[pair[1]];\n        }\n\n        let numNonGreedyStates = this.readInt();\n        for (j=0; j<numNonGreedyStates; j++) {\n            stateNumber = this.readInt();\n            atn.states[stateNumber].nonGreedy = true;\n        }\n\n        let numPrecedenceStates = this.readInt();\n        for (j=0; j<numPrecedenceStates; j++) {\n            stateNumber = this.readInt();\n            atn.states[stateNumber].isPrecedenceRule = true;\n        }\n    }\n\n    readRules(atn) {\n        let i;\n        const nrules = this.readInt();\n        if (atn.grammarType === ATNType.LEXER ) {\n            atn.ruleToTokenType = initArray(nrules, 0);\n        }\n        atn.ruleToStartState = initArray(nrules, 0);\n        for (i=0; i<nrules; i++) {\n            const s = this.readInt();\n            atn.ruleToStartState[i] = atn.states[s];\n            if ( atn.grammarType === ATNType.LEXER ) {\n                let tokenType = this.readInt();\n                if (tokenType === 0xFFFF) {\n                    tokenType = Token.EOF;\n                }\n                atn.ruleToTokenType[i] = tokenType;\n            }\n        }\n        atn.ruleToStopState = initArray(nrules, 0);\n        for (i=0; i<atn.states.length; i++) {\n            const state = atn.states[i];\n            if (!(state instanceof RuleStopState)) {\n                continue;\n            }\n            atn.ruleToStopState[state.ruleIndex] = state;\n            atn.ruleToStartState[state.ruleIndex].stopState = state;\n        }\n    }\n\n    readModes(atn) {\n        const nmodes = this.readInt();\n        for (let i=0; i<nmodes; i++) {\n            let s = this.readInt();\n            atn.modeToStartState.push(atn.states[s]);\n        }\n    }\n\n    readSets(atn, sets, readUnicode) {\n        const m = this.readInt();\n        for (let i=0; i<m; i++) {\n            const iset = new IntervalSet();\n            sets.push(iset);\n            const n = this.readInt();\n            const containsEof = this.readInt();\n            if (containsEof!==0) {\n                iset.addOne(-1);\n            }\n            for (let j=0; j<n; j++) {\n                const i1 = readUnicode();\n                const i2 = readUnicode();\n                iset.addRange(i1, i2);\n            }\n        }\n    }\n\n    readEdges(atn, sets) {\n        let i, j, state, trans, target;\n        const nedges = this.readInt();\n        for (i=0; i<nedges; i++) {\n            const src = this.readInt();\n            const trg = this.readInt();\n            const ttype = this.readInt();\n            const arg1 = this.readInt();\n            const arg2 = this.readInt();\n            const arg3 = this.readInt();\n            trans = this.edgeFactory(atn, ttype, src, trg, arg1, arg2, arg3, sets);\n            const srcState = atn.states[src];\n            srcState.addTransition(trans);\n        }\n        // edges for rule stop states can be derived, so they aren't serialized\n        for (i=0; i<atn.states.length; i++) {\n            state = atn.states[i];\n            for (j=0; j<state.transitions.length; j++) {\n                const t = state.transitions[j];\n                if (!(t instanceof RuleTransition)) {\n                    continue;\n                }\n                let outermostPrecedenceReturn = -1;\n                if (atn.ruleToStartState[t.target.ruleIndex].isPrecedenceRule) {\n                    if (t.precedence === 0) {\n                        outermostPrecedenceReturn = t.target.ruleIndex;\n                    }\n                }\n\n                trans = new EpsilonTransition(t.followState, outermostPrecedenceReturn);\n                atn.ruleToStopState[t.target.ruleIndex].addTransition(trans);\n            }\n        }\n\n        for (i=0; i<atn.states.length; i++) {\n            state = atn.states[i];\n            if (state instanceof BlockStartState) {\n                // we need to know the end state to set its start state\n                if (state.endState === null) {\n                    throw (\"IllegalState\");\n                }\n                // block end states can only be associated to a single block start\n                // state\n                if ( state.endState.startState !== null) {\n                    throw (\"IllegalState\");\n                }\n                state.endState.startState = state;\n            }\n            if (state instanceof PlusLoopbackState) {\n                for (j=0; j<state.transitions.length; j++) {\n                    target = state.transitions[j].target;\n                    if (target instanceof PlusBlockStartState) {\n                        target.loopBackState = state;\n                    }\n                }\n            } else if (state instanceof StarLoopbackState) {\n                for (j=0; j<state.transitions.length; j++) {\n                    target = state.transitions[j].target;\n                    if (target instanceof StarLoopEntryState) {\n                        target.loopBackState = state;\n                    }\n                }\n            }\n        }\n    }\n\n    readDecisions(atn) {\n        const ndecisions = this.readInt();\n        for (let i=0; i<ndecisions; i++) {\n            const s = this.readInt();\n            const decState = atn.states[s];\n            atn.decisionToState.push(decState);\n            decState.decision = i;\n        }\n    }\n\n    readLexerActions(atn) {\n        if (atn.grammarType === ATNType.LEXER) {\n            const count = this.readInt();\n            atn.lexerActions = initArray(count, null);\n            for (let i=0; i<count; i++) {\n                const actionType = this.readInt();\n                let data1 = this.readInt();\n                if (data1 === 0xFFFF) {\n                    data1 = -1;\n                }\n                let data2 = this.readInt();\n                if (data2 === 0xFFFF) {\n                    data2 = -1;\n                }\n\n                atn.lexerActions[i] = this.lexerActionFactory(actionType, data1, data2);\n            }\n        }\n    }\n\n    generateRuleBypassTransitions(atn) {\n        let i;\n        const count = atn.ruleToStartState.length;\n        for(i=0; i<count; i++) {\n            atn.ruleToTokenType[i] = atn.maxTokenType + i + 1;\n        }\n        for(i=0; i<count; i++) {\n            this.generateRuleBypassTransition(atn, i);\n        }\n    }\n\n    generateRuleBypassTransition(atn, idx) {\n        let i, state;\n        const bypassStart = new BasicBlockStartState();\n        bypassStart.ruleIndex = idx;\n        atn.addState(bypassStart);\n\n        const bypassStop = new BlockEndState();\n        bypassStop.ruleIndex = idx;\n        atn.addState(bypassStop);\n\n        bypassStart.endState = bypassStop;\n        atn.defineDecisionState(bypassStart);\n\n        bypassStop.startState = bypassStart;\n\n        let excludeTransition = null;\n        let endState = null;\n\n        if (atn.ruleToStartState[idx].isPrecedenceRule) {\n            // wrap from the beginning of the rule to the StarLoopEntryState\n            endState = null;\n            for(i=0; i<atn.states.length; i++) {\n                state = atn.states[i];\n                if (this.stateIsEndStateFor(state, idx)) {\n                    endState = state;\n                    excludeTransition = state.loopBackState.transitions[0];\n                    break;\n                }\n            }\n            if (excludeTransition === null) {\n                throw (\"Couldn't identify final state of the precedence rule prefix section.\");\n            }\n        } else {\n            endState = atn.ruleToStopState[idx];\n        }\n\n        // all non-excluded transitions that currently target end state need to\n        // target blockEnd instead\n        for(i=0; i<atn.states.length; i++) {\n            state = atn.states[i];\n            for(let j=0; j<state.transitions.length; j++) {\n                const transition = state.transitions[j];\n                if (transition === excludeTransition) {\n                    continue;\n                }\n                if (transition.target === endState) {\n                    transition.target = bypassStop;\n                }\n            }\n        }\n\n        // all transitions leaving the rule start state need to leave blockStart\n        // instead\n        const ruleToStartState = atn.ruleToStartState[idx];\n        const count = ruleToStartState.transitions.length;\n        while ( count > 0) {\n            bypassStart.addTransition(ruleToStartState.transitions[count-1]);\n            ruleToStartState.transitions = ruleToStartState.transitions.slice(-1);\n        }\n        // link the new states\n        atn.ruleToStartState[idx].addTransition(new EpsilonTransition(bypassStart));\n        bypassStop.addTransition(new EpsilonTransition(endState));\n\n        const matchState = new BasicState();\n        atn.addState(matchState);\n        matchState.addTransition(new AtomTransition(bypassStop, atn.ruleToTokenType[idx]));\n        bypassStart.addTransition(new EpsilonTransition(matchState));\n    }\n\n    stateIsEndStateFor(state, idx) {\n        if ( state.ruleIndex !== idx) {\n            return null;\n        }\n        if (!( state instanceof StarLoopEntryState)) {\n            return null;\n        }\n        const maybeLoopEndState = state.transitions[state.transitions.length - 1].target;\n        if (!( maybeLoopEndState instanceof LoopEndState)) {\n            return null;\n        }\n        if (maybeLoopEndState.epsilonOnlyTransitions &&\n            (maybeLoopEndState.transitions[0].target instanceof RuleStopState)) {\n            return state;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Analyze the {@link StarLoopEntryState} states in the specified ATN to set\n     * the {@link StarLoopEntryState//isPrecedenceDecision} field to the\n     * correct value.\n     * @param atn The ATN.\n     */\n    markPrecedenceDecisions(atn) {\n        for(let i=0; i<atn.states.length; i++) {\n            const state = atn.states[i];\n            if (!( state instanceof StarLoopEntryState)) {\n                continue;\n            }\n            // We analyze the ATN to determine if this ATN decision state is the\n            // decision for the closure block that determines whether a\n            // precedence rule should continue or complete.\n            if ( atn.ruleToStartState[state.ruleIndex].isPrecedenceRule) {\n                const maybeLoopEndState = state.transitions[state.transitions.length - 1].target;\n                if (maybeLoopEndState instanceof LoopEndState) {\n                    if ( maybeLoopEndState.epsilonOnlyTransitions &&\n                            (maybeLoopEndState.transitions[0].target instanceof RuleStopState)) {\n                        state.isPrecedenceDecision = true;\n                    }\n                }\n            }\n        }\n    }\n\n    verifyATN(atn) {\n        if (!this.deserializationOptions.verifyATN) {\n            return;\n        }\n        // verify assumptions\n        for(let i=0; i<atn.states.length; i++) {\n            const state = atn.states[i];\n            if (state === null) {\n                continue;\n            }\n            this.checkCondition(state.epsilonOnlyTransitions || state.transitions.length <= 1);\n            if (state instanceof PlusBlockStartState) {\n                this.checkCondition(state.loopBackState !== null);\n            } else  if (state instanceof StarLoopEntryState) {\n                this.checkCondition(state.loopBackState !== null);\n                this.checkCondition(state.transitions.length === 2);\n                if (state.transitions[0].target instanceof StarBlockStartState) {\n                    this.checkCondition(state.transitions[1].target instanceof LoopEndState);\n                    this.checkCondition(!state.nonGreedy);\n                } else if (state.transitions[0].target instanceof LoopEndState) {\n                    this.checkCondition(state.transitions[1].target instanceof StarBlockStartState);\n                    this.checkCondition(state.nonGreedy);\n                } else {\n                    throw(\"IllegalState\");\n                }\n            } else if (state instanceof StarLoopbackState) {\n                this.checkCondition(state.transitions.length === 1);\n                this.checkCondition(state.transitions[0].target instanceof StarLoopEntryState);\n            } else if (state instanceof LoopEndState) {\n                this.checkCondition(state.loopBackState !== null);\n            } else if (state instanceof RuleStartState) {\n                this.checkCondition(state.stopState !== null);\n            } else if (state instanceof BlockStartState) {\n                this.checkCondition(state.endState !== null);\n            } else if (state instanceof BlockEndState) {\n                this.checkCondition(state.startState !== null);\n            } else if (state instanceof DecisionState) {\n                this.checkCondition(state.transitions.length <= 1 || state.decision >= 0);\n            } else {\n                this.checkCondition(state.transitions.length <= 1 || (state instanceof RuleStopState));\n            }\n        }\n    }\n\n    checkCondition(condition, message) {\n        if (!condition) {\n            if (message === undefined || message===null) {\n                message = \"IllegalState\";\n            }\n            throw (message);\n        }\n    }\n\n    readInt() {\n        return this.data[this.pos++];\n    }\n\n    readInt32() {\n        const low = this.readInt();\n        const high = this.readInt();\n        return low | (high << 16);\n    }\n\n    readLong() {\n        const low = this.readInt32();\n        const high = this.readInt32();\n        return (low & 0x00000000FFFFFFFF) | (high << 32);\n    }\n\n    readUUID() {\n        const bb = [];\n        for(let i=7;i>=0;i--) {\n            const int = this.readInt();\n            /* jshint bitwise: false */\n            bb[(2*i)+1] = int & 0xFF;\n            bb[2*i] = (int >> 8) & 0xFF;\n        }\n        return byteToHex[bb[0]] + byteToHex[bb[1]] +\n        byteToHex[bb[2]] + byteToHex[bb[3]] + '-' +\n        byteToHex[bb[4]] + byteToHex[bb[5]] + '-' +\n        byteToHex[bb[6]] + byteToHex[bb[7]] + '-' +\n        byteToHex[bb[8]] + byteToHex[bb[9]] + '-' +\n        byteToHex[bb[10]] + byteToHex[bb[11]] +\n        byteToHex[bb[12]] + byteToHex[bb[13]] +\n        byteToHex[bb[14]] + byteToHex[bb[15]];\n    }\n\n    edgeFactory(atn, type, src, trg, arg1, arg2, arg3, sets) {\n        const target = atn.states[trg];\n        switch(type) {\n        case Transition.EPSILON:\n            return new EpsilonTransition(target);\n        case Transition.RANGE:\n            return arg3 !== 0 ? new RangeTransition(target, Token.EOF, arg2) : new RangeTransition(target, arg1, arg2);\n        case Transition.RULE:\n            return new RuleTransition(atn.states[arg1], arg2, arg3, target);\n        case Transition.PREDICATE:\n            return new PredicateTransition(target, arg1, arg2, arg3 !== 0);\n        case Transition.PRECEDENCE:\n            return new PrecedencePredicateTransition(target, arg1);\n        case Transition.ATOM:\n            return arg3 !== 0 ? new AtomTransition(target, Token.EOF) : new AtomTransition(target, arg1);\n        case Transition.ACTION:\n            return new ActionTransition(target, arg1, arg2, arg3 !== 0);\n        case Transition.SET:\n            return new SetTransition(target, sets[arg1]);\n        case Transition.NOT_SET:\n            return new NotSetTransition(target, sets[arg1]);\n        case Transition.WILDCARD:\n            return new WildcardTransition(target);\n        default:\n            throw \"The specified transition type: \" + type + \" is not valid.\";\n        }\n    }\n\n    stateFactory(type, ruleIndex) {\n        if (this.stateFactories === null) {\n            const sf = [];\n            sf[ATNState.INVALID_TYPE] = null;\n            sf[ATNState.BASIC] = () => new BasicState();\n            sf[ATNState.RULE_START] = () => new RuleStartState();\n            sf[ATNState.BLOCK_START] = () => new BasicBlockStartState();\n            sf[ATNState.PLUS_BLOCK_START] = () => new PlusBlockStartState();\n            sf[ATNState.STAR_BLOCK_START] = () => new StarBlockStartState();\n            sf[ATNState.TOKEN_START] = () => new TokensStartState();\n            sf[ATNState.RULE_STOP] = () => new RuleStopState();\n            sf[ATNState.BLOCK_END] = () => new BlockEndState();\n            sf[ATNState.STAR_LOOP_BACK] = () => new StarLoopbackState();\n            sf[ATNState.STAR_LOOP_ENTRY] = () => new StarLoopEntryState();\n            sf[ATNState.PLUS_LOOP_BACK] = () => new PlusLoopbackState();\n            sf[ATNState.LOOP_END] = () => new LoopEndState();\n            this.stateFactories = sf;\n        }\n        if (type>this.stateFactories.length || this.stateFactories[type] === null) {\n            throw(\"The specified state type \" + type + \" is not valid.\");\n        } else {\n            const s = this.stateFactories[type]();\n            if (s!==null) {\n                s.ruleIndex = ruleIndex;\n                return s;\n            }\n        }\n    }\n\n    lexerActionFactory(type, data1, data2) {\n        if (this.actionFactories === null) {\n            const af = [];\n            af[LexerActionType.CHANNEL] = (data1, data2) => new LexerChannelAction(data1);\n            af[LexerActionType.CUSTOM] = (data1, data2) => new LexerCustomAction(data1, data2);\n            af[LexerActionType.MODE] = (data1, data2) => new LexerModeAction(data1);\n            af[LexerActionType.MORE] = (data1, data2) => LexerMoreAction.INSTANCE;\n            af[LexerActionType.POP_MODE] = (data1, data2) => LexerPopModeAction.INSTANCE;\n            af[LexerActionType.PUSH_MODE] = (data1, data2) => new LexerPushModeAction(data1);\n            af[LexerActionType.SKIP] = (data1, data2) => LexerSkipAction.INSTANCE;\n            af[LexerActionType.TYPE] = (data1, data2) => new LexerTypeAction(data1);\n            this.actionFactories = af;\n        }\n        if (type>this.actionFactories.length || this.actionFactories[type] === null) {\n            throw(\"The specified lexer action type \" + type + \" is not valid.\");\n        } else {\n            return this.actionFactories[type](data1, data2);\n        }\n    }\n}\n\nfunction createByteToHex() {\n\tconst bth = [];\n\tfor (let i = 0; i < 256; i++) {\n\t\tbth[i] = (i + 0x100).toString(16).substr(1).toUpperCase();\n\t}\n\treturn bth;\n}\n\nconst byteToHex = createByteToHex();\n\n\nmodule.exports = ATNDeserializer;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {DFAState} = require('./../dfa/DFAState');\nconst {ATNConfigSet} = require('./ATNConfigSet');\nconst {getCachedPredictionContext} = require('./../PredictionContext');\nconst {Map} = require('./../Utils');\n\nclass ATNSimulator {\n    constructor(atn, sharedContextCache) {\n        /**\n         * The context cache maps all PredictionContext objects that are ==\n         * to a single cached copy. This cache is shared across all contexts\n         * in all ATNConfigs in all DFA states.  We rebuild each ATNConfigSet\n         * to use only cached nodes/graphs in addDFAState(). We don't want to\n         * fill this during closure() since there are lots of contexts that\n         * pop up but are not used ever again. It also greatly slows down closure().\n         *\n         * <p>This cache makes a huge difference in memory and a little bit in speed.\n         * For the Java grammar on java.*, it dropped the memory requirements\n         * at the end from 25M to 16M. We don't store any of the full context\n         * graphs in the DFA because they are limited to local context only,\n         * but apparently there's a lot of repetition there as well. We optimize\n         * the config contexts before storing the config set in the DFA states\n         * by literally rebuilding them with cached subgraphs only.</p>\n         *\n         * <p>I tried a cache for use during closure operations, that was\n         * whacked after each adaptivePredict(). It cost a little bit\n         * more time I think and doesn't save on the overall footprint\n         * so it's not worth the complexity.</p>\n         */\n        this.atn = atn;\n        this.sharedContextCache = sharedContextCache;\n        return this;\n    }\n\n    getCachedContext(context) {\n        if (this.sharedContextCache ===null) {\n            return context;\n        }\n        const visited = new Map();\n        return getCachedPredictionContext(context, this.sharedContextCache, visited);\n    }\n}\n\n// Must distinguish between missing edge and edge we know leads nowhere///\nATNSimulator.ERROR = new DFAState(0x7FFFFFFF, new ATNConfigSet());\n\n\nmodule.exports = ATNSimulator;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst INITIAL_NUM_TRANSITIONS = 4;\n\n/**\n * The following images show the relation of states and\n * {@link ATNState//transitions} for various grammar constructs.\n *\n * <ul>\n *\n * <li>Solid edges marked with an &//0949; indicate a required\n * {@link EpsilonTransition}.</li>\n *\n * <li>Dashed edges indicate locations where any transition derived from\n * {@link Transition} might appear.</li>\n *\n * <li>Dashed nodes are place holders for either a sequence of linked\n * {@link BasicState} states or the inclusion of a block representing a nested\n * construct in one of the forms below.</li>\n *\n * <li>Nodes showing multiple outgoing alternatives with a {@code ...} support\n * any number of alternatives (one or more). Nodes without the {@code ...} only\n * support the exact number of alternatives shown in the diagram.</li>\n *\n * </ul>\n *\n * <h2>Basic Blocks</h2>\n *\n * <h3>Rule</h3>\n *\n * <embed src=\"images/Rule.svg\" type=\"image/svg+xml\"/>\n *\n * <h3>Block of 1 or more alternatives</h3>\n *\n * <embed src=\"images/Block.svg\" type=\"image/svg+xml\"/>\n *\n * <h2>Greedy Loops</h2>\n *\n * <h3>Greedy Closure: {@code (...)*}</h3>\n *\n * <embed src=\"images/ClosureGreedy.svg\" type=\"image/svg+xml\"/>\n *\n * <h3>Greedy Positive Closure: {@code (...)+}</h3>\n *\n * <embed src=\"images/PositiveClosureGreedy.svg\" type=\"image/svg+xml\"/>\n *\n * <h3>Greedy Optional: {@code (...)?}</h3>\n *\n * <embed src=\"images/OptionalGreedy.svg\" type=\"image/svg+xml\"/>\n *\n * <h2>Non-Greedy Loops</h2>\n *\n * <h3>Non-Greedy Closure: {@code (...)*?}</h3>\n *\n * <embed src=\"images/ClosureNonGreedy.svg\" type=\"image/svg+xml\"/>\n *\n * <h3>Non-Greedy Positive Closure: {@code (...)+?}</h3>\n *\n * <embed src=\"images/PositiveClosureNonGreedy.svg\" type=\"image/svg+xml\"/>\n *\n * <h3>Non-Greedy Optional: {@code (...)??}</h3>\n *\n * <embed src=\"images/OptionalNonGreedy.svg\" type=\"image/svg+xml\"/>\n */\nclass ATNState {\n    constructor() {\n        // Which ATN are we in?\n        this.atn = null;\n        this.stateNumber = ATNState.INVALID_STATE_NUMBER;\n        this.stateType = null;\n        this.ruleIndex = 0; // at runtime, we don't have Rule objects\n        this.epsilonOnlyTransitions = false;\n        // Track the transitions emanating from this ATN state.\n        this.transitions = [];\n        // Used to cache lookahead during parsing, not used during construction\n        this.nextTokenWithinRule = null;\n    }\n\n    toString() {\n        return this.stateNumber;\n    }\n\n    equals(other) {\n        if (other instanceof ATNState) {\n            return this.stateNumber===other.stateNumber;\n        } else {\n            return false;\n        }\n    }\n\n    isNonGreedyExitState() {\n        return false;\n    }\n\n    addTransition(trans, index) {\n        if(index===undefined) {\n            index = -1;\n        }\n        if (this.transitions.length===0) {\n            this.epsilonOnlyTransitions = trans.isEpsilon;\n        } else if(this.epsilonOnlyTransitions !== trans.isEpsilon) {\n            this.epsilonOnlyTransitions = false;\n        }\n        if (index===-1) {\n            this.transitions.push(trans);\n        } else {\n            this.transitions.splice(index, 1, trans);\n        }\n    }\n}\n\n// constants for serialization\nATNState.INVALID_TYPE = 0;\nATNState.BASIC = 1;\nATNState.RULE_START = 2;\nATNState.BLOCK_START = 3;\nATNState.PLUS_BLOCK_START = 4;\nATNState.STAR_BLOCK_START = 5;\nATNState.TOKEN_START = 6;\nATNState.RULE_STOP = 7;\nATNState.BLOCK_END = 8;\nATNState.STAR_LOOP_BACK = 9;\nATNState.STAR_LOOP_ENTRY = 10;\nATNState.PLUS_LOOP_BACK = 11;\nATNState.LOOP_END = 12;\n\nATNState.serializationNames = [\n            \"INVALID\",\n            \"BASIC\",\n            \"RULE_START\",\n            \"BLOCK_START\",\n            \"PLUS_BLOCK_START\",\n            \"STAR_BLOCK_START\",\n            \"TOKEN_START\",\n            \"RULE_STOP\",\n            \"BLOCK_END\",\n            \"STAR_LOOP_BACK\",\n            \"STAR_LOOP_ENTRY\",\n            \"PLUS_LOOP_BACK\",\n            \"LOOP_END\" ];\n\nATNState.INVALID_STATE_NUMBER = -1;\n\n\nclass BasicState extends ATNState {\n    constructor() {\n        super();\n        this.stateType = ATNState.BASIC;\n    }\n}\n\nclass DecisionState extends ATNState {\n    constructor() {\n        super();\n        this.decision = -1;\n        this.nonGreedy = false;\n        return this;\n    }\n}\n\n/**\n *  The start of a regular {@code (...)} block\n */\nclass BlockStartState extends DecisionState {\n    constructor() {\n        super();\n        this.endState = null;\n        return this;\n    }\n}\n\nclass BasicBlockStartState extends BlockStartState {\n    constructor() {\n        super();\n        this.stateType = ATNState.BLOCK_START;\n        return this;\n    }\n}\n\n/**\n * Terminal node of a simple {@code (a|b|c)} block\n */\nclass BlockEndState extends ATNState {\n    constructor() {\n        super();\n        this.stateType = ATNState.BLOCK_END;\n        this.startState = null;\n        return this;\n    }\n}\n\n/**\n * The last node in the ATN for a rule, unless that rule is the start symbol.\n * In that case, there is one transition to EOF. Later, we might encode\n * references to all calls to this rule to compute FOLLOW sets for\n * error handling\n */\nclass RuleStopState extends ATNState {\n    constructor() {\n        super();\n        this.stateType = ATNState.RULE_STOP;\n        return this;\n    }\n}\n\nclass RuleStartState extends ATNState {\n    constructor() {\n        super();\n        this.stateType = ATNState.RULE_START;\n        this.stopState = null;\n        this.isPrecedenceRule = false;\n        return this;\n    }\n}\n\n/**\n * Decision state for {@code A+} and {@code (A|B)+}.  It has two transitions:\n * one to the loop back to start of the block and one to exit.\n */\nclass PlusLoopbackState extends DecisionState {\n    constructor() {\n        super();\n        this.stateType = ATNState.PLUS_LOOP_BACK;\n        return this;\n    }\n}\n\n/**\n * Start of {@code (A|B|...)+} loop. Technically a decision state, but\n * we don't use for code generation; somebody might need it, so I'm defining\n * it for completeness. In reality, the {@link PlusLoopbackState} node is the\n * real decision-making note for {@code A+}\n */\nclass PlusBlockStartState extends BlockStartState {\n    constructor() {\n        super();\n        this.stateType = ATNState.PLUS_BLOCK_START;\n        this.loopBackState = null;\n        return this;\n    }\n}\n\n/**\n * The block that begins a closure loop\n */\nclass StarBlockStartState extends BlockStartState {\n    constructor() {\n        super();\n        this.stateType = ATNState.STAR_BLOCK_START;\n        return this;\n    }\n}\n\nclass StarLoopbackState extends ATNState {\n    constructor() {\n        super();\n        this.stateType = ATNState.STAR_LOOP_BACK;\n        return this;\n    }\n}\n\nclass StarLoopEntryState extends DecisionState {\n    constructor() {\n        super();\n        this.stateType = ATNState.STAR_LOOP_ENTRY;\n        this.loopBackState = null;\n        // Indicates whether this state can benefit from a precedence DFA during SLL decision making.\n        this.isPrecedenceDecision = null;\n        return this;\n    }\n}\n\n/**\n * Mark the end of a * or + loop\n */\nclass LoopEndState extends ATNState {\n    constructor() {\n        super();\n        this.stateType = ATNState.LOOP_END;\n        this.loopBackState = null;\n        return this;\n    }\n}\n\n/**\n * The Tokens rule start state linking to each lexer rule start state\n */\nclass TokensStartState extends DecisionState {\n    constructor() {\n        super();\n        this.stateType = ATNState.TOKEN_START;\n        return this;\n    }\n}\n\nmodule.exports = {\n    ATNState,\n    BasicState,\n    DecisionState,\n    BlockStartState,\n    BlockEndState,\n    LoopEndState,\n    RuleStartState,\n    RuleStopState,\n    TokensStartState,\n    PlusLoopbackState,\n    StarLoopbackState,\n    StarLoopEntryState,\n    PlusBlockStartState,\n    StarBlockStartState,\n    BasicBlockStartState\n}\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\n/**\n * Represents the type of recognizer an ATN applies to\n */\nmodule.exports = {\n    LEXER: 0,\n    PARSER: 1\n};\n\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Token} = require('./../Token');\nconst Lexer = require('./../Lexer');\nconst ATN = require('./ATN');\nconst ATNSimulator = require('./ATNSimulator');\nconst {DFAState} = require('./../dfa/DFAState');\nconst {OrderedATNConfigSet} = require('./ATNConfigSet');\nconst {PredictionContext} = require('./../PredictionContext');\nconst {SingletonPredictionContext} = require('./../PredictionContext');\nconst {RuleStopState} = require('./ATNState');\nconst {LexerATNConfig} = require('./ATNConfig');\nconst {Transition} = require('./Transition');\nconst LexerActionExecutor = require('./LexerActionExecutor');\nconst {LexerNoViableAltException} = require('./../error/Errors');\n\nfunction resetSimState(sim) {\n\tsim.index = -1;\n\tsim.line = 0;\n\tsim.column = -1;\n\tsim.dfaState = null;\n}\n\nclass SimState {\n\tconstructor() {\n\t\tresetSimState(this);\n\t}\n\n\treset() {\n\t\tresetSimState(this);\n\t}\n}\n\nclass LexerATNSimulator extends ATNSimulator {\n\t/**\n\t * When we hit an accept state in either the DFA or the ATN, we\n\t * have to notify the character stream to start buffering characters\n\t * via {@link IntStream//mark} and record the current state. The current sim state\n\t * includes the current index into the input, the current line,\n\t * and current character position in that line. Note that the Lexer is\n\t * tracking the starting line and characterization of the token. These\n\t * variables track the \"state\" of the simulator when it hits an accept state.\n\t *\n\t * <p>We track these variables separately for the DFA and ATN simulation\n\t * because the DFA simulation often has to fail over to the ATN\n\t * simulation. If the ATN simulation fails, we need the DFA to fall\n\t * back to its previously accepted state, if any. If the ATN succeeds,\n\t * then the ATN does the accept and the DFA simulator that invoked it\n\t * can simply return the predicted token type.</p>\n\t */\n\tconstructor(recog, atn, decisionToDFA, sharedContextCache) {\n\t\tsuper(atn, sharedContextCache);\n\t\tthis.decisionToDFA = decisionToDFA;\n\t\tthis.recog = recog;\n\t\t/**\n\t\t * The current token's starting index into the character stream.\n\t\t * Shared across DFA to ATN simulation in case the ATN fails and the\n\t\t * DFA did not have a previous accept state. In this case, we use the\n\t\t * ATN-generated exception object\n\t\t */\n\t\tthis.startIndex = -1;\n\t\t// line number 1..n within the input///\n\t\tthis.line = 1;\n\t\t/**\n\t\t * The index of the character relative to the beginning of the line\n\t\t * 0..n-1\n\t\t */\n\t\tthis.column = 0;\n\t\tthis.mode = Lexer.DEFAULT_MODE;\n\t\t/**\n\t\t * Used during DFA/ATN exec to record the most recent accept configuration\n\t\t * info\n\t\t */\n\t\tthis.prevAccept = new SimState();\n\t}\n\n\tcopyState(simulator) {\n\t\tthis.column = simulator.column;\n\t\tthis.line = simulator.line;\n\t\tthis.mode = simulator.mode;\n\t\tthis.startIndex = simulator.startIndex;\n\t}\n\n\tmatch(input, mode) {\n\t\tthis.match_calls += 1;\n\t\tthis.mode = mode;\n\t\tconst mark = input.mark();\n\t\ttry {\n\t\t\tthis.startIndex = input.index;\n\t\t\tthis.prevAccept.reset();\n\t\t\tconst dfa = this.decisionToDFA[mode];\n\t\t\tif (dfa.s0 === null) {\n\t\t\t\treturn this.matchATN(input);\n\t\t\t} else {\n\t\t\t\treturn this.execATN(input, dfa.s0);\n\t\t\t}\n\t\t} finally {\n\t\t\tinput.release(mark);\n\t\t}\n\t}\n\n\treset() {\n\t\tthis.prevAccept.reset();\n\t\tthis.startIndex = -1;\n\t\tthis.line = 1;\n\t\tthis.column = 0;\n\t\tthis.mode = Lexer.DEFAULT_MODE;\n\t}\n\n\tmatchATN(input) {\n\t\tconst startState = this.atn.modeToStartState[this.mode];\n\n\t\tif (LexerATNSimulator.debug) {\n\t\t\tconsole.log(\"matchATN mode \" + this.mode + \" start: \" + startState);\n\t\t}\n\t\tconst old_mode = this.mode;\n\t\tconst s0_closure = this.computeStartState(input, startState);\n\t\tconst suppressEdge = s0_closure.hasSemanticContext;\n\t\ts0_closure.hasSemanticContext = false;\n\n\t\tconst next = this.addDFAState(s0_closure);\n\t\tif (!suppressEdge) {\n\t\t\tthis.decisionToDFA[this.mode].s0 = next;\n\t\t}\n\n\t\tconst predict = this.execATN(input, next);\n\n\t\tif (LexerATNSimulator.debug) {\n\t\t\tconsole.log(\"DFA after matchATN: \" + this.decisionToDFA[old_mode].toLexerString());\n\t\t}\n\t\treturn predict;\n\t}\n\n\texecATN(input, ds0) {\n\t\tif (LexerATNSimulator.debug) {\n\t\t\tconsole.log(\"start state closure=\" + ds0.configs);\n\t\t}\n\t\tif (ds0.isAcceptState) {\n\t\t\t// allow zero-length tokens\n\t\t\tthis.captureSimState(this.prevAccept, input, ds0);\n\t\t}\n\t\tlet t = input.LA(1);\n\t\tlet s = ds0; // s is current/from DFA state\n\n\t\twhile (true) { // while more work\n\t\t\tif (LexerATNSimulator.debug) {\n\t\t\t\tconsole.log(\"execATN loop starting closure: \" + s.configs);\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * As we move src->trg, src->trg, we keep track of the previous trg to\n\t\t\t * avoid looking up the DFA state again, which is expensive.\n\t\t\t * If the previous target was already part of the DFA, we might\n\t\t\t * be able to avoid doing a reach operation upon t. If s!=null,\n\t\t\t * it means that semantic predicates didn't prevent us from\n\t\t\t * creating a DFA state. Once we know s!=null, we check to see if\n\t\t\t * the DFA state has an edge already for t. If so, we can just reuse\n\t\t\t * it's configuration set; there's no point in re-computing it.\n\t\t\t * This is kind of like doing DFA simulation within the ATN\n\t\t\t * simulation because DFA simulation is really just a way to avoid\n\t\t\t * computing reach/closure sets. Technically, once we know that\n\t\t\t * we have a previously added DFA state, we could jump over to\n\t\t\t * the DFA simulator. But, that would mean popping back and forth\n\t\t\t * a lot and making things more complicated algorithmically.\n\t\t\t * This optimization makes a lot of sense for loops within DFA.\n\t\t\t * A character will take us back to an existing DFA state\n\t\t\t * that already has lots of edges out of it. e.g., .* in comments.\n\t\t\t * print(\"Target for:\" + str(s) + \" and:\" + str(t))\n\t\t\t */\n\t\t\tlet target = this.getExistingTargetState(s, t);\n\t\t\t// print(\"Existing:\" + str(target))\n\t\t\tif (target === null) {\n\t\t\t\ttarget = this.computeTargetState(input, s, t);\n\t\t\t\t// print(\"Computed:\" + str(target))\n\t\t\t}\n\t\t\tif (target === ATNSimulator.ERROR) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// If this is a consumable input element, make sure to consume before\n\t\t\t// capturing the accept state so the input index, line, and char\n\t\t\t// position accurately reflect the state of the interpreter at the\n\t\t\t// end of the token.\n\t\t\tif (t !== Token.EOF) {\n\t\t\t\tthis.consume(input);\n\t\t\t}\n\t\t\tif (target.isAcceptState) {\n\t\t\t\tthis.captureSimState(this.prevAccept, input, target);\n\t\t\t\tif (t === Token.EOF) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tt = input.LA(1);\n\t\t\ts = target; // flip; current DFA target becomes new src/from state\n\t\t}\n\t\treturn this.failOrAccept(this.prevAccept, input, s.configs, t);\n\t}\n\n\t/**\n\t * Get an existing target state for an edge in the DFA. If the target state\n\t * for the edge has not yet been computed or is otherwise not available,\n\t * this method returns {@code null}.\n\t *\n\t * @param s The current DFA state\n\t * @param t The next input symbol\n\t * @return The existing target DFA state for the given input symbol\n\t * {@code t}, or {@code null} if the target state for this edge is not\n\t * already cached\n\t */\n\tgetExistingTargetState(s, t) {\n\t\tif (s.edges === null || t < LexerATNSimulator.MIN_DFA_EDGE || t > LexerATNSimulator.MAX_DFA_EDGE) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet target = s.edges[t - LexerATNSimulator.MIN_DFA_EDGE];\n\t\tif(target===undefined) {\n\t\t\ttarget = null;\n\t\t}\n\t\tif (LexerATNSimulator.debug && target !== null) {\n\t\t\tconsole.log(\"reuse state \" + s.stateNumber + \" edge to \" + target.stateNumber);\n\t\t}\n\t\treturn target;\n\t}\n\n\t/**\n\t * Compute a target state for an edge in the DFA, and attempt to add the\n\t * computed state and corresponding edge to the DFA.\n\t *\n\t * @param input The input stream\n\t * @param s The current DFA state\n\t * @param t The next input symbol\n\t *\n\t * @return The computed target DFA state for the given input symbol\n\t * {@code t}. If {@code t} does not lead to a valid DFA state, this method\n\t * returns {@link //ERROR}.\n\t */\n\tcomputeTargetState(input, s, t) {\n\t\tconst reach = new OrderedATNConfigSet();\n\t\t// if we don't find an existing DFA state\n\t\t// Fill reach starting from closure, following t transitions\n\t\tthis.getReachableConfigSet(input, s.configs, reach, t);\n\n\t\tif (reach.items.length === 0) { // we got nowhere on t from s\n\t\t\tif (!reach.hasSemanticContext) {\n\t\t\t\t// we got nowhere on t, don't throw out this knowledge; it'd\n\t\t\t\t// cause a failover from DFA later.\n\t\t\t\tthis.addDFAEdge(s, t, ATNSimulator.ERROR);\n\t\t\t}\n\t\t\t// stop when we can't match any more char\n\t\t\treturn ATNSimulator.ERROR;\n\t\t}\n\t\t// Add an edge from s to target DFA found/created for reach\n\t\treturn this.addDFAEdge(s, t, null, reach);\n\t}\n\n\tfailOrAccept(prevAccept, input, reach, t) {\n\t\tif (this.prevAccept.dfaState !== null) {\n\t\t\tconst lexerActionExecutor = prevAccept.dfaState.lexerActionExecutor;\n\t\t\tthis.accept(input, lexerActionExecutor, this.startIndex,\n\t\t\t\t\tprevAccept.index, prevAccept.line, prevAccept.column);\n\t\t\treturn prevAccept.dfaState.prediction;\n\t\t} else {\n\t\t\t// if no accept and EOF is first char, return EOF\n\t\t\tif (t === Token.EOF && input.index === this.startIndex) {\n\t\t\t\treturn Token.EOF;\n\t\t\t}\n\t\t\tthrow new LexerNoViableAltException(this.recog, input, this.startIndex, reach);\n\t\t}\n\t}\n\n\t/**\n\t * Given a starting configuration set, figure out all ATN configurations\n\t * we can reach upon input {@code t}. Parameter {@code reach} is a return\n\t * parameter.\n\t */\n\tgetReachableConfigSet(input, closure,\n\t\t\treach, t) {\n\t\t// this is used to skip processing for configs which have a lower priority\n\t\t// than a config that already reached an accept state for the same rule\n\t\tlet skipAlt = ATN.INVALID_ALT_NUMBER;\n\t\tfor (let i = 0; i < closure.items.length; i++) {\n\t\t\tconst cfg = closure.items[i];\n\t\t\tconst currentAltReachedAcceptState = (cfg.alt === skipAlt);\n\t\t\tif (currentAltReachedAcceptState && cfg.passedThroughNonGreedyDecision) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (LexerATNSimulator.debug) {\n\t\t\t\tconsole.log(\"testing %s at %s\\n\", this.getTokenName(t), cfg\n\t\t\t\t\t\t.toString(this.recog, true));\n\t\t\t}\n\t\t\tfor (let j = 0; j < cfg.state.transitions.length; j++) {\n\t\t\t\tconst trans = cfg.state.transitions[j]; // for each transition\n\t\t\t\tconst target = this.getReachableTarget(trans, t);\n\t\t\t\tif (target !== null) {\n\t\t\t\t\tlet lexerActionExecutor = cfg.lexerActionExecutor;\n\t\t\t\t\tif (lexerActionExecutor !== null) {\n\t\t\t\t\t\tlexerActionExecutor = lexerActionExecutor.fixOffsetBeforeMatch(input.index - this.startIndex);\n\t\t\t\t\t}\n\t\t\t\t\tconst treatEofAsEpsilon = (t === Token.EOF);\n\t\t\t\t\tconst config = new LexerATNConfig({state:target, lexerActionExecutor:lexerActionExecutor}, cfg);\n\t\t\t\t\tif (this.closure(input, config, reach,\n\t\t\t\t\t\t\tcurrentAltReachedAcceptState, true, treatEofAsEpsilon)) {\n\t\t\t\t\t\t// any remaining configs for this alt have a lower priority\n\t\t\t\t\t\t// than the one that just reached an accept state.\n\t\t\t\t\t\tskipAlt = cfg.alt;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\taccept(input, lexerActionExecutor,\n\t\t\t   startIndex, index, line, charPos) {\n\t\t   if (LexerATNSimulator.debug) {\n\t\t\t   console.log(\"ACTION %s\\n\", lexerActionExecutor);\n\t\t   }\n\t\t   // seek to after last char in token\n\t\t   input.seek(index);\n\t\t   this.line = line;\n\t\t   this.column = charPos;\n\t\t   if (lexerActionExecutor !== null && this.recog !== null) {\n\t\t\t   lexerActionExecutor.execute(this.recog, input, startIndex);\n\t\t   }\n\t   }\n\n\tgetReachableTarget(trans, t) {\n\t\tif (trans.matches(t, 0, Lexer.MAX_CHAR_VALUE)) {\n\t\t\treturn trans.target;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tcomputeStartState(input, p) {\n\t\tconst initialContext = PredictionContext.EMPTY;\n\t\tconst configs = new OrderedATNConfigSet();\n\t\tfor (let i = 0; i < p.transitions.length; i++) {\n\t\t\tconst target = p.transitions[i].target;\n\t\t\tconst cfg = new LexerATNConfig({state:target, alt:i+1, context:initialContext}, null);\n\t\t\tthis.closure(input, cfg, configs, false, false, false);\n\t\t}\n\t\treturn configs;\n\t}\n\n\t/**\n\t * Since the alternatives within any lexer decision are ordered by\n\t * preference, this method stops pursuing the closure as soon as an accept\n\t * state is reached. After the first accept state is reached by depth-first\n\t * search from {@code config}, all other (potentially reachable) states for\n\t * this rule would have a lower priority.\n\t *\n\t * @return {Boolean} {@code true} if an accept state is reached, otherwise\n\t * {@code false}.\n\t */\n\tclosure(input, config, configs,\n\t\t\tcurrentAltReachedAcceptState, speculative, treatEofAsEpsilon) {\n\t\tlet cfg = null;\n\t\tif (LexerATNSimulator.debug) {\n\t\t\tconsole.log(\"closure(\" + config.toString(this.recog, true) + \")\");\n\t\t}\n\t\tif (config.state instanceof RuleStopState) {\n\t\t\tif (LexerATNSimulator.debug) {\n\t\t\t\tif (this.recog !== null) {\n\t\t\t\t\tconsole.log(\"closure at %s rule stop %s\\n\", this.recog.ruleNames[config.state.ruleIndex], config);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.log(\"closure at rule stop %s\\n\", config);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (config.context === null || config.context.hasEmptyPath()) {\n\t\t\t\tif (config.context === null || config.context.isEmpty()) {\n\t\t\t\t\tconfigs.add(config);\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\tconfigs.add(new LexerATNConfig({ state:config.state, context:PredictionContext.EMPTY}, config));\n\t\t\t\t\tcurrentAltReachedAcceptState = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (config.context !== null && !config.context.isEmpty()) {\n\t\t\t\tfor (let i = 0; i < config.context.length; i++) {\n\t\t\t\t\tif (config.context.getReturnState(i) !== PredictionContext.EMPTY_RETURN_STATE) {\n\t\t\t\t\t\tconst newContext = config.context.getParent(i); // \"pop\" return state\n\t\t\t\t\t\tconst returnState = this.atn.states[config.context.getReturnState(i)];\n\t\t\t\t\t\tcfg = new LexerATNConfig({ state:returnState, context:newContext }, config);\n\t\t\t\t\t\tcurrentAltReachedAcceptState = this.closure(input, cfg,\n\t\t\t\t\t\t\t\tconfigs, currentAltReachedAcceptState, speculative,\n\t\t\t\t\t\t\t\ttreatEofAsEpsilon);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn currentAltReachedAcceptState;\n\t\t}\n\t\t// optimization\n\t\tif (!config.state.epsilonOnlyTransitions) {\n\t\t\tif (!currentAltReachedAcceptState || !config.passedThroughNonGreedyDecision) {\n\t\t\t\tconfigs.add(config);\n\t\t\t}\n\t\t}\n\t\tfor (let j = 0; j < config.state.transitions.length; j++) {\n\t\t\tconst trans = config.state.transitions[j];\n\t\t\tcfg = this.getEpsilonTarget(input, config, trans, configs, speculative, treatEofAsEpsilon);\n\t\t\tif (cfg !== null) {\n\t\t\t\tcurrentAltReachedAcceptState = this.closure(input, cfg, configs,\n\t\t\t\t\t\tcurrentAltReachedAcceptState, speculative, treatEofAsEpsilon);\n\t\t\t}\n\t\t}\n\t\treturn currentAltReachedAcceptState;\n\t}\n\n\t// side-effect: can alter configs.hasSemanticContext\n\tgetEpsilonTarget(input, config, trans,\n\t\t\tconfigs, speculative, treatEofAsEpsilon) {\n\t\tlet cfg = null;\n\t\tif (trans.serializationType === Transition.RULE) {\n\t\t\tconst newContext = SingletonPredictionContext.create(config.context, trans.followState.stateNumber);\n\t\t\tcfg = new LexerATNConfig( { state:trans.target, context:newContext}, config);\n\t\t} else if (trans.serializationType === Transition.PRECEDENCE) {\n\t\t\tthrow \"Precedence predicates are not supported in lexers.\";\n\t\t} else if (trans.serializationType === Transition.PREDICATE) {\n\t\t\t// Track traversing semantic predicates. If we traverse,\n\t\t\t// we cannot add a DFA state for this \"reach\" computation\n\t\t\t// because the DFA would not test the predicate again in the\n\t\t\t// future. Rather than creating collections of semantic predicates\n\t\t\t// like v3 and testing them on prediction, v4 will test them on the\n\t\t\t// fly all the time using the ATN not the DFA. This is slower but\n\t\t\t// semantically it's not used that often. One of the key elements to\n\t\t\t// this predicate mechanism is not adding DFA states that see\n\t\t\t// predicates immediately afterwards in the ATN. For example,\n\n\t\t\t// a : ID {p1}? | ID {p2}? ;\n\n\t\t\t// should create the start state for rule 'a' (to save start state\n\t\t\t// competition), but should not create target of ID state. The\n\t\t\t// collection of ATN states the following ID references includes\n\t\t\t// states reached by traversing predicates. Since this is when we\n\t\t\t// test them, we cannot cash the DFA state target of ID.\n\n\t\t\tif (LexerATNSimulator.debug) {\n\t\t\t\tconsole.log(\"EVAL rule \" + trans.ruleIndex + \":\" + trans.predIndex);\n\t\t\t}\n\t\t\tconfigs.hasSemanticContext = true;\n\t\t\tif (this.evaluatePredicate(input, trans.ruleIndex, trans.predIndex, speculative)) {\n\t\t\t\tcfg = new LexerATNConfig({ state:trans.target}, config);\n\t\t\t}\n\t\t} else if (trans.serializationType === Transition.ACTION) {\n\t\t\tif (config.context === null || config.context.hasEmptyPath()) {\n\t\t\t\t// execute actions anywhere in the start rule for a token.\n\t\t\t\t//\n\t\t\t\t// TODO: if the entry rule is invoked recursively, some\n\t\t\t\t// actions may be executed during the recursive call. The\n\t\t\t\t// problem can appear when hasEmptyPath() is true but\n\t\t\t\t// isEmpty() is false. In this case, the config needs to be\n\t\t\t\t// split into two contexts - one with just the empty path\n\t\t\t\t// and another with everything but the empty path.\n\t\t\t\t// Unfortunately, the current algorithm does not allow\n\t\t\t\t// getEpsilonTarget to return two configurations, so\n\t\t\t\t// additional modifications are needed before we can support\n\t\t\t\t// the split operation.\n\t\t\t\tconst lexerActionExecutor = LexerActionExecutor.append(config.lexerActionExecutor,\n\t\t\t\t\t\tthis.atn.lexerActions[trans.actionIndex]);\n\t\t\t\tcfg = new LexerATNConfig({ state:trans.target, lexerActionExecutor:lexerActionExecutor }, config);\n\t\t\t} else {\n\t\t\t\t// ignore actions in referenced rules\n\t\t\t\tcfg = new LexerATNConfig( { state:trans.target}, config);\n\t\t\t}\n\t\t} else if (trans.serializationType === Transition.EPSILON) {\n\t\t\tcfg = new LexerATNConfig({ state:trans.target}, config);\n\t\t} else if (trans.serializationType === Transition.ATOM ||\n\t\t\t\t\ttrans.serializationType === Transition.RANGE ||\n\t\t\t\t\ttrans.serializationType === Transition.SET) {\n\t\t\tif (treatEofAsEpsilon) {\n\t\t\t\tif (trans.matches(Token.EOF, 0, Lexer.MAX_CHAR_VALUE)) {\n\t\t\t\t\tcfg = new LexerATNConfig( { state:trans.target }, config);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cfg;\n\t}\n\n\t/**\n\t * Evaluate a predicate specified in the lexer.\n\t *\n\t * <p>If {@code speculative} is {@code true}, this method was called before\n\t * {@link //consume} for the matched character. This method should call\n\t * {@link //consume} before evaluating the predicate to ensure position\n\t * sensitive values, including {@link Lexer//getText}, {@link Lexer//getLine},\n\t * and {@link Lexer//getcolumn}, properly reflect the current\n\t * lexer state. This method should restore {@code input} and the simulator\n\t * to the original state before returning (i.e. undo the actions made by the\n\t * call to {@link //consume}.</p>\n\t *\n\t * @param input The input stream.\n\t * @param ruleIndex The rule containing the predicate.\n\t * @param predIndex The index of the predicate within the rule.\n\t * @param speculative {@code true} if the current index in {@code input} is\n\t * one character before the predicate's location.\n\t *\n\t * @return {@code true} if the specified predicate evaluates to\n\t * {@code true}.\n\t */\n\tevaluatePredicate(input, ruleIndex,\n\t\t\tpredIndex, speculative) {\n\t\t// assume true if no recognizer was provided\n\t\tif (this.recog === null) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!speculative) {\n\t\t\treturn this.recog.sempred(null, ruleIndex, predIndex);\n\t\t}\n\t\tconst savedcolumn = this.column;\n\t\tconst savedLine = this.line;\n\t\tconst index = input.index;\n\t\tconst marker = input.mark();\n\t\ttry {\n\t\t\tthis.consume(input);\n\t\t\treturn this.recog.sempred(null, ruleIndex, predIndex);\n\t\t} finally {\n\t\t\tthis.column = savedcolumn;\n\t\t\tthis.line = savedLine;\n\t\t\tinput.seek(index);\n\t\t\tinput.release(marker);\n\t\t}\n\t}\n\n\tcaptureSimState(settings, input, dfaState) {\n\t\tsettings.index = input.index;\n\t\tsettings.line = this.line;\n\t\tsettings.column = this.column;\n\t\tsettings.dfaState = dfaState;\n\t}\n\n\taddDFAEdge(from_, tk, to, cfgs) {\n\t\tif (to === undefined) {\n\t\t\tto = null;\n\t\t}\n\t\tif (cfgs === undefined) {\n\t\t\tcfgs = null;\n\t\t}\n\t\tif (to === null && cfgs !== null) {\n\t\t\t// leading to this call, ATNConfigSet.hasSemanticContext is used as a\n\t\t\t// marker indicating dynamic predicate evaluation makes this edge\n\t\t\t// dependent on the specific input sequence, so the static edge in the\n\t\t\t// DFA should be omitted. The target DFAState is still created since\n\t\t\t// execATN has the ability to resynchronize with the DFA state cache\n\t\t\t// following the predicate evaluation step.\n\t\t\t//\n\t\t\t// TJP notes: next time through the DFA, we see a pred again and eval.\n\t\t\t// If that gets us to a previously created (but dangling) DFA\n\t\t\t// state, we can continue in pure DFA mode from there.\n\t\t\t// /\n\t\t\tconst suppressEdge = cfgs.hasSemanticContext;\n\t\t\tcfgs.hasSemanticContext = false;\n\n\t\t\tto = this.addDFAState(cfgs);\n\n\t\t\tif (suppressEdge) {\n\t\t\t\treturn to;\n\t\t\t}\n\t\t}\n\t\t// add the edge\n\t\tif (tk < LexerATNSimulator.MIN_DFA_EDGE || tk > LexerATNSimulator.MAX_DFA_EDGE) {\n\t\t\t// Only track edges within the DFA bounds\n\t\t\treturn to;\n\t\t}\n\t\tif (LexerATNSimulator.debug) {\n\t\t\tconsole.log(\"EDGE \" + from_ + \" -> \" + to + \" upon \" + tk);\n\t\t}\n\t\tif (from_.edges === null) {\n\t\t\t// make room for tokens 1..n and -1 masquerading as index 0\n\t\t\tfrom_.edges = [];\n\t\t}\n\t\tfrom_.edges[tk - LexerATNSimulator.MIN_DFA_EDGE] = to; // connect\n\n\t\treturn to;\n\t}\n\n\t/**\n\t * Add a new DFA state if there isn't one with this set of\n\t * configurations already. This method also detects the first\n\t * configuration containing an ATN rule stop state. Later, when\n\t * traversing the DFA, we will know which rule to accept.\n\t */\n\taddDFAState(configs) {\n\t\tconst proposed = new DFAState(null, configs);\n\t\tlet firstConfigWithRuleStopState = null;\n\t\tfor (let i = 0; i < configs.items.length; i++) {\n\t\t\tconst cfg = configs.items[i];\n\t\t\tif (cfg.state instanceof RuleStopState) {\n\t\t\t\tfirstConfigWithRuleStopState = cfg;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (firstConfigWithRuleStopState !== null) {\n\t\t\tproposed.isAcceptState = true;\n\t\t\tproposed.lexerActionExecutor = firstConfigWithRuleStopState.lexerActionExecutor;\n\t\t\tproposed.prediction = this.atn.ruleToTokenType[firstConfigWithRuleStopState.state.ruleIndex];\n\t\t}\n\t\tconst dfa = this.decisionToDFA[this.mode];\n\t\tconst existing = dfa.states.get(proposed);\n\t\tif (existing!==null) {\n\t\t\treturn existing;\n\t\t}\n\t\tconst newState = proposed;\n\t\tnewState.stateNumber = dfa.states.length;\n\t\tconfigs.setReadonly(true);\n\t\tnewState.configs = configs;\n\t\tdfa.states.add(newState);\n\t\treturn newState;\n\t}\n\n\tgetDFA(mode) {\n\t\treturn this.decisionToDFA[mode];\n\t}\n\n// Get the text matched so far for the current token.\n\tgetText(input) {\n\t\t// index is first lookahead char, don't include.\n\t\treturn input.getText(this.startIndex, input.index - 1);\n\t}\n\n\tconsume(input) {\n\t\tconst curChar = input.LA(1);\n\t\tif (curChar === \"\\n\".charCodeAt(0)) {\n\t\t\tthis.line += 1;\n\t\t\tthis.column = 0;\n\t\t} else {\n\t\t\tthis.column += 1;\n\t\t}\n\t\tinput.consume();\n\t}\n\n\tgetTokenName(tt) {\n\t\tif (tt === -1) {\n\t\t\treturn \"EOF\";\n\t\t} else {\n\t\t\treturn \"'\" + String.fromCharCode(tt) + \"'\";\n\t\t}\n\t}\n}\n\nLexerATNSimulator.debug = false;\nLexerATNSimulator.dfa_debug = false;\n\nLexerATNSimulator.MIN_DFA_EDGE = 0;\nLexerATNSimulator.MAX_DFA_EDGE = 127; // forces unicode to stay in ATN\n\nLexerATNSimulator.match_calls = 0;\n\nmodule.exports = LexerATNSimulator;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst LexerActionType = {\n    // The type of a {@link LexerChannelAction} action.\n    CHANNEL: 0,\n    // The type of a {@link LexerCustomAction} action\n    CUSTOM: 1,\n    // The type of a {@link LexerModeAction} action.\n    MODE: 2,\n    //The type of a {@link LexerMoreAction} action.\n    MORE: 3,\n    //The type of a {@link LexerPopModeAction} action.\n    POP_MODE: 4,\n    //The type of a {@link LexerPushModeAction} action.\n    PUSH_MODE: 5,\n    //The type of a {@link LexerSkipAction} action.\n    SKIP: 6,\n    //The type of a {@link LexerTypeAction} action.\n    TYPE: 7\n}\n\nclass LexerAction {\n    constructor(action) {\n        this.actionType = action;\n        this.isPositionDependent = false;\n    }\n\n    hashCode() {\n        const hash = new Hash();\n        this.updateHashCode(hash);\n        return hash.finish()\n    }\n\n    updateHashCode(hash) {\n        hash.update(this.actionType);\n    }\n\n    equals(other) {\n        return this === other;\n    }\n}\n\n\n/**\n * Implements the {@code skip} lexer action by calling {@link Lexer//skip}.\n *\n * <p>The {@code skip} command does not have any parameters, so this action is\n * implemented as a singleton instance exposed by {@link //INSTANCE}.</p>\n */\nclass LexerSkipAction extends LexerAction {\n    constructor() {\n        super(LexerActionType.SKIP);\n    }\n\n    execute(lexer) {\n        lexer.skip();\n    }\n\n    toString() {\n        return \"skip\";\n    }\n}\n\n// Provides a singleton instance of this parameterless lexer action.\nLexerSkipAction.INSTANCE = new LexerSkipAction();\n\n/**\n * Implements the {@code type} lexer action by calling {@link Lexer//setType}\n * with the assigned type\n */\nclass LexerTypeAction extends LexerAction {\n    constructor(type) {\n        super(LexerActionType.TYPE);\n        this.type = type;\n    }\n\n    execute(lexer) {\n        lexer.type = this.type;\n    }\n\n    updateHashCode(hash) {\n        hash.update(this.actionType, this.type);\n    }\n\n    equals(other) {\n        if(this === other) {\n            return true;\n        } else if (! (other instanceof LexerTypeAction)) {\n            return false;\n        } else {\n            return this.type === other.type;\n        }\n    }\n\n    toString() {\n        return \"type(\" + this.type + \")\";\n    }\n}\n\n\n/**\n * Implements the {@code pushMode} lexer action by calling\n * {@link Lexer//pushMode} with the assigned mode\n */\nclass LexerPushModeAction extends LexerAction {\n    constructor(mode) {\n        super(LexerActionType.PUSH_MODE);\n        this.mode = mode;\n    }\n\n    /**\n     * <p>This action is implemented by calling {@link Lexer//pushMode} with the\n     * value provided by {@link //getMode}.</p>\n     */\n    execute(lexer) {\n        lexer.pushMode(this.mode);\n    }\n\n    updateHashCode(hash) {\n        hash.update(this.actionType, this.mode);\n    }\n\n    equals(other) {\n        if (this === other) {\n            return true;\n        } else if (! (other instanceof LexerPushModeAction)) {\n            return false;\n        } else {\n            return this.mode === other.mode;\n        }\n    }\n\n    toString() {\n        return \"pushMode(\" + this.mode + \")\";\n    }\n}\n\n/**\n * Implements the {@code popMode} lexer action by calling {@link Lexer//popMode}.\n *\n * <p>The {@code popMode} command does not have any parameters, so this action is\n * implemented as a singleton instance exposed by {@link //INSTANCE}.</p>\n */\nclass LexerPopModeAction extends LexerAction {\n    constructor() {\n        super(LexerActionType.POP_MODE);\n    }\n\n    /**\n     * <p>This action is implemented by calling {@link Lexer//popMode}.</p>\n     */\n    execute(lexer) {\n        lexer.popMode();\n    }\n\n    toString() {\n        return \"popMode\";\n    }\n}\n\nLexerPopModeAction.INSTANCE = new LexerPopModeAction();\n\n/**\n * Implements the {@code more} lexer action by calling {@link Lexer//more}.\n *\n * <p>The {@code more} command does not have any parameters, so this action is\n * implemented as a singleton instance exposed by {@link //INSTANCE}.</p>\n */\nclass LexerMoreAction extends LexerAction {\n    constructor() {\n        super(LexerActionType.MORE);\n    }\n\n    /**\n     * <p>This action is implemented by calling {@link Lexer//popMode}.</p>\n     */\n    execute(lexer) {\n        lexer.more();\n    }\n\n    toString() {\n        return \"more\";\n    }\n}\n\nLexerMoreAction.INSTANCE = new LexerMoreAction();\n\n\n/**\n * Implements the {@code mode} lexer action by calling {@link Lexer//mode} with\n * the assigned mode\n */\nclass LexerModeAction extends LexerAction {\n    constructor(mode) {\n        super(LexerActionType.MODE);\n        this.mode = mode;\n    }\n\n    /**\n     * <p>This action is implemented by calling {@link Lexer//mode} with the\n     * value provided by {@link //getMode}.</p>\n     */\n    execute(lexer) {\n        lexer.mode(this.mode);\n    }\n\n    updateHashCode(hash) {\n        hash.update(this.actionType, this.mode);\n    }\n\n    equals(other) {\n        if (this === other) {\n            return true;\n        } else if (! (other instanceof LexerModeAction)) {\n            return false;\n        } else {\n            return this.mode === other.mode;\n        }\n    }\n\n    toString() {\n        return \"mode(\" + this.mode + \")\";\n    }\n}\n\n/**\n * Executes a custom lexer action by calling {@link Recognizer//action} with the\n * rule and action indexes assigned to the custom action. The implementation of\n * a custom action is added to the generated code for the lexer in an override\n * of {@link Recognizer//action} when the grammar is compiled.\n *\n * <p>This class may represent embedded actions created with the <code>{...}</code>\n * syntax in ANTLR 4, as well as actions created for lexer commands where the\n * command argument could not be evaluated when the grammar was compiled.</p>\n */\nclass LexerCustomAction extends LexerAction {\n    /**\n     * Constructs a custom lexer action with the specified rule and action\n     * indexes.\n     *\n     * @param ruleIndex The rule index to use for calls to\n     * {@link Recognizer//action}.\n     * @param actionIndex The action index to use for calls to\n     * {@link Recognizer//action}.\n     */\n    constructor(ruleIndex, actionIndex) {\n        super(LexerActionType.CUSTOM);\n        this.ruleIndex = ruleIndex;\n        this.actionIndex = actionIndex;\n        this.isPositionDependent = true;\n    }\n\n    /**\n     * <p>Custom actions are implemented by calling {@link Lexer//action} with the\n     * appropriate rule and action indexes.</p>\n     */\n    execute(lexer) {\n        lexer.action(null, this.ruleIndex, this.actionIndex);\n    }\n\n    updateHashCode(hash) {\n        hash.update(this.actionType, this.ruleIndex, this.actionIndex);\n    }\n\n    equals(other) {\n        if (this === other) {\n            return true;\n        } else if (! (other instanceof LexerCustomAction)) {\n            return false;\n        } else {\n            return this.ruleIndex === other.ruleIndex && this.actionIndex === other.actionIndex;\n        }\n    }\n}\n\n/**\n * Implements the {@code channel} lexer action by calling\n * {@link Lexer//setChannel} with the assigned channel.\n * Constructs a new {@code channel} action with the specified channel value.\n * @param channel The channel value to pass to {@link Lexer//setChannel}\n */\nclass LexerChannelAction extends LexerAction {\n    constructor(channel) {\n        super(LexerActionType.CHANNEL);\n        this.channel = channel;\n    }\n\n    /**\n     * <p>This action is implemented by calling {@link Lexer//setChannel} with the\n     * value provided by {@link //getChannel}.</p>\n     */\n    execute(lexer) {\n        lexer._channel = this.channel;\n    }\n\n    updateHashCode(hash) {\n        hash.update(this.actionType, this.channel);\n    }\n\n    equals(other) {\n        if (this === other) {\n            return true;\n        } else if (! (other instanceof LexerChannelAction)) {\n            return false;\n        } else {\n            return this.channel === other.channel;\n        }\n    }\n\n    toString() {\n        return \"channel(\" + this.channel + \")\";\n    }\n}\n\n\n/**\n * This implementation of {@link LexerAction} is used for tracking input offsets\n * for position-dependent actions within a {@link LexerActionExecutor}.\n *\n * <p>This action is not serialized as part of the ATN, and is only required for\n * position-dependent lexer actions which appear at a location other than the\n * end of a rule. For more information about DFA optimizations employed for\n * lexer actions, see {@link LexerActionExecutor//append} and\n * {@link LexerActionExecutor//fixOffsetBeforeMatch}.</p>\n *\n * Constructs a new indexed custom action by associating a character offset\n * with a {@link LexerAction}.\n *\n * <p>Note: This class is only required for lexer actions for which\n * {@link LexerAction//isPositionDependent} returns {@code true}.</p>\n *\n * @param offset The offset into the input {@link CharStream}, relative to\n * the token start index, at which the specified lexer action should be\n * executed.\n * @param action The lexer action to execute at a particular offset in the\n * input {@link CharStream}.\n */\nclass LexerIndexedCustomAction extends LexerAction {\n    constructor(offset, action) {\n        super(action.actionType);\n        this.offset = offset;\n        this.action = action;\n        this.isPositionDependent = true;\n    }\n\n    /**\n     * <p>This method calls {@link //execute} on the result of {@link //getAction}\n     * using the provided {@code lexer}.</p>\n     */\n    execute(lexer) {\n        // assume the input stream position was properly set by the calling code\n        this.action.execute(lexer);\n    }\n\n    updateHashCode(hash) {\n        hash.update(this.actionType, this.offset, this.action);\n    }\n\n    equals(other) {\n        if (this === other) {\n            return true;\n        } else if (! (other instanceof LexerIndexedCustomAction)) {\n            return false;\n        } else {\n            return this.offset === other.offset && this.action === other.action;\n        }\n    }\n}\n\nmodule.exports = {\n    LexerActionType,\n    LexerSkipAction,\n    LexerChannelAction,\n    LexerCustomAction,\n    LexerIndexedCustomAction,\n    LexerMoreAction,\n    LexerTypeAction,\n    LexerPushModeAction,\n    LexerPopModeAction,\n    LexerModeAction\n}\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {hashStuff} = require(\"../Utils\");\nconst {LexerIndexedCustomAction} = require('./LexerAction');\n\nclass LexerActionExecutor {\n\t/**\n\t * Represents an executor for a sequence of lexer actions which traversed during\n\t * the matching operation of a lexer rule (token).\n\t *\n\t * <p>The executor tracks position information for position-dependent lexer actions\n\t * efficiently, ensuring that actions appearing only at the end of the rule do\n\t * not cause bloating of the {@link DFA} created for the lexer.</p>\n\t */\n\tconstructor(lexerActions) {\n\t\tthis.lexerActions = lexerActions === null ? [] : lexerActions;\n\t\t/**\n\t\t * Caches the result of {@link //hashCode} since the hash code is an element\n\t\t * of the performance-critical {@link LexerATNConfig//hashCode} operation\n\t\t */\n\t\tthis.cachedHashCode = hashStuff(lexerActions); // \"\".join([str(la) for la in\n\t\t// lexerActions]))\n\t\treturn this;\n\t}\n\n\t/**\n\t * Creates a {@link LexerActionExecutor} which encodes the current offset\n\t * for position-dependent lexer actions.\n\t *\n\t * <p>Normally, when the executor encounters lexer actions where\n\t * {@link LexerAction//isPositionDependent} returns {@code true}, it calls\n\t * {@link IntStream//seek} on the input {@link CharStream} to set the input\n\t * position to the <em>end</em> of the current token. This behavior provides\n\t * for efficient DFA representation of lexer actions which appear at the end\n\t * of a lexer rule, even when the lexer rule matches a variable number of\n\t * characters.</p>\n\t *\n\t * <p>Prior to traversing a match transition in the ATN, the current offset\n\t * from the token start index is assigned to all position-dependent lexer\n\t * actions which have not already been assigned a fixed offset. By storing\n\t * the offsets relative to the token start index, the DFA representation of\n\t * lexer actions which appear in the middle of tokens remains efficient due\n\t * to sharing among tokens of the same length, regardless of their absolute\n\t * position in the input stream.</p>\n\t *\n\t * <p>If the current executor already has offsets assigned to all\n\t * position-dependent lexer actions, the method returns {@code this}.</p>\n\t *\n\t * @param offset The current offset to assign to all position-dependent\n\t * lexer actions which do not already have offsets assigned.\n\t *\n\t * @return {LexerActionExecutor} A {@link LexerActionExecutor} which stores input stream offsets\n\t * for all position-dependent lexer actions.\n\t */\n\tfixOffsetBeforeMatch(offset) {\n\t\tlet updatedLexerActions = null;\n\t\tfor (let i = 0; i < this.lexerActions.length; i++) {\n\t\t\tif (this.lexerActions[i].isPositionDependent &&\n\t\t\t\t\t!(this.lexerActions[i] instanceof LexerIndexedCustomAction)) {\n\t\t\t\tif (updatedLexerActions === null) {\n\t\t\t\t\tupdatedLexerActions = this.lexerActions.concat([]);\n\t\t\t\t}\n\t\t\t\tupdatedLexerActions[i] = new LexerIndexedCustomAction(offset,\n\t\t\t\t\t\tthis.lexerActions[i]);\n\t\t\t}\n\t\t}\n\t\tif (updatedLexerActions === null) {\n\t\t\treturn this;\n\t\t} else {\n\t\t\treturn new LexerActionExecutor(updatedLexerActions);\n\t\t}\n\t}\n\n\t/**\n\t * Execute the actions encapsulated by this executor within the context of a\n\t * particular {@link Lexer}.\n\t *\n\t * <p>This method calls {@link IntStream//seek} to set the position of the\n\t * {@code input} {@link CharStream} prior to calling\n\t * {@link LexerAction//execute} on a position-dependent action. Before the\n\t * method returns, the input position will be restored to the same position\n\t * it was in when the method was invoked.</p>\n\t *\n\t * @param lexer The lexer instance.\n\t * @param input The input stream which is the source for the current token.\n\t * When this method is called, the current {@link IntStream//index} for\n\t * {@code input} should be the start of the following token, i.e. 1\n\t * character past the end of the current token.\n\t * @param startIndex The token start index. This value may be passed to\n\t * {@link IntStream//seek} to set the {@code input} position to the beginning\n\t * of the token.\n\t */\n\texecute(lexer, input, startIndex) {\n\t\tlet requiresSeek = false;\n\t\tconst stopIndex = input.index;\n\t\ttry {\n\t\t\tfor (let i = 0; i < this.lexerActions.length; i++) {\n\t\t\t\tlet lexerAction = this.lexerActions[i];\n\t\t\t\tif (lexerAction instanceof LexerIndexedCustomAction) {\n\t\t\t\t\tconst offset = lexerAction.offset;\n\t\t\t\t\tinput.seek(startIndex + offset);\n\t\t\t\t\tlexerAction = lexerAction.action;\n\t\t\t\t\trequiresSeek = (startIndex + offset) !== stopIndex;\n\t\t\t\t} else if (lexerAction.isPositionDependent) {\n\t\t\t\t\tinput.seek(stopIndex);\n\t\t\t\t\trequiresSeek = false;\n\t\t\t\t}\n\t\t\t\tlexerAction.execute(lexer);\n\t\t\t}\n\t\t} finally {\n\t\t\tif (requiresSeek) {\n\t\t\t\tinput.seek(stopIndex);\n\t\t\t}\n\t\t}\n\t}\n\n\thashCode() {\n\t\treturn this.cachedHashCode;\n\t}\n\n\tupdateHashCode(hash) {\n\t\thash.update(this.cachedHashCode);\n\t}\n\n\tequals(other) {\n\t\tif (this === other) {\n\t\t\treturn true;\n\t\t} else if (!(other instanceof LexerActionExecutor)) {\n\t\t\treturn false;\n\t\t} else if (this.cachedHashCode != other.cachedHashCode) {\n\t\t\treturn false;\n\t\t} else if (this.lexerActions.length != other.lexerActions.length) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\tconst numActions = this.lexerActions.length\n\t\t\tfor (let idx = 0; idx < numActions; ++idx) {\n\t\t\t\tif (!this.lexerActions[idx].equals(other.lexerActions[idx])) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/**\n\t * Creates a {@link LexerActionExecutor} which executes the actions for\n\t * the input {@code lexerActionExecutor} followed by a specified\n\t * {@code lexerAction}.\n\t *\n\t * @param lexerActionExecutor The executor for actions already traversed by\n\t * the lexer while matching a token within a particular\n\t * {@link LexerATNConfig}. If this is {@code null}, the method behaves as\n\t * though it were an empty executor.\n\t * @param lexerAction The lexer action to execute after the actions\n\t * specified in {@code lexerActionExecutor}.\n\t *\n\t * @return {LexerActionExecutor} A {@link LexerActionExecutor} for executing the combine actions\n\t * of {@code lexerActionExecutor} and {@code lexerAction}.\n\t */\n\tstatic append(lexerActionExecutor, lexerAction) {\n\t\tif (lexerActionExecutor === null) {\n\t\t\treturn new LexerActionExecutor([ lexerAction ]);\n\t\t}\n\t\tconst lexerActions = lexerActionExecutor.lexerActions.concat([ lexerAction ]);\n\t\treturn new LexerActionExecutor(lexerActions);\n\t}\n}\n\n\nmodule.exports = LexerActionExecutor;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst Utils = require('./../Utils');\nconst {Set, BitSet, DoubleDict} = Utils;\n\nconst ATN = require('./ATN');\nconst {ATNState, RuleStopState} = require('./ATNState');\n\nconst {ATNConfig} = require('./ATNConfig');\nconst {ATNConfigSet} = require('./ATNConfigSet');\nconst {Token} = require('./../Token');\nconst {DFAState, PredPrediction} = require('./../dfa/DFAState');\nconst ATNSimulator = require('./ATNSimulator');\nconst PredictionMode = require('./PredictionMode');\nconst RuleContext = require('./../RuleContext');\nconst ParserRuleContext = require('./../ParserRuleContext');\nconst {SemanticContext} = require('./SemanticContext');\nconst {PredictionContext} = require('./../PredictionContext');\nconst {Interval} = require('./../IntervalSet');\nconst {Transition, SetTransition, NotSetTransition, RuleTransition, ActionTransition} = require('./Transition');\nconst {NoViableAltException} = require('./../error/Errors');\nconst {SingletonPredictionContext, predictionContextFromRuleContext} = require('./../PredictionContext');\n\n\n/**\n * The embodiment of the adaptive LL(*), ALL(*), parsing strategy.\n *\n * <p>\n * The basic complexity of the adaptive strategy makes it harder to understand.\n * We begin with ATN simulation to build paths in a DFA. Subsequent prediction\n * requests go through the DFA first. If they reach a state without an edge for\n * the current symbol, the algorithm fails over to the ATN simulation to\n * complete the DFA path for the current input (until it finds a conflict state\n * or uniquely predicting state).</p>\n *\n * <p>\n * All of that is done without using the outer context because we want to create\n * a DFA that is not dependent upon the rule invocation stack when we do a\n * prediction. One DFA works in all contexts. We avoid using context not\n * necessarily because it's slower, although it can be, but because of the DFA\n * caching problem. The closure routine only considers the rule invocation stack\n * created during prediction beginning in the decision rule. For example, if\n * prediction occurs without invoking another rule's ATN, there are no context\n * stacks in the configurations. When lack of context leads to a conflict, we\n * don't know if it's an ambiguity or a weakness in the strong LL(*) parsing\n * strategy (versus full LL(*)).</p>\n *\n * <p>\n * When SLL yields a configuration set with conflict, we rewind the input and\n * retry the ATN simulation, this time using full outer context without adding\n * to the DFA. Configuration context stacks will be the full invocation stacks\n * from the start rule. If we get a conflict using full context, then we can\n * definitively say we have a true ambiguity for that input sequence. If we\n * don't get a conflict, it implies that the decision is sensitive to the outer\n * context. (It is not context-sensitive in the sense of context-sensitive\n * grammars.)</p>\n *\n * <p>\n * The next time we reach this DFA state with an SLL conflict, through DFA\n * simulation, we will again retry the ATN simulation using full context mode.\n * This is slow because we can't save the results and have to \"interpret\" the\n * ATN each time we get that input.</p>\n *\n * <p>\n * <strong>CACHING FULL CONTEXT PREDICTIONS</strong></p>\n *\n * <p>\n * We could cache results from full context to predicted alternative easily and\n * that saves a lot of time but doesn't work in presence of predicates. The set\n * of visible predicates from the ATN start state changes depending on the\n * context, because closure can fall off the end of a rule. I tried to cache\n * tuples (stack context, semantic context, predicted alt) but it was slower\n * than interpreting and much more complicated. Also required a huge amount of\n * memory. The goal is not to create the world's fastest parser anyway. I'd like\n * to keep this algorithm simple. By launching multiple threads, we can improve\n * the speed of parsing across a large number of files.</p>\n *\n * <p>\n * There is no strict ordering between the amount of input used by SLL vs LL,\n * which makes it really hard to build a cache for full context. Let's say that\n * we have input A B C that leads to an SLL conflict with full context X. That\n * implies that using X we might only use A B but we could also use A B C D to\n * resolve conflict. Input A B C D could predict alternative 1 in one position\n * in the input and A B C E could predict alternative 2 in another position in\n * input. The conflicting SLL configurations could still be non-unique in the\n * full context prediction, which would lead us to requiring more input than the\n * original A B C.\tTo make a\tprediction cache work, we have to track\tthe exact\n * input\tused during the previous prediction. That amounts to a cache that maps\n * X to a specific DFA for that context.</p>\n *\n * <p>\n * Something should be done for left-recursive expression predictions. They are\n * likely LL(1) + pred eval. Easier to do the whole SLL unless error and retry\n * with full LL thing Sam does.</p>\n *\n * <p>\n * <strong>AVOIDING FULL CONTEXT PREDICTION</strong></p>\n *\n * <p>\n * We avoid doing full context retry when the outer context is empty, we did not\n * dip into the outer context by falling off the end of the decision state rule,\n * or when we force SLL mode.</p>\n *\n * <p>\n * As an example of the not dip into outer context case, consider as super\n * constructor calls versus function calls. One grammar might look like\n * this:</p>\n *\n * <pre>\n * ctorBody\n *   : '{' superCall? stat* '}'\n *   ;\n * </pre>\n *\n * <p>\n * Or, you might see something like</p>\n *\n * <pre>\n * stat\n *   : superCall ';'\n *   | expression ';'\n *   | ...\n *   ;\n * </pre>\n *\n * <p>\n * In both cases I believe that no closure operations will dip into the outer\n * context. In the first case ctorBody in the worst case will stop at the '}'.\n * In the 2nd case it should stop at the ';'. Both cases should stay within the\n * entry rule and not dip into the outer context.</p>\n *\n * <p>\n * <strong>PREDICATES</strong></p>\n *\n * <p>\n * Predicates are always evaluated if present in either SLL or LL both. SLL and\n * LL simulation deals with predicates differently. SLL collects predicates as\n * it performs closure operations like ANTLR v3 did. It delays predicate\n * evaluation until it reaches and accept state. This allows us to cache the SLL\n * ATN simulation whereas, if we had evaluated predicates on-the-fly during\n * closure, the DFA state configuration sets would be different and we couldn't\n * build up a suitable DFA.</p>\n *\n * <p>\n * When building a DFA accept state during ATN simulation, we evaluate any\n * predicates and return the sole semantically valid alternative. If there is\n * more than 1 alternative, we report an ambiguity. If there are 0 alternatives,\n * we throw an exception. Alternatives without predicates act like they have\n * true predicates. The simple way to think about it is to strip away all\n * alternatives with false predicates and choose the minimum alternative that\n * remains.</p>\n *\n * <p>\n * When we start in the DFA and reach an accept state that's predicated, we test\n * those and return the minimum semantically viable alternative. If no\n * alternatives are viable, we throw an exception.</p>\n *\n * <p>\n * During full LL ATN simulation, closure always evaluates predicates and\n * on-the-fly. This is crucial to reducing the configuration set size during\n * closure. It hits a landmine when parsing with the Java grammar, for example,\n * without this on-the-fly evaluation.</p>\n *\n * <p>\n * <strong>SHARING DFA</strong></p>\n *\n * <p>\n * All instances of the same parser share the same decision DFAs through a\n * static field. Each instance gets its own ATN simulator but they share the\n * same {@link //decisionToDFA} field. They also share a\n * {@link PredictionContextCache} object that makes sure that all\n * {@link PredictionContext} objects are shared among the DFA states. This makes\n * a big size difference.</p>\n *\n * <p>\n * <strong>THREAD SAFETY</strong></p>\n *\n * <p>\n * The {@link ParserATNSimulator} locks on the {@link //decisionToDFA} field when\n * it adds a new DFA object to that array. {@link //addDFAEdge}\n * locks on the DFA for the current decision when setting the\n * {@link DFAState//edges} field. {@link //addDFAState} locks on\n * the DFA for the current decision when looking up a DFA state to see if it\n * already exists. We must make sure that all requests to add DFA states that\n * are equivalent result in the same shared DFA object. This is because lots of\n * threads will be trying to update the DFA at once. The\n * {@link //addDFAState} method also locks inside the DFA lock\n * but this time on the shared context cache when it rebuilds the\n * configurations' {@link PredictionContext} objects using cached\n * subgraphs/nodes. No other locking occurs, even during DFA simulation. This is\n * safe as long as we can guarantee that all threads referencing\n * {@code s.edge[t]} get the same physical target {@link DFAState}, or\n * {@code null}. Once into the DFA, the DFA simulation does not reference the\n * {@link DFA//states} map. It follows the {@link DFAState//edges} field to new\n * targets. The DFA simulator will either find {@link DFAState//edges} to be\n * {@code null}, to be non-{@code null} and {@code dfa.edges[t]} null, or\n * {@code dfa.edges[t]} to be non-null. The\n * {@link //addDFAEdge} method could be racing to set the field\n * but in either case the DFA simulator works; if {@code null}, and requests ATN\n * simulation. It could also race trying to get {@code dfa.edges[t]}, but either\n * way it will work because it's not doing a test and set operation.</p>\n *\n * <p>\n * <strong>Starting with SLL then failing to combined SLL/LL (Two-Stage\n * Parsing)</strong></p>\n *\n * <p>\n * Sam pointed out that if SLL does not give a syntax error, then there is no\n * point in doing full LL, which is slower. We only have to try LL if we get a\n * syntax error. For maximum speed, Sam starts the parser set to pure SLL\n * mode with the {@link BailErrorStrategy}:</p>\n *\n * <pre>\n * parser.{@link Parser//getInterpreter() getInterpreter()}.{@link //setPredictionMode setPredictionMode}{@code (}{@link PredictionMode//SLL}{@code )};\n * parser.{@link Parser//setErrorHandler setErrorHandler}(new {@link BailErrorStrategy}());\n * </pre>\n *\n * <p>\n * If it does not get a syntax error, then we're done. If it does get a syntax\n * error, we need to retry with the combined SLL/LL strategy.</p>\n *\n * <p>\n * The reason this works is as follows. If there are no SLL conflicts, then the\n * grammar is SLL (at least for that input set). If there is an SLL conflict,\n * the full LL analysis must yield a set of viable alternatives which is a\n * subset of the alternatives reported by SLL. If the LL set is a singleton,\n * then the grammar is LL but not SLL. If the LL set is the same size as the SLL\n * set, the decision is SLL. If the LL set has size &gt; 1, then that decision\n * is truly ambiguous on the current input. If the LL set is smaller, then the\n * SLL conflict resolution might choose an alternative that the full LL would\n * rule out as a possibility based upon better context information. If that's\n * the case, then the SLL parse will definitely get an error because the full LL\n * analysis says it's not viable. If SLL conflict resolution chooses an\n * alternative within the LL set, them both SLL and LL would choose the same\n * alternative because they both choose the minimum of multiple conflicting\n * alternatives.</p>\n *\n * <p>\n * Let's say we have a set of SLL conflicting alternatives {@code {1, 2, 3}} and\n * a smaller LL set called <em>s</em>. If <em>s</em> is {@code {2, 3}}, then SLL\n * parsing will get an error because SLL will pursue alternative 1. If\n * <em>s</em> is {@code {1, 2}} or {@code {1, 3}} then both SLL and LL will\n * choose the same alternative because alternative one is the minimum of either\n * set. If <em>s</em> is {@code {2}} or {@code {3}} then SLL will get a syntax\n * error. If <em>s</em> is {@code {1}} then SLL will succeed.</p>\n *\n * <p>\n * Of course, if the input is invalid, then we will get an error for sure in\n * both SLL and LL parsing. Erroneous input will therefore require 2 passes over\n * the input.</p>\n */\nclass ParserATNSimulator extends ATNSimulator {\n    constructor(parser, atn, decisionToDFA, sharedContextCache) {\n        super(atn, sharedContextCache);\n        this.parser = parser;\n        this.decisionToDFA = decisionToDFA;\n        // SLL, LL, or LL + exact ambig detection?//\n        this.predictionMode = PredictionMode.LL;\n        // LAME globals to avoid parameters!!!!! I need these down deep in predTransition\n        this._input = null;\n        this._startIndex = 0;\n        this._outerContext = null;\n        this._dfa = null;\n        /**\n         * Each prediction operation uses a cache for merge of prediction contexts.\n         *  Don't keep around as it wastes huge amounts of memory. DoubleKeyMap\n         *  isn't synchronized but we're ok since two threads shouldn't reuse same\n         *  parser/atnsim object because it can only handle one input at a time.\n         *  This maps graphs a and b to merged result c. (a,b)&rarr;c. We can avoid\n         *  the merge if we ever see a and b again.  Note that (b,a)&rarr;c should\n         *  also be examined during cache lookup.\n         */\n        this.mergeCache = null;\n        this.debug = false;\n        this.debug_closure = false;\n        this.debug_add = false;\n        this.debug_list_atn_decisions = false;\n        this.dfa_debug = false;\n        this.retry_debug = false;\n    }\n\n    reset() {}\n\n    adaptivePredict(input, decision, outerContext) {\n        if (this.debug || this.debug_list_atn_decisions) {\n            console.log(\"adaptivePredict decision \" + decision +\n                                   \" exec LA(1)==\" + this.getLookaheadName(input) +\n                                   \" line \" + input.LT(1).line + \":\" +\n                                   input.LT(1).column);\n        }\n        this._input = input;\n        this._startIndex = input.index;\n        this._outerContext = outerContext;\n\n        const dfa = this.decisionToDFA[decision];\n        this._dfa = dfa;\n        const m = input.mark();\n        const index = input.index;\n\n        // Now we are certain to have a specific decision's DFA\n        // But, do we still need an initial state?\n        try {\n            let s0;\n            if (dfa.precedenceDfa) {\n                // the start state for a precedence DFA depends on the current\n                // parser precedence, and is provided by a DFA method.\n                s0 = dfa.getPrecedenceStartState(this.parser.getPrecedence());\n            } else {\n                // the start state for a \"regular\" DFA is just s0\n                s0 = dfa.s0;\n            }\n            if (s0===null) {\n                if (outerContext===null) {\n                    outerContext = RuleContext.EMPTY;\n                }\n                if (this.debug || this.debug_list_atn_decisions) {\n                    console.log(\"predictATN decision \" + dfa.decision +\n                                       \" exec LA(1)==\" + this.getLookaheadName(input) +\n                                       \", outerContext=\" + outerContext.toString(this.parser.ruleNames));\n                }\n\n                const fullCtx = false;\n                let s0_closure = this.computeStartState(dfa.atnStartState, RuleContext.EMPTY, fullCtx);\n\n                if( dfa.precedenceDfa) {\n                    // If this is a precedence DFA, we use applyPrecedenceFilter\n                    // to convert the computed start state to a precedence start\n                    // state. We then use DFA.setPrecedenceStartState to set the\n                    // appropriate start state for the precedence level rather\n                    // than simply setting DFA.s0.\n                    //\n                    dfa.s0.configs = s0_closure; // not used for prediction but useful to know start configs anyway\n                    s0_closure = this.applyPrecedenceFilter(s0_closure);\n                    s0 = this.addDFAState(dfa, new DFAState(null, s0_closure));\n                    dfa.setPrecedenceStartState(this.parser.getPrecedence(), s0);\n                } else {\n                    s0 = this.addDFAState(dfa, new DFAState(null, s0_closure));\n                    dfa.s0 = s0;\n                }\n            }\n            const alt = this.execATN(dfa, s0, input, index, outerContext);\n            if (this.debug) {\n                console.log(\"DFA after predictATN: \" + dfa.toString(this.parser.literalNames, this.parser.symbolicNames));\n            }\n            return alt;\n        } finally {\n            this._dfa = null;\n            this.mergeCache = null; // wack cache after each prediction\n            input.seek(index);\n            input.release(m);\n        }\n    }\n\n    /**\n     * Performs ATN simulation to compute a predicted alternative based\n     *  upon the remaining input, but also updates the DFA cache to avoid\n     *  having to traverse the ATN again for the same input sequence.\n     *\n     * There are some key conditions we're looking for after computing a new\n     * set of ATN configs (proposed DFA state):\n     *       if the set is empty, there is no viable alternative for current symbol\n     *       does the state uniquely predict an alternative?\n     *       does the state have a conflict that would prevent us from\n     *         putting it on the work list?\n     *\n     * We also have some key operations to do:\n     *       add an edge from previous DFA state to potentially new DFA state, D,\n     *         upon current symbol but only if adding to work list, which means in all\n     *         cases except no viable alternative (and possibly non-greedy decisions?)\n     *       collecting predicates and adding semantic context to DFA accept states\n     *       adding rule context to context-sensitive DFA accept states\n     *       consuming an input symbol\n     *       reporting a conflict\n     *       reporting an ambiguity\n     *       reporting a context sensitivity\n     *       reporting insufficient predicates\n     *\n     * cover these cases:\n     *    dead end\n     *    single alt\n     *    single alt + preds\n     *    conflict\n     *    conflict + preds\n     *\n     */\n    execATN(dfa, s0, input, startIndex, outerContext ) {\n        if (this.debug || this.debug_list_atn_decisions) {\n            console.log(\"execATN decision \" + dfa.decision +\n                    \" exec LA(1)==\" + this.getLookaheadName(input) +\n                    \" line \" + input.LT(1).line + \":\" + input.LT(1).column);\n        }\n        let alt;\n        let previousD = s0;\n\n        if (this.debug) {\n            console.log(\"s0 = \" + s0);\n        }\n        let t = input.LA(1);\n        while(true) { // while more work\n            let D = this.getExistingTargetState(previousD, t);\n            if(D===null) {\n                D = this.computeTargetState(dfa, previousD, t);\n            }\n            if(D===ATNSimulator.ERROR) {\n                // if any configs in previous dipped into outer context, that\n                // means that input up to t actually finished entry rule\n                // at least for SLL decision. Full LL doesn't dip into outer\n                // so don't need special case.\n                // We will get an error no matter what so delay until after\n                // decision; better error message. Also, no reachable target\n                // ATN states in SLL implies LL will also get nowhere.\n                // If conflict in states that dip out, choose min since we\n                // will get error no matter what.\n                const e = this.noViableAlt(input, outerContext, previousD.configs, startIndex);\n                input.seek(startIndex);\n                alt = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(previousD.configs, outerContext);\n                if(alt!==ATN.INVALID_ALT_NUMBER) {\n                    return alt;\n                } else {\n                    throw e;\n                }\n            }\n            if(D.requiresFullContext && this.predictionMode !== PredictionMode.SLL) {\n                // IF PREDS, MIGHT RESOLVE TO SINGLE ALT => SLL (or syntax error)\n                let conflictingAlts = null;\n                if (D.predicates!==null) {\n                    if (this.debug) {\n                        console.log(\"DFA state has preds in DFA sim LL failover\");\n                    }\n                    const conflictIndex = input.index;\n                    if(conflictIndex !== startIndex) {\n                        input.seek(startIndex);\n                    }\n                    conflictingAlts = this.evalSemanticContext(D.predicates, outerContext, true);\n                    if (conflictingAlts.length===1) {\n                        if(this.debug) {\n                            console.log(\"Full LL avoided\");\n                        }\n                        return conflictingAlts.minValue();\n                    }\n                    if (conflictIndex !== startIndex) {\n                        // restore the index so reporting the fallback to full\n                        // context occurs with the index at the correct spot\n                        input.seek(conflictIndex);\n                    }\n                }\n                if (this.dfa_debug) {\n                    console.log(\"ctx sensitive state \" + outerContext +\" in \" + D);\n                }\n                const fullCtx = true;\n                const s0_closure = this.computeStartState(dfa.atnStartState, outerContext, fullCtx);\n                this.reportAttemptingFullContext(dfa, conflictingAlts, D.configs, startIndex, input.index);\n                alt = this.execATNWithFullContext(dfa, D, s0_closure, input, startIndex, outerContext);\n                return alt;\n            }\n            if (D.isAcceptState) {\n                if (D.predicates===null) {\n                    return D.prediction;\n                }\n                const stopIndex = input.index;\n                input.seek(startIndex);\n                const alts = this.evalSemanticContext(D.predicates, outerContext, true);\n                if (alts.length===0) {\n                    throw this.noViableAlt(input, outerContext, D.configs, startIndex);\n                } else if (alts.length===1) {\n                    return alts.minValue();\n                } else {\n                    // report ambiguity after predicate evaluation to make sure the correct set of ambig alts is reported.\n                    this.reportAmbiguity(dfa, D, startIndex, stopIndex, false, alts, D.configs);\n                    return alts.minValue();\n                }\n            }\n            previousD = D;\n\n            if (t !== Token.EOF) {\n                input.consume();\n                t = input.LA(1);\n            }\n        }\n    }\n\n    /**\n     * Get an existing target state for an edge in the DFA. If the target state\n     * for the edge has not yet been computed or is otherwise not available,\n     * this method returns {@code null}.\n     *\n     * @param previousD The current DFA state\n     * @param t The next input symbol\n     * @return The existing target DFA state for the given input symbol\n     * {@code t}, or {@code null} if the target state for this edge is not\n     * already cached\n     */\n    getExistingTargetState(previousD, t) {\n        const edges = previousD.edges;\n        if (edges===null) {\n            return null;\n        } else {\n            return edges[t + 1] || null;\n        }\n    }\n\n    /**\n     * Compute a target state for an edge in the DFA, and attempt to add the\n     * computed state and corresponding edge to the DFA.\n     *\n     * @param dfa The DFA\n     * @param previousD The current DFA state\n     * @param t The next input symbol\n     *\n     * @return The computed target DFA state for the given input symbol\n     * {@code t}. If {@code t} does not lead to a valid DFA state, this method\n     * returns {@link //ERROR\n     */\n    computeTargetState(dfa, previousD, t) {\n       const reach = this.computeReachSet(previousD.configs, t, false);\n        if(reach===null) {\n            this.addDFAEdge(dfa, previousD, t, ATNSimulator.ERROR);\n            return ATNSimulator.ERROR;\n        }\n        // create new target state; we'll add to DFA after it's complete\n        let D = new DFAState(null, reach);\n\n        const predictedAlt = this.getUniqueAlt(reach);\n\n        if (this.debug) {\n            const altSubSets = PredictionMode.getConflictingAltSubsets(reach);\n            console.log(\"SLL altSubSets=\" + Utils.arrayToString(altSubSets) +\n                        /*\", previous=\" + previousD.configs + */\n                        \", configs=\" + reach +\n                        \", predict=\" + predictedAlt +\n                        \", allSubsetsConflict=\" +\n                        PredictionMode.allSubsetsConflict(altSubSets) + \", conflictingAlts=\" +\n                        this.getConflictingAlts(reach));\n        }\n        if (predictedAlt!==ATN.INVALID_ALT_NUMBER) {\n            // NO CONFLICT, UNIQUELY PREDICTED ALT\n            D.isAcceptState = true;\n            D.configs.uniqueAlt = predictedAlt;\n            D.prediction = predictedAlt;\n        } else if (PredictionMode.hasSLLConflictTerminatingPrediction(this.predictionMode, reach)) {\n            // MORE THAN ONE VIABLE ALTERNATIVE\n            D.configs.conflictingAlts = this.getConflictingAlts(reach);\n            D.requiresFullContext = true;\n            // in SLL-only mode, we will stop at this state and return the minimum alt\n            D.isAcceptState = true;\n            D.prediction = D.configs.conflictingAlts.minValue();\n        }\n        if (D.isAcceptState && D.configs.hasSemanticContext) {\n            this.predicateDFAState(D, this.atn.getDecisionState(dfa.decision));\n            if( D.predicates!==null) {\n                D.prediction = ATN.INVALID_ALT_NUMBER;\n            }\n        }\n        // all adds to dfa are done after we've created full D state\n        D = this.addDFAEdge(dfa, previousD, t, D);\n        return D;\n    }\n\n    predicateDFAState(dfaState, decisionState) {\n        // We need to test all predicates, even in DFA states that\n        // uniquely predict alternative.\n        const nalts = decisionState.transitions.length;\n        // Update DFA so reach becomes accept state with (predicate,alt)\n        // pairs if preds found for conflicting alts\n        const altsToCollectPredsFrom = this.getConflictingAltsOrUniqueAlt(dfaState.configs);\n        const altToPred = this.getPredsForAmbigAlts(altsToCollectPredsFrom, dfaState.configs, nalts);\n        if (altToPred!==null) {\n            dfaState.predicates = this.getPredicatePredictions(altsToCollectPredsFrom, altToPred);\n            dfaState.prediction = ATN.INVALID_ALT_NUMBER; // make sure we use preds\n        } else {\n            // There are preds in configs but they might go away\n            // when OR'd together like {p}? || NONE == NONE. If neither\n            // alt has preds, resolve to min alt\n            dfaState.prediction = altsToCollectPredsFrom.minValue();\n        }\n    }\n\n// comes back with reach.uniqueAlt set to a valid alt\n    execATNWithFullContext(dfa, D, // how far we got before failing over\n                                         s0,\n                                         input,\n                                         startIndex,\n                                         outerContext) {\n        if (this.debug || this.debug_list_atn_decisions) {\n            console.log(\"execATNWithFullContext \"+s0);\n        }\n        const fullCtx = true;\n        let foundExactAmbig = false;\n        let reach;\n        let previous = s0;\n        input.seek(startIndex);\n        let t = input.LA(1);\n        let predictedAlt = -1;\n        while (true) { // while more work\n            reach = this.computeReachSet(previous, t, fullCtx);\n            if (reach===null) {\n                // if any configs in previous dipped into outer context, that\n                // means that input up to t actually finished entry rule\n                // at least for LL decision. Full LL doesn't dip into outer\n                // so don't need special case.\n                // We will get an error no matter what so delay until after\n                // decision; better error message. Also, no reachable target\n                // ATN states in SLL implies LL will also get nowhere.\n                // If conflict in states that dip out, choose min since we\n                // will get error no matter what.\n                const e = this.noViableAlt(input, outerContext, previous, startIndex);\n                input.seek(startIndex);\n                const alt = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(previous, outerContext);\n                if(alt!==ATN.INVALID_ALT_NUMBER) {\n                    return alt;\n                } else {\n                    throw e;\n                }\n            }\n            const altSubSets = PredictionMode.getConflictingAltSubsets(reach);\n            if(this.debug) {\n                console.log(\"LL altSubSets=\" + altSubSets + \", predict=\" +\n                      PredictionMode.getUniqueAlt(altSubSets) + \", resolvesToJustOneViableAlt=\" +\n                      PredictionMode.resolvesToJustOneViableAlt(altSubSets));\n            }\n            reach.uniqueAlt = this.getUniqueAlt(reach);\n            // unique prediction?\n            if(reach.uniqueAlt!==ATN.INVALID_ALT_NUMBER) {\n                predictedAlt = reach.uniqueAlt;\n                break;\n            } else if (this.predictionMode !== PredictionMode.LL_EXACT_AMBIG_DETECTION) {\n                predictedAlt = PredictionMode.resolvesToJustOneViableAlt(altSubSets);\n                if(predictedAlt !== ATN.INVALID_ALT_NUMBER) {\n                    break;\n                }\n            } else {\n                // In exact ambiguity mode, we never try to terminate early.\n                // Just keeps scarfing until we know what the conflict is\n                if (PredictionMode.allSubsetsConflict(altSubSets) && PredictionMode.allSubsetsEqual(altSubSets)) {\n                    foundExactAmbig = true;\n                    predictedAlt = PredictionMode.getSingleViableAlt(altSubSets);\n                    break;\n                }\n                // else there are multiple non-conflicting subsets or\n                // we're not sure what the ambiguity is yet.\n                // So, keep going.\n            }\n            previous = reach;\n            if( t !== Token.EOF) {\n                input.consume();\n                t = input.LA(1);\n            }\n        }\n        // If the configuration set uniquely predicts an alternative,\n        // without conflict, then we know that it's a full LL decision\n        // not SLL.\n        if (reach.uniqueAlt !== ATN.INVALID_ALT_NUMBER ) {\n            this.reportContextSensitivity(dfa, predictedAlt, reach, startIndex, input.index);\n            return predictedAlt;\n        }\n        // We do not check predicates here because we have checked them\n        // on-the-fly when doing full context prediction.\n\n        //\n        // In non-exact ambiguity detection mode, we might\tactually be able to\n        // detect an exact ambiguity, but I'm not going to spend the cycles\n        // needed to check. We only emit ambiguity warnings in exact ambiguity\n        // mode.\n        //\n        // For example, we might know that we have conflicting configurations.\n        // But, that does not mean that there is no way forward without a\n        // conflict. It's possible to have nonconflicting alt subsets as in:\n\n        // altSubSets=[{1, 2}, {1, 2}, {1}, {1, 2}]\n\n        // from\n        //\n        //    [(17,1,[5 $]), (13,1,[5 10 $]), (21,1,[5 10 $]), (11,1,[$]),\n        //     (13,2,[5 10 $]), (21,2,[5 10 $]), (11,2,[$])]\n        //\n        // In this case, (17,1,[5 $]) indicates there is some next sequence that\n        // would resolve this without conflict to alternative 1. Any other viable\n        // next sequence, however, is associated with a conflict.  We stop\n        // looking for input because no amount of further lookahead will alter\n        // the fact that we should predict alternative 1.  We just can't say for\n        // sure that there is an ambiguity without looking further.\n\n        this.reportAmbiguity(dfa, D, startIndex, input.index, foundExactAmbig, null, reach);\n\n        return predictedAlt;\n    }\n\n    computeReachSet(closure, t, fullCtx) {\n        if (this.debug) {\n            console.log(\"in computeReachSet, starting closure: \" + closure);\n        }\n        if( this.mergeCache===null) {\n            this.mergeCache = new DoubleDict();\n        }\n        const intermediate = new ATNConfigSet(fullCtx);\n\n        // Configurations already in a rule stop state indicate reaching the end\n        // of the decision rule (local context) or end of the start rule (full\n        // context). Once reached, these configurations are never updated by a\n        // closure operation, so they are handled separately for the performance\n        // advantage of having a smaller intermediate set when calling closure.\n        //\n        // For full-context reach operations, separate handling is required to\n        // ensure that the alternative matching the longest overall sequence is\n        // chosen when multiple such configurations can match the input.\n\n        let skippedStopStates = null;\n\n        // First figure out where we can reach on input t\n        for (let i=0; i<closure.items.length;i++) {\n            const c = closure.items[i];\n            if(this.debug) {\n                console.log(\"testing \" + this.getTokenName(t) + \" at \" + c);\n            }\n            if (c.state instanceof RuleStopState) {\n                if (fullCtx || t === Token.EOF) {\n                    if (skippedStopStates===null) {\n                        skippedStopStates = [];\n                    }\n                    skippedStopStates.push(c);\n                    if(this.debug_add) {\n                        console.log(\"added \" + c + \" to skippedStopStates\");\n                    }\n                }\n                continue;\n            }\n            for(let j=0;j<c.state.transitions.length;j++) {\n                const trans = c.state.transitions[j];\n                const target = this.getReachableTarget(trans, t);\n                if (target!==null) {\n                    const cfg = new ATNConfig({state:target}, c);\n                    intermediate.add(cfg, this.mergeCache);\n                    if(this.debug_add) {\n                        console.log(\"added \" + cfg + \" to intermediate\");\n                    }\n                }\n            }\n        }\n        // Now figure out where the reach operation can take us...\n        let reach = null;\n\n        // This block optimizes the reach operation for intermediate sets which\n        // trivially indicate a termination state for the overall\n        // adaptivePredict operation.\n        //\n        // The conditions assume that intermediate\n        // contains all configurations relevant to the reach set, but this\n        // condition is not true when one or more configurations have been\n        // withheld in skippedStopStates, or when the current symbol is EOF.\n        //\n        if (skippedStopStates===null && t!==Token.EOF) {\n            if (intermediate.items.length===1) {\n                // Don't pursue the closure if there is just one state.\n                // It can only have one alternative; just add to result\n                // Also don't pursue the closure if there is unique alternative\n                // among the configurations.\n                reach = intermediate;\n            } else if (this.getUniqueAlt(intermediate)!==ATN.INVALID_ALT_NUMBER) {\n                // Also don't pursue the closure if there is unique alternative\n                // among the configurations.\n                reach = intermediate;\n            }\n        }\n        // If the reach set could not be trivially determined, perform a closure\n        // operation on the intermediate set to compute its initial value.\n        //\n        if (reach===null) {\n            reach = new ATNConfigSet(fullCtx);\n            const closureBusy = new Set();\n            const treatEofAsEpsilon = t === Token.EOF;\n            for (let k=0; k<intermediate.items.length;k++) {\n                this.closure(intermediate.items[k], reach, closureBusy, false, fullCtx, treatEofAsEpsilon);\n            }\n        }\n        if (t === Token.EOF) {\n            // After consuming EOF no additional input is possible, so we are\n            // only interested in configurations which reached the end of the\n            // decision rule (local context) or end of the start rule (full\n            // context). Update reach to contain only these configurations. This\n            // handles both explicit EOF transitions in the grammar and implicit\n            // EOF transitions following the end of the decision or start rule.\n            //\n            // When reach==intermediate, no closure operation was performed. In\n            // this case, removeAllConfigsNotInRuleStopState needs to check for\n            // reachable rule stop states as well as configurations already in\n            // a rule stop state.\n            //\n            // This is handled before the configurations in skippedStopStates,\n            // because any configurations potentially added from that list are\n            // already guaranteed to meet this condition whether or not it's\n            // required.\n            //\n            reach = this.removeAllConfigsNotInRuleStopState(reach, reach === intermediate);\n        }\n        // If skippedStopStates!==null, then it contains at least one\n        // configuration. For full-context reach operations, these\n        // configurations reached the end of the start rule, in which case we\n        // only add them back to reach if no configuration during the current\n        // closure operation reached such a state. This ensures adaptivePredict\n        // chooses an alternative matching the longest overall sequence when\n        // multiple alternatives are viable.\n        //\n        if (skippedStopStates!==null && ( (! fullCtx) || (! PredictionMode.hasConfigInRuleStopState(reach)))) {\n            for (let l=0; l<skippedStopStates.length;l++) {\n                reach.add(skippedStopStates[l], this.mergeCache);\n            }\n        }\n        if (reach.items.length===0) {\n            return null;\n        } else {\n            return reach;\n        }\n    }\n\n    /**\n     * Return a configuration set containing only the configurations from\n     * {@code configs} which are in a {@link RuleStopState}. If all\n     * configurations in {@code configs} are already in a rule stop state, this\n     * method simply returns {@code configs}.\n     *\n     * <p>When {@code lookToEndOfRule} is true, this method uses\n     * {@link ATN//nextTokens} for each configuration in {@code configs} which is\n     * not already in a rule stop state to see if a rule stop state is reachable\n     * from the configuration via epsilon-only transitions.</p>\n     *\n     * @param configs the configuration set to update\n     * @param lookToEndOfRule when true, this method checks for rule stop states\n     * reachable by epsilon-only transitions from each configuration in\n     * {@code configs}.\n     *\n     * @return {@code configs} if all configurations in {@code configs} are in a\n     * rule stop state, otherwise return a new configuration set containing only\n     * the configurations from {@code configs} which are in a rule stop state\n     */\n    removeAllConfigsNotInRuleStopState(configs, lookToEndOfRule) {\n        if (PredictionMode.allConfigsInRuleStopStates(configs)) {\n            return configs;\n        }\n        const result = new ATNConfigSet(configs.fullCtx);\n        for(let i=0; i<configs.items.length;i++) {\n            const config = configs.items[i];\n            if (config.state instanceof RuleStopState) {\n                result.add(config, this.mergeCache);\n                continue;\n            }\n            if (lookToEndOfRule && config.state.epsilonOnlyTransitions) {\n                const nextTokens = this.atn.nextTokens(config.state);\n                if (nextTokens.contains(Token.EPSILON)) {\n                    const endOfRuleState = this.atn.ruleToStopState[config.state.ruleIndex];\n                    result.add(new ATNConfig({state:endOfRuleState}, config), this.mergeCache);\n                }\n            }\n        }\n        return result;\n    }\n\n    computeStartState(p, ctx, fullCtx) {\n        // always at least the implicit call to start rule\n        const initialContext = predictionContextFromRuleContext(this.atn, ctx);\n        const configs = new ATNConfigSet(fullCtx);\n        for(let i=0;i<p.transitions.length;i++) {\n            const target = p.transitions[i].target;\n            const c = new ATNConfig({ state:target, alt:i+1, context:initialContext }, null);\n            const closureBusy = new Set();\n            this.closure(c, configs, closureBusy, true, fullCtx, false);\n        }\n        return configs;\n    }\n\n    /**\n     * This method transforms the start state computed by\n     * {@link //computeStartState} to the special start state used by a\n     * precedence DFA for a particular precedence value. The transformation\n     * process applies the following changes to the start state's configuration\n     * set.\n     *\n     * <ol>\n     * <li>Evaluate the precedence predicates for each configuration using\n     * {@link SemanticContext//evalPrecedence}.</li>\n     * <li>Remove all configurations which predict an alternative greater than\n     * 1, for which another configuration that predicts alternative 1 is in the\n     * same ATN state with the same prediction context. This transformation is\n     * valid for the following reasons:\n     * <ul>\n     * <li>The closure block cannot contain any epsilon transitions which bypass\n     * the body of the closure, so all states reachable via alternative 1 are\n     * part of the precedence alternatives of the transformed left-recursive\n     * rule.</li>\n     * <li>The \"primary\" portion of a left recursive rule cannot contain an\n     * epsilon transition, so the only way an alternative other than 1 can exist\n     * in a state that is also reachable via alternative 1 is by nesting calls\n     * to the left-recursive rule, with the outer calls not being at the\n     * preferred precedence level.</li>\n     * </ul>\n     * </li>\n     * </ol>\n     *\n     * <p>\n     * The prediction context must be considered by this filter to address\n     * situations like the following.\n     * </p>\n     * <code>\n     * <pre>\n     * grammar TA;\n     * prog: statement* EOF;\n     * statement: letterA | statement letterA 'b' ;\n     * letterA: 'a';\n     * </pre>\n     * </code>\n     * <p>\n     * If the above grammar, the ATN state immediately before the token\n     * reference {@code 'a'} in {@code letterA} is reachable from the left edge\n     * of both the primary and closure blocks of the left-recursive rule\n     * {@code statement}. The prediction context associated with each of these\n     * configurations distinguishes between them, and prevents the alternative\n     * which stepped out to {@code prog} (and then back in to {@code statement}\n     * from being eliminated by the filter.\n     * </p>\n     *\n     * @param configs The configuration set computed by\n     * {@link //computeStartState} as the start state for the DFA.\n     * @return The transformed configuration set representing the start state\n     * for a precedence DFA at a particular precedence level (determined by\n     * calling {@link Parser//getPrecedence})\n     */\n    applyPrecedenceFilter(configs) {\n        let config;\n        const statesFromAlt1 = [];\n        const configSet = new ATNConfigSet(configs.fullCtx);\n        for(let i=0; i<configs.items.length; i++) {\n            config = configs.items[i];\n            // handle alt 1 first\n            if (config.alt !== 1) {\n                continue;\n            }\n            const updatedContext = config.semanticContext.evalPrecedence(this.parser, this._outerContext);\n            if (updatedContext===null) {\n                // the configuration was eliminated\n                continue;\n            }\n            statesFromAlt1[config.state.stateNumber] = config.context;\n            if (updatedContext !== config.semanticContext) {\n                configSet.add(new ATNConfig({semanticContext:updatedContext}, config), this.mergeCache);\n            } else {\n                configSet.add(config, this.mergeCache);\n            }\n        }\n        for(let i=0; i<configs.items.length; i++) {\n            config = configs.items[i];\n            if (config.alt === 1) {\n                // already handled\n                continue;\n            }\n            // In the future, this elimination step could be updated to also\n            // filter the prediction context for alternatives predicting alt>1\n            // (basically a graph subtraction algorithm).\n            if (!config.precedenceFilterSuppressed) {\n                const context = statesFromAlt1[config.state.stateNumber] || null;\n                if (context!==null && context.equals(config.context)) {\n                    // eliminated\n                    continue;\n                }\n            }\n            configSet.add(config, this.mergeCache);\n        }\n        return configSet;\n    }\n\n    getReachableTarget(trans, ttype) {\n        if (trans.matches(ttype, 0, this.atn.maxTokenType)) {\n            return trans.target;\n        } else {\n            return null;\n        }\n    }\n\n    getPredsForAmbigAlts(ambigAlts, configs, nalts) {\n        // REACH=[1|1|[]|0:0, 1|2|[]|0:1]\n        // altToPred starts as an array of all null contexts. The entry at index i\n        // corresponds to alternative i. altToPred[i] may have one of three values:\n        //   1. null: no ATNConfig c is found such that c.alt==i\n        //   2. SemanticContext.NONE: At least one ATNConfig c exists such that\n        //      c.alt==i and c.semanticContext==SemanticContext.NONE. In other words,\n        //      alt i has at least one unpredicated config.\n        //   3. Non-NONE Semantic Context: There exists at least one, and for all\n        //      ATNConfig c such that c.alt==i, c.semanticContext!=SemanticContext.NONE.\n        //\n        // From this, it is clear that NONE||anything==NONE.\n        //\n        let altToPred = [];\n        for(let i=0;i<configs.items.length;i++) {\n            const c = configs.items[i];\n            if(ambigAlts.contains( c.alt )) {\n                altToPred[c.alt] = SemanticContext.orContext(altToPred[c.alt] || null, c.semanticContext);\n            }\n        }\n        let nPredAlts = 0;\n        for (let i =1;i< nalts+1;i++) {\n            const pred = altToPred[i] || null;\n            if (pred===null) {\n                altToPred[i] = SemanticContext.NONE;\n            } else if (pred !== SemanticContext.NONE) {\n                nPredAlts += 1;\n            }\n        }\n        // nonambig alts are null in altToPred\n        if (nPredAlts===0) {\n            altToPred = null;\n        }\n        if (this.debug) {\n            console.log(\"getPredsForAmbigAlts result \" + Utils.arrayToString(altToPred));\n        }\n        return altToPred;\n    }\n\n    getPredicatePredictions(ambigAlts, altToPred) {\n        const pairs = [];\n        let containsPredicate = false;\n        for (let i=1; i<altToPred.length;i++) {\n            const pred = altToPred[i];\n            // unpredicated is indicated by SemanticContext.NONE\n            if( ambigAlts!==null && ambigAlts.contains( i )) {\n                pairs.push(new PredPrediction(pred, i));\n            }\n            if (pred !== SemanticContext.NONE) {\n                containsPredicate = true;\n            }\n        }\n        if (! containsPredicate) {\n            return null;\n        }\n        return pairs;\n    }\n\n    /**\n     * This method is used to improve the localization of error messages by\n     * choosing an alternative rather than throwing a\n     * {@link NoViableAltException} in particular prediction scenarios where the\n     * {@link //ERROR} state was reached during ATN simulation.\n     *\n     * <p>\n     * The default implementation of this method uses the following\n     * algorithm to identify an ATN configuration which successfully parsed the\n     * decision entry rule. Choosing such an alternative ensures that the\n     * {@link ParserRuleContext} returned by the calling rule will be complete\n     * and valid, and the syntax error will be reported later at a more\n     * localized location.</p>\n     *\n     * <ul>\n     * <li>If a syntactically valid path or paths reach the end of the decision rule and\n     * they are semantically valid if predicated, return the min associated alt.</li>\n     * <li>Else, if a semantically invalid but syntactically valid path exist\n     * or paths exist, return the minimum associated alt.\n     * </li>\n     * <li>Otherwise, return {@link ATN//INVALID_ALT_NUMBER}.</li>\n     * </ul>\n     *\n     * <p>\n     * In some scenarios, the algorithm described above could predict an\n     * alternative which will result in a {@link FailedPredicateException} in\n     * the parser. Specifically, this could occur if the <em>only</em> configuration\n     * capable of successfully parsing to the end of the decision rule is\n     * blocked by a semantic predicate. By choosing this alternative within\n     * {@link //adaptivePredict} instead of throwing a\n     * {@link NoViableAltException}, the resulting\n     * {@link FailedPredicateException} in the parser will identify the specific\n     * predicate which is preventing the parser from successfully parsing the\n     * decision rule, which helps developers identify and correct logic errors\n     * in semantic predicates.\n     * </p>\n     *\n     * @param configs The ATN configurations which were valid immediately before\n     * the {@link //ERROR} state was reached\n     * @param outerContext The is the \\gamma_0 initial parser context from the paper\n     * or the parser stack at the instant before prediction commences.\n     *\n     * @return The value to return from {@link //adaptivePredict}, or\n     * {@link ATN//INVALID_ALT_NUMBER} if a suitable alternative was not\n     * identified and {@link //adaptivePredict} should report an error instead\n     */\n    getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(configs, outerContext) {\n        const cfgs = this.splitAccordingToSemanticValidity(configs, outerContext);\n        const semValidConfigs = cfgs[0];\n        const semInvalidConfigs = cfgs[1];\n        let alt = this.getAltThatFinishedDecisionEntryRule(semValidConfigs);\n        if (alt!==ATN.INVALID_ALT_NUMBER) { // semantically/syntactically viable path exists\n            return alt;\n        }\n        // Is there a syntactically valid path with a failed pred?\n        if (semInvalidConfigs.items.length>0) {\n            alt = this.getAltThatFinishedDecisionEntryRule(semInvalidConfigs);\n            if (alt!==ATN.INVALID_ALT_NUMBER) { // syntactically viable path exists\n                return alt;\n            }\n        }\n        return ATN.INVALID_ALT_NUMBER;\n    }\n\n    getAltThatFinishedDecisionEntryRule(configs) {\n        const alts = [];\n        for(let i=0;i<configs.items.length; i++) {\n            const c = configs.items[i];\n            if (c.reachesIntoOuterContext>0 || ((c.state instanceof RuleStopState) && c.context.hasEmptyPath())) {\n                if(alts.indexOf(c.alt)<0) {\n                    alts.push(c.alt);\n                }\n            }\n        }\n        if (alts.length===0) {\n            return ATN.INVALID_ALT_NUMBER;\n        } else {\n            return Math.min.apply(null, alts);\n        }\n    }\n\n    /**\n     * Walk the list of configurations and split them according to\n     * those that have preds evaluating to true/false.  If no pred, assume\n     * true pred and include in succeeded set.  Returns Pair of sets.\n     *\n     * Create a new set so as not to alter the incoming parameter.\n     *\n     * Assumption: the input stream has been restored to the starting point\n     * prediction, which is where predicates need to evaluate.*/\n    splitAccordingToSemanticValidity( configs, outerContext) {\n        const succeeded = new ATNConfigSet(configs.fullCtx);\n        const failed = new ATNConfigSet(configs.fullCtx);\n        for(let i=0;i<configs.items.length; i++) {\n            const c = configs.items[i];\n            if (c.semanticContext !== SemanticContext.NONE) {\n                const predicateEvaluationResult = c.semanticContext.evaluate(this.parser, outerContext);\n                if (predicateEvaluationResult) {\n                    succeeded.add(c);\n                } else {\n                    failed.add(c);\n                }\n            } else {\n                succeeded.add(c);\n            }\n        }\n        return [succeeded, failed];\n    }\n\n    /**\n     * Look through a list of predicate/alt pairs, returning alts for the\n     * pairs that win. A {@code NONE} predicate indicates an alt containing an\n     * unpredicated config which behaves as \"always true.\" If !complete\n     * then we stop at the first predicate that evaluates to true. This\n     * includes pairs with null predicates.\n     */\n    evalSemanticContext(predPredictions, outerContext, complete) {\n        const predictions = new BitSet();\n        for(let i=0;i<predPredictions.length;i++) {\n            const pair = predPredictions[i];\n            if (pair.pred === SemanticContext.NONE) {\n                predictions.add(pair.alt);\n                if (! complete) {\n                    break;\n                }\n                continue;\n            }\n            const predicateEvaluationResult = pair.pred.evaluate(this.parser, outerContext);\n            if (this.debug || this.dfa_debug) {\n                console.log(\"eval pred \" + pair + \"=\" + predicateEvaluationResult);\n            }\n            if (predicateEvaluationResult) {\n                if (this.debug || this.dfa_debug) {\n                    console.log(\"PREDICT \" + pair.alt);\n                }\n                predictions.add(pair.alt);\n                if (! complete) {\n                    break;\n                }\n            }\n        }\n        return predictions;\n    }\n\n// TODO: If we are doing predicates, there is no point in pursuing\n//     closure operations if we reach a DFA state that uniquely predicts\n//     alternative. We will not be caching that DFA state and it is a\n//     waste to pursue the closure. Might have to advance when we do\n//     ambig detection thought :(\n//\n    closure(config, configs, closureBusy, collectPredicates, fullCtx, treatEofAsEpsilon) {\n        const initialDepth = 0;\n        this.closureCheckingStopState(config, configs, closureBusy, collectPredicates,\n                                 fullCtx, initialDepth, treatEofAsEpsilon);\n    }\n\n    closureCheckingStopState(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon) {\n        if (this.debug || this.debug_closure) {\n            console.log(\"closure(\" + config.toString(this.parser,true) + \")\");\n            // console.log(\"configs(\" + configs.toString() + \")\");\n            if(config.reachesIntoOuterContext>50) {\n                throw \"problem\";\n            }\n        }\n        if (config.state instanceof RuleStopState) {\n            // We hit rule end. If we have context info, use it\n            // run thru all possible stack tops in ctx\n            if (! config.context.isEmpty()) {\n                for (let i =0; i<config.context.length; i++) {\n                    if (config.context.getReturnState(i) === PredictionContext.EMPTY_RETURN_STATE) {\n                        if (fullCtx) {\n                            configs.add(new ATNConfig({state:config.state, context:PredictionContext.EMPTY}, config), this.mergeCache);\n                            continue;\n                        } else {\n                            // we have no context info, just chase follow links (if greedy)\n                            if (this.debug) {\n                                console.log(\"FALLING off rule \" + this.getRuleName(config.state.ruleIndex));\n                            }\n                            this.closure_(config, configs, closureBusy, collectPredicates,\n                                     fullCtx, depth, treatEofAsEpsilon);\n                        }\n                        continue;\n                    }\n                    const returnState = this.atn.states[config.context.getReturnState(i)];\n                    const newContext = config.context.getParent(i); // \"pop\" return state\n                    const parms = {state:returnState, alt:config.alt, context:newContext, semanticContext:config.semanticContext};\n                    const c = new ATNConfig(parms, null);\n                    // While we have context to pop back from, we may have\n                    // gotten that context AFTER having falling off a rule.\n                    // Make sure we track that we are now out of context.\n                    c.reachesIntoOuterContext = config.reachesIntoOuterContext;\n                    this.closureCheckingStopState(c, configs, closureBusy, collectPredicates, fullCtx, depth - 1, treatEofAsEpsilon);\n                }\n                return;\n            } else if( fullCtx) {\n                // reached end of start rule\n                configs.add(config, this.mergeCache);\n                return;\n            } else {\n                // else if we have no context info, just chase follow links (if greedy)\n                if (this.debug) {\n                    console.log(\"FALLING off rule \" + this.getRuleName(config.state.ruleIndex));\n                }\n            }\n        }\n        this.closure_(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon);\n    }\n\n    // Do the actual work of walking epsilon edges//\n    closure_(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon) {\n        const p = config.state;\n        // optimization\n        if (! p.epsilonOnlyTransitions) {\n            configs.add(config, this.mergeCache);\n            // make sure to not return here, because EOF transitions can act as\n            // both epsilon transitions and non-epsilon transitions.\n        }\n        for(let i = 0;i<p.transitions.length; i++) {\n            if(i === 0 && this.canDropLoopEntryEdgeInLeftRecursiveRule(config))\n                continue;\n\n            const t = p.transitions[i];\n            const continueCollecting = collectPredicates && !(t instanceof ActionTransition);\n            const c = this.getEpsilonTarget(config, t, continueCollecting, depth === 0, fullCtx, treatEofAsEpsilon);\n            if (c!==null) {\n                let newDepth = depth;\n                if ( config.state instanceof RuleStopState) {\n                    // target fell off end of rule; mark resulting c as having dipped into outer context\n                    // We can't get here if incoming config was rule stop and we had context\n                    // track how far we dip into outer context.  Might\n                    // come in handy and we avoid evaluating context dependent\n                    // preds if this is > 0.\n                    if (this._dfa !== null && this._dfa.precedenceDfa) {\n                        if (t.outermostPrecedenceReturn === this._dfa.atnStartState.ruleIndex) {\n                            c.precedenceFilterSuppressed = true;\n                        }\n                    }\n\n                    c.reachesIntoOuterContext += 1;\n                    if (closureBusy.add(c)!==c) {\n                        // avoid infinite recursion for right-recursive rules\n                        continue;\n                    }\n                    configs.dipsIntoOuterContext = true; // TODO: can remove? only care when we add to set per middle of this method\n                    newDepth -= 1;\n                    if (this.debug) {\n                        console.log(\"dips into outer ctx: \" + c);\n                    }\n                } else {\n                    if (!t.isEpsilon && closureBusy.add(c)!==c){\n                        // avoid infinite recursion for EOF* and EOF+\n                        continue;\n                    }\n                    if (t instanceof RuleTransition) {\n                        // latch when newDepth goes negative - once we step out of the entry context we can't return\n                        if (newDepth >= 0) {\n                            newDepth += 1;\n                        }\n                    }\n                }\n                this.closureCheckingStopState(c, configs, closureBusy, continueCollecting, fullCtx, newDepth, treatEofAsEpsilon);\n            }\n        }\n    }\n\n    canDropLoopEntryEdgeInLeftRecursiveRule(config) {\n        // return False\n        const p = config.state;\n        // First check to see if we are in StarLoopEntryState generated during\n        // left-recursion elimination. For efficiency, also check if\n        // the context has an empty stack case. If so, it would mean\n        // global FOLLOW so we can't perform optimization\n        // Are we the special loop entry/exit state? or SLL wildcard\n        if(p.stateType !== ATNState.STAR_LOOP_ENTRY)\n            return false;\n        if(p.stateType !== ATNState.STAR_LOOP_ENTRY || !p.isPrecedenceDecision ||\n               config.context.isEmpty() || config.context.hasEmptyPath())\n            return false;\n\n        // Require all return states to return back to the same rule that p is in.\n        const numCtxs = config.context.length;\n        for(let i=0; i<numCtxs; i++) { // for each stack context\n            const returnState = this.atn.states[config.context.getReturnState(i)];\n            if (returnState.ruleIndex !== p.ruleIndex)\n                return false;\n        }\n\n        const decisionStartState = p.transitions[0].target;\n        const blockEndStateNum = decisionStartState.endState.stateNumber;\n        const blockEndState = this.atn.states[blockEndStateNum];\n\n        // Verify that the top of each stack context leads to loop entry/exit\n        // state through epsilon edges and w/o leaving rule.\n        for(let i=0; i<numCtxs; i++) { // for each stack context\n            const returnStateNumber = config.context.getReturnState(i);\n            const returnState = this.atn.states[returnStateNumber];\n            // all states must have single outgoing epsilon edge\n            if (returnState.transitions.length !== 1 || !returnState.transitions[0].isEpsilon)\n                return false;\n\n            // Look for prefix op case like 'not expr', (' type ')' expr\n            const returnStateTarget = returnState.transitions[0].target;\n            if ( returnState.stateType === ATNState.BLOCK_END && returnStateTarget === p )\n                continue;\n\n            // Look for 'expr op expr' or case where expr's return state is block end\n            // of (...)* internal block; the block end points to loop back\n            // which points to p but we don't need to check that\n            if ( returnState === blockEndState )\n                continue;\n\n            // Look for ternary expr ? expr : expr. The return state points at block end,\n            // which points at loop entry state\n            if ( returnStateTarget === blockEndState )\n                continue;\n\n            // Look for complex prefix 'between expr and expr' case where 2nd expr's\n            // return state points at block end state of (...)* internal block\n            if (returnStateTarget.stateType === ATNState.BLOCK_END && returnStateTarget.transitions.length === 1\n                    && returnStateTarget.transitions[0].isEpsilon && returnStateTarget.transitions[0].target === p)\n                continue;\n\n            // anything else ain't conforming\n            return false;\n        }\n        return true;\n    }\n\n    getRuleName(index) {\n        if (this.parser!==null && index>=0) {\n            return this.parser.ruleNames[index];\n        } else {\n            return \"<rule \" + index + \">\";\n        }\n    }\n\n    getEpsilonTarget(config, t, collectPredicates, inContext, fullCtx, treatEofAsEpsilon) {\n        switch(t.serializationType) {\n        case Transition.RULE:\n            return this.ruleTransition(config, t);\n        case Transition.PRECEDENCE:\n            return this.precedenceTransition(config, t, collectPredicates, inContext, fullCtx);\n        case Transition.PREDICATE:\n            return this.predTransition(config, t, collectPredicates, inContext, fullCtx);\n        case Transition.ACTION:\n            return this.actionTransition(config, t);\n        case Transition.EPSILON:\n            return new ATNConfig({state:t.target}, config);\n        case Transition.ATOM:\n        case Transition.RANGE:\n        case Transition.SET:\n            // EOF transitions act like epsilon transitions after the first EOF\n            // transition is traversed\n            if (treatEofAsEpsilon) {\n                if (t.matches(Token.EOF, 0, 1)) {\n                    return new ATNConfig({state: t.target}, config);\n                }\n            }\n            return null;\n        default:\n            return null;\n        }\n    }\n\n    actionTransition(config, t) {\n        if (this.debug) {\n            const index = t.actionIndex === -1 ? 65535 : t.actionIndex;\n            console.log(\"ACTION edge \" + t.ruleIndex + \":\" + index);\n        }\n        return new ATNConfig({state:t.target}, config);\n    }\n\n    precedenceTransition(config, pt, collectPredicates, inContext, fullCtx) {\n        if (this.debug) {\n            console.log(\"PRED (collectPredicates=\" + collectPredicates + \") \" +\n                    pt.precedence + \">=_p, ctx dependent=true\");\n            if (this.parser!==null) {\n                console.log(\"context surrounding pred is \" + Utils.arrayToString(this.parser.getRuleInvocationStack()));\n            }\n        }\n        let c = null;\n        if (collectPredicates && inContext) {\n            if (fullCtx) {\n                // In full context mode, we can evaluate predicates on-the-fly\n                // during closure, which dramatically reduces the size of\n                // the config sets. It also obviates the need to test predicates\n                // later during conflict resolution.\n                const currentPosition = this._input.index;\n                this._input.seek(this._startIndex);\n                const predSucceeds = pt.getPredicate().evaluate(this.parser, this._outerContext);\n                this._input.seek(currentPosition);\n                if (predSucceeds) {\n                    c = new ATNConfig({state:pt.target}, config); // no pred context\n                }\n            } else {\n                const newSemCtx = SemanticContext.andContext(config.semanticContext, pt.getPredicate());\n                c = new ATNConfig({state:pt.target, semanticContext:newSemCtx}, config);\n            }\n        } else {\n            c = new ATNConfig({state:pt.target}, config);\n        }\n        if (this.debug) {\n            console.log(\"config from pred transition=\" + c);\n        }\n        return c;\n    }\n\n    predTransition(config, pt, collectPredicates, inContext, fullCtx) {\n        if (this.debug) {\n            console.log(\"PRED (collectPredicates=\" + collectPredicates + \") \" + pt.ruleIndex +\n                    \":\" + pt.predIndex + \", ctx dependent=\" + pt.isCtxDependent);\n            if (this.parser!==null) {\n                console.log(\"context surrounding pred is \" + Utils.arrayToString(this.parser.getRuleInvocationStack()));\n            }\n        }\n        let c = null;\n        if (collectPredicates && ((pt.isCtxDependent && inContext) || ! pt.isCtxDependent)) {\n            if (fullCtx) {\n                // In full context mode, we can evaluate predicates on-the-fly\n                // during closure, which dramatically reduces the size of\n                // the config sets. It also obviates the need to test predicates\n                // later during conflict resolution.\n                const currentPosition = this._input.index;\n                this._input.seek(this._startIndex);\n                const predSucceeds = pt.getPredicate().evaluate(this.parser, this._outerContext);\n                this._input.seek(currentPosition);\n                if (predSucceeds) {\n                    c = new ATNConfig({state:pt.target}, config); // no pred context\n                }\n            } else {\n                const newSemCtx = SemanticContext.andContext(config.semanticContext, pt.getPredicate());\n                c = new ATNConfig({state:pt.target, semanticContext:newSemCtx}, config);\n            }\n        } else {\n            c = new ATNConfig({state:pt.target}, config);\n        }\n        if (this.debug) {\n            console.log(\"config from pred transition=\" + c);\n        }\n        return c;\n    }\n\n    ruleTransition(config, t) {\n        if (this.debug) {\n            console.log(\"CALL rule \" + this.getRuleName(t.target.ruleIndex) + \", ctx=\" + config.context);\n        }\n        const returnState = t.followState;\n        const newContext = SingletonPredictionContext.create(config.context, returnState.stateNumber);\n        return new ATNConfig({state:t.target, context:newContext}, config );\n    }\n\n    getConflictingAlts(configs) {\n        const altsets = PredictionMode.getConflictingAltSubsets(configs);\n        return PredictionMode.getAlts(altsets);\n    }\n\n    /**\n     * Sam pointed out a problem with the previous definition, v3, of\n     * ambiguous states. If we have another state associated with conflicting\n     * alternatives, we should keep going. For example, the following grammar\n     *\n     * s : (ID | ID ID?) ';' ;\n     *\n     * When the ATN simulation reaches the state before ';', it has a DFA\n     * state that looks like: [12|1|[], 6|2|[], 12|2|[]]. Naturally\n     * 12|1|[] and 12|2|[] conflict, but we cannot stop processing this node\n     * because alternative to has another way to continue, via [6|2|[]].\n     * The key is that we have a single state that has config's only associated\n     * with a single alternative, 2, and crucially the state transitions\n     * among the configurations are all non-epsilon transitions. That means\n     * we don't consider any conflicts that include alternative 2. So, we\n     * ignore the conflict between alts 1 and 2. We ignore a set of\n     * conflicting alts when there is an intersection with an alternative\n     * associated with a single alt state in the state&rarr;config-list map.\n     *\n     * It's also the case that we might have two conflicting configurations but\n     * also a 3rd nonconflicting configuration for a different alternative:\n     * [1|1|[], 1|2|[], 8|3|[]]. This can come about from grammar:\n     *\n     * a : A | A | A B ;\n     *\n     * After matching input A, we reach the stop state for rule A, state 1.\n     * State 8 is the state right before B. Clearly alternatives 1 and 2\n     * conflict and no amount of further lookahead will separate the two.\n     * However, alternative 3 will be able to continue and so we do not\n     * stop working on this state. In the previous example, we're concerned\n     * with states associated with the conflicting alternatives. Here alt\n     * 3 is not associated with the conflicting configs, but since we can continue\n     * looking for input reasonably, I don't declare the state done. We\n     * ignore a set of conflicting alts when we have an alternative\n     * that we still need to pursue\n     */\n    getConflictingAltsOrUniqueAlt(configs) {\n        let conflictingAlts = null;\n        if (configs.uniqueAlt!== ATN.INVALID_ALT_NUMBER) {\n            conflictingAlts = new BitSet();\n            conflictingAlts.add(configs.uniqueAlt);\n        } else {\n            conflictingAlts = configs.conflictingAlts;\n        }\n        return conflictingAlts;\n    }\n\n    getTokenName(t) {\n        if (t===Token.EOF) {\n            return \"EOF\";\n        }\n        if( this.parser!==null && this.parser.literalNames!==null) {\n            if (t >= this.parser.literalNames.length && t >= this.parser.symbolicNames.length) {\n                console.log(\"\" + t + \" ttype out of range: \" + this.parser.literalNames);\n                console.log(\"\" + this.parser.getInputStream().getTokens());\n            } else {\n                const name = this.parser.literalNames[t] || this.parser.symbolicNames[t];\n                return name + \"<\" + t + \">\";\n            }\n        }\n        return \"\" + t;\n    }\n\n    getLookaheadName(input) {\n        return this.getTokenName(input.LA(1));\n    }\n\n    /**\n     * Used for debugging in adaptivePredict around execATN but I cut\n     * it out for clarity now that alg. works well. We can leave this\n     * \"dead\" code for a bit\n     */\n    dumpDeadEndConfigs(nvae) {\n        console.log(\"dead end configs: \");\n        const decs = nvae.getDeadEndConfigs();\n        for(let i=0; i<decs.length; i++) {\n            const c = decs[i];\n            let trans = \"no edges\";\n            if (c.state.transitions.length>0) {\n                const t = c.state.transitions[0];\n                if (t instanceof AtomTransition) {\n                    trans = \"Atom \"+ this.getTokenName(t.label);\n                } else if (t instanceof SetTransition) {\n                    const neg = (t instanceof NotSetTransition);\n                    trans = (neg ? \"~\" : \"\") + \"Set \" + t.set;\n                }\n            }\n            console.error(c.toString(this.parser, true) + \":\" + trans);\n        }\n    }\n\n    noViableAlt(input, outerContext, configs, startIndex) {\n        return new NoViableAltException(this.parser, input, input.get(startIndex), input.LT(1), configs, outerContext);\n    }\n\n    getUniqueAlt(configs) {\n        let alt = ATN.INVALID_ALT_NUMBER;\n        for(let i=0;i<configs.items.length;i++) {\n            const c = configs.items[i];\n            if (alt === ATN.INVALID_ALT_NUMBER) {\n                alt = c.alt // found first alt\n            } else if( c.alt!==alt) {\n                return ATN.INVALID_ALT_NUMBER;\n            }\n        }\n        return alt;\n    }\n\n    /**\n     * Add an edge to the DFA, if possible. This method calls\n     * {@link //addDFAState} to ensure the {@code to} state is present in the\n     * DFA. If {@code from} is {@code null}, or if {@code t} is outside the\n     * range of edges that can be represented in the DFA tables, this method\n     * returns without adding the edge to the DFA.\n     *\n     * <p>If {@code to} is {@code null}, this method returns {@code null}.\n     * Otherwise, this method returns the {@link DFAState} returned by calling\n     * {@link //addDFAState} for the {@code to} state.</p>\n     *\n     * @param dfa The DFA\n     * @param from_ The source state for the edge\n     * @param t The input symbol\n     * @param to The target state for the edge\n     *\n     * @return If {@code to} is {@code null}, this method returns {@code null};\n     * otherwise this method returns the result of calling {@link //addDFAState}\n     * on {@code to}\n     */\n    addDFAEdge(dfa, from_, t, to) {\n        if( this.debug) {\n            console.log(\"EDGE \" + from_ + \" -> \" + to + \" upon \" + this.getTokenName(t));\n        }\n        if (to===null) {\n            return null;\n        }\n        to = this.addDFAState(dfa, to); // used existing if possible not incoming\n        if (from_===null || t < -1 || t > this.atn.maxTokenType) {\n            return to;\n        }\n        if (from_.edges===null) {\n            from_.edges = [];\n        }\n        from_.edges[t+1] = to; // connect\n\n        if (this.debug) {\n            const literalNames = this.parser===null ? null : this.parser.literalNames;\n            const symbolicNames = this.parser===null ? null : this.parser.symbolicNames;\n            console.log(\"DFA=\\n\" + dfa.toString(literalNames, symbolicNames));\n        }\n        return to;\n    }\n\n    /**\n     * Add state {@code D} to the DFA if it is not already present, and return\n     * the actual instance stored in the DFA. If a state equivalent to {@code D}\n     * is already in the DFA, the existing state is returned. Otherwise this\n     * method returns {@code D} after adding it to the DFA.\n     *\n     * <p>If {@code D} is {@link //ERROR}, this method returns {@link //ERROR} and\n     * does not change the DFA.</p>\n     *\n     * @param dfa The dfa\n     * @param D The DFA state to add\n     * @return The state stored in the DFA. This will be either the existing\n     * state if {@code D} is already in the DFA, or {@code D} itself if the\n     * state was not already present\n     */\n    addDFAState(dfa, D) {\n        if (D === ATNSimulator.ERROR) {\n            return D;\n        }\n        const existing = dfa.states.get(D);\n        if(existing!==null) {\n            return existing;\n        }\n        D.stateNumber = dfa.states.length;\n        if (! D.configs.readOnly) {\n            D.configs.optimizeConfigs(this);\n            D.configs.setReadonly(true);\n        }\n        dfa.states.add(D);\n        if (this.debug) {\n            console.log(\"adding new DFA state: \" + D);\n        }\n        return D;\n    }\n\n    reportAttemptingFullContext(dfa, conflictingAlts, configs, startIndex, stopIndex) {\n        if (this.debug || this.retry_debug) {\n            const interval = new Interval(startIndex, stopIndex + 1);\n            console.log(\"reportAttemptingFullContext decision=\" + dfa.decision + \":\" + configs +\n                               \", input=\" + this.parser.getTokenStream().getText(interval));\n        }\n        if (this.parser!==null) {\n            this.parser.getErrorListenerDispatch().reportAttemptingFullContext(this.parser, dfa, startIndex, stopIndex, conflictingAlts, configs);\n        }\n    }\n\n    reportContextSensitivity(dfa, prediction, configs, startIndex, stopIndex) {\n        if (this.debug || this.retry_debug) {\n            const interval = new Interval(startIndex, stopIndex + 1);\n            console.log(\"reportContextSensitivity decision=\" + dfa.decision + \":\" + configs +\n                               \", input=\" + this.parser.getTokenStream().getText(interval));\n        }\n        if (this.parser!==null) {\n            this.parser.getErrorListenerDispatch().reportContextSensitivity(this.parser, dfa, startIndex, stopIndex, prediction, configs);\n        }\n    }\n\n    // If context sensitive parsing, we know it's ambiguity not conflict//\n    reportAmbiguity(dfa, D, startIndex, stopIndex,\n                                   exact, ambigAlts, configs ) {\n        if (this.debug || this.retry_debug) {\n            const interval = new Interval(startIndex, stopIndex + 1);\n            console.log(\"reportAmbiguity \" + ambigAlts + \":\" + configs +\n                               \", input=\" + this.parser.getTokenStream().getText(interval));\n        }\n        if (this.parser!==null) {\n            this.parser.getErrorListenerDispatch().reportAmbiguity(this.parser, dfa, startIndex, stopIndex, exact, ambigAlts, configs);\n        }\n    }\n}\n\nmodule.exports = ParserATNSimulator;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Map, BitSet, AltDict, hashStuff} = require('./../Utils');\nconst ATN = require('./ATN');\nconst {RuleStopState} = require('./ATNState');\nconst {ATNConfigSet} = require('./ATNConfigSet');\nconst {ATNConfig} = require('./ATNConfig');\nconst {SemanticContext} = require('./SemanticContext');\n\n/**\n * This enumeration defines the prediction modes available in ANTLR 4 along with\n * utility methods for analyzing configuration sets for conflicts and/or\n * ambiguities.\n */\nconst PredictionMode = {\n    /**\n     * The SLL(*) prediction mode. This prediction mode ignores the current\n     * parser context when making predictions. This is the fastest prediction\n     * mode, and provides correct results for many grammars. This prediction\n     * mode is more powerful than the prediction mode provided by ANTLR 3, but\n     * may result in syntax errors for grammar and input combinations which are\n     * not SLL.\n     *\n     * <p>\n     * When using this prediction mode, the parser will either return a correct\n     * parse tree (i.e. the same parse tree that would be returned with the\n     * {@link //LL} prediction mode), or it will report a syntax error. If a\n     * syntax error is encountered when using the {@link //SLL} prediction mode,\n     * it may be due to either an actual syntax error in the input or indicate\n     * that the particular combination of grammar and input requires the more\n     * powerful {@link //LL} prediction abilities to complete successfully.</p>\n     *\n     * <p>\n     * This prediction mode does not provide any guarantees for prediction\n     * behavior for syntactically-incorrect inputs.</p>\n     */\n    SLL: 0,\n\n    /**\n     * The LL(*) prediction mode. This prediction mode allows the current parser\n     * context to be used for resolving SLL conflicts that occur during\n     * prediction. This is the fastest prediction mode that guarantees correct\n     * parse results for all combinations of grammars with syntactically correct\n     * inputs.\n     *\n     * <p>\n     * When using this prediction mode, the parser will make correct decisions\n     * for all syntactically-correct grammar and input combinations. However, in\n     * cases where the grammar is truly ambiguous this prediction mode might not\n     * report a precise answer for <em>exactly which</em> alternatives are\n     * ambiguous.</p>\n     *\n     * <p>\n     * This prediction mode does not provide any guarantees for prediction\n     * behavior for syntactically-incorrect inputs.</p>\n     */\n    LL: 1,\n\n    /**\n     *\n     * The LL(*) prediction mode with exact ambiguity detection. In addition to\n     * the correctness guarantees provided by the {@link //LL} prediction mode,\n     * this prediction mode instructs the prediction algorithm to determine the\n     * complete and exact set of ambiguous alternatives for every ambiguous\n     * decision encountered while parsing.\n     *\n     * <p>\n     * This prediction mode may be used for diagnosing ambiguities during\n     * grammar development. Due to the performance overhead of calculating sets\n     * of ambiguous alternatives, this prediction mode should be avoided when\n     * the exact results are not necessary.</p>\n     *\n     * <p>\n     * This prediction mode does not provide any guarantees for prediction\n     * behavior for syntactically-incorrect inputs.</p>\n     */\n    LL_EXACT_AMBIG_DETECTION: 2,\n\n    /**\n     *\n     * Computes the SLL prediction termination condition.\n     *\n     * <p>\n     * This method computes the SLL prediction termination condition for both of\n     * the following cases.</p>\n     *\n     * <ul>\n     * <li>The usual SLL+LL fallback upon SLL conflict</li>\n     * <li>Pure SLL without LL fallback</li>\n     * </ul>\n     *\n     * <p><strong>COMBINED SLL+LL PARSING</strong></p>\n     *\n     * <p>When LL-fallback is enabled upon SLL conflict, correct predictions are\n     * ensured regardless of how the termination condition is computed by this\n     * method. Due to the substantially higher cost of LL prediction, the\n     * prediction should only fall back to LL when the additional lookahead\n     * cannot lead to a unique SLL prediction.</p>\n     *\n     * <p>Assuming combined SLL+LL parsing, an SLL configuration set with only\n     * conflicting subsets should fall back to full LL, even if the\n     * configuration sets don't resolve to the same alternative (e.g.\n     * {@code {1,2}} and {@code {3,4}}. If there is at least one non-conflicting\n     * configuration, SLL could continue with the hopes that more lookahead will\n     * resolve via one of those non-conflicting configurations.</p>\n     *\n     * <p>Here's the prediction termination rule them: SLL (for SLL+LL parsing)\n     * stops when it sees only conflicting configuration subsets. In contrast,\n     * full LL keeps going when there is uncertainty.</p>\n     *\n     * <p><strong>HEURISTIC</strong></p>\n     *\n     * <p>As a heuristic, we stop prediction when we see any conflicting subset\n     * unless we see a state that only has one alternative associated with it.\n     * The single-alt-state thing lets prediction continue upon rules like\n     * (otherwise, it would admit defeat too soon):</p>\n     *\n     * <p>{@code [12|1|[], 6|2|[], 12|2|[]]. s : (ID | ID ID?) ';' ;}</p>\n     *\n     * <p>When the ATN simulation reaches the state before {@code ';'}, it has a\n     * DFA state that looks like: {@code [12|1|[], 6|2|[], 12|2|[]]}. Naturally\n     * {@code 12|1|[]} and {@code 12|2|[]} conflict, but we cannot stop\n     * processing this node because alternative to has another way to continue,\n     * via {@code [6|2|[]]}.</p>\n     *\n     * <p>It also let's us continue for this rule:</p>\n     *\n     * <p>{@code [1|1|[], 1|2|[], 8|3|[]] a : A | A | A B ;}</p>\n     *\n     * <p>After matching input A, we reach the stop state for rule A, state 1.\n     * State 8 is the state right before B. Clearly alternatives 1 and 2\n     * conflict and no amount of further lookahead will separate the two.\n     * However, alternative 3 will be able to continue and so we do not stop\n     * working on this state. In the previous example, we're concerned with\n     * states associated with the conflicting alternatives. Here alt 3 is not\n     * associated with the conflicting configs, but since we can continue\n     * looking for input reasonably, don't declare the state done.</p>\n     *\n     * <p><strong>PURE SLL PARSING</strong></p>\n     *\n     * <p>To handle pure SLL parsing, all we have to do is make sure that we\n     * combine stack contexts for configurations that differ only by semantic\n     * predicate. From there, we can do the usual SLL termination heuristic.</p>\n     *\n     * <p><strong>PREDICATES IN SLL+LL PARSING</strong></p>\n     *\n     * <p>SLL decisions don't evaluate predicates until after they reach DFA stop\n     * states because they need to create the DFA cache that works in all\n     * semantic situations. In contrast, full LL evaluates predicates collected\n     * during start state computation so it can ignore predicates thereafter.\n     * This means that SLL termination detection can totally ignore semantic\n     * predicates.</p>\n     *\n     * <p>Implementation-wise, {@link ATNConfigSet} combines stack contexts but not\n     * semantic predicate contexts so we might see two configurations like the\n     * following.</p>\n     *\n     * <p>{@code (s, 1, x, {}), (s, 1, x', {p})}</p>\n     *\n     * <p>Before testing these configurations against others, we have to merge\n     * {@code x} and {@code x'} (without modifying the existing configurations).\n     * For example, we test {@code (x+x')==x''} when looking for conflicts in\n     * the following configurations.</p>\n     *\n     * <p>{@code (s, 1, x, {}), (s, 1, x', {p}), (s, 2, x'', {})}</p>\n     *\n     * <p>If the configuration set has predicates (as indicated by\n     * {@link ATNConfigSet//hasSemanticContext}), this algorithm makes a copy of\n     * the configurations to strip out all of the predicates so that a standard\n     * {@link ATNConfigSet} will merge everything ignoring predicates.</p>\n     */\n    hasSLLConflictTerminatingPrediction: function( mode, configs) {\n        // Configs in rule stop states indicate reaching the end of the decision\n        // rule (local context) or end of start rule (full context). If all\n        // configs meet this condition, then none of the configurations is able\n        // to match additional input so we terminate prediction.\n        //\n        if (PredictionMode.allConfigsInRuleStopStates(configs)) {\n            return true;\n        }\n        // pure SLL mode parsing\n        if (mode === PredictionMode.SLL) {\n            // Don't bother with combining configs from different semantic\n            // contexts if we can fail over to full LL; costs more time\n            // since we'll often fail over anyway.\n            if (configs.hasSemanticContext) {\n                // dup configs, tossing out semantic predicates\n                const dup = new ATNConfigSet();\n                for(let i=0;i<configs.items.length;i++) {\n                    let c = configs.items[i];\n                    c = new ATNConfig({semanticContext:SemanticContext.NONE}, c);\n                    dup.add(c);\n                }\n                configs = dup;\n            }\n            // now we have combined contexts for configs with dissimilar preds\n        }\n        // pure SLL or combined SLL+LL mode parsing\n        const altsets = PredictionMode.getConflictingAltSubsets(configs);\n        return PredictionMode.hasConflictingAltSet(altsets) && !PredictionMode.hasStateAssociatedWithOneAlt(configs);\n    },\n\n    /**\n     * Checks if any configuration in {@code configs} is in a\n     * {@link RuleStopState}. Configurations meeting this condition have reached\n     * the end of the decision rule (local context) or end of start rule (full\n     * context).\n     *\n     * @param configs the configuration set to test\n     * @return {@code true} if any configuration in {@code configs} is in a\n     * {@link RuleStopState}, otherwise {@code false}\n     */\n    hasConfigInRuleStopState: function(configs) {\n        for(let i=0;i<configs.items.length;i++) {\n            const c = configs.items[i];\n            if (c.state instanceof RuleStopState) {\n                return true;\n            }\n        }\n        return false;\n    },\n\n    /**\n     * Checks if all configurations in {@code configs} are in a\n     * {@link RuleStopState}. Configurations meeting this condition have reached\n     * the end of the decision rule (local context) or end of start rule (full\n     * context).\n     *\n     * @param configs the configuration set to test\n     * @return {@code true} if all configurations in {@code configs} are in a\n     * {@link RuleStopState}, otherwise {@code false}\n     */\n    allConfigsInRuleStopStates: function(configs) {\n        for(let i=0;i<configs.items.length;i++) {\n            const c = configs.items[i];\n            if (!(c.state instanceof RuleStopState)) {\n                return false;\n            }\n        }\n        return true;\n    },\n\n    /**\n     *\n     * Full LL prediction termination.\n     *\n     * <p>Can we stop looking ahead during ATN simulation or is there some\n     * uncertainty as to which alternative we will ultimately pick, after\n     * consuming more input? Even if there are partial conflicts, we might know\n     * that everything is going to resolve to the same minimum alternative. That\n     * means we can stop since no more lookahead will change that fact. On the\n     * other hand, there might be multiple conflicts that resolve to different\n     * minimums. That means we need more look ahead to decide which of those\n     * alternatives we should predict.</p>\n     *\n     * <p>The basic idea is to split the set of configurations {@code C}, into\n     * conflicting subsets {@code (s, _, ctx, _)} and singleton subsets with\n     * non-conflicting configurations. Two configurations conflict if they have\n     * identical {@link ATNConfig//state} and {@link ATNConfig//context} values\n     * but different {@link ATNConfig//alt} value, e.g. {@code (s, i, ctx, _)}\n     * and {@code (s, j, ctx, _)} for {@code i!=j}.</p>\n     *\n     * <p>Reduce these configuration subsets to the set of possible alternatives.\n     * You can compute the alternative subsets in one pass as follows:</p>\n     *\n     * <p>{@code A_s,ctx = {i | (s, i, ctx, _)}} for each configuration in\n     * {@code C} holding {@code s} and {@code ctx} fixed.</p>\n     *\n     * <p>Or in pseudo-code, for each configuration {@code c} in {@code C}:</p>\n     *\n     * <pre>\n     * map[c] U= c.{@link ATNConfig//alt alt} // map hash/equals uses s and x, not\n     * alt and not pred\n     * </pre>\n     *\n     * <p>The values in {@code map} are the set of {@code A_s,ctx} sets.</p>\n     *\n     * <p>If {@code |A_s,ctx|=1} then there is no conflict associated with\n     * {@code s} and {@code ctx}.</p>\n     *\n     * <p>Reduce the subsets to singletons by choosing a minimum of each subset. If\n     * the union of these alternative subsets is a singleton, then no amount of\n     * more lookahead will help us. We will always pick that alternative. If,\n     * however, there is more than one alternative, then we are uncertain which\n     * alternative to predict and must continue looking for resolution. We may\n     * or may not discover an ambiguity in the future, even if there are no\n     * conflicting subsets this round.</p>\n     *\n     * <p>The biggest sin is to terminate early because it means we've made a\n     * decision but were uncertain as to the eventual outcome. We haven't used\n     * enough lookahead. On the other hand, announcing a conflict too late is no\n     * big deal; you will still have the conflict. It's just inefficient. It\n     * might even look until the end of file.</p>\n     *\n     * <p>No special consideration for semantic predicates is required because\n     * predicates are evaluated on-the-fly for full LL prediction, ensuring that\n     * no configuration contains a semantic context during the termination\n     * check.</p>\n     *\n     * <p><strong>CONFLICTING CONFIGS</strong></p>\n     *\n     * <p>Two configurations {@code (s, i, x)} and {@code (s, j, x')}, conflict\n     * when {@code i!=j} but {@code x=x'}. Because we merge all\n     * {@code (s, i, _)} configurations together, that means that there are at\n     * most {@code n} configurations associated with state {@code s} for\n     * {@code n} possible alternatives in the decision. The merged stacks\n     * complicate the comparison of configuration contexts {@code x} and\n     * {@code x'}. Sam checks to see if one is a subset of the other by calling\n     * merge and checking to see if the merged result is either {@code x} or\n     * {@code x'}. If the {@code x} associated with lowest alternative {@code i}\n     * is the superset, then {@code i} is the only possible prediction since the\n     * others resolve to {@code min(i)} as well. However, if {@code x} is\n     * associated with {@code j>i} then at least one stack configuration for\n     * {@code j} is not in conflict with alternative {@code i}. The algorithm\n     * should keep going, looking for more lookahead due to the uncertainty.</p>\n     *\n     * <p>For simplicity, I'm doing a equality check between {@code x} and\n     * {@code x'} that lets the algorithm continue to consume lookahead longer\n     * than necessary. The reason I like the equality is of course the\n     * simplicity but also because that is the test you need to detect the\n     * alternatives that are actually in conflict.</p>\n     *\n     * <p><strong>CONTINUE/STOP RULE</strong></p>\n     *\n     * <p>Continue if union of resolved alternative sets from non-conflicting and\n     * conflicting alternative subsets has more than one alternative. We are\n     * uncertain about which alternative to predict.</p>\n     *\n     * <p>The complete set of alternatives, {@code [i for (_,i,_)]}, tells us which\n     * alternatives are still in the running for the amount of input we've\n     * consumed at this point. The conflicting sets let us to strip away\n     * configurations that won't lead to more states because we resolve\n     * conflicts to the configuration with a minimum alternate for the\n     * conflicting set.</p>\n     *\n     * <p><strong>CASES</strong></p>\n     *\n     * <ul>\n     *\n     * <li>no conflicts and more than 1 alternative in set =&gt; continue</li>\n     *\n     * <li> {@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s, 3, z)},\n     * {@code (s', 1, y)}, {@code (s', 2, y)} yields non-conflicting set\n     * {@code {3}} U conflicting sets {@code min({1,2})} U {@code min({1,2})} =\n     * {@code {1,3}} =&gt; continue\n     * </li>\n     *\n     * <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 1, y)},\n     * {@code (s', 2, y)}, {@code (s'', 1, z)} yields non-conflicting set\n     * {@code {1}} U conflicting sets {@code min({1,2})} U {@code min({1,2})} =\n     * {@code {1}} =&gt; stop and predict 1</li>\n     *\n     * <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 1, y)},\n     * {@code (s', 2, y)} yields conflicting, reduced sets {@code {1}} U\n     * {@code {1}} = {@code {1}} =&gt; stop and predict 1, can announce\n     * ambiguity {@code {1,2}}</li>\n     *\n     * <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 2, y)},\n     * {@code (s', 3, y)} yields conflicting, reduced sets {@code {1}} U\n     * {@code {2}} = {@code {1,2}} =&gt; continue</li>\n     *\n     * <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 3, y)},\n     * {@code (s', 4, y)} yields conflicting, reduced sets {@code {1}} U\n     * {@code {3}} = {@code {1,3}} =&gt; continue</li>\n     *\n     * </ul>\n     *\n     * <p><strong>EXACT AMBIGUITY DETECTION</strong></p>\n     *\n     * <p>If all states report the same conflicting set of alternatives, then we\n     * know we have the exact ambiguity set.</p>\n     *\n     * <p><code>|A_<em>i</em>|&gt;1</code> and\n     * <code>A_<em>i</em> = A_<em>j</em></code> for all <em>i</em>, <em>j</em>.</p>\n     *\n     * <p>In other words, we continue examining lookahead until all {@code A_i}\n     * have more than one alternative and all {@code A_i} are the same. If\n     * {@code A={{1,2}, {1,3}}}, then regular LL prediction would terminate\n     * because the resolved set is {@code {1}}. To determine what the real\n     * ambiguity is, we have to know whether the ambiguity is between one and\n     * two or one and three so we keep going. We can only stop prediction when\n     * we need exact ambiguity detection when the sets look like\n     * {@code A={{1,2}}} or {@code {{1,2},{1,2}}}, etc...</p>\n     */\n    resolvesToJustOneViableAlt: function(altsets) {\n        return PredictionMode.getSingleViableAlt(altsets);\n    },\n\n    /**\n     * Determines if every alternative subset in {@code altsets} contains more\n     * than one alternative.\n     *\n     * @param altsets a collection of alternative subsets\n     * @return {@code true} if every {@link BitSet} in {@code altsets} has\n     * {@link BitSet//cardinality cardinality} &gt; 1, otherwise {@code false}\n     */\n    allSubsetsConflict: function(altsets) {\n        return ! PredictionMode.hasNonConflictingAltSet(altsets);\n    },\n    /**\n     * Determines if any single alternative subset in {@code altsets} contains\n     * exactly one alternative.\n     *\n     * @param altsets a collection of alternative subsets\n     * @return {@code true} if {@code altsets} contains a {@link BitSet} with\n     * {@link BitSet//cardinality cardinality} 1, otherwise {@code false}\n     */\n    hasNonConflictingAltSet: function(altsets) {\n        for(let i=0;i<altsets.length;i++) {\n            const alts = altsets[i];\n            if (alts.length===1) {\n                return true;\n            }\n        }\n        return false;\n    },\n\n\n    /**\n     * Determines if any single alternative subset in {@code altsets} contains\n     * more than one alternative.\n     *\n     * @param altsets a collection of alternative subsets\n     * @return {@code true} if {@code altsets} contains a {@link BitSet} with\n     * {@link BitSet//cardinality cardinality} &gt; 1, otherwise {@code false}\n     */\n    hasConflictingAltSet: function(altsets) {\n        for(let i=0;i<altsets.length;i++) {\n            const alts = altsets[i];\n            if (alts.length>1) {\n                return true;\n            }\n        }\n        return false;\n    },\n\n\n    /**\n     * Determines if every alternative subset in {@code altsets} is equivalent.\n     *\n     * @param altsets a collection of alternative subsets\n     * @return {@code true} if every member of {@code altsets} is equal to the\n     * others, otherwise {@code false}\n     */\n    allSubsetsEqual: function(altsets) {\n        let first = null;\n        for(let i=0;i<altsets.length;i++) {\n            const alts = altsets[i];\n            if (first === null) {\n                first = alts;\n            } else if (alts!==first) {\n                return false;\n            }\n        }\n        return true;\n    },\n\n\n    /**\n     * Returns the unique alternative predicted by all alternative subsets in\n     * {@code altsets}. If no such alternative exists, this method returns\n     * {@link ATN//INVALID_ALT_NUMBER}.\n     *\n     * @param altsets a collection of alternative subsets\n     */\n    getUniqueAlt: function(altsets) {\n        const all = PredictionMode.getAlts(altsets);\n        if (all.length===1) {\n            return all.minValue();\n        } else {\n            return ATN.INVALID_ALT_NUMBER;\n        }\n    },\n\n    /**\n     * Gets the complete set of represented alternatives for a collection of\n     * alternative subsets. This method returns the union of each {@link BitSet}\n     * in {@code altsets}.\n     *\n     * @param altsets a collection of alternative subsets\n     * @return the set of represented alternatives in {@code altsets}\n     */\n    getAlts: function(altsets) {\n        const all = new BitSet();\n        altsets.map( function(alts) { all.or(alts); });\n        return all;\n    },\n\n    /**\n     * This function gets the conflicting alt subsets from a configuration set.\n     * For each configuration {@code c} in {@code configs}:\n     *\n     * <pre>\n     * map[c] U= c.{@link ATNConfig//alt alt} // map hash/equals uses s and x, not\n     * alt and not pred\n     * </pre>\n     */\n    getConflictingAltSubsets: function(configs) {\n        const configToAlts = new Map();\n        configToAlts.hashFunction = function(cfg) { hashStuff(cfg.state.stateNumber, cfg.context); };\n        configToAlts.equalsFunction = function(c1, c2) { return c1.state.stateNumber === c2.state.stateNumber && c1.context.equals(c2.context);};\n        configs.items.map(function(cfg) {\n            let alts = configToAlts.get(cfg);\n            if (alts === null) {\n                alts = new BitSet();\n                configToAlts.put(cfg, alts);\n            }\n            alts.add(cfg.alt);\n        });\n        return configToAlts.getValues();\n    },\n\n    /**\n     * Get a map from state to alt subset from a configuration set. For each\n     * configuration {@code c} in {@code configs}:\n     *\n     * <pre>\n     * map[c.{@link ATNConfig//state state}] U= c.{@link ATNConfig//alt alt}\n     * </pre>\n     */\n    getStateToAltMap: function(configs) {\n        const m = new AltDict();\n        configs.items.map(function(c) {\n            let alts = m.get(c.state);\n            if (alts === null) {\n                alts = new BitSet();\n                m.put(c.state, alts);\n            }\n            alts.add(c.alt);\n        });\n        return m;\n    },\n\n    hasStateAssociatedWithOneAlt: function(configs) {\n        const values = PredictionMode.getStateToAltMap(configs).values();\n        for(let i=0;i<values.length;i++) {\n            if (values[i].length===1) {\n                return true;\n            }\n        }\n        return false;\n    },\n\n    getSingleViableAlt: function(altsets) {\n        let result = null;\n        for(let i=0;i<altsets.length;i++) {\n            const alts = altsets[i];\n            const minAlt = alts.minValue();\n            if(result===null) {\n                result = minAlt;\n            } else if(result!==minAlt) { // more than 1 viable alt\n                return ATN.INVALID_ALT_NUMBER;\n            }\n        }\n        return result;\n    }\n};\n\nmodule.exports = PredictionMode;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst { Set, Hash, equalArrays } = require('./../Utils');\n\n/**\n * A tree structure used to record the semantic context in which\n * an ATN configuration is valid.  It's either a single predicate,\n * a conjunction {@code p1&&p2}, or a sum of products {@code p1||p2}.\n *\n * <p>I have scoped the {@link AND}, {@link OR}, and {@link Predicate} subclasses of\n * {@link SemanticContext} within the scope of this outer class.</p>\n */\nclass SemanticContext {\n\n\thashCode() {\n\t\tconst hash = new Hash();\n\t\tthis.updateHashCode(hash);\n\t\treturn hash.finish();\n\t}\n\n\t/**\n\t * For context independent predicates, we evaluate them without a local\n\t * context (i.e., null context). That way, we can evaluate them without\n\t * having to create proper rule-specific context during prediction (as\n\t * opposed to the parser, which creates them naturally). In a practical\n\t * sense, this avoids a cast exception from RuleContext to myruleContext.\n\t *\n\t * <p>For context dependent predicates, we must pass in a local context so that\n\t * references such as $arg evaluate properly as _localctx.arg. We only\n\t * capture context dependent predicates in the context in which we begin\n\t * prediction, so we passed in the outer context here in case of context\n\t * dependent predicate evaluation.</p>\n\t */\n\tevaluate(parser, outerContext) {}\n\n\t/**\n\t * Evaluate the precedence predicates for the context and reduce the result.\n\t *\n\t * @param parser The parser instance.\n\t * @param outerContext The current parser context object.\n\t * @return The simplified semantic context after precedence predicates are\n\t * evaluated, which will be one of the following values.\n\t * <ul>\n\t * <li>{@link //NONE}: if the predicate simplifies to {@code true} after\n\t * precedence predicates are evaluated.</li>\n\t * <li>{@code null}: if the predicate simplifies to {@code false} after\n\t * precedence predicates are evaluated.</li>\n\t * <li>{@code this}: if the semantic context is not changed as a result of\n\t * precedence predicate evaluation.</li>\n\t * <li>A non-{@code null} {@link SemanticContext}: the new simplified\n\t * semantic context after precedence predicates are evaluated.</li>\n\t * </ul>\n\t */\n\tevalPrecedence(parser, outerContext) {\n\t\treturn this;\n\t}\n\n\tstatic andContext(a, b) {\n\t\tif (a === null || a === SemanticContext.NONE) {\n\t\t\treturn b;\n\t\t}\n\t\tif (b === null || b === SemanticContext.NONE) {\n\t\t\treturn a;\n\t\t}\n\t\tconst result = new AND(a, b);\n\t\tif (result.opnds.length === 1) {\n\t\t\treturn result.opnds[0];\n\t\t} else {\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tstatic orContext(a, b) {\n\t\tif (a === null) {\n\t\t\treturn b;\n\t\t}\n\t\tif (b === null) {\n\t\t\treturn a;\n\t\t}\n\t\tif (a === SemanticContext.NONE || b === SemanticContext.NONE) {\n\t\t\treturn SemanticContext.NONE;\n\t\t}\n\t\tconst result = new OR(a, b);\n\t\tif (result.opnds.length === 1) {\n\t\t\treturn result.opnds[0];\n\t\t} else {\n\t\t\treturn result;\n\t\t}\n\t}\n}\n\n\nclass Predicate extends SemanticContext {\n\n\tconstructor(ruleIndex, predIndex, isCtxDependent) {\n\t\tsuper();\n\t\tthis.ruleIndex = ruleIndex === undefined ? -1 : ruleIndex;\n\t\tthis.predIndex = predIndex === undefined ? -1 : predIndex;\n\t\tthis.isCtxDependent = isCtxDependent === undefined ? false : isCtxDependent; // e.g., $i ref in pred\n\t}\n\n\tevaluate(parser, outerContext) {\n\t\tconst localctx = this.isCtxDependent ? outerContext : null;\n\t\treturn parser.sempred(localctx, this.ruleIndex, this.predIndex);\n\t}\n\n\tupdateHashCode(hash) {\n\t\thash.update(this.ruleIndex, this.predIndex, this.isCtxDependent);\n\t}\n\n\tequals(other) {\n\t\tif (this === other) {\n\t\t\treturn true;\n\t\t} else if (!(other instanceof Predicate)) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn this.ruleIndex === other.ruleIndex &&\n\t\t\t\t\tthis.predIndex === other.predIndex &&\n\t\t\t\t\tthis.isCtxDependent === other.isCtxDependent;\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn \"{\" + this.ruleIndex + \":\" + this.predIndex + \"}?\";\n\t}\n}\n\n/**\n * The default {@link SemanticContext}, which is semantically equivalent to\n * a predicate of the form {@code {true}?}\n */\nSemanticContext.NONE = new Predicate();\n\n\nclass PrecedencePredicate extends SemanticContext {\n\n\tconstructor(precedence) {\n\t\tsuper();\n\t\tthis.precedence = precedence === undefined ? 0 : precedence;\n\t}\n\n\tevaluate(parser, outerContext) {\n\t\treturn parser.precpred(outerContext, this.precedence);\n\t}\n\n\tevalPrecedence(parser, outerContext) {\n\t\tif (parser.precpred(outerContext, this.precedence)) {\n\t\t\treturn SemanticContext.NONE;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tcompareTo(other) {\n\t\treturn this.precedence - other.precedence;\n\t}\n\n\tupdateHashCode(hash) {\n\t\thash.update(this.precedence);\n\t}\n\n\tequals(other) {\n\t\tif (this === other) {\n\t\t\treturn true;\n\t\t} else if (!(other instanceof PrecedencePredicate)) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn this.precedence === other.precedence;\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn \"{\" + this.precedence + \">=prec}?\";\n\t}\n\n\tstatic filterPrecedencePredicates(set) {\n\t\tconst result = [];\n\t\tset.values().map( function(context) {\n\t\t\tif (context instanceof PrecedencePredicate) {\n\t\t\t\tresult.push(context);\n\t\t\t}\n\t\t});\n\t\treturn result;\n\t}\n}\n\nclass AND extends SemanticContext {\n\t/**\n\t * A semantic context which is true whenever none of the contained contexts\n\t * is false\n\t */\n\tconstructor(a, b) {\n\t\tsuper();\n\t\tconst operands = new Set();\n\t\tif (a instanceof AND) {\n\t\t\ta.opnds.map(function(o) {\n\t\t\t\toperands.add(o);\n\t\t\t});\n\t\t} else {\n\t\t\toperands.add(a);\n\t\t}\n\t\tif (b instanceof AND) {\n\t\t\tb.opnds.map(function(o) {\n\t\t\t\toperands.add(o);\n\t\t\t});\n\t\t} else {\n\t\t\toperands.add(b);\n\t\t}\n\t\tconst precedencePredicates = PrecedencePredicate.filterPrecedencePredicates(operands);\n\t\tif (precedencePredicates.length > 0) {\n\t\t\t// interested in the transition with the lowest precedence\n\t\t\tlet reduced = null;\n\t\t\tprecedencePredicates.map( function(p) {\n\t\t\t\tif(reduced===null || p.precedence<reduced.precedence) {\n\t\t\t\t\treduced = p;\n\t\t\t\t}\n\t\t\t});\n\t\t\toperands.add(reduced);\n\t\t}\n\t\tthis.opnds = Array.from(operands.values());\n\t}\n\n\tequals(other) {\n\t\tif (this === other) {\n\t\t\treturn true;\n\t\t} else if (!(other instanceof AND)) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn equalArrays(this.opnds, other.opnds);\n\t\t}\n\t}\n\n\tupdateHashCode(hash) {\n\t\thash.update(this.opnds, \"AND\");\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t *\n\t * <p>\n\t * The evaluation of predicates by this context is short-circuiting, but\n\t * unordered.</p>\n\t */\n\tevaluate(parser, outerContext) {\n\t\tfor (let i = 0; i < this.opnds.length; i++) {\n\t\t\tif (!this.opnds[i].evaluate(parser, outerContext)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tevalPrecedence(parser, outerContext) {\n\t\tlet differs = false;\n\t\tconst operands = [];\n\t\tfor (let i = 0; i < this.opnds.length; i++) {\n\t\t\tconst context = this.opnds[i];\n\t\t\tconst evaluated = context.evalPrecedence(parser, outerContext);\n\t\t\tdiffers |= (evaluated !== context);\n\t\t\tif (evaluated === null) {\n\t\t\t\t// The AND context is false if any element is false\n\t\t\t\treturn null;\n\t\t\t} else if (evaluated !== SemanticContext.NONE) {\n\t\t\t\t// Reduce the result by skipping true elements\n\t\t\t\toperands.push(evaluated);\n\t\t\t}\n\t\t}\n\t\tif (!differs) {\n\t\t\treturn this;\n\t\t}\n\t\tif (operands.length === 0) {\n\t\t\t// all elements were true, so the AND context is true\n\t\t\treturn SemanticContext.NONE;\n\t\t}\n\t\tlet result = null;\n\t\toperands.map(function(o) {\n\t\t\tresult = result === null ? o : SemanticContext.andContext(result, o);\n\t\t});\n\t\treturn result;\n\t}\n\n\ttoString() {\n\t\tconst s = this.opnds.map(o => o.toString());\n\t\treturn (s.length > 3 ? s.slice(3) : s).join(\"&&\");\n\t}\n}\n\n\nclass OR extends SemanticContext {\n\t/**\n\t * A semantic context which is true whenever at least one of the contained\n\t * contexts is true\n\t */\n\tconstructor(a, b) {\n\t\tsuper();\n\t\tconst operands = new Set();\n\t\tif (a instanceof OR) {\n\t\t\ta.opnds.map(function(o) {\n\t\t\t\toperands.add(o);\n\t\t\t});\n\t\t} else {\n\t\t\toperands.add(a);\n\t\t}\n\t\tif (b instanceof OR) {\n\t\t\tb.opnds.map(function(o) {\n\t\t\t\toperands.add(o);\n\t\t\t});\n\t\t} else {\n\t\t\toperands.add(b);\n\t\t}\n\n\t\tconst precedencePredicates = PrecedencePredicate.filterPrecedencePredicates(operands);\n\t\tif (precedencePredicates.length > 0) {\n\t\t\t// interested in the transition with the highest precedence\n\t\t\tconst s = precedencePredicates.sort(function(a, b) {\n\t\t\t\treturn a.compareTo(b);\n\t\t\t});\n\t\t\tconst reduced = s[s.length-1];\n\t\t\toperands.add(reduced);\n\t\t}\n\t\tthis.opnds = Array.from(operands.values());\n\t}\n\n\tequals(other) {\n\t\tif (this === other) {\n\t\t\treturn true;\n\t\t} else if (!(other instanceof OR)) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn equalArrays(this.opnds, other.opnds);\n\t\t}\n\t}\n\n\tupdateHashCode(hash) {\n\t\thash.update(this.opnds, \"OR\");\n\t}\n\n\t/**\n\t * <p>\n\t * The evaluation of predicates by this context is short-circuiting, but\n\t * unordered.</p>\n\t */\n\tevaluate(parser, outerContext) {\n\t\tfor (let i = 0; i < this.opnds.length; i++) {\n\t\t\tif (this.opnds[i].evaluate(parser, outerContext)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tevalPrecedence(parser, outerContext) {\n\t\tlet differs = false;\n\t\tconst operands = [];\n\t\tfor (let i = 0; i < this.opnds.length; i++) {\n\t\t\tconst context = this.opnds[i];\n\t\t\tconst evaluated = context.evalPrecedence(parser, outerContext);\n\t\t\tdiffers |= (evaluated !== context);\n\t\t\tif (evaluated === SemanticContext.NONE) {\n\t\t\t\t// The OR context is true if any element is true\n\t\t\t\treturn SemanticContext.NONE;\n\t\t\t} else if (evaluated !== null) {\n\t\t\t\t// Reduce the result by skipping false elements\n\t\t\t\toperands.push(evaluated);\n\t\t\t}\n\t\t}\n\t\tif (!differs) {\n\t\t\treturn this;\n\t\t}\n\t\tif (operands.length === 0) {\n\t\t\t// all elements were false, so the OR context is false\n\t\t\treturn null;\n\t\t}\n\t\tconst result = null;\n\t\toperands.map(function(o) {\n\t\t\treturn result === null ? o : SemanticContext.orContext(result, o);\n\t\t});\n\t\treturn result;\n\t}\n\n\ttoString() {\n\t\tconst s = this.opnds.map(o => o.toString());\n\t\treturn (s.length > 3 ? s.slice(3) : s).join(\"||\");\n\t}\n}\n\nmodule.exports = {\n\tSemanticContext,\n\tPrecedencePredicate,\n\tPredicate\n}\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Token} = require('./../Token');\nconst {IntervalSet} = require('./../IntervalSet');\nconst {Predicate, PrecedencePredicate} = require('./SemanticContext');\n\n/**\n * An ATN transition between any two ATN states.  Subclasses define\n * atom, set, epsilon, action, predicate, rule transitions.\n *\n * <p>This is a one way link.  It emanates from a state (usually via a list of\n * transitions) and has a target state.</p>\n *\n * <p>Since we never have to change the ATN transitions once we construct it,\n * we can fix these transitions as specific classes. The DFA transitions\n * on the other hand need to update the labels as it adds transitions to\n * the states. We'll use the term Edge for the DFA to distinguish them from\n * ATN transitions.</p>\n */\nclass Transition {\n    constructor(target) {\n        // The target of this transition.\n        if (target===undefined || target===null) {\n            throw \"target cannot be null.\";\n        }\n        this.target = target;\n        // Are we epsilon, action, sempred?\n        this.isEpsilon = false;\n        this.label = null;\n    }\n}\n\n// constants for serialization\n\nTransition.EPSILON = 1;\nTransition.RANGE = 2;\nTransition.RULE = 3;\n// e.g., {isType(input.LT(1))}?\nTransition.PREDICATE = 4;\nTransition.ATOM = 5;\nTransition.ACTION = 6;\n// ~(A|B) or ~atom, wildcard, which convert to next 2\nTransition.SET = 7;\nTransition.NOT_SET = 8;\nTransition.WILDCARD = 9;\nTransition.PRECEDENCE = 10;\n\nTransition.serializationNames = [\n            \"INVALID\",\n            \"EPSILON\",\n            \"RANGE\",\n            \"RULE\",\n            \"PREDICATE\",\n            \"ATOM\",\n            \"ACTION\",\n            \"SET\",\n            \"NOT_SET\",\n            \"WILDCARD\",\n            \"PRECEDENCE\"\n        ];\n\nTransition.serializationTypes = {\n        EpsilonTransition: Transition.EPSILON,\n        RangeTransition: Transition.RANGE,\n        RuleTransition: Transition.RULE,\n        PredicateTransition: Transition.PREDICATE,\n        AtomTransition: Transition.ATOM,\n        ActionTransition: Transition.ACTION,\n        SetTransition: Transition.SET,\n        NotSetTransition: Transition.NOT_SET,\n        WildcardTransition: Transition.WILDCARD,\n        PrecedencePredicateTransition: Transition.PRECEDENCE\n    };\n\n\n// TODO: make all transitions sets? no, should remove set edges\n\nclass AtomTransition extends Transition {\n    constructor(target, label) {\n        super(target);\n        // The token type or character value; or, signifies special label.\n        this.label_ = label;\n        this.label = this.makeLabel();\n        this.serializationType = Transition.ATOM;\n    }\n\n    makeLabel() {\n        const s = new IntervalSet();\n        s.addOne(this.label_);\n        return s;\n    }\n\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n        return this.label_ === symbol;\n    }\n\n    toString() {\n        return this.label_;\n    }\n}\n\n\nclass RuleTransition extends Transition {\n    constructor(ruleStart, ruleIndex, precedence, followState) {\n        super(ruleStart);\n        // ptr to the rule definition object for this rule ref\n        this.ruleIndex = ruleIndex;\n        this.precedence = precedence;\n        // what node to begin computations following ref to rule\n        this.followState = followState;\n        this.serializationType = Transition.RULE;\n        this.isEpsilon = true;\n    }\n\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n        return false;\n    }\n}\n\nclass EpsilonTransition extends Transition {\n    constructor(target, outermostPrecedenceReturn) {\n        super(target);\n        this.serializationType = Transition.EPSILON;\n        this.isEpsilon = true;\n        this.outermostPrecedenceReturn = outermostPrecedenceReturn;\n    }\n\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n        return false;\n    }\n\n    toString() {\n        return \"epsilon\";\n    }\n}\n\n\nclass RangeTransition extends Transition {\n    constructor(target, start, stop) {\n        super(target);\n        this.serializationType = Transition.RANGE;\n        this.start = start;\n        this.stop = stop;\n        this.label = this.makeLabel();\n    }\n\n    makeLabel() {\n        const s = new IntervalSet();\n        s.addRange(this.start, this.stop);\n        return s;\n    }\n\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n        return symbol >= this.start && symbol <= this.stop;\n    }\n\n    toString() {\n        return \"'\" + String.fromCharCode(this.start) + \"'..'\" + String.fromCharCode(this.stop) + \"'\";\n    }\n}\n\n\nclass AbstractPredicateTransition extends Transition {\n    constructor(target) {\n        super(target);\n    }\n}\n\nclass PredicateTransition extends AbstractPredicateTransition {\n    constructor(target, ruleIndex, predIndex, isCtxDependent) {\n        super(target);\n        this.serializationType = Transition.PREDICATE;\n        this.ruleIndex = ruleIndex;\n        this.predIndex = predIndex;\n        this.isCtxDependent = isCtxDependent; // e.g., $i ref in pred\n        this.isEpsilon = true;\n    }\n\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n        return false;\n    }\n\n    getPredicate() {\n        return new Predicate(this.ruleIndex, this.predIndex, this.isCtxDependent);\n    }\n\n    toString() {\n        return \"pred_\" + this.ruleIndex + \":\" + this.predIndex;\n    }\n}\n\n\nclass ActionTransition extends Transition {\n    constructor(target, ruleIndex, actionIndex, isCtxDependent) {\n        super(target);\n        this.serializationType = Transition.ACTION;\n        this.ruleIndex = ruleIndex;\n        this.actionIndex = actionIndex===undefined ? -1 : actionIndex;\n        this.isCtxDependent = isCtxDependent===undefined ? false : isCtxDependent; // e.g., $i ref in pred\n        this.isEpsilon = true;\n    }\n\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n        return false;\n    }\n\n    toString() {\n        return \"action_\" + this.ruleIndex + \":\" + this.actionIndex;\n    }\n}\n\n\n// A transition containing a set of values.\nclass SetTransition extends Transition {\n    constructor(target, set) {\n        super(target);\n        this.serializationType = Transition.SET;\n        if (set !==undefined && set !==null) {\n            this.label = set;\n        } else {\n            this.label = new IntervalSet();\n            this.label.addOne(Token.INVALID_TYPE);\n        }\n    }\n\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n        return this.label.contains(symbol);\n    }\n\n    toString() {\n        return this.label.toString();\n    }\n}\n\nclass NotSetTransition extends SetTransition {\n    constructor(target, set) {\n        super(target, set);\n        this.serializationType = Transition.NOT_SET;\n    }\n\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n        return symbol >= minVocabSymbol && symbol <= maxVocabSymbol &&\n                !super.matches(symbol, minVocabSymbol, maxVocabSymbol);\n    }\n\n    toString() {\n        return '~' + super.toString();\n    }\n}\n\nclass WildcardTransition extends Transition {\n    constructor(target) {\n        super(target);\n        this.serializationType = Transition.WILDCARD;\n    }\n\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n        return symbol >= minVocabSymbol && symbol <= maxVocabSymbol;\n    }\n\n    toString() {\n        return \".\";\n    }\n}\n\nclass PrecedencePredicateTransition extends AbstractPredicateTransition {\n    constructor(target, precedence) {\n        super(target);\n        this.serializationType = Transition.PRECEDENCE;\n        this.precedence = precedence;\n        this.isEpsilon = true;\n    }\n\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n        return false;\n    }\n\n    getPredicate() {\n        return new PrecedencePredicate(this.precedence);\n    }\n\n    toString() {\n        return this.precedence + \" >= _p\";\n    }\n}\n\nmodule.exports = {\n    Transition,\n    AtomTransition,\n    SetTransition,\n    NotSetTransition,\n    RuleTransition,\n    ActionTransition,\n    EpsilonTransition,\n    RangeTransition,\n    WildcardTransition,\n    PredicateTransition,\n    PrecedencePredicateTransition,\n    AbstractPredicateTransition\n}\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nexports.ATN = require('./ATN');\nexports.ATNDeserializer = require('./ATNDeserializer');\nexports.LexerATNSimulator = require('./LexerATNSimulator');\nexports.ParserATNSimulator = require('./ParserATNSimulator');\nexports.PredictionMode = require('./PredictionMode');\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Set} = require(\"../Utils\");\nconst {DFAState} = require('./DFAState');\nconst {StarLoopEntryState} = require('../atn/ATNState');\nconst {ATNConfigSet} = require('./../atn/ATNConfigSet');\nconst {DFASerializer} = require('./DFASerializer');\nconst {LexerDFASerializer} = require('./DFASerializer');\n\nclass DFA {\n\tconstructor(atnStartState, decision) {\n\t\tif (decision === undefined) {\n\t\t\tdecision = 0;\n\t\t}\n\t\t/**\n\t\t * From which ATN state did we create this DFA?\n\t\t */\n\t\tthis.atnStartState = atnStartState;\n\t\tthis.decision = decision;\n\t\t/**\n\t\t * A set of all DFA states. Use {@link Map} so we can get old state back\n\t\t * ({@link Set} only allows you to see if it's there).\n\t\t */\n\t\tthis._states = new Set();\n\t\tthis.s0 = null;\n\t\t/**\n\t\t * {@code true} if this DFA is for a precedence decision; otherwise,\n\t\t * {@code false}. This is the backing field for {@link //isPrecedenceDfa},\n\t\t * {@link //setPrecedenceDfa}\n\t\t */\n\t\tthis.precedenceDfa = false;\n\t\tif (atnStartState instanceof StarLoopEntryState)\n\t\t{\n\t\t\tif (atnStartState.isPrecedenceDecision) {\n\t\t\t\tthis.precedenceDfa = true;\n\t\t\t\tconst precedenceState = new DFAState(null, new ATNConfigSet());\n\t\t\t\tprecedenceState.edges = [];\n\t\t\t\tprecedenceState.isAcceptState = false;\n\t\t\t\tprecedenceState.requiresFullContext = false;\n\t\t\t\tthis.s0 = precedenceState;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get the start state for a specific precedence value.\n\t *\n\t * @param precedence The current precedence.\n\t * @return The start state corresponding to the specified precedence, or\n\t * {@code null} if no start state exists for the specified precedence.\n\t *\n\t * @throws IllegalStateException if this is not a precedence DFA.\n\t * @see //isPrecedenceDfa()\n\t */\n\tgetPrecedenceStartState(precedence) {\n\t\tif (!(this.precedenceDfa)) {\n\t\t\tthrow (\"Only precedence DFAs may contain a precedence start state.\");\n\t\t}\n\t\t// s0.edges is never null for a precedence DFA\n\t\tif (precedence < 0 || precedence >= this.s0.edges.length) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this.s0.edges[precedence] || null;\n\t}\n\n\t/**\n\t * Set the start state for a specific precedence value.\n\t *\n\t * @param precedence The current precedence.\n\t * @param startState The start state corresponding to the specified\n\t * precedence.\n\t *\n\t * @throws IllegalStateException if this is not a precedence DFA.\n\t * @see //isPrecedenceDfa()\n\t */\n\tsetPrecedenceStartState(precedence, startState) {\n\t\tif (!(this.precedenceDfa)) {\n\t\t\tthrow (\"Only precedence DFAs may contain a precedence start state.\");\n\t\t}\n\t\tif (precedence < 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t/**\n\t\t * synchronization on s0 here is ok. when the DFA is turned into a\n\t\t * precedence DFA, s0 will be initialized once and not updated again\n\t\t * s0.edges is never null for a precedence DFA\n\t\t */\n\t\tthis.s0.edges[precedence] = startState;\n\t}\n\n\t/**\n\t * Sets whether this is a precedence DFA. If the specified value differs\n\t * from the current DFA configuration, the following actions are taken;\n\t * otherwise no changes are made to the current DFA.\n\t *\n\t * <ul>\n\t * <li>The {@link //states} map is cleared</li>\n\t * <li>If {@code precedenceDfa} is {@code false}, the initial state\n\t * {@link //s0} is set to {@code null}; otherwise, it is initialized to a new\n\t * {@link DFAState} with an empty outgoing {@link DFAState//edges} array to\n\t * store the start states for individual precedence values.</li>\n\t * <li>The {@link //precedenceDfa} field is updated</li>\n\t * </ul>\n\t *\n\t * @param precedenceDfa {@code true} if this is a precedence DFA; otherwise,\n\t * {@code false}\n\t */\n\tsetPrecedenceDfa(precedenceDfa) {\n\t\tif (this.precedenceDfa!==precedenceDfa) {\n\t\t\tthis._states = new Set();\n\t\t\tif (precedenceDfa) {\n\t\t\t\tconst precedenceState = new DFAState(null, new ATNConfigSet());\n\t\t\t\tprecedenceState.edges = [];\n\t\t\t\tprecedenceState.isAcceptState = false;\n\t\t\t\tprecedenceState.requiresFullContext = false;\n\t\t\t\tthis.s0 = precedenceState;\n\t\t\t} else {\n\t\t\t\tthis.s0 = null;\n\t\t\t}\n\t\t\tthis.precedenceDfa = precedenceDfa;\n\t\t}\n\t}\n\n\t/**\n\t * Return a list of all states in this DFA, ordered by state number.\n\t */\n\tsortedStates() {\n\t\tconst list = this._states.values();\n\t\treturn list.sort(function(a, b) {\n\t\t\treturn a.stateNumber - b.stateNumber;\n\t\t});\n\t}\n\n\ttoString(literalNames, symbolicNames) {\n\t\tliteralNames = literalNames || null;\n\t\tsymbolicNames = symbolicNames || null;\n\t\tif (this.s0 === null) {\n\t\t\treturn \"\";\n\t\t}\n\t\tconst serializer = new DFASerializer(this, literalNames, symbolicNames);\n\t\treturn serializer.toString();\n\t}\n\n\ttoLexerString() {\n\t\tif (this.s0 === null) {\n\t\t\treturn \"\";\n\t\t}\n\t\tconst serializer = new LexerDFASerializer(this);\n\t\treturn serializer.toString();\n\t}\n\n\tget states(){\n\t\treturn this._states;\n\t}\n}\n\n\nmodule.exports = DFA;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\nconst Utils = require('./../Utils');\n\n/**\n * A DFA walker that knows how to dump them to serialized strings.\n */\nclass DFASerializer {\n    constructor(dfa, literalNames, symbolicNames) {\n        this.dfa = dfa;\n        this.literalNames = literalNames || [];\n        this.symbolicNames = symbolicNames || [];\n    }\n\n    toString() {\n       if(this.dfa.s0 === null) {\n           return null;\n       }\n       let buf = \"\";\n       const states = this.dfa.sortedStates();\n       for(let i=0; i<states.length; i++) {\n           const s = states[i];\n           if(s.edges!==null) {\n                const n = s.edges.length;\n                for(let j=0;j<n;j++) {\n                    const t = s.edges[j] || null;\n                    if(t!==null && t.stateNumber !== 0x7FFFFFFF) {\n                        buf = buf.concat(this.getStateString(s));\n                        buf = buf.concat(\"-\");\n                        buf = buf.concat(this.getEdgeLabel(j));\n                        buf = buf.concat(\"->\");\n                        buf = buf.concat(this.getStateString(t));\n                        buf = buf.concat('\\n');\n                    }\n                }\n           }\n       }\n       return buf.length===0 ? null : buf;\n    }\n\n    getEdgeLabel(i) {\n        if (i===0) {\n            return \"EOF\";\n        } else if(this.literalNames !==null || this.symbolicNames!==null) {\n            return this.literalNames[i-1] || this.symbolicNames[i-1];\n        } else {\n            return String.fromCharCode(i-1);\n        }\n    }\n\n    getStateString(s) {\n        const baseStateStr = ( s.isAcceptState ? \":\" : \"\") + \"s\" + s.stateNumber + ( s.requiresFullContext ? \"^\" : \"\");\n        if(s.isAcceptState) {\n            if (s.predicates !== null) {\n                return baseStateStr + \"=>\" + Utils.arrayToString(s.predicates);\n            } else {\n                return baseStateStr + \"=>\" + s.prediction.toString();\n            }\n        } else {\n            return baseStateStr;\n        }\n    }\n}\n\nclass LexerDFASerializer extends DFASerializer {\n    constructor(dfa) {\n        super(dfa, null);\n    }\n\n    getEdgeLabel(i) {\n        return \"'\" + String.fromCharCode(i) + \"'\";\n    }\n}\n\nmodule.exports = { DFASerializer , LexerDFASerializer };\n\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {ATNConfigSet} = require('./../atn/ATNConfigSet');\nconst {Hash, Set} = require('./../Utils');\n\n/**\n * Map a predicate to a predicted alternative.\n */\nclass PredPrediction {\n\tconstructor(pred, alt) {\n\t\tthis.alt = alt;\n\t\tthis.pred = pred;\n\t}\n\n\ttoString() {\n\t\treturn \"(\" + this.pred + \", \" + this.alt + \")\";\n\t}\n}\n\n/**\n * A DFA state represents a set of possible ATN configurations.\n * As Aho, Sethi, Ullman p. 117 says \"The DFA uses its state\n * to keep track of all possible states the ATN can be in after\n * reading each input symbol. That is to say, after reading\n * input a1a2..an, the DFA is in a state that represents the\n * subset T of the states of the ATN that are reachable from the\n * ATN's start state along some path labeled a1a2..an.\"\n * In conventional NFA&rarr;DFA conversion, therefore, the subset T\n * would be a bitset representing the set of states the\n * ATN could be in. We need to track the alt predicted by each\n * state as well, however. More importantly, we need to maintain\n * a stack of states, tracking the closure operations as they\n * jump from rule to rule, emulating rule invocations (method calls).\n * I have to add a stack to simulate the proper lookahead sequences for\n * the underlying LL grammar from which the ATN was derived.\n *\n * <p>I use a set of ATNConfig objects not simple states. An ATNConfig\n * is both a state (ala normal conversion) and a RuleContext describing\n * the chain of rules (if any) followed to arrive at that state.</p>\n *\n * <p>A DFA state may have multiple references to a particular state,\n * but with different ATN contexts (with same or different alts)\n * meaning that state was reached via a different set of rule invocations.</p>\n */\nclass DFAState {\n\tconstructor(stateNumber, configs) {\n\t\tif (stateNumber === null) {\n\t\t\tstateNumber = -1;\n\t\t}\n\t\tif (configs === null) {\n\t\t\tconfigs = new ATNConfigSet();\n\t\t}\n\t\tthis.stateNumber = stateNumber;\n\t\tthis.configs = configs;\n\t\t/**\n\t\t * {@code edges[symbol]} points to target of symbol. Shift up by 1 so (-1)\n\t\t * {@link Token//EOF} maps to {@code edges[0]}.\n\t\t */\n\t\tthis.edges = null;\n\t\tthis.isAcceptState = false;\n\t\t/**\n\t\t * if accept state, what ttype do we match or alt do we predict?\n\t\t * This is set to {@link ATN//INVALID_ALT_NUMBER} when {@link//predicates}\n\t\t * {@code !=null} or {@link //requiresFullContext}.\n\t\t */\n\t\tthis.prediction = 0;\n\t\tthis.lexerActionExecutor = null;\n\t\t/**\n\t\t * Indicates that this state was created during SLL prediction that\n\t\t * discovered a conflict between the configurations in the state. Future\n\t\t * {@link ParserATNSimulator//execATN} invocations immediately jumped doing\n\t\t * full context prediction if this field is true.\n\t\t */\n\t\tthis.requiresFullContext = false;\n\t\t/**\n\t\t * During SLL parsing, this is a list of predicates associated with the\n\t\t * ATN configurations of the DFA state. When we have predicates,\n\t\t * {@link //requiresFullContext} is {@code false} since full context\n\t\t * prediction evaluates predicates\n\t\t * on-the-fly. If this is not null, then {@link //prediction} is\n\t\t * {@link ATN//INVALID_ALT_NUMBER}.\n\t\t *\n\t\t * <p>We only use these for non-{@link //requiresFullContext} but\n\t\t * conflicting states. That\n\t\t * means we know from the context (it's $ or we don't dip into outer\n\t\t * context) that it's an ambiguity not a conflict.</p>\n\t\t *\n\t\t * <p>This list is computed by {@link\n\t\t * ParserATNSimulator//predicateDFAState}.</p>\n\t\t */\n\t\tthis.predicates = null;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the set of all alts mentioned by all ATN configurations in this\n\t * DFA state.\n\t */\n\tgetAltSet() {\n\t\tconst alts = new Set();\n\t\tif (this.configs !== null) {\n\t\t\tfor (let i = 0; i < this.configs.length; i++) {\n\t\t\t\tconst c = this.configs[i];\n\t\t\t\talts.add(c.alt);\n\t\t\t}\n\t\t}\n\t\tif (alts.length === 0) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\treturn alts;\n\t\t}\n\t}\n\n\t/**\n\t * Two {@link DFAState} instances are equal if their ATN configuration sets\n\t * are the same. This method is used to see if a state already exists.\n\t *\n\t * <p>Because the number of alternatives and number of ATN configurations are\n\t * finite, there is a finite number of DFA states that can be processed.\n\t * This is necessary to show that the algorithm terminates.</p>\n\t *\n\t * <p>Cannot test the DFA state numbers here because in\n\t * {@link ParserATNSimulator//addDFAState} we need to know if any other state\n\t * exists that has this exact set of ATN configurations. The\n\t * {@link //stateNumber} is irrelevant.</p>\n\t */\n\tequals(other) {\n\t\t// compare set of ATN configurations in this set with other\n\t\treturn this === other ||\n\t\t\t\t(other instanceof DFAState &&\n\t\t\t\t\tthis.configs.equals(other.configs));\n\t}\n\n\ttoString() {\n\t\tlet s = \"\" + this.stateNumber + \":\" + this.configs;\n\t\tif(this.isAcceptState) {\n\t\t\ts = s + \"=>\";\n\t\t\tif (this.predicates !== null)\n\t\t\t\ts = s + this.predicates;\n\t\t\telse\n\t\t\t\ts = s + this.prediction;\n\t\t}\n\t\treturn s;\n\t}\n\n\thashCode() {\n\t\tconst hash = new Hash();\n\t\thash.update(this.configs);\n\t\treturn hash.finish();\n\t}\n}\n\nmodule.exports = { DFAState, PredPrediction };\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nexports.DFA = require('./DFA');\nexports.DFASerializer = require('./DFASerializer').DFASerializer;\nexports.LexerDFASerializer = require('./DFASerializer').LexerDFASerializer;\nexports.PredPrediction = require('./DFAState').PredPrediction;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {BitSet} = require('./../Utils');\nconst {ErrorListener} = require('./ErrorListener')\nconst {Interval} = require('./../IntervalSet')\n\n\n/**\n * This implementation of {@link ANTLRErrorListener} can be used to identify\n *  certain potential correctness and performance problems in grammars. \"Reports\"\n *  are made by calling {@link Parser//notifyErrorListeners} with the appropriate\n *  message.\n *\n *  <ul>\n *  <li><b>Ambiguities</b>: These are cases where more than one path through the\n *  grammar can match the input.</li>\n *  <li><b>Weak context sensitivity</b>: These are cases where full-context\n *  prediction resolved an SLL conflict to a unique alternative which equaled the\n *  minimum alternative of the SLL conflict.</li>\n *  <li><b>Strong (forced) context sensitivity</b>: These are cases where the\n *  full-context prediction resolved an SLL conflict to a unique alternative,\n *  <em>and</em> the minimum alternative of the SLL conflict was found to not be\n *  a truly viable alternative. Two-stage parsing cannot be used for inputs where\n *  this situation occurs.</li>\n *  </ul>\n */\nclass DiagnosticErrorListener extends ErrorListener {\n\tconstructor(exactOnly) {\n\t\tsuper();\n\t\texactOnly = exactOnly || true;\n\t\t// whether all ambiguities or only exact ambiguities are reported.\n\t\tthis.exactOnly = exactOnly;\n\t}\n\n\treportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {\n\t\tif (this.exactOnly && !exact) {\n\t\t\treturn;\n\t\t}\n\t\tconst msg = \"reportAmbiguity d=\" +\n\t\t\tthis.getDecisionDescription(recognizer, dfa) +\n\t\t\t\": ambigAlts=\" +\n\t\t\tthis.getConflictingAlts(ambigAlts, configs) +\n\t\t\t\", input='\" +\n\t\t\trecognizer.getTokenStream().getText(new Interval(startIndex, stopIndex)) + \"'\"\n\t\trecognizer.notifyErrorListeners(msg);\n\t}\n\n\treportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {\n\t\tconst msg = \"reportAttemptingFullContext d=\" +\n\t\t\tthis.getDecisionDescription(recognizer, dfa) +\n\t\t\t\", input='\" +\n\t\t\trecognizer.getTokenStream().getText(new Interval(startIndex, stopIndex)) + \"'\"\n\t\trecognizer.notifyErrorListeners(msg);\n\t}\n\n\treportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs) {\n\t\tconst msg = \"reportContextSensitivity d=\" +\n\t\t\tthis.getDecisionDescription(recognizer, dfa) +\n\t\t\t\", input='\" +\n\t\t\trecognizer.getTokenStream().getText(new Interval(startIndex, stopIndex)) + \"'\"\n\t\trecognizer.notifyErrorListeners(msg);\n\t}\n\n\tgetDecisionDescription(recognizer, dfa) {\n\t\tconst decision = dfa.decision\n\t\tconst ruleIndex = dfa.atnStartState.ruleIndex\n\n\t\tconst ruleNames = recognizer.ruleNames\n\t\tif (ruleIndex < 0 || ruleIndex >= ruleNames.length) {\n\t\t\treturn \"\" + decision;\n\t\t}\n\t\tconst ruleName = ruleNames[ruleIndex] || null\n\t\tif (ruleName === null || ruleName.length === 0) {\n\t\t\treturn \"\" + decision;\n\t\t}\n\t\treturn `${decision} (${ruleName})`;\n\t}\n\n\t/**\n\t * Computes the set of conflicting or ambiguous alternatives from a\n\t * configuration set, if that information was not already provided by the\n\t * parser.\n\t *\n\t * @param reportedAlts The set of conflicting or ambiguous alternatives, as\n\t * reported by the parser.\n\t * @param configs The conflicting or ambiguous configuration set.\n\t * @return Returns {@code reportedAlts} if it is not {@code null}, otherwise\n\t * returns the set of alternatives represented in {@code configs}.\n     */\n\tgetConflictingAlts(reportedAlts, configs) {\n\t\tif (reportedAlts !== null) {\n\t\t\treturn reportedAlts;\n\t\t}\n\t\tconst result = new BitSet()\n\t\tfor (let i = 0; i < configs.items.length; i++) {\n\t\t\tresult.add(configs.items[i].alt);\n\t\t}\n\t\treturn `{${result.values().join(\", \")}}`;\n\t}\n}\n\nmodule.exports = DiagnosticErrorListener\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\n/**\n * Provides an empty default implementation of {@link ANTLRErrorListener}. The\n * default implementation of each method does nothing, but can be overridden as\n * necessary.\n */\nclass ErrorListener {\n    syntaxError(recognizer, offendingSymbol, line, column, msg, e) {\n    }\n\n    reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {\n    }\n\n    reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {\n    }\n\n    reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs) {\n    }\n}\n\n/**\n * {@inheritDoc}\n *\n * <p>\n * This implementation prints messages to {@link System//err} containing the\n * values of {@code line}, {@code charPositionInLine}, and {@code msg} using\n * the following format.</p>\n *\n * <pre>\n * line <em>line</em>:<em>charPositionInLine</em> <em>msg</em>\n * </pre>\n *\n */\nclass ConsoleErrorListener extends ErrorListener {\n    constructor() {\n        super();\n    }\n\n    syntaxError(recognizer, offendingSymbol, line, column, msg, e) {\n        console.error(\"line \" + line + \":\" + column + \" \" + msg);\n    }\n}\n\n\n/**\n * Provides a default instance of {@link ConsoleErrorListener}.\n */\nConsoleErrorListener.INSTANCE = new ConsoleErrorListener();\n\nclass ProxyErrorListener extends ErrorListener {\n    constructor(delegates) {\n        super();\n        if (delegates===null) {\n            throw \"delegates\";\n        }\n        this.delegates = delegates;\n        return this;\n    }\n\n    syntaxError(recognizer, offendingSymbol, line, column, msg, e) {\n        this.delegates.map(d => d.syntaxError(recognizer, offendingSymbol, line, column, msg, e));\n    }\n\n    reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {\n        this.delegates.map(d => d.reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs));\n    }\n\n    reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {\n        this.delegates.map(d => d.reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs));\n    }\n\n    reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs) {\n        this.delegates.map(d => d.reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs));\n    }\n}\n\nmodule.exports = {ErrorListener, ConsoleErrorListener, ProxyErrorListener}\n\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Token} = require('./../Token')\nconst {NoViableAltException, InputMismatchException, FailedPredicateException, ParseCancellationException} = require('./Errors')\nconst {ATNState} = require('./../atn/ATNState')\nconst {Interval, IntervalSet} = require('./../IntervalSet')\n\nclass ErrorStrategy {\n\n    reset(recognizer) {\n    }\n\n    recoverInline(recognizer) {\n    }\n\n    recover(recognizer, e) {\n    }\n\n    sync(recognizer) {\n    }\n\n    inErrorRecoveryMode(recognizer) {\n    }\n\n    reportError(recognizer) {\n    }\n}\n\n\n/**\n * This is the default implementation of {@link ANTLRErrorStrategy} used for\n * error reporting and recovery in ANTLR parsers.\n*/\nclass DefaultErrorStrategy extends ErrorStrategy {\n    constructor() {\n        super();\n        /**\n         * Indicates whether the error strategy is currently \"recovering from an\n         * error\". This is used to suppress reporting multiple error messages while\n         * attempting to recover from a detected syntax error.\n         *\n         * @see //inErrorRecoveryMode\n         */\n        this.errorRecoveryMode = false;\n\n        /**\n         * The index into the input stream where the last error occurred.\n         * This is used to prevent infinite loops where an error is found\n         * but no token is consumed during recovery...another error is found,\n         * ad nauseum. This is a failsafe mechanism to guarantee that at least\n         * one token/tree node is consumed for two errors.\n         */\n        this.lastErrorIndex = -1;\n        this.lastErrorStates = null;\n        this.nextTokensContext = null;\n        this.nextTokenState = 0;\n    }\n\n    /**\n     * <p>The default implementation simply calls {@link //endErrorCondition} to\n     * ensure that the handler is not in error recovery mode.</p>\n    */\n    reset(recognizer) {\n        this.endErrorCondition(recognizer);\n    }\n\n    /**\n     * This method is called to enter error recovery mode when a recognition\n     * exception is reported.\n     *\n     * @param recognizer the parser instance\n    */\n    beginErrorCondition(recognizer) {\n        this.errorRecoveryMode = true;\n    }\n\n    inErrorRecoveryMode(recognizer) {\n        return this.errorRecoveryMode;\n    }\n\n    /**\n     * This method is called to leave error recovery mode after recovering from\n     * a recognition exception.\n     * @param recognizer\n     */\n    endErrorCondition(recognizer) {\n        this.errorRecoveryMode = false;\n        this.lastErrorStates = null;\n        this.lastErrorIndex = -1;\n    }\n\n    /**\n     * {@inheritDoc}\n     * <p>The default implementation simply calls {@link //endErrorCondition}.</p>\n     */\n    reportMatch(recognizer) {\n        this.endErrorCondition(recognizer);\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * <p>The default implementation returns immediately if the handler is already\n     * in error recovery mode. Otherwise, it calls {@link //beginErrorCondition}\n     * and dispatches the reporting task based on the runtime type of {@code e}\n     * according to the following table.</p>\n     *\n     * <ul>\n     * <li>{@link NoViableAltException}: Dispatches the call to\n     * {@link //reportNoViableAlternative}</li>\n     * <li>{@link InputMismatchException}: Dispatches the call to\n     * {@link //reportInputMismatch}</li>\n     * <li>{@link FailedPredicateException}: Dispatches the call to\n     * {@link //reportFailedPredicate}</li>\n     * <li>All other types: calls {@link Parser//notifyErrorListeners} to report\n     * the exception</li>\n     * </ul>\n     */\n    reportError(recognizer, e) {\n       // if we've already reported an error and have not matched a token\n       // yet successfully, don't report any errors.\n        if(this.inErrorRecoveryMode(recognizer)) {\n            return; // don't report spurious errors\n        }\n        this.beginErrorCondition(recognizer);\n        if ( e instanceof NoViableAltException ) {\n            this.reportNoViableAlternative(recognizer, e);\n        } else if ( e instanceof InputMismatchException ) {\n            this.reportInputMismatch(recognizer, e);\n        } else if ( e instanceof FailedPredicateException ) {\n            this.reportFailedPredicate(recognizer, e);\n        } else {\n            console.log(\"unknown recognition error type: \" + e.constructor.name);\n            console.log(e.stack);\n            recognizer.notifyErrorListeners(e.getOffendingToken(), e.getMessage(), e);\n        }\n    }\n\n    /**\n     *\n     * {@inheritDoc}\n     *\n     * <p>The default implementation resynchronizes the parser by consuming tokens\n     * until we find one in the resynchronization set--loosely the set of tokens\n     * that can follow the current rule.</p>\n     *\n     */\n    recover(recognizer, e) {\n        if (this.lastErrorIndex===recognizer.getInputStream().index &&\n            this.lastErrorStates !== null && this.lastErrorStates.indexOf(recognizer.state)>=0) {\n            // uh oh, another error at same token index and previously-visited\n            // state in ATN; must be a case where LT(1) is in the recovery\n            // token set so nothing got consumed. Consume a single token\n            // at least to prevent an infinite loop; this is a failsafe.\n            recognizer.consume();\n        }\n        this.lastErrorIndex = recognizer._input.index;\n        if (this.lastErrorStates === null) {\n            this.lastErrorStates = [];\n        }\n        this.lastErrorStates.push(recognizer.state);\n        const followSet = this.getErrorRecoverySet(recognizer)\n        this.consumeUntil(recognizer, followSet);\n    }\n\n    /**\n     * The default implementation of {@link ANTLRErrorStrategy//sync} makes sure\n     * that the current lookahead symbol is consistent with what were expecting\n     * at this point in the ATN. You can call this anytime but ANTLR only\n     * generates code to check before subrules/loops and each iteration.\n     *\n     * <p>Implements Jim Idle's magic sync mechanism in closures and optional\n     * subrules. E.g.,</p>\n     *\n     * <pre>\n     * a : sync ( stuff sync )* ;\n     * sync : {consume to what can follow sync} ;\n     * </pre>\n     *\n     * At the start of a sub rule upon error, {@link //sync} performs single\n     * token deletion, if possible. If it can't do that, it bails on the current\n     * rule and uses the default error recovery, which consumes until the\n     * resynchronization set of the current rule.\n     *\n     * <p>If the sub rule is optional ({@code (...)?}, {@code (...)*}, or block\n     * with an empty alternative), then the expected set includes what follows\n     * the subrule.</p>\n     *\n     * <p>During loop iteration, it consumes until it sees a token that can start a\n     * sub rule or what follows loop. Yes, that is pretty aggressive. We opt to\n     * stay in the loop as long as possible.</p>\n     *\n     * <p><strong>ORIGINS</strong></p>\n     *\n     * <p>Previous versions of ANTLR did a poor job of their recovery within loops.\n     * A single mismatch token or missing token would force the parser to bail\n     * out of the entire rules surrounding the loop. So, for rule</p>\n     *\n     * <pre>\n     * classDef : 'class' ID '{' member* '}'\n     * </pre>\n     *\n     * input with an extra token between members would force the parser to\n     * consume until it found the next class definition rather than the next\n     * member definition of the current class.\n     *\n     * <p>This functionality cost a little bit of effort because the parser has to\n     * compare token set at the start of the loop and at each iteration. If for\n     * some reason speed is suffering for you, you can turn off this\n     * functionality by simply overriding this method as a blank { }.</p>\n     *\n     */\n    sync(recognizer) {\n        // If already recovering, don't try to sync\n        if (this.inErrorRecoveryMode(recognizer)) {\n            return;\n        }\n        const s = recognizer._interp.atn.states[recognizer.state];\n        const la = recognizer.getTokenStream().LA(1);\n        // try cheaper subset first; might get lucky. seems to shave a wee bit off\n        const nextTokens = recognizer.atn.nextTokens(s);\n        if(nextTokens.contains(la)) {\n            this.nextTokensContext = null;\n            this.nextTokenState = ATNState.INVALID_STATE_NUMBER;\n            return;\n        } else if (nextTokens.contains(Token.EPSILON)) {\n            if(this.nextTokensContext === null) {\n                // It's possible the next token won't match information tracked\n                // by sync is restricted for performance.\n                this.nextTokensContext = recognizer._ctx;\n                this.nextTokensState = recognizer._stateNumber;\n            }\n            return;\n        }\n        switch (s.stateType) {\n        case ATNState.BLOCK_START:\n        case ATNState.STAR_BLOCK_START:\n        case ATNState.PLUS_BLOCK_START:\n        case ATNState.STAR_LOOP_ENTRY:\n           // report error and recover if possible\n            if( this.singleTokenDeletion(recognizer) !== null) {\n                return;\n            } else {\n                throw new InputMismatchException(recognizer);\n            }\n        case ATNState.PLUS_LOOP_BACK:\n        case ATNState.STAR_LOOP_BACK:\n            this.reportUnwantedToken(recognizer);\n            const expecting = new IntervalSet()\n            expecting.addSet(recognizer.getExpectedTokens());\n            const whatFollowsLoopIterationOrRule = expecting.addSet(this.getErrorRecoverySet(recognizer))\n            this.consumeUntil(recognizer, whatFollowsLoopIterationOrRule);\n            break;\n        default:\n            // do nothing if we can't identify the exact kind of ATN state\n        }\n    }\n\n    /**\n     * This is called by {@link //reportError} when the exception is a\n     * {@link NoViableAltException}.\n     *\n     * @see //reportError\n     *\n     * @param recognizer the parser instance\n     * @param e the recognition exception\n     */\n    reportNoViableAlternative(recognizer, e) {\n        const tokens = recognizer.getTokenStream()\n        let input\n        if(tokens !== null) {\n            if (e.startToken.type===Token.EOF) {\n                input = \"<EOF>\";\n            } else {\n                input = tokens.getText(new Interval(e.startToken.tokenIndex, e.offendingToken.tokenIndex));\n            }\n        } else {\n            input = \"<unknown input>\";\n        }\n        const msg = \"no viable alternative at input \" + this.escapeWSAndQuote(input)\n        recognizer.notifyErrorListeners(msg, e.offendingToken, e);\n    }\n\n    /**\n     * This is called by {@link //reportError} when the exception is an\n     * {@link InputMismatchException}.\n     *\n     * @see //reportError\n     *\n     * @param recognizer the parser instance\n     * @param e the recognition exception\n     */\n    reportInputMismatch(recognizer, e) {\n        const msg = \"mismatched input \" + this.getTokenErrorDisplay(e.offendingToken) +\n            \" expecting \" + e.getExpectedTokens().toString(recognizer.literalNames, recognizer.symbolicNames)\n        recognizer.notifyErrorListeners(msg, e.offendingToken, e);\n    }\n\n    /**\n     * This is called by {@link //reportError} when the exception is a\n     * {@link FailedPredicateException}.\n     *\n     * @see //reportError\n     *\n     * @param recognizer the parser instance\n     * @param e the recognition exception\n     */\n    reportFailedPredicate(recognizer, e) {\n        const ruleName = recognizer.ruleNames[recognizer._ctx.ruleIndex]\n        const msg = \"rule \" + ruleName + \" \" + e.message\n        recognizer.notifyErrorListeners(msg, e.offendingToken, e);\n    }\n\n    /**\n     * This method is called to report a syntax error which requires the removal\n     * of a token from the input stream. At the time this method is called, the\n     * erroneous symbol is current {@code LT(1)} symbol and has not yet been\n     * removed from the input stream. When this method returns,\n     * {@code recognizer} is in error recovery mode.\n     *\n     * <p>This method is called when {@link //singleTokenDeletion} identifies\n     * single-token deletion as a viable recovery strategy for a mismatched\n     * input error.</p>\n     *\n     * <p>The default implementation simply returns if the handler is already in\n     * error recovery mode. Otherwise, it calls {@link //beginErrorCondition} to\n     * enter error recovery mode, followed by calling\n     * {@link Parser//notifyErrorListeners}.</p>\n     *\n     * @param recognizer the parser instance\n     *\n     */\n    reportUnwantedToken(recognizer) {\n        if (this.inErrorRecoveryMode(recognizer)) {\n            return;\n        }\n        this.beginErrorCondition(recognizer);\n        const t = recognizer.getCurrentToken()\n        const tokenName = this.getTokenErrorDisplay(t)\n        const expecting = this.getExpectedTokens(recognizer)\n        const msg = \"extraneous input \" + tokenName + \" expecting \" +\n            expecting.toString(recognizer.literalNames, recognizer.symbolicNames)\n        recognizer.notifyErrorListeners(msg, t, null);\n    }\n\n    /**\n     * This method is called to report a syntax error which requires the\n     * insertion of a missing token into the input stream. At the time this\n     * method is called, the missing token has not yet been inserted. When this\n     * method returns, {@code recognizer} is in error recovery mode.\n     *\n     * <p>This method is called when {@link //singleTokenInsertion} identifies\n     * single-token insertion as a viable recovery strategy for a mismatched\n     * input error.</p>\n     *\n     * <p>The default implementation simply returns if the handler is already in\n     * error recovery mode. Otherwise, it calls {@link //beginErrorCondition} to\n     * enter error recovery mode, followed by calling\n     * {@link Parser//notifyErrorListeners}.</p>\n     *\n     * @param recognizer the parser instance\n     */\n    reportMissingToken(recognizer) {\n        if ( this.inErrorRecoveryMode(recognizer)) {\n            return;\n        }\n        this.beginErrorCondition(recognizer);\n        const t = recognizer.getCurrentToken()\n        const expecting = this.getExpectedTokens(recognizer)\n        const msg = \"missing \" + expecting.toString(recognizer.literalNames, recognizer.symbolicNames) +\n            \" at \" + this.getTokenErrorDisplay(t)\n        recognizer.notifyErrorListeners(msg, t, null);\n    }\n\n    /**\n     * <p>The default implementation attempts to recover from the mismatched input\n     * by using single token insertion and deletion as described below. If the\n     * recovery attempt fails, this method throws an\n     * {@link InputMismatchException}.</p>\n     *\n     * <p><strong>EXTRA TOKEN</strong> (single token deletion)</p>\n     *\n     * <p>{@code LA(1)} is not what we are looking for. If {@code LA(2)} has the\n     * right token, however, then assume {@code LA(1)} is some extra spurious\n     * token and delete it. Then consume and return the next token (which was\n     * the {@code LA(2)} token) as the successful result of the match operation.</p>\n     *\n     * <p>This recovery strategy is implemented by {@link\n     * //singleTokenDeletion}.</p>\n     *\n     * <p><strong>MISSING TOKEN</strong> (single token insertion)</p>\n     *\n     * <p>If current token (at {@code LA(1)}) is consistent with what could come\n     * after the expected {@code LA(1)} token, then assume the token is missing\n     * and use the parser's {@link TokenFactory} to create it on the fly. The\n     * \"insertion\" is performed by returning the created token as the successful\n     * result of the match operation.</p>\n     *\n     * <p>This recovery strategy is implemented by {@link\n     * //singleTokenInsertion}.</p>\n     *\n     * <p><strong>EXAMPLE</strong></p>\n     *\n     * <p>For example, Input {@code i=(3;} is clearly missing the {@code ')'}. When\n     * the parser returns from the nested call to {@code expr}, it will have\n     * call chain:</p>\n     *\n     * <pre>\n     * stat &rarr; expr &rarr; atom\n     * </pre>\n     *\n     * and it will be trying to match the {@code ')'} at this point in the\n     * derivation:\n     *\n     * <pre>\n     * =&gt; ID '=' '(' INT ')' ('+' atom)* ';'\n     * ^\n     * </pre>\n     *\n     * The attempt to match {@code ')'} will fail when it sees {@code ';'} and\n     * call {@link //recoverInline}. To recover, it sees that {@code LA(1)==';'}\n     * is in the set of tokens that can follow the {@code ')'} token reference\n     * in rule {@code atom}. It can assume that you forgot the {@code ')'}.\n     */\n    recoverInline(recognizer) {\n        // SINGLE TOKEN DELETION\n        const matchedSymbol = this.singleTokenDeletion(recognizer)\n        if (matchedSymbol !== null) {\n            // we have deleted the extra token.\n            // now, move past ttype token as if all were ok\n            recognizer.consume();\n            return matchedSymbol;\n        }\n        // SINGLE TOKEN INSERTION\n        if (this.singleTokenInsertion(recognizer)) {\n            return this.getMissingSymbol(recognizer);\n        }\n        // even that didn't work; must throw the exception\n        throw new InputMismatchException(recognizer);\n    }\n\n    /**\n     * This method implements the single-token insertion inline error recovery\n     * strategy. It is called by {@link //recoverInline} if the single-token\n     * deletion strategy fails to recover from the mismatched input. If this\n     * method returns {@code true}, {@code recognizer} will be in error recovery\n     * mode.\n     *\n     * <p>This method determines whether or not single-token insertion is viable by\n     * checking if the {@code LA(1)} input symbol could be successfully matched\n     * if it were instead the {@code LA(2)} symbol. If this method returns\n     * {@code true}, the caller is responsible for creating and inserting a\n     * token with the correct type to produce this behavior.</p>\n     *\n     * @param recognizer the parser instance\n     * @return {@code true} if single-token insertion is a viable recovery\n     * strategy for the current mismatched input, otherwise {@code false}\n     */\n    singleTokenInsertion(recognizer) {\n        const currentSymbolType = recognizer.getTokenStream().LA(1)\n        // if current token is consistent with what could come after current\n        // ATN state, then we know we're missing a token; error recovery\n        // is free to conjure up and insert the missing token\n        const atn = recognizer._interp.atn\n        const currentState = atn.states[recognizer.state]\n        const next = currentState.transitions[0].target\n        const expectingAtLL2 = atn.nextTokens(next, recognizer._ctx)\n        if (expectingAtLL2.contains(currentSymbolType) ){\n            this.reportMissingToken(recognizer);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * This method implements the single-token deletion inline error recovery\n     * strategy. It is called by {@link //recoverInline} to attempt to recover\n     * from mismatched input. If this method returns null, the parser and error\n     * handler state will not have changed. If this method returns non-null,\n     * {@code recognizer} will <em>not</em> be in error recovery mode since the\n     * returned token was a successful match.\n     *\n     * <p>If the single-token deletion is successful, this method calls\n     * {@link //reportUnwantedToken} to report the error, followed by\n     * {@link Parser//consume} to actually \"delete\" the extraneous token. Then,\n     * before returning {@link //reportMatch} is called to signal a successful\n     * match.</p>\n     *\n     * @param recognizer the parser instance\n     * @return the successfully matched {@link Token} instance if single-token\n     * deletion successfully recovers from the mismatched input, otherwise\n     * {@code null}\n     */\n    singleTokenDeletion(recognizer) {\n        const nextTokenType = recognizer.getTokenStream().LA(2)\n        const expecting = this.getExpectedTokens(recognizer)\n        if (expecting.contains(nextTokenType)) {\n            this.reportUnwantedToken(recognizer);\n            // print(\"recoverFromMismatchedToken deleting \" \\\n            // + str(recognizer.getTokenStream().LT(1)) \\\n            // + \" since \" + str(recognizer.getTokenStream().LT(2)) \\\n            // + \" is what we want\", file=sys.stderr)\n            recognizer.consume(); // simply delete extra token\n            // we want to return the token we're actually matching\n            const matchedSymbol = recognizer.getCurrentToken()\n            this.reportMatch(recognizer); // we know current token is correct\n            return matchedSymbol;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Conjure up a missing token during error recovery.\n     *\n     * The recognizer attempts to recover from single missing\n     * symbols. But, actions might refer to that missing symbol.\n     * For example, x=ID {f($x);}. The action clearly assumes\n     * that there has been an identifier matched previously and that\n     * $x points at that token. If that token is missing, but\n     * the next token in the stream is what we want we assume that\n     * this token is missing and we keep going. Because we\n     * have to return some token to replace the missing token,\n     * we have to conjure one up. This method gives the user control\n     * over the tokens returned for missing tokens. Mostly,\n     * you will want to create something special for identifier\n     * tokens. For literals such as '{' and ',', the default\n     * action in the parser or tree parser works. It simply creates\n     * a CommonToken of the appropriate type. The text will be the token.\n     * If you change what tokens must be created by the lexer,\n     * override this method to create the appropriate tokens.\n     *\n     */\n    getMissingSymbol(recognizer) {\n        const currentSymbol = recognizer.getCurrentToken()\n        const expecting = this.getExpectedTokens(recognizer)\n        const expectedTokenType = expecting.first() // get any element\n        let tokenText\n        if (expectedTokenType===Token.EOF) {\n            tokenText = \"<missing EOF>\";\n        } else {\n            tokenText = \"<missing \" + recognizer.literalNames[expectedTokenType] + \">\";\n        }\n        let current = currentSymbol\n        const lookback = recognizer.getTokenStream().LT(-1)\n        if (current.type===Token.EOF && lookback !== null) {\n            current = lookback;\n        }\n        return recognizer.getTokenFactory().create(current.source,\n            expectedTokenType, tokenText, Token.DEFAULT_CHANNEL,\n            -1, -1, current.line, current.column);\n    }\n\n    getExpectedTokens(recognizer) {\n        return recognizer.getExpectedTokens();\n    }\n\n    /**\n     * How should a token be displayed in an error message? The default\n     * is to display just the text, but during development you might\n     * want to have a lot of information spit out. Override in that case\n     * to use t.toString() (which, for CommonToken, dumps everything about\n     * the token). This is better than forcing you to override a method in\n     * your token objects because you don't have to go modify your lexer\n     * so that it creates a new Java type.\n     */\n    getTokenErrorDisplay(t) {\n        if (t === null) {\n            return \"<no token>\";\n        }\n        let s = t.text\n        if (s === null) {\n            if (t.type===Token.EOF) {\n                s = \"<EOF>\";\n            } else {\n                s = \"<\" + t.type + \">\";\n            }\n        }\n        return this.escapeWSAndQuote(s);\n    }\n\n    escapeWSAndQuote(s) {\n        s = s.replace(/\\n/g,\"\\\\n\");\n        s = s.replace(/\\r/g,\"\\\\r\");\n        s = s.replace(/\\t/g,\"\\\\t\");\n        return \"'\" + s + \"'\";\n    }\n\n    /**\n     * Compute the error recovery set for the current rule. During\n     * rule invocation, the parser pushes the set of tokens that can\n     * follow that rule reference on the stack; this amounts to\n     * computing FIRST of what follows the rule reference in the\n     * enclosing rule. See LinearApproximator.FIRST().\n     * This local follow set only includes tokens\n     * from within the rule; i.e., the FIRST computation done by\n     * ANTLR stops at the end of a rule.\n     *\n     * EXAMPLE\n     *\n     * When you find a \"no viable alt exception\", the input is not\n     * consistent with any of the alternatives for rule r. The best\n     * thing to do is to consume tokens until you see something that\n     * can legally follow a call to r//or* any rule that called r.\n     * You don't want the exact set of viable next tokens because the\n     * input might just be missing a token--you might consume the\n     * rest of the input looking for one of the missing tokens.\n     *\n     * Consider grammar:\n     *\n     * a : '[' b ']'\n     * | '(' b ')'\n     * ;\n     * b : c '^' INT ;\n     * c : ID\n     * | INT\n     * ;\n     *\n     * At each rule invocation, the set of tokens that could follow\n     * that rule is pushed on a stack. Here are the various\n     * context-sensitive follow sets:\n     *\n     * FOLLOW(b1_in_a) = FIRST(']') = ']'\n     * FOLLOW(b2_in_a) = FIRST(')') = ')'\n     * FOLLOW(c_in_b) = FIRST('^') = '^'\n     *\n     * Upon erroneous input \"[]\", the call chain is\n     *\n     * a -> b -> c\n     *\n     * and, hence, the follow context stack is:\n     *\n     * depth follow set start of rule execution\n     * 0 <EOF> a (from main())\n     * 1 ']' b\n     * 2 '^' c\n     *\n     * Notice that ')' is not included, because b would have to have\n     * been called from a different context in rule a for ')' to be\n     * included.\n     *\n     * For error recovery, we cannot consider FOLLOW(c)\n     * (context-sensitive or otherwise). We need the combined set of\n     * all context-sensitive FOLLOW sets--the set of all tokens that\n     * could follow any reference in the call chain. We need to\n     * resync to one of those tokens. Note that FOLLOW(c)='^' and if\n     * we resync'd to that token, we'd consume until EOF. We need to\n     * sync to context-sensitive FOLLOWs for a, b, and c: {']','^'}.\n     * In this case, for input \"[]\", LA(1) is ']' and in the set, so we would\n     * not consume anything. After printing an error, rule c would\n     * return normally. Rule b would not find the required '^' though.\n     * At this point, it gets a mismatched token error and throws an\n     * exception (since LA(1) is not in the viable following token\n     * set). The rule exception handler tries to recover, but finds\n     * the same recovery set and doesn't consume anything. Rule b\n     * exits normally returning to rule a. Now it finds the ']' (and\n     * with the successful match exits errorRecovery mode).\n     *\n     * So, you can see that the parser walks up the call chain looking\n     * for the token that was a member of the recovery set.\n     *\n     * Errors are not generated in errorRecovery mode.\n     *\n     * ANTLR's error recovery mechanism is based upon original ideas:\n     *\n     * \"Algorithms + Data Structures = Programs\" by Niklaus Wirth\n     *\n     * and\n     *\n     * \"A note on error recovery in recursive descent parsers\":\n     * http://portal.acm.org/citation.cfm?id=947902.947905\n     *\n     * Later, Josef Grosch had some good ideas:\n     *\n     * \"Efficient and Comfortable Error Recovery in Recursive Descent\n     * Parsers\":\n     * ftp://www.cocolab.com/products/cocktail/doca4.ps/ell.ps.zip\n     *\n     * Like Grosch I implement context-sensitive FOLLOW sets that are combined\n     * at run-time upon error to avoid overhead during parsing.\n     */\n    getErrorRecoverySet(recognizer) {\n        const atn = recognizer._interp.atn\n        let ctx = recognizer._ctx\n        const recoverSet = new IntervalSet()\n        while (ctx !== null && ctx.invokingState>=0) {\n            // compute what follows who invoked us\n            const invokingState = atn.states[ctx.invokingState]\n            const rt = invokingState.transitions[0]\n            const follow = atn.nextTokens(rt.followState)\n            recoverSet.addSet(follow);\n            ctx = ctx.parentCtx;\n        }\n        recoverSet.removeOne(Token.EPSILON);\n        return recoverSet;\n    }\n\n// Consume tokens until one matches the given token set.//\n    consumeUntil(recognizer, set) {\n        let ttype = recognizer.getTokenStream().LA(1)\n        while( ttype !== Token.EOF && !set.contains(ttype)) {\n            recognizer.consume();\n            ttype = recognizer.getTokenStream().LA(1);\n        }\n    }\n}\n\n\n/**\n * This implementation of {@link ANTLRErrorStrategy} responds to syntax errors\n * by immediately canceling the parse operation with a\n * {@link ParseCancellationException}. The implementation ensures that the\n * {@link ParserRuleContext//exception} field is set for all parse tree nodes\n * that were not completed prior to encountering the error.\n *\n * <p>\n * This error strategy is useful in the following scenarios.</p>\n *\n * <ul>\n * <li><strong>Two-stage parsing:</strong> This error strategy allows the first\n * stage of two-stage parsing to immediately terminate if an error is\n * encountered, and immediately fall back to the second stage. In addition to\n * avoiding wasted work by attempting to recover from errors here, the empty\n * implementation of {@link BailErrorStrategy//sync} improves the performance of\n * the first stage.</li>\n * <li><strong>Silent validation:</strong> When syntax errors are not being\n * reported or logged, and the parse result is simply ignored if errors occur,\n * the {@link BailErrorStrategy} avoids wasting work on recovering from errors\n * when the result will be ignored either way.</li>\n * </ul>\n *\n * <p>\n * {@code myparser.setErrorHandler(new BailErrorStrategy());}</p>\n *\n * @see Parser//setErrorHandler(ANTLRErrorStrategy)\n * */\nclass BailErrorStrategy extends DefaultErrorStrategy {\n    constructor() {\n        super();\n    }\n\n    /**\n     * Instead of recovering from exception {@code e}, re-throw it wrapped\n     * in a {@link ParseCancellationException} so it is not caught by the\n     * rule function catches. Use {@link Exception//getCause()} to get the\n     * original {@link RecognitionException}.\n     */\n    recover(recognizer, e) {\n        let context = recognizer._ctx\n        while (context !== null) {\n            context.exception = e;\n            context = context.parentCtx;\n        }\n        throw new ParseCancellationException(e);\n    }\n\n    /**\n     * Make sure we don't attempt to recover inline; if the parser\n     * successfully recovers, it won't throw an exception.\n     */\n    recoverInline(recognizer) {\n        this.recover(recognizer, new InputMismatchException(recognizer));\n    }\n\n// Make sure we don't attempt to recover from problems in subrules.//\n    sync(recognizer) {\n        // pass\n    }\n}\n\n\nmodule.exports = {BailErrorStrategy, DefaultErrorStrategy};\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\n/**\n * The root of the ANTLR exception hierarchy. In general, ANTLR tracks just\n *  3 kinds of errors: prediction errors, failed predicate errors, and\n *  mismatched input errors. In each case, the parser knows where it is\n *  in the input, where it is in the ATN, the rule invocation stack,\n *  and what kind of problem occurred.\n */\n\nconst {PredicateTransition} = require('./../atn/Transition');\nconst {Interval} = require('../IntervalSet').Interval;\n\nclass RecognitionException extends Error {\n    constructor(params) {\n        super(params.message);\n        if (!!Error.captureStackTrace) {\n            Error.captureStackTrace(this, RecognitionException);\n        } else {\n            var stack = new Error().stack;\n        }\n        this.message = params.message;\n        this.recognizer = params.recognizer;\n        this.input = params.input;\n        this.ctx = params.ctx;\n        /**\n         * The current {@link Token} when an error occurred. Since not all streams\n         * support accessing symbols by index, we have to track the {@link Token}\n         * instance itself\n        */\n        this.offendingToken = null;\n        /**\n         * Get the ATN state number the parser was in at the time the error\n         * occurred. For {@link NoViableAltException} and\n         * {@link LexerNoViableAltException} exceptions, this is the\n         * {@link DecisionState} number. For others, it is the state whose outgoing\n         * edge we couldn't match.\n         */\n        this.offendingState = -1;\n        if (this.recognizer!==null) {\n            this.offendingState = this.recognizer.state;\n        }\n    }\n\n    /**\n     * Gets the set of input symbols which could potentially follow the\n     * previously matched symbol at the time this exception was thrown.\n     *\n     * <p>If the set of expected tokens is not known and could not be computed,\n     * this method returns {@code null}.</p>\n     *\n     * @return The set of token types that could potentially follow the current\n     * state in the ATN, or {@code null} if the information is not available.\n     */\n    getExpectedTokens() {\n        if (this.recognizer!==null) {\n            return this.recognizer.atn.getExpectedTokens(this.offendingState, this.ctx);\n        } else {\n            return null;\n        }\n    }\n\n    // <p>If the state number is not known, this method returns -1.</p>\n    toString() {\n        return this.message;\n    }\n}\n\nclass LexerNoViableAltException extends RecognitionException {\n    constructor(lexer, input, startIndex, deadEndConfigs) {\n        super({message: \"\", recognizer: lexer, input: input, ctx: null});\n        this.startIndex = startIndex;\n        this.deadEndConfigs = deadEndConfigs;\n    }\n\n    toString() {\n        let symbol = \"\";\n        if (this.startIndex >= 0 && this.startIndex < this.input.size) {\n            symbol = this.input.getText(new Interval(this.startIndex,this.startIndex));\n        }\n        return \"LexerNoViableAltException\" + symbol;\n    }\n}\n\n\n/**\n * Indicates that the parser could not decide which of two or more paths\n * to take based upon the remaining input. It tracks the starting token\n * of the offending input and also knows where the parser was\n * in the various paths when the error. Reported by reportNoViableAlternative()\n */\nclass NoViableAltException extends RecognitionException {\n    constructor(recognizer, input, startToken, offendingToken, deadEndConfigs, ctx) {\n        ctx = ctx || recognizer._ctx;\n        offendingToken = offendingToken || recognizer.getCurrentToken();\n        startToken = startToken || recognizer.getCurrentToken();\n        input = input || recognizer.getInputStream();\n        super({message: \"\", recognizer: recognizer, input: input, ctx: ctx});\n        // Which configurations did we try at input.index() that couldn't match\n        // input.LT(1)?//\n        this.deadEndConfigs = deadEndConfigs;\n        // The token object at the start index; the input stream might\n        // not be buffering tokens so get a reference to it. (At the\n        // time the error occurred, of course the stream needs to keep a\n        // buffer all of the tokens but later we might not have access to those.)\n        this.startToken = startToken;\n        this.offendingToken = offendingToken;\n    }\n}\n\n/**\n * This signifies any kind of mismatched input exceptions such as\n * when the current input does not match the expected token.\n*/\nclass InputMismatchException extends RecognitionException {\n    constructor(recognizer) {\n        super({message: \"\", recognizer: recognizer, input: recognizer.getInputStream(), ctx: recognizer._ctx});\n        this.offendingToken = recognizer.getCurrentToken();\n    }\n}\n\nfunction formatMessage(predicate, message) {\n    if (message !==null) {\n        return message;\n    } else {\n        return \"failed predicate: {\" + predicate + \"}?\";\n    }\n}\n\n/**\n * A semantic predicate failed during validation. Validation of predicates\n * occurs when normally parsing the alternative just like matching a token.\n * Disambiguating predicate evaluation occurs when we test a predicate during\n * prediction.\n*/\nclass FailedPredicateException extends RecognitionException {\n    constructor(recognizer, predicate, message) {\n        super({\n            message: formatMessage(predicate, message || null), recognizer: recognizer,\n            input: recognizer.getInputStream(), ctx: recognizer._ctx\n        });\n        const s = recognizer._interp.atn.states[recognizer.state]\n        const trans = s.transitions[0]\n        if (trans instanceof PredicateTransition) {\n            this.ruleIndex = trans.ruleIndex;\n            this.predicateIndex = trans.predIndex;\n        } else {\n            this.ruleIndex = 0;\n            this.predicateIndex = 0;\n        }\n        this.predicate = predicate;\n        this.offendingToken = recognizer.getCurrentToken();\n    }\n}\n\n\nclass ParseCancellationException extends Error{\n    constructor() {\n        super()\n        Error.captureStackTrace(this, ParseCancellationException);\n    }\n}\n\nmodule.exports = {\n    RecognitionException,\n    NoViableAltException,\n    LexerNoViableAltException,\n    InputMismatchException,\n    FailedPredicateException,\n    ParseCancellationException\n};\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nmodule.exports.RecognitionException = require('./Errors').RecognitionException;\nmodule.exports.NoViableAltException = require('./Errors').NoViableAltException;\nmodule.exports.LexerNoViableAltException = require('./Errors').LexerNoViableAltException;\nmodule.exports.InputMismatchException = require('./Errors').InputMismatchException;\nmodule.exports.FailedPredicateException = require('./Errors').FailedPredicateException;\nmodule.exports.DiagnosticErrorListener = require('./DiagnosticErrorListener');\nmodule.exports.BailErrorStrategy = require('./ErrorStrategy').BailErrorStrategy;\nmodule.exports.DefaultErrorStrategy = require('./ErrorStrategy').DefaultErrorStrategy;\nmodule.exports.ErrorListener = require('./ErrorListener').ErrorListener;\n","/*! https://mths.be/codepointat v0.2.0 by @mathias */\nif (!String.prototype.codePointAt) {\n\t(function() {\n\t\t'use strict'; // needed to support `apply`/`call` with `undefined`/`null`\n\t\tvar defineProperty = (function() {\n\t\t\t// IE 8 only supports `Object.defineProperty` on DOM elements\n\t\t\tlet result;\n\t\t\ttry {\n\t\t\t\tconst object = {};\n\t\t\t\tconst $defineProperty = Object.defineProperty;\n\t\t\t\tresult = $defineProperty(object, object, object) && $defineProperty;\n\t\t\t} catch(error) {\n\t\t\t}\n\t\t\treturn result;\n\t\t}());\n\t\tconst codePointAt = function(position) {\n\t\t\tif (this == null) {\n\t\t\t\tthrow TypeError();\n\t\t\t}\n\t\t\tconst string = String(this);\n\t\t\tconst size = string.length;\n\t\t\t// `ToInteger`\n\t\t\tlet index = position ? Number(position) : 0;\n\t\t\tif (index !== index) { // better `isNaN`\n\t\t\t\tindex = 0;\n\t\t\t}\n\t\t\t// Account for out-of-bounds indices:\n\t\t\tif (index < 0 || index >= size) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\t// Get the first code unit\n\t\t\tconst first = string.charCodeAt(index);\n\t\t\tlet second;\n\t\t\tif ( // check if its the start of a surrogate pair\n\t\t\t\tfirst >= 0xD800 && first <= 0xDBFF && // high surrogate\n\t\t\t\tsize > index + 1 // there is a next code unit\n\t\t\t) {\n\t\t\t\tsecond = string.charCodeAt(index + 1);\n\t\t\t\tif (second >= 0xDC00 && second <= 0xDFFF) { // low surrogate\n\t\t\t\t\t// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\t\t\t\t\treturn (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn first;\n\t\t};\n\t\tif (defineProperty) {\n\t\t\tdefineProperty(String.prototype, 'codePointAt', {\n\t\t\t\t'value': codePointAt,\n\t\t\t\t'configurable': true,\n\t\t\t\t'writable': true\n\t\t\t});\n\t\t} else {\n\t\t\tString.prototype.codePointAt = codePointAt;\n\t\t}\n\t}());\n}\n","/*! https://mths.be/fromcodepoint v0.2.1 by @mathias */\nif (!String.fromCodePoint) {\n\t(function() {\n\t\tconst defineProperty = (function() {\n\t\t\t// IE 8 only supports `Object.defineProperty` on DOM elements\n\t\t\tlet result;\n\t\t\ttry {\n\t\t\t\tconst object = {};\n\t\t\t\tconst $defineProperty = Object.defineProperty;\n\t\t\t\tresult = $defineProperty(object, object, object) && $defineProperty;\n\t\t\t} catch(error) {}\n\t\t\treturn result;\n\t\t}());\n\t\tconst stringFromCharCode = String.fromCharCode;\n\t\tconst floor = Math.floor;\n\t\tconst fromCodePoint = function(_) {\n\t\t\tconst MAX_SIZE = 0x4000;\n\t\t\tconst codeUnits = [];\n\t\t\tlet highSurrogate;\n\t\t\tlet lowSurrogate;\n\t\t\tlet index = -1;\n\t\t\tconst length = arguments.length;\n\t\t\tif (!length) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\tlet result = '';\n\t\t\twhile (++index < length) {\n\t\t\t\tlet codePoint = Number(arguments[index]);\n\t\t\t\tif (\n\t\t\t\t\t!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n\t\t\t\t\tcodePoint < 0 || // not a valid Unicode code point\n\t\t\t\t\tcodePoint > 0x10FFFF || // not a valid Unicode code point\n\t\t\t\t\tfloor(codePoint) !== codePoint // not an integer\n\t\t\t\t) {\n\t\t\t\t\tthrow RangeError('Invalid code point: ' + codePoint);\n\t\t\t\t}\n\t\t\t\tif (codePoint <= 0xFFFF) { // BMP code point\n\t\t\t\t\tcodeUnits.push(codePoint);\n\t\t\t\t} else { // Astral code point; split in surrogate halves\n\t\t\t\t\t// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\t\t\t\t\tcodePoint -= 0x10000;\n\t\t\t\t\thighSurrogate = (codePoint >> 10) + 0xD800;\n\t\t\t\t\tlowSurrogate = (codePoint % 0x400) + 0xDC00;\n\t\t\t\t\tcodeUnits.push(highSurrogate, lowSurrogate);\n\t\t\t\t}\n\t\t\t\tif (index + 1 === length || codeUnits.length > MAX_SIZE) {\n\t\t\t\t\tresult += stringFromCharCode.apply(null, codeUnits);\n\t\t\t\t\tcodeUnits.length = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\t\tif (defineProperty) {\n\t\t\tdefineProperty(String, 'fromCodePoint', {\n\t\t\t\t'value': fromCodePoint,\n\t\t\t\t'configurable': true,\n\t\t\t\t'writable': true\n\t\t\t});\n\t\t} else {\n\t\t\tString.fromCodePoint = fromCodePoint;\n\t\t}\n\t}());\n}\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Token} = require('./../Token');\nconst {Interval} = require('./../IntervalSet');\nconst INVALID_INTERVAL = new Interval(-1, -2);\n\n/**\n * The basic notion of a tree has a parent, a payload, and a list of children.\n * It is the most abstract interface for all the trees used by ANTLR.\n */\nclass Tree {}\n\nclass SyntaxTree extends Tree {\n\tconstructor() {\n\t\tsuper();\n\t}\n}\n\nclass ParseTree extends SyntaxTree {\n\tconstructor() {\n\t\tsuper();\n\t}\n}\n\nclass RuleNode extends ParseTree {\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\tgetRuleContext(){\n\t\tthrow new Error(\"missing interface implementation\")\n\t}\n}\n\nclass TerminalNode extends ParseTree {\n\tconstructor() {\n\t\tsuper();\n\t}\n}\n\nclass ErrorNode extends TerminalNode {\n\tconstructor() {\n\t\tsuper();\n\t}\n}\n\nclass ParseTreeVisitor {\n\tvisit(ctx) {\n\t\t if (Array.isArray(ctx)) {\n\t\t\treturn ctx.map(function(child) {\n\t\t\t\treturn child.accept(this);\n\t\t\t}, this);\n\t\t} else {\n\t\t\treturn ctx.accept(this);\n\t\t}\n\t}\n\n\tvisitChildren(ctx) {\n\t\tif (ctx.children) {\n\t\t\treturn this.visit(ctx.children);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tvisitTerminal(node) {\n\t}\n\n\tvisitErrorNode(node) {\n\t}\n}\n\nclass ParseTreeListener {\n\tvisitTerminal(node) {\n\t}\n\n\tvisitErrorNode(node) {\n\t}\n\n\tenterEveryRule(node) {\n\t}\n\n\texitEveryRule(node) {\n\t}\n}\n\nclass TerminalNodeImpl extends TerminalNode {\n\tconstructor(symbol) {\n\t\tsuper();\n\t\tthis.parentCtx = null;\n\t\tthis.symbol = symbol;\n\t}\n\n\tgetChild(i) {\n\t\treturn null;\n\t}\n\n\tgetSymbol() {\n\t\treturn this.symbol;\n\t}\n\n\tgetParent() {\n\t\treturn this.parentCtx;\n\t}\n\n\tgetPayload() {\n\t\treturn this.symbol;\n\t}\n\n\tgetSourceInterval() {\n\t\tif (this.symbol === null) {\n\t\t\treturn INVALID_INTERVAL;\n\t\t}\n\t\tconst tokenIndex = this.symbol.tokenIndex;\n\t\treturn new Interval(tokenIndex, tokenIndex);\n\t}\n\n\tgetChildCount() {\n\t\treturn 0;\n\t}\n\n\taccept(visitor) {\n\t\treturn visitor.visitTerminal(this);\n\t}\n\n\tgetText() {\n\t\treturn this.symbol.text;\n\t}\n\n\ttoString() {\n\t\tif (this.symbol.type === Token.EOF) {\n\t\t\treturn \"<EOF>\";\n\t\t} else {\n\t\t\treturn this.symbol.text;\n\t\t}\n\t}\n}\n\n\n/**\n * Represents a token that was consumed during resynchronization\n * rather than during a valid match operation. For example,\n * we will create this kind of a node during single token insertion\n * and deletion as well as during \"consume until error recovery set\"\n * upon no viable alternative exceptions.\n */\nclass ErrorNodeImpl extends TerminalNodeImpl {\n\tconstructor(token) {\n\t\tsuper(token);\n\t}\n\n\tisErrorNode() {\n\t\treturn true;\n\t}\n\n\taccept(visitor) {\n\t\treturn visitor.visitErrorNode(this);\n\t}\n}\n\nclass ParseTreeWalker {\n\n\t/**\n\t * Performs a walk on the given parse tree starting at the root and going down recursively\n\t * with depth-first search. On each node, {@link ParseTreeWalker//enterRule} is called before\n\t * recursively walking down into child nodes, then\n\t * {@link ParseTreeWalker//exitRule} is called after the recursive call to wind up.\n\t * @param listener The listener used by the walker to process grammar rules\n\t * @param t The parse tree to be walked on\n\t */\n\twalk(listener, t) {\n\t\tconst errorNode = t instanceof ErrorNode ||\n\t\t\t\t(t.isErrorNode !== undefined && t.isErrorNode());\n\t\tif (errorNode) {\n\t\t\tlistener.visitErrorNode(t);\n\t\t} else if (t instanceof TerminalNode) {\n\t\t\tlistener.visitTerminal(t);\n\t\t} else {\n\t\t\tthis.enterRule(listener, t);\n\t\t\tfor (let i = 0; i < t.getChildCount(); i++) {\n\t\t\t\tconst child = t.getChild(i);\n\t\t\t\tthis.walk(listener, child);\n\t\t\t}\n\t\t\tthis.exitRule(listener, t);\n\t\t}\n\t}\n\n\t/**\n\t * Enters a grammar rule by first triggering the generic event {@link ParseTreeListener//enterEveryRule}\n\t * then by triggering the event specific to the given parse tree node\n\t * @param listener The listener responding to the trigger events\n\t * @param r The grammar rule containing the rule context\n\t */\n\tenterRule(listener, r) {\n\t\tconst ctx = r.getRuleContext();\n\t\tlistener.enterEveryRule(ctx);\n\t\tctx.enterRule(listener);\n\t}\n\n\t/**\n\t * Exits a grammar rule by first triggering the event specific to the given parse tree node\n\t * then by triggering the generic event {@link ParseTreeListener//exitEveryRule}\n\t * @param listener The listener responding to the trigger events\n\t * @param r The grammar rule containing the rule context\n\t */\n\texitRule(listener, r) {\n\t\tconst ctx = r.getRuleContext();\n\t\tctx.exitRule(listener);\n\t\tlistener.exitEveryRule(ctx);\n\t}\n}\n\nParseTreeWalker.DEFAULT = new ParseTreeWalker();\n\nmodule.exports = {\n\tRuleNode,\n\tErrorNode,\n\tTerminalNode,\n\tErrorNodeImpl,\n\tTerminalNodeImpl,\n\tParseTreeListener,\n\tParseTreeVisitor,\n\tParseTreeWalker,\n\tINVALID_INTERVAL\n}\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst Utils = require('./../Utils');\nconst {Token} = require('./../Token');\nconst {ErrorNode, TerminalNode, RuleNode} = require('./Tree');\n\n/** A set of utility routines useful for all kinds of ANTLR trees. */\nconst Trees = {\n    /**\n     * Print out a whole tree in LISP form. {@link //getNodeText} is used on the\n     *  node payloads to get the text for the nodes.  Detect\n     *  parse trees and extract data appropriately.\n     */\n    toStringTree: function(tree, ruleNames, recog) {\n        ruleNames = ruleNames || null;\n        recog = recog || null;\n        if(recog!==null) {\n            ruleNames = recog.ruleNames;\n        }\n        let s = Trees.getNodeText(tree, ruleNames);\n        s = Utils.escapeWhitespace(s, false);\n        const c = tree.getChildCount();\n        if(c===0) {\n            return s;\n        }\n        let res = \"(\" + s + ' ';\n        if(c>0) {\n            s = Trees.toStringTree(tree.getChild(0), ruleNames);\n            res = res.concat(s);\n        }\n        for(let i=1;i<c;i++) {\n            s = Trees.toStringTree(tree.getChild(i), ruleNames);\n            res = res.concat(' ' + s);\n        }\n        res = res.concat(\")\");\n        return res;\n    },\n\n    getNodeText: function(t, ruleNames, recog) {\n        ruleNames = ruleNames || null;\n        recog = recog || null;\n        if(recog!==null) {\n            ruleNames = recog.ruleNames;\n        }\n        if(ruleNames!==null) {\n            if (t instanceof RuleNode) {\n                const context = t.getRuleContext()\n                const altNumber = context.getAltNumber();\n                // use const value of ATN.INVALID_ALT_NUMBER to avoid circular dependency\n                if ( altNumber != 0 ) {\n                    return ruleNames[t.ruleIndex]+\":\"+altNumber;\n                }\n                return ruleNames[t.ruleIndex];\n            } else if ( t instanceof ErrorNode) {\n                return t.toString();\n            } else if(t instanceof TerminalNode) {\n                if(t.symbol!==null) {\n                    return t.symbol.text;\n                }\n            }\n        }\n        // no recog for rule names\n        const payload = t.getPayload();\n        if (payload instanceof Token ) {\n            return payload.text;\n        }\n        return t.getPayload().toString();\n    },\n\n    /**\n     * Return ordered list of all children of this node\n     */\n    getChildren: function(t) {\n        const list = [];\n        for(let i=0;i<t.getChildCount();i++) {\n            list.push(t.getChild(i));\n        }\n        return list;\n    },\n\n    /**\n     * Return a list of all ancestors of this node.  The first node of\n     * list is the root and the last is the parent of this node.\n     */\n    getAncestors: function(t) {\n        let ancestors = [];\n        t = t.getParent();\n        while(t!==null) {\n            ancestors = [t].concat(ancestors);\n            t = t.getParent();\n        }\n        return ancestors;\n    },\n\n    findAllTokenNodes: function(t, ttype) {\n        return Trees.findAllNodes(t, ttype, true);\n    },\n\n    findAllRuleNodes: function(t, ruleIndex) {\n        return Trees.findAllNodes(t, ruleIndex, false);\n    },\n\n    findAllNodes: function(t, index, findTokens) {\n        const nodes = [];\n        Trees._findAllNodes(t, index, findTokens, nodes);\n        return nodes;\n    },\n\n    _findAllNodes: function(t, index, findTokens, nodes) {\n        // check this node (the root) first\n        if(findTokens && (t instanceof TerminalNode)) {\n            if(t.symbol.type===index) {\n                nodes.push(t);\n            }\n        } else if(!findTokens && (t instanceof RuleNode)) {\n            if(t.ruleIndex===index) {\n                nodes.push(t);\n            }\n        }\n        // check children\n        for(let i=0;i<t.getChildCount();i++) {\n            Trees._findAllNodes(t.getChild(i), index, findTokens, nodes);\n        }\n    },\n\n    descendants: function(t) {\n        let nodes = [t];\n        for(let i=0;i<t.getChildCount();i++) {\n            nodes = nodes.concat(Trees.descendants(t.getChild(i)));\n        }\n        return nodes;\n    }\n}\n\nmodule.exports = Trees;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst Tree = require('./Tree');\nconst Trees = require('./Trees');\nmodule.exports = {...Tree, Trees}\n","var MILLISECONDS_IN_MINUTE = 60000\n\n/**\n * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.\n * They usually appear for dates that denote time before the timezones were introduced\n * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891\n * and GMT+01:00:00 after that date)\n *\n * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,\n * which would lead to incorrect calculations.\n *\n * This function returns the timezone offset in milliseconds that takes seconds in account.\n */\nmodule.exports = function getTimezoneOffsetInMilliseconds (dirtyDate) {\n  var date = new Date(dirtyDate.getTime())\n  var baseTimezoneOffset = date.getTimezoneOffset()\n  date.setSeconds(0, 0)\n  var millisecondsPartOfTimezoneOffset = date.getTime() % MILLISECONDS_IN_MINUTE\n\n  return baseTimezoneOffset * MILLISECONDS_IN_MINUTE + millisecondsPartOfTimezoneOffset\n}\n","var parse = require('../parse/index.js')\n\n/**\n * @category Day Helpers\n * @summary Add the specified number of days to the given date.\n *\n * @description\n * Add the specified number of days to the given date.\n *\n * @param {Date|String|Number} date - the date to be changed\n * @param {Number} amount - the amount of days to be added\n * @returns {Date} the new date with the days added\n *\n * @example\n * // Add 10 days to 1 September 2014:\n * var result = addDays(new Date(2014, 8, 1), 10)\n * //=> Thu Sep 11 2014 00:00:00\n */\nfunction addDays (dirtyDate, dirtyAmount) {\n  var date = parse(dirtyDate)\n  var amount = Number(dirtyAmount)\n  date.setDate(date.getDate() + amount)\n  return date\n}\n\nmodule.exports = addDays\n","var addMilliseconds = require('../add_milliseconds/index.js')\n\nvar MILLISECONDS_IN_HOUR = 3600000\n\n/**\n * @category Hour Helpers\n * @summary Add the specified number of hours to the given date.\n *\n * @description\n * Add the specified number of hours to the given date.\n *\n * @param {Date|String|Number} date - the date to be changed\n * @param {Number} amount - the amount of hours to be added\n * @returns {Date} the new date with the hours added\n *\n * @example\n * // Add 2 hours to 10 July 2014 23:00:00:\n * var result = addHours(new Date(2014, 6, 10, 23, 0), 2)\n * //=> Fri Jul 11 2014 01:00:00\n */\nfunction addHours (dirtyDate, dirtyAmount) {\n  var amount = Number(dirtyAmount)\n  return addMilliseconds(dirtyDate, amount * MILLISECONDS_IN_HOUR)\n}\n\nmodule.exports = addHours\n","var parse = require('../parse/index.js')\n\n/**\n * @category Millisecond Helpers\n * @summary Add the specified number of milliseconds to the given date.\n *\n * @description\n * Add the specified number of milliseconds to the given date.\n *\n * @param {Date|String|Number} date - the date to be changed\n * @param {Number} amount - the amount of milliseconds to be added\n * @returns {Date} the new date with the milliseconds added\n *\n * @example\n * // Add 750 milliseconds to 10 July 2014 12:45:30.000:\n * var result = addMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)\n * //=> Thu Jul 10 2014 12:45:30.750\n */\nfunction addMilliseconds (dirtyDate, dirtyAmount) {\n  var timestamp = parse(dirtyDate).getTime()\n  var amount = Number(dirtyAmount)\n  return new Date(timestamp + amount)\n}\n\nmodule.exports = addMilliseconds\n","var addMilliseconds = require('../add_milliseconds/index.js')\n\nvar MILLISECONDS_IN_MINUTE = 60000\n\n/**\n * @category Minute Helpers\n * @summary Add the specified number of minutes to the given date.\n *\n * @description\n * Add the specified number of minutes to the given date.\n *\n * @param {Date|String|Number} date - the date to be changed\n * @param {Number} amount - the amount of minutes to be added\n * @returns {Date} the new date with the minutes added\n *\n * @example\n * // Add 30 minutes to 10 July 2014 12:00:00:\n * var result = addMinutes(new Date(2014, 6, 10, 12, 0), 30)\n * //=> Thu Jul 10 2014 12:30:00\n */\nfunction addMinutes (dirtyDate, dirtyAmount) {\n  var amount = Number(dirtyAmount)\n  return addMilliseconds(dirtyDate, amount * MILLISECONDS_IN_MINUTE)\n}\n\nmodule.exports = addMinutes\n","var parse = require('../parse/index.js')\nvar getDaysInMonth = require('../get_days_in_month/index.js')\n\n/**\n * @category Month Helpers\n * @summary Add the specified number of months to the given date.\n *\n * @description\n * Add the specified number of months to the given date.\n *\n * @param {Date|String|Number} date - the date to be changed\n * @param {Number} amount - the amount of months to be added\n * @returns {Date} the new date with the months added\n *\n * @example\n * // Add 5 months to 1 September 2014:\n * var result = addMonths(new Date(2014, 8, 1), 5)\n * //=> Sun Feb 01 2015 00:00:00\n */\nfunction addMonths (dirtyDate, dirtyAmount) {\n  var date = parse(dirtyDate)\n  var amount = Number(dirtyAmount)\n  var desiredMonth = date.getMonth() + amount\n  var dateWithDesiredMonth = new Date(0)\n  dateWithDesiredMonth.setFullYear(date.getFullYear(), desiredMonth, 1)\n  dateWithDesiredMonth.setHours(0, 0, 0, 0)\n  var daysInMonth = getDaysInMonth(dateWithDesiredMonth)\n  // Set the last day of the new month\n  // if the original date was the last day of the longer month\n  date.setMonth(desiredMonth, Math.min(daysInMonth, date.getDate()))\n  return date\n}\n\nmodule.exports = addMonths\n","var addMilliseconds = require('../add_milliseconds/index.js')\n\n/**\n * @category Second Helpers\n * @summary Add the specified number of seconds to the given date.\n *\n * @description\n * Add the specified number of seconds to the given date.\n *\n * @param {Date|String|Number} date - the date to be changed\n * @param {Number} amount - the amount of seconds to be added\n * @returns {Date} the new date with the seconds added\n *\n * @example\n * // Add 30 seconds to 10 July 2014 12:45:00:\n * var result = addSeconds(new Date(2014, 6, 10, 12, 45, 0), 30)\n * //=> Thu Jul 10 2014 12:45:30\n */\nfunction addSeconds (dirtyDate, dirtyAmount) {\n  var amount = Number(dirtyAmount)\n  return addMilliseconds(dirtyDate, amount * 1000)\n}\n\nmodule.exports = addSeconds\n","var addDays = require('../add_days/index.js')\n\n/**\n * @category Week Helpers\n * @summary Add the specified number of weeks to the given date.\n *\n * @description\n * Add the specified number of week to the given date.\n *\n * @param {Date|String|Number} date - the date to be changed\n * @param {Number} amount - the amount of weeks to be added\n * @returns {Date} the new date with the weeks added\n *\n * @example\n * // Add 4 weeks to 1 September 2014:\n * var result = addWeeks(new Date(2014, 8, 1), 4)\n * //=> Mon Sep 29 2014 00:00:00\n */\nfunction addWeeks (dirtyDate, dirtyAmount) {\n  var amount = Number(dirtyAmount)\n  var days = amount * 7\n  return addDays(dirtyDate, days)\n}\n\nmodule.exports = addWeeks\n","var addMonths = require('../add_months/index.js')\n\n/**\n * @category Year Helpers\n * @summary Add the specified number of years to the given date.\n *\n * @description\n * Add the specified number of years to the given date.\n *\n * @param {Date|String|Number} date - the date to be changed\n * @param {Number} amount - the amount of years to be added\n * @returns {Date} the new date with the years added\n *\n * @example\n * // Add 5 years to 1 September 2014:\n * var result = addYears(new Date(2014, 8, 1), 5)\n * //=> Sun Sep 01 2019 00:00:00\n */\nfunction addYears (dirtyDate, dirtyAmount) {\n  var amount = Number(dirtyAmount)\n  return addMonths(dirtyDate, amount * 12)\n}\n\nmodule.exports = addYears\n","var parse = require('../parse/index.js')\n\n/**\n * @category Month Helpers\n * @summary Get the number of days in a month of the given date.\n *\n * @description\n * Get the number of days in a month of the given date.\n *\n * @param {Date|String|Number} date - the given date\n * @returns {Number} the number of days in a month\n *\n * @example\n * // How many days are in February 2000?\n * var result = getDaysInMonth(new Date(2000, 1))\n * //=> 29\n */\nfunction getDaysInMonth (dirtyDate) {\n  var date = parse(dirtyDate)\n  var year = date.getFullYear()\n  var monthIndex = date.getMonth()\n  var lastDayOfMonth = new Date(0)\n  lastDayOfMonth.setFullYear(year, monthIndex + 1, 0)\n  lastDayOfMonth.setHours(0, 0, 0, 0)\n  return lastDayOfMonth.getDate()\n}\n\nmodule.exports = getDaysInMonth\n","/**\n * @category Common Helpers\n * @summary Is the given argument an instance of Date?\n *\n * @description\n * Is the given argument an instance of Date?\n *\n * @param {*} argument - the argument to check\n * @returns {Boolean} the given argument is an instance of Date\n *\n * @example\n * // Is 'mayonnaise' a Date?\n * var result = isDate('mayonnaise')\n * //=> false\n */\nfunction isDate (argument) {\n  return argument instanceof Date\n}\n\nmodule.exports = isDate\n","var getTimezoneOffsetInMilliseconds = require('../_lib/getTimezoneOffsetInMilliseconds/index.js')\nvar isDate = require('../is_date/index.js')\n\nvar MILLISECONDS_IN_HOUR = 3600000\nvar MILLISECONDS_IN_MINUTE = 60000\nvar DEFAULT_ADDITIONAL_DIGITS = 2\n\nvar parseTokenDateTimeDelimeter = /[T ]/\nvar parseTokenPlainTime = /:/\n\n// year tokens\nvar parseTokenYY = /^(\\d{2})$/\nvar parseTokensYYY = [\n  /^([+-]\\d{2})$/, // 0 additional digits\n  /^([+-]\\d{3})$/, // 1 additional digit\n  /^([+-]\\d{4})$/ // 2 additional digits\n]\n\nvar parseTokenYYYY = /^(\\d{4})/\nvar parseTokensYYYYY = [\n  /^([+-]\\d{4})/, // 0 additional digits\n  /^([+-]\\d{5})/, // 1 additional digit\n  /^([+-]\\d{6})/ // 2 additional digits\n]\n\n// date tokens\nvar parseTokenMM = /^-(\\d{2})$/\nvar parseTokenDDD = /^-?(\\d{3})$/\nvar parseTokenMMDD = /^-?(\\d{2})-?(\\d{2})$/\nvar parseTokenWww = /^-?W(\\d{2})$/\nvar parseTokenWwwD = /^-?W(\\d{2})-?(\\d{1})$/\n\n// time tokens\nvar parseTokenHH = /^(\\d{2}([.,]\\d*)?)$/\nvar parseTokenHHMM = /^(\\d{2}):?(\\d{2}([.,]\\d*)?)$/\nvar parseTokenHHMMSS = /^(\\d{2}):?(\\d{2}):?(\\d{2}([.,]\\d*)?)$/\n\n// timezone tokens\nvar parseTokenTimezone = /([Z+-].*)$/\nvar parseTokenTimezoneZ = /^(Z)$/\nvar parseTokenTimezoneHH = /^([+-])(\\d{2})$/\nvar parseTokenTimezoneHHMM = /^([+-])(\\d{2}):?(\\d{2})$/\n\n/**\n * @category Common Helpers\n * @summary Convert the given argument to an instance of Date.\n *\n * @description\n * Convert the given argument to an instance of Date.\n *\n * If the argument is an instance of Date, the function returns its clone.\n *\n * If the argument is a number, it is treated as a timestamp.\n *\n * If an argument is a string, the function tries to parse it.\n * Function accepts complete ISO 8601 formats as well as partial implementations.\n * ISO 8601: http://en.wikipedia.org/wiki/ISO_8601\n *\n * If all above fails, the function passes the given argument to Date constructor.\n *\n * @param {Date|String|Number} argument - the value to convert\n * @param {Object} [options] - the object with options\n * @param {0 | 1 | 2} [options.additionalDigits=2] - the additional number of digits in the extended year format\n * @returns {Date} the parsed date in the local time zone\n *\n * @example\n * // Convert string '2014-02-11T11:30:30' to date:\n * var result = parse('2014-02-11T11:30:30')\n * //=> Tue Feb 11 2014 11:30:30\n *\n * @example\n * // Parse string '+02014101',\n * // if the additional number of digits in the extended year format is 1:\n * var result = parse('+02014101', {additionalDigits: 1})\n * //=> Fri Apr 11 2014 00:00:00\n */\nfunction parse (argument, dirtyOptions) {\n  if (isDate(argument)) {\n    // Prevent the date to lose the milliseconds when passed to new Date() in IE10\n    return new Date(argument.getTime())\n  } else if (typeof argument !== 'string') {\n    return new Date(argument)\n  }\n\n  var options = dirtyOptions || {}\n  var additionalDigits = options.additionalDigits\n  if (additionalDigits == null) {\n    additionalDigits = DEFAULT_ADDITIONAL_DIGITS\n  } else {\n    additionalDigits = Number(additionalDigits)\n  }\n\n  var dateStrings = splitDateString(argument)\n\n  var parseYearResult = parseYear(dateStrings.date, additionalDigits)\n  var year = parseYearResult.year\n  var restDateString = parseYearResult.restDateString\n\n  var date = parseDate(restDateString, year)\n\n  if (date) {\n    var timestamp = date.getTime()\n    var time = 0\n    var offset\n\n    if (dateStrings.time) {\n      time = parseTime(dateStrings.time)\n    }\n\n    if (dateStrings.timezone) {\n      offset = parseTimezone(dateStrings.timezone) * MILLISECONDS_IN_MINUTE\n    } else {\n      var fullTime = timestamp + time\n      var fullTimeDate = new Date(fullTime)\n\n      offset = getTimezoneOffsetInMilliseconds(fullTimeDate)\n\n      // Adjust time when it's coming from DST\n      var fullTimeDateNextDay = new Date(fullTime)\n      fullTimeDateNextDay.setDate(fullTimeDate.getDate() + 1)\n      var offsetDiff =\n        getTimezoneOffsetInMilliseconds(fullTimeDateNextDay) -\n        getTimezoneOffsetInMilliseconds(fullTimeDate)\n      if (offsetDiff > 0) {\n        offset += offsetDiff\n      }\n    }\n\n    return new Date(timestamp + time + offset)\n  } else {\n    return new Date(argument)\n  }\n}\n\nfunction splitDateString (dateString) {\n  var dateStrings = {}\n  var array = dateString.split(parseTokenDateTimeDelimeter)\n  var timeString\n\n  if (parseTokenPlainTime.test(array[0])) {\n    dateStrings.date = null\n    timeString = array[0]\n  } else {\n    dateStrings.date = array[0]\n    timeString = array[1]\n  }\n\n  if (timeString) {\n    var token = parseTokenTimezone.exec(timeString)\n    if (token) {\n      dateStrings.time = timeString.replace(token[1], '')\n      dateStrings.timezone = token[1]\n    } else {\n      dateStrings.time = timeString\n    }\n  }\n\n  return dateStrings\n}\n\nfunction parseYear (dateString, additionalDigits) {\n  var parseTokenYYY = parseTokensYYY[additionalDigits]\n  var parseTokenYYYYY = parseTokensYYYYY[additionalDigits]\n\n  var token\n\n  // YYYY or YYYYY\n  token = parseTokenYYYY.exec(dateString) || parseTokenYYYYY.exec(dateString)\n  if (token) {\n    var yearString = token[1]\n    return {\n      year: parseInt(yearString, 10),\n      restDateString: dateString.slice(yearString.length)\n    }\n  }\n\n  // YY or YYY\n  token = parseTokenYY.exec(dateString) || parseTokenYYY.exec(dateString)\n  if (token) {\n    var centuryString = token[1]\n    return {\n      year: parseInt(centuryString, 10) * 100,\n      restDateString: dateString.slice(centuryString.length)\n    }\n  }\n\n  // Invalid ISO-formatted year\n  return {\n    year: null\n  }\n}\n\nfunction parseDate (dateString, year) {\n  // Invalid ISO-formatted year\n  if (year === null) {\n    return null\n  }\n\n  var token\n  var date\n  var month\n  var week\n\n  // YYYY\n  if (dateString.length === 0) {\n    date = new Date(0)\n    date.setUTCFullYear(year)\n    return date\n  }\n\n  // YYYY-MM\n  token = parseTokenMM.exec(dateString)\n  if (token) {\n    date = new Date(0)\n    month = parseInt(token[1], 10) - 1\n    date.setUTCFullYear(year, month)\n    return date\n  }\n\n  // YYYY-DDD or YYYYDDD\n  token = parseTokenDDD.exec(dateString)\n  if (token) {\n    date = new Date(0)\n    var dayOfYear = parseInt(token[1], 10)\n    date.setUTCFullYear(year, 0, dayOfYear)\n    return date\n  }\n\n  // YYYY-MM-DD or YYYYMMDD\n  token = parseTokenMMDD.exec(dateString)\n  if (token) {\n    date = new Date(0)\n    month = parseInt(token[1], 10) - 1\n    var day = parseInt(token[2], 10)\n    date.setUTCFullYear(year, month, day)\n    return date\n  }\n\n  // YYYY-Www or YYYYWww\n  token = parseTokenWww.exec(dateString)\n  if (token) {\n    week = parseInt(token[1], 10) - 1\n    return dayOfISOYear(year, week)\n  }\n\n  // YYYY-Www-D or YYYYWwwD\n  token = parseTokenWwwD.exec(dateString)\n  if (token) {\n    week = parseInt(token[1], 10) - 1\n    var dayOfWeek = parseInt(token[2], 10) - 1\n    return dayOfISOYear(year, week, dayOfWeek)\n  }\n\n  // Invalid ISO-formatted date\n  return null\n}\n\nfunction parseTime (timeString) {\n  var token\n  var hours\n  var minutes\n\n  // hh\n  token = parseTokenHH.exec(timeString)\n  if (token) {\n    hours = parseFloat(token[1].replace(',', '.'))\n    return (hours % 24) * MILLISECONDS_IN_HOUR\n  }\n\n  // hh:mm or hhmm\n  token = parseTokenHHMM.exec(timeString)\n  if (token) {\n    hours = parseInt(token[1], 10)\n    minutes = parseFloat(token[2].replace(',', '.'))\n    return (hours % 24) * MILLISECONDS_IN_HOUR +\n      minutes * MILLISECONDS_IN_MINUTE\n  }\n\n  // hh:mm:ss or hhmmss\n  token = parseTokenHHMMSS.exec(timeString)\n  if (token) {\n    hours = parseInt(token[1], 10)\n    minutes = parseInt(token[2], 10)\n    var seconds = parseFloat(token[3].replace(',', '.'))\n    return (hours % 24) * MILLISECONDS_IN_HOUR +\n      minutes * MILLISECONDS_IN_MINUTE +\n      seconds * 1000\n  }\n\n  // Invalid ISO-formatted time\n  return null\n}\n\nfunction parseTimezone (timezoneString) {\n  var token\n  var absoluteOffset\n\n  // Z\n  token = parseTokenTimezoneZ.exec(timezoneString)\n  if (token) {\n    return 0\n  }\n\n  // hh\n  token = parseTokenTimezoneHH.exec(timezoneString)\n  if (token) {\n    absoluteOffset = parseInt(token[2], 10) * 60\n    return (token[1] === '+') ? -absoluteOffset : absoluteOffset\n  }\n\n  // hh:mm or hhmm\n  token = parseTokenTimezoneHHMM.exec(timezoneString)\n  if (token) {\n    absoluteOffset = parseInt(token[2], 10) * 60 + parseInt(token[3], 10)\n    return (token[1] === '+') ? -absoluteOffset : absoluteOffset\n  }\n\n  return 0\n}\n\nfunction dayOfISOYear (isoYear, week, day) {\n  week = week || 0\n  day = day || 0\n  var date = new Date(0)\n  date.setUTCFullYear(isoYear, 0, 4)\n  var fourthOfJanuaryDay = date.getUTCDay() || 7\n  var diff = week * 7 + day + 1 - fourthOfJanuaryDay\n  date.setUTCDate(date.getUTCDate() + diff)\n  return date\n}\n\nmodule.exports = parse\n","'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n","/**\n *  Exports the FHIR model data for STU3.  This is an internal structure that\n *  will likely evolve as more FHIR specific processing is added.\n */\nmodule.exports = {\n  /**\n   *  A hash of resource element paths (e.g. Observation.value) that are known\n   *  to point to fiels that are choice types.\n   */\n  choiceTypePaths: require('./choiceTypePaths.json'),\n\n  /**\n   *  A hash from paths to the path for which their content is defined, e.g.\n   *  Questionnaire.item.item -> Questionnaire.item.\n   */\n  pathsDefinedElsewhere: require('./pathsDefinedElsewhere.json')\n}\n","// Contains the FHIRPath Aggregate functions.\n// (Section 7 of the FHIRPath 2.0.0 (N1) specification).\n\nlet engine = {};\nconst math = require(\"./math\");\nconst equality  = require(\"./equality\");\nconst util = require('./utilities');\n\nengine.aggregateMacro = function(data, expr, initialValue) {\n  return data.reduce((total, x, i) => {\n    this.$index = i;\n    return this.$total = expr(x);\n  }, this.$total = initialValue);\n};\n\nengine.countFn = function(x) {\n  if (x && x.length) {\n    return x.length;\n  } else {\n    return 0;\n  }\n};\n\n// Shortcut for \"value.aggregate($this+$total, 0)\"\nengine.sumFn = function(data) {\n  return engine.aggregateMacro.apply(this, [data, ($this) => {\n    return math.plus(util.arraify($this), util.arraify(this.$total));\n  }, 0]);\n};\n\n// Shortcut for \"value.aggregate(iif($total.empty(), $this, iif($this < $total, $this, $total)))\"\nengine.minFn = function (data) {\n  return engine.aggregateMacro.apply(this, [data, (curr) => {\n    const $this = util.arraify(curr);\n    const $total = util.arraify(this.$total);\n    return util.isEmpty($total)\n      ? $this\n      : equality.lt($this, $total) ? $this : $total;\n  }]);\n};\n\n// Shortcut for \"value.aggregate(iif($total.empty(), $this, iif($this > $total, $this, $total)))\"\nengine.maxFn = function (data) {\n  return engine.aggregateMacro.apply(this, [data, (curr) => {\n    const $this = util.arraify(curr);\n    const $total = util.arraify(this.$total);\n    return util.isEmpty($total)\n      ? $this\n      : equality.gt($this, $total) ? $this : $total;\n  }]);\n};\n\n// Shortcut for \"value.sum()/value.count()\"\nengine.avgFn = function (data) {\n  return math.div(engine.sumFn(data), engine.countFn(data));\n};\n\nmodule.exports = engine;\n","// This file holds code to hande the FHIRPath Math functions.\n\nvar deepEqual = require('./deep-equal');\n\nvar engine = {};\n\n\n// b is assumed to have one element and it tests whether b[0] is in a\nfunction containsImpl(a,b){\n  if(b.length == 0) { return true; }\n  for(var i = 0; i < a.length; i++){\n    if(deepEqual(a[i], b[0])) { return true; }\n  }\n  return false;\n}\n\nengine.contains = function(a, b){\n  if(b.length == 0) { return []; }\n  if(a.length == 0) { return false; }\n  if(b.length > 1) {\n    throw new Error(\"Expected singleton on right side of contains, got \" + JSON.stringify(b));\n  }\n  return containsImpl(a,b);\n};\n\nengine.in = function(a, b){\n  if(a.length == 0) { return []; }\n  if(b.length == 0) { return false; }\n  if(a.length > 1) {\n    throw new Error(\"Expected singleton on right side of in, got \" + JSON.stringify(b));\n  }\n  return containsImpl(b,a);\n};\n\nmodule.exports = engine;\n","// This file holds code to hande the FHIRPath Combining functions.\n\nconst combineFns = {};\nconst {distinctFn} = require('./filtering');\nconst hashObject = require('./hash-object');\n\ncombineFns.union = function(coll1, coll2){\n  return distinctFn(coll1.concat(coll2));\n};\n\ncombineFns.combineFn = function(coll1, coll2){\n  return coll1.concat(coll2);\n};\n\ncombineFns.intersect = function(coll1, coll2) {\n  let result = [];\n  const coll1Length = coll1.length;\n  let uncheckedLength = coll2.length;\n\n  if (coll1Length && uncheckedLength) {\n    let coll2hash = {};\n    coll2.forEach(item => {\n      const hash = hashObject(item);\n      if (coll2hash[hash]) {\n        uncheckedLength--;\n      } else {\n        coll2hash[hash] = true;\n      }\n    });\n\n    for (let i=0; i<coll1Length && uncheckedLength > 0; ++i) {\n      let item = coll1[i];\n      let hash = hashObject(item);\n      if (coll2hash[hash]) {\n        result.push(item);\n        coll2hash[hash] = false;\n        uncheckedLength--;\n      }\n    }\n  }\n\n  return result;\n};\n\n\nmodule.exports = combineFns;\n","// These are values that should not change during an evaluation of a FHIRPath\n// expression (e.g. the return value of today(), per the spec.)  They are\n// constant during at least one evaluation.\n\nmodule.exports = {\n  /**\n   *  Resets the constants.  Should be called when before the engine starts its\n   *  processing.\n   */\n  reset: function() {\n    this.nowDate = new Date(); // a Date object representing \"now\"\n    this.today = null;\n    this.now = null;\n    this.timeOfDay = null;\n    this.localTimezoneOffset = null;\n  },\n\n  /**\n   *  The cached value of today().\n   */\n  today: null,\n\n  /**\n   *  The cached value of now().\n   */\n  now: null,\n\n  /**\n   *  The cached value of timeOfDay().\n   */\n  timeOfDay: null\n};\n","var engine = {};\nconst types = require('./types');\nconst constants = require('./constants');\nconst FP_DateTime = types.FP_DateTime;\nconst FP_Time = types.FP_Time;\n\n/**\n *  Implements FHIRPath now().\n */\nengine.now = function(){\n  if (!constants.now) {\n    // return new FP_DateTime((new Date()).toISOString());\n    // The above would construct an FP_DateTime with a timezone of \"Z\", which\n    // would not make a difference for computation, but if the end result of an\n    // expression is \"now()\", then it would look different when output to a user.\n    // Construct it ourselves to preserve timezone\n    var now = constants.nowDate; // a JS Date\n    var isoStr = FP_DateTime.isoDateTime(now);\n    constants.now = new FP_DateTime(isoStr);\n  }\n  return constants.now;\n};\n\n\n/**\n *  Implements FHIRPath today().  See comments in now(). This does not\n *  include a timezone offset.\n */\nengine.today = function(){\n  if (!constants.today) {\n    // Construct the string ourselves to preserve timezone\n    var now = constants.nowDate; // a JS Date\n    var isoStr = FP_DateTime.isoDate(now);\n    constants.today = new FP_DateTime(isoStr);\n  }\n  return constants.today;\n};\n\n/**\n *  Implements FHIRPath timeOfDay().  See comments in now(). This does not\n *  include a timezone offset.\n */\nengine.timeOfDay = function() {\n  if (!constants.timeOfDay) {\n    // Construct the string ourselves to preserve timezone\n    const now = constants.nowDate; // a JS Date\n    const isoStr = FP_DateTime.isoTime(now);\n    constants.timeOfDay = new FP_Time(isoStr);\n  }\n  return constants.timeOfDay;\n};\n\nmodule.exports = engine;\n","// Originally copied from node-deep-equal\n// (https://github.com/substack/node-deep-equal), with modifications.\n// For the license for node-deep-equal, see the bottom of this file.\n\nvar types = require('./types');\nvar FP_Type = types.FP_Type;\nvar util = require('./utilities');\nvar numbers = require('./numbers');\nvar pSlice = Array.prototype.slice;\nvar objectKeys = Object.keys;\nvar isArguments = function (object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n};\n\nfunction isString(myVar) {\n  return (typeof myVar === 'string' || myVar instanceof String);\n}\n\nfunction isNumber(n) {\n  return !isNaN(parseFloat(n)) && isFinite(n);\n}\n\nfunction normalizeStr(x) {\n  return x.toUpperCase().replace(/\\s+/, ' ');\n}\n\n/**\n * Performs a deep comparison between two values to determine if they are equal.\n * When you need to compare many objects, you can use hashObject instead for\n * optimization (if changes are needed here, they are likely also needed there).\n * @param {any} actual - one of the comparing objects\n * @param {any} expected - one of the comparing objects\n * @param {Object} [opts] - comparison options\n * @param {boolean} [opts.fuzzy] - false (by default), if comparing objects for\n *   equality (see https://hl7.org/fhirpath/#equals).\n *   true, if comparing objects for equivalence\n *   (see https://hl7.org/fhirpath/#equivalent).\n * @return {boolean}\n */\nfunction deepEqual(actual, expected, opts) {\n  actual = util.valData(actual);\n  expected = util.valData(expected);\n  if (!opts) opts = {};\n\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n  }\n\n  if (opts.fuzzy) {\n    if(isString(actual) && isString(expected)) {\n      return normalizeStr(actual) == normalizeStr(expected);\n    }\n    if(isNumber(actual) && isNumber(expected)) {\n      return numbers.isEquivalent(actual, expected);\n    }\n  }\n  else { // !opts.fuzzy\n    // If these are numbers, they need to be rounded to the maximum supported\n    // precision to remove floating point arithmetic errors (e.g. 0.1+0.1+0.1 should\n    // equal 0.3) before comparing.\n    if (typeof actual === 'number' && typeof expected === 'number') {\n      return numbers.isEqual(actual, expected);\n    }\n  }\n\n  if (actual instanceof Date && expected instanceof Date) {\n    return actual.getTime() === expected.getTime();\n  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {\n    return actual === expected;\n  }\n  else {\n    var actualIsFPT = actual instanceof FP_Type;\n    var expectedIsFPT = expected instanceof FP_Type;\n    if (actualIsFPT && expectedIsFPT) { // if both are FP_Type\n      let rtn = opts.fuzzy ? actual.equivalentTo(expected) :\n        actual.equals(expected); // May return undefined\n      return rtn;\n    }\n    else if (actualIsFPT || expectedIsFPT) { // if only one is an FP_Type\n      // See if the other is convertible.\n      let fpt, nonFPT;\n      if (actualIsFPT) {\n        fpt = actual;\n        nonFPT = expected;\n      }\n      else {\n        fpt = expected;\n        nonFPT = actual;\n      }\n      let rtn = typeof nonFPT === 'string';\n      if (rtn) {\n        let d = fpt.constructor.checkString(nonFPT);\n        if (d) {\n          rtn = opts.fuzzy ? actual.equivalentTo(d) :\n            fpt.equals(d); // May return undefined\n        }\n        else\n          rtn = false; // not a date string\n      }\n      return rtn;\n    }\n    // 7.4. For all other Object pairs, including Array objects, equivalence is\n    // determined by having the same number of owned properties (as verified\n    // with Object.prototype.hasOwnProperty.call), the same set of keys\n    // (although not necessarily the same order), equivalent values for every\n    // corresponding key, and an identical 'prototype' property. Note: this\n    // accounts for both named and indexed properties on Arrays.\n    return objEquiv(actual, expected, opts);\n  }\n}\n\nfunction isUndefinedOrNull(value) {\n  return value === null || value === undefined;\n}\n\nfunction objEquiv(a, b, opts) {\n  var i, key;\n  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))\n    return false;\n  // an identical 'prototype' property.\n  if (a.prototype !== b.prototype) return false;\n  //~~~I've managed to break Object.keys through screwy arguments passing.\n  //   Converting to array solves the problem.\n  if(isArguments(a) || isArguments(b)) {\n    a = isArguments(a) ? pSlice.call(a) : a;\n    b = isArguments(b) ? pSlice.call(b) : b;\n    return deepEqual(a, b, opts);\n  }\n  try {\n    var ka = objectKeys(a), kb = objectKeys(b);\n  } catch (e) {//happens when one is a string literal and the other isn't\n    return false;\n  }\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length != kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  // If the length of the array is one, return the value of deepEqual (which can\n  // be \"undefined\".\n  if (ka.length === 1) {\n    key = ka[0];\n    return deepEqual(a[key], b[key], opts);\n  }\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!deepEqual(a[key], b[key], opts)) return false;\n  }\n  return typeof a === typeof b;\n}\n\nmodule.exports = deepEqual;\n\n// The license for node-deep-equal, on which the above code is based, is as\n// follows:\n//\n// This software is released under the MIT license:\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\n// this software and associated documentation files (the \"Software\"), to deal in\n// the Software without restriction, including without limitation the rights to\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n// the Software, and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n","// This file holds code to hande the FHIRPath Math functions.\n\nvar util = require(\"./utilities\");\nvar deepEqual = require('./deep-equal');\nvar types = require('./types');\nconst FP_Type = types.FP_Type;\nconst FP_DateTime = types.FP_DateTime;\nconst FP_Time = types.FP_Time;\n\nvar engine = {};\n\nfunction equality(x,y){\n  if(util.isEmpty(x) || util.isEmpty(y)) { return []; }\n  return deepEqual(x, y);\n}\n\nfunction equivalence(x,y){\n  if(util.isEmpty(x) && util.isEmpty(y)) { return [true]; }\n  if(util.isEmpty(x) || util.isEmpty(y)) { return []; }\n  return deepEqual(x, y, {fuzzy: true});\n}\n\nengine.equal = function(a, b){\n  return equality(a, b);\n};\n\nengine.unequal = function(a, b){\n  var eq = equality(a, b);\n  return eq === undefined ? undefined : !eq;\n};\n\nengine.equival = function(a, b){\n  return equivalence(a, b);\n};\n\nengine.unequival = function(a, b){\n  return !equivalence(a, b);\n};\n\n/**\n *  Checks that the types of a and b are suitable for comparison in an\n *  inequality expression.  It is assumed that a check has already been made\n *  that there is at least one value in a and b.\n * @param a the left side of the inequality expression (which should be an array of\n *  one value).\n * @param b the right side of the inequality expression (which should be an array of\n *  one value).\n * @return the singleton values of the arrays a, and b.  If one was an FP_Type\n *  and the other was convertible, the coverted value will be retureed.\n */\nfunction typecheck(a, b){\n  let rtn = null;\n  util.assertAtMostOne(a, \"Singleton was expected\");\n  util.assertAtMostOne(b, \"Singleton was expected\");\n  a = util.valData(a[0]);\n  b = util.valData(b[0]);\n  let lClass = a.constructor;\n  let rClass = b.constructor;\n  if (lClass != rClass) {\n    // See if one is an FPDateTime or FTTime while the other is a string.\n    var d;\n    if (lClass === String && (rClass === FP_DateTime || rClass === FP_Time)) {\n      d = rClass.checkString(a);\n      if (d)\n        rtn = [d, b];\n    }\n    else if (rClass === String && (lClass===FP_DateTime || lClass===FP_Time)) {\n      d = lClass.checkString(b);\n      if (d)\n        rtn = [a, d];\n    }\n\n    if (!rtn) {\n      util.raiseError('Type of \"'+a+'\" ('+lClass.name+') did not match type of \"'+\n        b+'\" ('+rClass.name+')', 'InequalityExpression');\n    }\n  }\n  return rtn ? rtn : [a, b];\n}\n\nengine.lt = function(a, b){\n  if (!a.length || !b.length) return [];\n  const [a0, b0] = typecheck(a,b);\n  if (a0 instanceof FP_Type) {\n    const compare = a0.compare(b0);\n    return compare === null ? [] : compare < 0;\n  }\n  return a0 < b0;\n};\n\nengine.gt = function(a, b){\n  if (!a.length || !b.length) return [];\n  const [a0, b0] = typecheck(a,b);\n  if (a0 instanceof FP_Type) {\n    const compare = a0.compare(b0);\n    return compare === null ? [] : compare > 0;\n  }\n  return a0 > b0;\n};\n\nengine.lte = function(a, b){\n  if (!a.length || !b.length) return [];\n  const [a0, b0] = typecheck(a,b);\n  if (a0 instanceof FP_Type) {\n    const compare = a0.compare(b0);\n    return compare === null ? [] : compare <= 0;\n  }\n  return  a0 <= b0;\n};\n\nengine.gte = function(a, b){\n  if (!a.length || !b.length) return [];\n  const [a0, b0] = typecheck(a,b);\n  if (a0 instanceof FP_Type) {\n    const compare = a0.compare(b0);\n    return compare === null ? [] : compare >= 0;\n  }\n  return a0 >= b0;\n};\n\n\nmodule.exports = engine;\n","// This file holds code to hande the FHIRPath Existence functions (5.1 in the\n// specification).\n\nconst util = require(\"./utilities\");\nconst {whereMacro, distinctFn} = require(\"./filtering\");\nconst misc = require(\"./misc\");\nconst hashObject = require('./hash-object');\n\nconst engine = {};\nengine.emptyFn = util.isEmpty;\n\nengine.notFn = function(coll) {\n  let d = misc.singleton(coll, 'Boolean');\n  return (typeof (d) === 'boolean') ? !d : [];\n};\n\nengine.existsMacro  = function(coll, expr) {\n  var vec = coll;\n  if (expr) {\n    return engine.existsMacro(whereMacro(coll, expr));\n  }\n  return !util.isEmpty(vec);\n};\n\nengine.allMacro = function(coll, expr) {\n  for (let i=0, len=coll.length; i<len; ++i) {\n    this.$index = i;\n    if(!util.isTrue(expr(coll[i]))){\n      return [false];\n    }\n  }\n  return [true];\n};\n\nengine.allTrueFn  = function(x) {\n  let rtn = true;\n  for (let i=0, len=x.length; i<len && rtn; ++i) {\n    let xi = util.assertType(x[i], [\"boolean\"], \"allTrue\");\n    rtn = xi === true;\n  }\n  return [rtn];\n};\n\nengine.anyTrueFn  = function(x) {\n  let rtn = false;\n  for (let i=0, len=x.length; i<len && !rtn; ++i) {\n    let xi = util.assertType(x[i], [\"boolean\"], \"anyTrue\");\n    rtn = xi === true;\n  }\n  return [rtn];\n};\n\nengine.allFalseFn  = function(x) {\n  let rtn = true;\n  for (let i=0, len=x.length; i<len && rtn; ++i) {\n    let xi = util.assertType(x[i], [\"boolean\"], \"allFalse\");\n    rtn = xi === false;\n  }\n  return [rtn];\n};\n\nengine.anyFalseFn  = function(x) {\n  let rtn = false;\n  for (let i=0, len=x.length; i<len && !rtn; ++i) {\n    let xi = util.assertType(x[i], [\"boolean\"], \"anyFalse\");\n    rtn = xi === false;\n  }\n  return [rtn];\n};\n\n\n/**\n *  Returns true if coll1 is a subset of coll2.\n */\nfunction subsetOf(coll1, coll2) {\n  const coll1Length = coll1.length;\n  let rtn = coll1Length <= coll2.length;\n  if (rtn && coll1Length) {\n    const c2Hash = coll2.reduce((hash, item) => {\n      hash[hashObject(item)] = true;\n      return hash;\n    }, {});\n    rtn = !coll1.some(item => !c2Hash[hashObject(item)]);\n  }\n  return rtn;\n}\n\nengine.subsetOfFn = function(coll1, coll2) {\n  return [subsetOf(coll1, coll2)];\n};\n\nengine.supersetOfFn = function(coll1, coll2) {\n  return [subsetOf(coll2, coll1)];\n};\n\nengine.isDistinctFn = function(x) {\n  return [x.length === distinctFn(x).length];\n};\n\nmodule.exports = engine;\n","// This is fhirpath interpreter\n// everything starts at evaluate function,\n// which is passed  fhirpath AST and resource.\n//\n// We reduce/eval recursively each node in AST\n// passing the context and current data\n//\n// each AST node has eval function, which should be registered in evalTable\n// and named after node type\n// if node needs to eval father it's children it has to call `doEval` function\n//\n// most of nodes do function or operator invocation at the end\n//\n// For invocation's and operator's there is one lookup table -\n// invocationTable and two helper functions doInvoke and infixInvoke for\n// operators\n// 1. operator or function is looked up in table\n// 2. using signature (in  .arity property) unpack parameters\n// 3. check params types\n// 4. do call function\n// 5. wrap result by util.arraify\n//\n// if function is nullable\n// and one of parameters is empty/null - function will not be invoked and empty\n// result returned\n//\n// Not solved problem is overloading functions by types - for example + operator defined\n// for strings and numbers\n// we can make dispatching params type dependent - let see\n\nconst {version} = require('../package.json');\nconst parser = require(\"./parser\");\nconst util = require(\"./utilities\");\nrequire(\"./polyfill\");\nconst constants = require('./constants');\n\nlet engine    = {}; // the object with all FHIRPath functions and operations\nlet existence = require(\"./existence\");\nlet filtering = require(\"./filtering\");\nlet aggregate = require(\"./aggregate\");\nlet combining = require(\"./combining\");\nlet misc      = require(\"./misc\");\nlet equality  = require(\"./equality\");\nlet collections  = require(\"./collections\");\nlet math      = require(\"./math\");\nlet strings   = require(\"./strings\");\nlet navigation= require(\"./navigation\");\nlet datetime  = require(\"./datetime\");\nlet logic  = require(\"./logic\");\nconst types = require(\"./types\");\nconst {\n  FP_DateTime, FP_Time, FP_Quantity,\n  FP_Type, ResourceNode, TypeInfo\n} = types;\nlet makeResNode = ResourceNode.makeResNode;\n\n// * fn: handler\n// * arity: is index map with type signature\n//   if type is in array (like [Boolean]) - this means\n//   function accepts value of this type or empty value {}\n// * nullable - means propagate empty result, i.e. instead\n//   calling function if one of params is  empty return empty\n\nengine.invocationTable = {\n  empty:        {fn: existence.emptyFn},\n  not:          {fn: existence.notFn},\n  exists:       {fn: existence.existsMacro, arity: {0: [], 1: [\"Expr\"]}},\n  all:          {fn: existence.allMacro, arity: {1: [\"Expr\"]}},\n  allTrue:      {fn: existence.allTrueFn},\n  anyTrue:      {fn: existence.anyTrueFn},\n  allFalse:     {fn: existence.allFalseFn},\n  anyFalse:     {fn: existence.anyFalseFn},\n  subsetOf:     {fn: existence.subsetOfFn, arity: {1: [\"AnyAtRoot\"]}},\n  supersetOf:   {fn: existence.supersetOfFn, arity: {1: [\"AnyAtRoot\"]}},\n  isDistinct:   {fn: existence.isDistinctFn},\n  distinct:     {fn: filtering.distinctFn},\n  count:        {fn: aggregate.countFn},\n  where:        {fn: filtering.whereMacro, arity: {1: [\"Expr\"]}},\n  extension:    {fn: filtering.extension, arity: {1: [\"String\"]}},\n  select:       {fn: filtering.selectMacro, arity: {1: [\"Expr\"]}},\n  aggregate:    {fn: aggregate.aggregateMacro, arity: {1: [\"Expr\"], 2: [\"Expr\", \"Integer\"]}},\n  sum:          {fn: aggregate.sumFn},\n  min:          {fn: aggregate.minFn},\n  max:          {fn: aggregate.maxFn},\n  avg:          {fn: aggregate.avgFn},\n  single:       {fn: filtering.singleFn},\n  first:        {fn: filtering.firstFn},\n  last:         {fn: filtering.lastFn},\n  type:         {fn: types.typeFn, arity: {0: []}},\n  ofType:       {fn: filtering.ofTypeFn, arity: {1: [\"TypeSpecifier\"]}},\n  is:           {fn: types.isFn, arity: {1: [\"TypeSpecifier\"]}},\n  tail:         {fn: filtering.tailFn},\n  take:         {fn: filtering.takeFn, arity: {1: [\"Integer\"]}},\n  skip:         {fn: filtering.skipFn, arity: {1: [\"Integer\"]}},\n  combine:      {fn: combining.combineFn, arity: {1: [\"AnyAtRoot\"]}},\n  union:        {fn: combining.union,   arity: {1: [\"AnyAtRoot\"]}},\n  intersect:    {fn: combining.intersect,   arity: {1: [\"AnyAtRoot\"]}},\n  iif:          {fn: misc.iifMacro,    arity: {2: [\"Expr\", \"Expr\"], 3: [\"Expr\", \"Expr\", \"Expr\"]}},\n  trace:        {fn: misc.traceFn,     arity: {0: [], 1: [\"String\"]}},\n  toInteger:    {fn: misc.toInteger},\n  toDecimal:    {fn: misc.toDecimal},\n  toString:     {fn: misc.toString},\n  toDateTime:   {fn: misc.toDateTime},\n  toTime:       {fn: misc.toTime},\n  toBoolean:    {fn: misc.toBoolean},\n  toQuantity:   {fn: misc.toQuantity, arity: {0: [], 1: [\"String\"]}},\n  convertsToBoolean:    {fn: misc.createConvertsToFn(misc.toBoolean, 'boolean')},\n  convertsToInteger:    {fn: misc.createConvertsToFn(misc.toInteger, 'number')},\n  convertsToDecimal:    {fn: misc.createConvertsToFn(misc.toDecimal, 'number')},\n  convertsToString:     {fn: misc.createConvertsToFn(misc.toString, 'string')},\n  convertsToDateTime:   {fn: misc.createConvertsToFn(misc.toDateTime, FP_DateTime)},\n  convertsToTime:       {fn: misc.createConvertsToFn(misc.toTime, FP_Time)},\n  convertsToQuantity:   {fn: misc.createConvertsToFn(misc.toQuantity, FP_Quantity)},\n\n  indexOf:        {fn: strings.indexOf,          arity: {1: [\"String\"]}},\n  substring:      {fn: strings.substring,        arity: {1: [\"Integer\"], 2: [\"Integer\",\"Integer\"]}},\n  startsWith:     {fn: strings.startsWith,       arity: {1: [\"String\"]}},\n  endsWith:       {fn: strings.endsWith,         arity: {1: [\"String\"]}},\n  contains:       {fn: strings.containsFn,       arity: {1: [\"String\"]}},\n  upper:          {fn: strings.upper},\n  lower:          {fn: strings.lower},\n  replace:        {fn: strings.replace,          arity: {2: [\"String\", \"String\"]}},\n  matches:        {fn: strings.matches,          arity: {1: [\"String\"]}},\n  replaceMatches: {fn: strings.replaceMatches,   arity: {2: [\"String\", \"String\"]}},\n  length:         {fn: strings.length },\n  toChars:        {fn: strings.toChars },\n\n  abs:            {fn: math.abs},\n  ceiling:        {fn: math.ceiling},\n  exp:            {fn: math.exp},\n  floor:          {fn: math.floor},\n  ln:             {fn: math.ln},\n  log:            {fn: math.log, arity:  {1: [\"Number\"]}, nullable: true},\n  power:          {fn: math.power, arity:  {1: [\"Number\"]}, nullable: true},\n  round:          {fn: math.round, arity:  {1: [\"Number\"]}},\n  sqrt:           {fn: math.sqrt},\n  truncate:       {fn: math.truncate},\n\n  now:            {fn: datetime.now },\n  today:          {fn: datetime.today },\n  timeOfDay:      {fn: datetime.timeOfDay },\n\n  repeat:          {fn: filtering.repeatMacro, arity: {1: [\"Expr\"]}},\n  children:        {fn: navigation.children },\n  descendants:     {fn: navigation.descendants },\n\n  \"|\":          {fn: combining.union,   arity: {2: [\"Any\", \"Any\"]}},\n  \"=\":          {fn: equality.equal,   arity: {2: [\"Any\", \"Any\"]}, nullable: true},\n  \"!=\":         {fn: equality.unequal,   arity: {2: [\"Any\", \"Any\"]}, nullable: true},\n  \"~\":          {fn: equality.equival,   arity: {2: [\"Any\", \"Any\"]}},\n  \"!~\":         {fn: equality.unequival,   arity: {2: [\"Any\", \"Any\"]}},\n  \"<\":          {fn: equality.lt,   arity: {2: [\"Any\", \"Any\"]}, nullable: true},\n  \">\":          {fn: equality.gt,   arity: {2: [\"Any\", \"Any\"]}, nullable: true},\n  \"<=\":         {fn: equality.lte,  arity: {2: [\"Any\", \"Any\"]}, nullable: true},\n  \">=\":         {fn: equality.gte,  arity: {2: [\"Any\", \"Any\"]}, nullable: true},\n  \"containsOp\": {fn: collections.contains,   arity: {2: [\"Any\", \"Any\"]}},\n  \"inOp\":       {fn: collections.in,  arity: {2: [\"Any\", \"Any\"]}},\n  \"isOp\":       {fn: types.isFn,  arity: {2: [\"Any\", \"TypeSpecifier\"]}},\n  \"&\":          {fn: math.amp,     arity:  {2: [\"String\", \"String\"]}},\n  \"+\":          {fn: math.plus,    arity:  {2: [\"Any\", \"Any\"]}, nullable: true},\n  \"-\":          {fn: math.minus,   arity:  {2: [\"Any\", \"Any\"]}, nullable: true},\n  \"*\":          {fn: math.mul,     arity:  {2: [\"Number\", \"Number\"]}, nullable: true},\n  \"/\":          {fn: math.div,     arity:  {2: [\"Number\", \"Number\"]}, nullable: true},\n  \"mod\":        {fn: math.mod,     arity:  {2: [\"Number\", \"Number\"]}, nullable: true},\n  \"div\":        {fn: math.intdiv,  arity:  {2: [\"Number\", \"Number\"]}, nullable: true},\n\n  \"or\":        {fn: logic.orOp,  arity:       {2: [[\"Boolean\"], [\"Boolean\"]]}},\n  \"and\":       {fn: logic.andOp,  arity:      {2: [[\"Boolean\"], [\"Boolean\"]]}},\n  \"xor\":       {fn: logic.xorOp,  arity:      {2: [[\"Boolean\"], [\"Boolean\"]]}},\n  \"implies\":   {fn: logic.impliesOp,  arity:  {2: [[\"Boolean\"], [\"Boolean\"]]}},\n};\n\nengine.InvocationExpression = function(ctx, parentData, node) {\n  return node.children.reduce(function(acc, ch) {\n    return engine.doEval(ctx, acc, ch);\n  }, parentData);\n};\n\nengine.TermExpression = function(ctx, parentData, node) {\n  if (parentData) {\n    parentData = parentData.map((x) => {\n      if (x instanceof Object && x.resourceType) {\n        return makeResNode(x, x.resourceType);\n      }\n      return x;\n    });\n  }\n\n  return engine.doEval(ctx,parentData, node.children[0]);\n};\n\nengine.PolarityExpression = function(ctx, parentData, node) {\n  var sign = node.terminalNodeText[0]; // either - or + per grammar\n  var rtn = engine.doEval(ctx,parentData, node.children[0]);\n  if (rtn.length !== 1) {  // not yet in spec, but per Bryn Rhodes\n    throw new Error('Unary ' + sign +\n     ' can only be applied to an individual number.');\n  }\n  if (typeof rtn[0] != 'number' || isNaN(rtn[0]))\n    throw new Error('Unary ' + sign + ' can only be applied to a number.');\n  if (sign === '-')\n    rtn[0] = -rtn[0];\n  return rtn;\n};\n\nengine.TypeSpecifier = function(ctx, parentData, node) {\n  let namespace, name;\n  const identifiers = node.text.split('.').map(i => i.replace(/(^`|`$)/g, \"\"));\n  switch (identifiers.length) {\n    case 2:\n      [namespace, name] = identifiers;\n      break;\n    case 1:\n      [name] = identifiers;\n      break;\n    default:\n      throw new Error(\"Expected TypeSpecifier node, got \" + JSON.stringify(node));\n  }\n\n  return new TypeInfo({ namespace, name });\n};\n\nengine.ExternalConstantTerm = function(ctx, parentData, node) {\n  var extConstant = node.children[0];\n  var identifier = extConstant.children[0];\n  var varName = engine.Identifier(ctx, parentData, identifier)[0];\n  var value = ctx.vars[varName];\n  if (!(varName in ctx.vars)) {\n    throw new Error(\n      \"Attempting to access an undefined environment variable: \" + varName\n    );\n  }\n  // For convenience, we all variable values to be passed in without their array\n  // wrapper.  However, when evaluating, we need to put the array back in.\n  return value === undefined || value === null\n    ? []\n    : value instanceof Array ? value : [value];\n};\n\nengine.LiteralTerm = function(ctx, parentData, node) {\n  var term = node.children[0];\n  if(term){\n    return engine.doEval(ctx, parentData, term);\n  } else {\n    return [node.text];\n  }\n};\n\nengine.StringLiteral = function(ctx, parentData, node) {\n  // Remove the beginning and ending quotes.\n  var rtn = node.text.replace(/(^'|'$)/g, \"\");\n  rtn = rtn.replace(/\\\\(u\\d{4}|.)/g, function(match, submatch) {\n    switch(match) {\n      case '\\\\r':\n        return '\\r';\n      case '\\\\n':\n        return \"\\n\";\n      case '\\\\t':\n        return '\\t';\n      case '\\\\f':\n        return '\\f';\n      default:\n        if (submatch.length > 1)\n          return String.fromCharCode('0x'+submatch.slice(1));\n        else\n          return submatch;\n    }\n  });\n  return [rtn];\n};\n\nengine.BooleanLiteral = function(ctx, parentData, node) {\n  if(node.text  === \"true\") {\n    return [true];\n  } else {\n    return [false];\n  }\n};\n\nengine.QuantityLiteral = function(ctx, parentData, node) {\n  var valueNode = node.children[0];\n  var value = Number(valueNode.terminalNodeText[0]);\n  var unitNode = valueNode.children[0];\n  var unit = unitNode.terminalNodeText[0];\n  // Sometimes the unit is in a child node of the child\n  if (!unit && unitNode.children)\n    unit = unitNode.children[0].terminalNodeText[0];\n\n  return [new FP_Quantity(value, unit)];\n};\n\nengine.DateTimeLiteral = function(ctx, parentData, node) {\n  var dateStr = node.text.slice(1); // Remove the @\n  return [new FP_DateTime(dateStr)];\n};\n\nengine.TimeLiteral = function(ctx, parentData, node) {\n  var timeStr = node.text.slice(1); // Remove the @\n  return [new FP_Time(timeStr)];\n};\n\nengine.NumberLiteral = function(ctx, parentData, node) {\n  return [Number(node.text)];\n};\n\nengine.Identifier = function(ctx, parentData, node) {\n  return [node.text.replace(/(^`|`$)/g, \"\")];\n};\n\nengine.InvocationTerm = function(ctx, parentData, node) {\n  return engine.doEval(ctx,parentData, node.children[0]);\n};\n\n\nengine.MemberInvocation = function(ctx, parentData, node ) {\n  const key = engine.doEval(ctx, parentData, node.children[0])[0];\n  const model = ctx.model;\n\n  if (parentData) {\n    if(util.isCapitalized(key)) {\n      return parentData\n        .filter((x) => x instanceof ResourceNode && x.path === key);\n    } else {\n      const path = parentData.path || parentData.__path__;\n      return parentData.reduce(function(acc, res) {\n        res = makeResNode(res, path);\n        var childPath = res.path + '.' + key;\n        if (model) {\n          let defPath = model.pathsDefinedElsewhere[childPath];\n          if (defPath)\n            childPath = defPath;\n        }\n        let toAdd, _toAdd;\n        let actualTypes = model && model.choiceTypePaths[childPath];\n        if (actualTypes) {\n          // Use actualTypes to find the field's value\n          for (let t of actualTypes) {\n            let field = key + t;\n            toAdd = res.data[field];\n            if (toAdd !== undefined) {\n              childPath = t;\n              _toAdd = res.data['_' + key];\n              break;\n            } else {\n              toAdd = res._data[key];\n            }\n          }\n        }\n        else {\n          toAdd = res.data[key];\n          if (toAdd !== undefined) {\n            _toAdd = res.data['_' + key];\n          } else {\n            toAdd = res._data[key];\n          }\n          if (key === 'extension') {\n            childPath = 'Extension';\n          }\n        }\n\n        if (util.isSome(toAdd)) {\n          if(Array.isArray(toAdd)) {\n            acc = acc.concat(toAdd.map((x, i)=>\n              makeResNode(x, childPath, _toAdd && _toAdd[i])));\n          } else {\n            acc.push(makeResNode(toAdd, childPath, _toAdd));\n          }\n          return acc;\n        } else {\n          return acc;\n        }\n      }, []);\n    }\n  } else {\n    return [];\n  }\n};\n\nengine.IndexerExpression = function(ctx, parentData, node) {\n  const coll_node = node.children[0];\n  const idx_node = node.children[1];\n  var coll = engine.doEval(ctx, parentData, coll_node);\n  var idx = engine.doEval(ctx, parentData, idx_node);\n\n  if(util.isEmpty(idx)) {\n    return [];\n  }\n\n  var idxNum = parseInt(idx[0]);\n  if(coll && util.isSome(idxNum) && coll.length>idxNum && idxNum>=0) {\n    return [coll[idxNum]];\n  } else {\n    return [];\n  }\n};\n\nengine.Functn = function(ctx, parentData, node) {\n  return node.children.map(function(x) {\n    return engine.doEval(ctx, parentData, x);\n  });\n};\n\nengine.realizeParams = function(ctx, parentData, args) {\n  if(args && args[0] && args[0].children) {\n    return args[0].children.map(function(x) {\n      return engine.doEval(ctx, parentData, x);\n    });\n  } else {\n    return [];\n  }\n};\n\nfunction makeParam(ctx, parentData, type, param) {\n  if(type === \"Expr\"){\n    return function(data) {\n      ctx.$this = util.arraify(data);\n      return engine.doEval(ctx, ctx.$this, param);\n    };\n  }\n  if(type === \"AnyAtRoot\"){\n    ctx.$this = ctx.$this || ctx.dataRoot;\n    return engine.doEval(ctx, ctx.$this, param);\n  }\n  if(type === \"Identifier\"){\n    if(param.type === \"TermExpression\") {\n      return param.text;\n    } else {\n      throw new Error(\"Expected identifier node, got \" + JSON.stringify(param));\n    }\n  }\n\n  if(type === \"TypeSpecifier\") {\n    return engine.TypeSpecifier(ctx, parentData, param);\n  }\n\n  ctx.$this = parentData;\n  const res = engine.doEval(ctx, parentData, param);\n  if(type === \"Any\") {\n    return res;\n  }\n  if(Array.isArray(type)) {\n    if(res.length === 0) {\n      return [];\n    } else {\n      type = type[0];\n    }\n  }\n  return misc.singleton(res, type);\n}\n\nfunction doInvoke(ctx, fnName, data, rawParams){\n  var invoc = engine.invocationTable[fnName];\n  var res;\n  if(invoc) {\n    if(!invoc.arity){\n      if(!rawParams){\n        res = invoc.fn.call(ctx, util.arraify(data));\n        return util.arraify(res);\n      } else {\n        throw new Error(fnName + \" expects no params\");\n      }\n    } else {\n      var paramsNumber = rawParams ? rawParams.length : 0;\n      var argTypes = invoc.arity[paramsNumber];\n      if(argTypes){\n        var params = [];\n        for(var i = 0; i < paramsNumber; i++){\n          var tp = argTypes[i];\n          var pr = rawParams[i];\n          params.push(makeParam(ctx, data, tp, pr));\n        }\n        params.unshift(data);\n        if(invoc.nullable) {\n          if(params.some(isNullable)){\n            return [];\n          }\n        }\n        res = invoc.fn.apply(ctx, params);\n        return util.arraify(res);\n      } else {\n        console.log(fnName + \" wrong arity: got \" + paramsNumber );\n        return [];\n      }\n    }\n  } else {\n    throw new Error(\"Not implemented: \" + fnName);\n  }\n}\nfunction isNullable(x) {\n  return x === null || x === undefined || util.isEmpty(x);\n}\n\nfunction infixInvoke(ctx, fnName, data, rawParams){\n  var invoc = engine.invocationTable[fnName];\n  if(invoc && invoc.fn) {\n    var paramsNumber = rawParams ? rawParams.length : 0;\n    if(paramsNumber !== 2) { throw new Error(\"Infix invoke should have arity 2\"); }\n    var argTypes = invoc.arity[paramsNumber];\n    if(argTypes){\n      var params = [];\n      for(var i = 0; i < paramsNumber; i++){\n        var tp = argTypes[i];\n        var pr = rawParams[i];\n        params.push(makeParam(ctx, data, tp, pr));\n      }\n      if(invoc.nullable) {\n        if(params.some(isNullable)){\n          return [];\n        }\n      }\n      var res = invoc.fn.apply(ctx, params);\n      return util.arraify(res);\n    } else {\n      console.log(fnName + \" wrong arity: got \" + paramsNumber );\n      return [];\n    }\n  } else {\n    throw new Error(\"Not impl \" + fnName);\n  }\n}\n\nengine.FunctionInvocation = function(ctx, parentData, node) {\n  var args = engine.doEval(ctx, parentData, node.children[0]);\n  const fnName = args[0];\n  args.shift();\n  var rawParams = args && args[0] && args[0].children;\n  return doInvoke(ctx, fnName, parentData, rawParams);\n};\n\nengine.ParamList = function(ctx, parentData, node) {\n  // we do not eval param list because sometimes it should be passed as\n  // lambda/macro (for example in case of where(...)\n  return node;\n};\n\n\nengine.UnionExpression = function(ctx, parentData, node) {\n  return infixInvoke(ctx, '|', parentData, node.children);\n};\n\nengine.ThisInvocation = function(ctx) {\n  return ctx.$this;\n};\n\nengine.TotalInvocation = function(ctx) {\n  return util.arraify(ctx.$total);\n};\n\nengine.IndexInvocation = function(ctx) {\n  return util.arraify(ctx.$index);\n};\n\nengine.OpExpression = function(ctx, parentData, node) {\n  var op = node.terminalNodeText[0];\n  return infixInvoke(ctx, op, parentData, node.children);\n};\n\nengine.AliasOpExpression = function(map){\n  return function(ctx, parentData, node) {\n    var op = node.terminalNodeText[0];\n    var alias = map[op];\n    if(!alias) { throw new Error(\"Do not know how to alias \" + op + \" by \" + JSON.stringify(map)); }\n    return infixInvoke(ctx, alias, parentData, node.children);\n  };\n};\n\nengine.NullLiteral = function() {\n  return [];\n};\n\nengine.ParenthesizedTerm = function(ctx, parentData, node) {\n  return engine.doEval(ctx, parentData, node.children[0]);\n};\n\n\nengine.evalTable = { // not every evaluator is listed if they are defined on engine\n  BooleanLiteral: engine.BooleanLiteral,\n  EqualityExpression: engine.OpExpression,\n  FunctionInvocation: engine.FunctionInvocation,\n  Functn: engine.Functn,\n  Identifier: engine.Identifier,\n  IndexerExpression: engine.IndexerExpression,\n  InequalityExpression: engine.OpExpression,\n  InvocationExpression: engine.InvocationExpression,\n  AdditiveExpression: engine.OpExpression,\n  MultiplicativeExpression: engine.OpExpression,\n  TypeExpression: engine.AliasOpExpression({\"is\": \"isOp\"}),\n  MembershipExpression: engine.AliasOpExpression({\"contains\": \"containsOp\", \"in\": \"inOp\"}),\n  NullLiteral: engine.NullLiteral,\n  EntireExpression: engine.InvocationTerm,\n  InvocationTerm: engine.InvocationTerm,\n  LiteralTerm: engine.LiteralTerm,\n  MemberInvocation: engine.MemberInvocation,\n  NumberLiteral: engine.NumberLiteral,\n  ParamList: engine.ParamList,\n  ParenthesizedTerm: engine.ParenthesizedTerm,\n  StringLiteral: engine.StringLiteral,\n  TermExpression: engine.TermExpression,\n  ThisInvocation: engine.ThisInvocation,\n  TotalInvocation: engine.TotalInvocation,\n  IndexInvocation: engine.IndexInvocation,\n  UnionExpression: engine.UnionExpression,\n  OrExpression: engine.OpExpression,\n  ImpliesExpression: engine.OpExpression,\n  AndExpression: engine.OpExpression,\n  XorExpression: engine.OpExpression\n};\n\n\nengine.doEval = function(ctx, parentData, node) {\n  const evaluator = engine.evalTable[node.type] || engine[node.type];\n  if(evaluator){\n    return evaluator.call(engine, ctx, parentData, node);\n  } else {\n    throw new Error(\"No \" + node.type + \" evaluator \");\n  }\n};\n\nfunction parse(path) {\n  return parser.parse(path);\n}\n\n\n/**\n *  Applies the given parsed FHIRPath expression to the given resource,\n *  returning the result of doEval.\n * @param {(object|object[])} resource -  FHIR resource, bundle as js object or array of resources\n *  This resource will be modified by this function to add type information.\n * @param {string} parsedPath - fhirpath expression, sample 'Patient.name.given'\n * @param {object} context - a hash of variable name/value pairs.\n * @param {object} model - The \"model\" data object specific to a domain, e.g. R4.\n *  For example, you could pass in the result of require(\"fhirpath/fhir-context/r4\");\n */\nfunction applyParsedPath(resource, parsedPath, context, model) {\n  constants.reset();\n  let dataRoot = util.arraify(resource);\n  // doEval takes a \"ctx\" object, and we store things in that as we parse, so we\n  // need to put user-provided variable data in a sub-object, ctx.vars.\n  // Set up default standard variables, and allow override from the variables.\n  // However, we'll keep our own copy of dataRoot for internal processing.\n  let vars = {context: resource, ucum: 'http://unitsofmeasure.org'};\n  let ctx = {dataRoot, vars: Object.assign(vars, context), model};\n  let rtn = engine.doEval(ctx, dataRoot, parsedPath.children[0]);\n  let firstRtn = Array.isArray(rtn) ? rtn[0] : rtn;\n  // Path for the data extracted from the resource.\n  let path = firstRtn instanceof ResourceNode ? firstRtn.path : null;\n\n  // Resolve any internal \"ResourceNode\" instances.  Continue to let FP_Type\n  // subclasses through.\n  rtn = (function visit(n) {\n    n = util.valData(n);\n    if (Array.isArray(n)) {\n      for (let i=0, len=n.length; i<len; ++i)\n        n[i] = visit(n[i]);\n    }\n    else if (typeof n === 'object' && !(n instanceof FP_Type)) {\n      for (let k of Object.keys(n))\n        n[k] = visit(n[k]);\n    }\n    return n;\n  })(rtn);\n  // Add a hidden (non-enumerable) property with the path to the data extracted\n  // from the resource.\n  if (path && typeof rtn === 'object') {\n    Object.defineProperty(rtn, '__path__', {value: path});\n  }\n  return rtn;\n}\n\n/**\n *  Evaluates the \"path\" FHIRPath expression on the given resource or part of the resource,\n *  using data from \"context\" for variables mentioned in the \"path\" expression.\n * @param {(object|object[])} fhirData -  FHIR resource, part of a resource (in this case\n *  path.base should be provided), bundle as js object or array of resources.\n *  This object/array will be modified by this function to add type information.\n * @param {string|object} path - string with FHIRPath expression, sample 'Patient.name.given',\n *  or object, if fhirData represents the part of the FHIR resource:\n * @param {string} path.base - base path in resource from which fhirData was extracted\n * @param {string} path.expression - FHIRPath expression relative to path.base\n * @param {object} context - a hash of variable name/value pairs.\n * @param {object} model - The \"model\" data object specific to a domain, e.g. R4.\n *  For example, you could pass in the result of require(\"fhirpath/fhir-context/r4\");\n */\nfunction evaluate(fhirData, path, context, model) {\n  return compile(path, model)(fhirData, context);\n}\n\n/**\n *  Returns a function that takes a resource or part of the resource and an\n *  optional context hash (see \"evaluate\"), and returns the result of evaluating\n *  the given FHIRPath expression on that resource.  The advantage of this\n *  function over \"evaluate\" is that if you have multiple resources, the given\n *  FHIRPath expression will only be parsed once.\n * @param {string|object} path - string with FHIRPath expression to be parsed or object:\n * @param {string} path.base - base path in resource from which a part of\n *   the resource was extracted\n * @param {string} path.expression - FHIRPath expression relative to path.base\n * @param {object} model - The \"model\" data object specific to a domain, e.g. R4.\n *  For example, you could pass in the result of require(\"fhirpath/fhir-context/r4\");\n */\nfunction compile(path, model) {\n  if (typeof path === 'object') {\n    const node = parse(path.expression);\n    return function (fhirData, context) {\n      const inObjPath = fhirData && fhirData.__path__;\n      const resource = makeResNode(fhirData, path.base || inObjPath);\n      return applyParsedPath(resource, node, context, model);\n    };\n  } else {\n    const node = parse(path);\n    return function (fhirData, context) {\n      const inObjPath = fhirData && fhirData.__path__;\n      const resource = inObjPath ? makeResNode(fhirData, inObjPath) : fhirData;\n      return applyParsedPath(resource, node, context, model);\n    };\n  }\n}\n\nmodule.exports = {\n  version,\n  parse,\n  compile,\n  evaluate,\n  // Might as well export the UCUM library, since we are using it.\n  ucumUtils: require('@lhncbc/ucum-lhc').UcumLhcUtils.getInstance()\n};\n","// Contains the FHIRPath Filtering and Projection functions.  (Section 5.2 of\n// the FHIRPath 1.0.0 specification).\n\n/**\n *  Adds the filtering and projection functions to the given FHIRPath engine.\n */\nconst util = require('./utilities');\nconst {TypeInfo, ResourceNode} = require('./types');\nconst hashObject = require('./hash-object');\n\nvar engine = {};\nengine.whereMacro = function(parentData, expr) {\n  if(parentData !== false && ! parentData) { return []; }\n\n  return util.flatten(parentData.filter((x, i) => {\n    this.$index = i;\n    return expr(x)[0];\n  }));\n};\n\nengine.extension = function(parentData, url) {\n  if(parentData !== false && ! parentData || !url) { return []; }\n\n  return util.flatten(parentData.map((x, i) => {\n    this.$index = i;\n    const extensions = (x && (x.data && x.data.extension || x._data && x._data.extension));\n    if (extensions) {\n      return extensions\n        .filter(extension => extension.url === url)\n        .map(x => ResourceNode.makeResNode(x, 'Extension'));\n    }\n    return [];\n  }));\n};\n\nengine.selectMacro = function(data, expr) {\n  if(data !== false && ! data) { return []; }\n  return util.flatten(data.map((x, i) => {\n    this.$index = i;\n    return expr(x);\n  }));\n};\n\nengine.repeatMacro = function(parentData, expr) {\n  if(parentData !== false && ! parentData) { return []; }\n\n  let res = [];\n  const unique = {};\n  const length = parentData.length;\n  for(let i = 0; i < length; ++i) {\n    let newItems = parentData[i];\n    do {\n      newItems = expr(newItems)\n        .filter(item => {\n          const key = hashObject(item);\n          const isUnique = !unique[key];\n          if (isUnique) {\n            unique[key] = true;\n          }\n          return isUnique;\n        });\n    } while (res.length < res.push.apply(res, newItems));\n  }\n  return res;\n};\n\n//TODO: behavior on object?\nengine.singleFn = function(x) {\n  if(x.length == 1){\n    return x;\n  } else if (x.length == 0) {\n    return [];\n  } else {\n    //TODO: should throw error?\n    return {$status: \"error\", $error: \"Expected single\"};\n  }\n};\n\n\nengine.firstFn = function(x) {\n  return x[0];\n};\n\nengine.lastFn = function(x) {\n  return x[x.length - 1];\n};\n\nengine.tailFn = function(x) {\n  return x.slice(1, x.length);\n};\n\nengine.takeFn = function(x, n) {\n  return x.slice(0, n);\n};\n\nengine.skipFn = function(x, num) {\n  return x.slice(num, x.length);\n};\n\nengine.ofTypeFn = function(coll, typeInfo) {\n  return coll.filter(value => {\n    return TypeInfo.fromValue(value).is(typeInfo);\n  });\n};\n\nengine.distinctFn = function(x) {\n  let unique = [];\n  // Since this requires a deep equals, use a hash table (on JSON strings) for\n  // efficiency.\n  if (x.length > 0) {\n    let uniqueHash = {};\n    for (let i=0, len=x.length; i<len; ++i) {\n      let xObj = x[i];\n      let xStr = hashObject(xObj);\n      if (!uniqueHash[xStr]) {\n        unique.push(xObj);\n        uniqueHash[xStr] = true;\n      }\n    }\n  }\n  return unique;\n};\n\nmodule.exports = engine;\n","const ucumUtils = require('@lhncbc/ucum-lhc').UcumLhcUtils.getInstance();\nconst {roundToMaxPrecision} = require('./numbers');\nconst {valData} = require('./utilities');\nconst {FP_Type, FP_Quantity} = require('./types');\n\n/**\n *  Returns a JSON version of the given object, but with the object's keys\n *  in sorted order (or at least stable order,\n *  see https://stackoverflow.com/a/35810961/360782) and the values in\n *  unified forms, e.g. \"1 year\" is converted to the same value as \"12 months\",\n *  \"3 'min'\" is converted to the same value as \"120 'sec'\".\n *  This function is used instead of deepEqual for optimization when you need\n *  to compare many objects.\n */\nfunction hashObject(obj) {\n  return JSON.stringify(prepareObject(obj));\n}\n\n/**\n * Brings an object to the unified form so that it can be serialized to JSON to\n * compare with other objects according to https://hl7.org/fhirpath/#equals\n * This function is following the logic from deepEqual (if changes are needed\n * here they are likely also needed there).\n */\nfunction prepareObject(value) {\n  value = valData(value);\n\n  if (typeof value === 'number') {\n    return roundToMaxPrecision(value);\n  } else if (value instanceof Date) {\n    return value.toISOString();\n  } if (value instanceof FP_Quantity) {\n    const magnitude = FP_Quantity._yearMonthConversionFactor[value.unit];\n    if (magnitude) {\n      return '_!yearMonth!_:' + magnitude * value.value;\n    } else {\n      const ucumQuantity = FP_Quantity.toUcumQuantity(value.value, value.unit);\n      const unit = ucumUtils.getSpecifiedUnit(ucumQuantity.unit).unit;\n      return '_!' + unit.property_ + '!_:' + unit.magnitude_ * ucumQuantity.value;\n    }\n  } else if (value instanceof FP_Type) {\n    return value.toString();\n  } else if (typeof value === 'object') {\n    return Array.isArray(value) ?\n      value.map(prepareObject) :\n      Object.keys(value).sort().reduce(\n        (o, key) => {\n          const v = value[key];\n          o[key] = prepareObject(v);\n          return o;\n        }, {});\n  }\n\n  return  value;\n}\n\nmodule.exports = hashObject;\n","var engine = {};\n\nengine.orOp = function(a, b) {\n  if(Array.isArray(b)){\n    if(a === true){\n      return true;\n    } else if (a === false) {\n      return [];\n    } else if (Array.isArray(a)) {\n      return [];\n    }\n  }\n  if(Array.isArray(a)){\n    if(b === true ){\n      return true;\n    } else {\n      return [];\n    }\n  }\n  return a || b;\n};\n\nengine.andOp = function(a, b) {\n  if(Array.isArray(b)){\n    if(a === true){\n      return [];\n    } else if (a === false) {\n      return false;\n    } else if (Array.isArray(a)) {\n      return [];\n    }\n  }\n  if(Array.isArray(a)){\n    if(b === true ){\n      return [];\n    } else {\n      return false;\n    }\n  }\n  return a && b;\n};\n\nengine.xorOp = function(a, b) {\n  // If a or b are arrays, they must be the empty set.\n  // In that case, the result is always the empty set.\n  if (Array.isArray(a) || Array.isArray(b))\n    return [];\n  return ( a && !b ) || ( !a && b );\n};\n\nengine.impliesOp = function(a, b) {\n  if(Array.isArray(b)){\n    if(a === true){\n      return [];\n    } else if (a === false) {\n      return true;\n    } else if (Array.isArray(a)) {\n      return [];\n    }\n  }\n  if(Array.isArray(a)){\n    if(b === true ){\n      return true;\n    } else {\n      return [];\n    }\n  }\n  if(a === false) { return true; }\n  return (a && b);\n};\n\n\nmodule.exports = engine;\n","// This file holds code to hande the FHIRPath Math functions.\n\nvar types = require('./types');\nlet {FP_TimeBase, FP_Quantity} = types;\nconst util = require(\"./utilities\");\n\n/**\n *  Adds the math functions to the given FHIRPath engine.\n */\n\nvar engine = {};\n\nfunction ensureNumberSingleton(x){\n  let d = util.valData(x);\n  if (typeof d !== 'number') {\n    if (d.length == 1 && typeof (d=util.valData(d[0])) === 'number') {\n      return d;\n    }else{\n      throw new Error(\"Expected number, but got \" + JSON.stringify(d || x));\n    }\n  }\n  else\n    return d;\n}\n\nfunction isEmpty(x) {\n  if(typeof(x) == 'number'){\n    return false;\n  }\n  return x.length == 0;\n}\n\nengine.amp = function(x, y){\n  return (x || \"\") + (y || \"\");\n};\n\n//HACK: for only polymorphic function\n//  Actually, \"minus\" is now also polymorphic\nengine.plus = function(xs, ys){\n  if(xs.length == 1 && ys.length == 1) {\n    var x = util.valData(xs[0]);\n    var y = util.valData(ys[0]);\n    // In the future, this and other functions might need to return ResourceNode\n    // to preserve the type information (integer vs decimal, and maybe decimal\n    // vs string if decimals are represented as strings), in order to support\n    // \"as\" and \"is\", but that support is deferred for now.\n    if(typeof x == \"string\" && typeof y == \"string\") {\n      return x + y;\n    }\n    if(typeof x == \"number\" && typeof y == \"number\") {\n      return x + y;\n    }\n    if(x instanceof FP_TimeBase && y instanceof FP_Quantity) {\n      return x.plus(y);\n    }\n  }\n  throw new Error(\"Cannot \" + JSON.stringify(xs) + \" + \" + JSON.stringify(ys));\n};\n\nengine.minus = function(xs, ys){\n  if(xs.length == 1 && ys.length == 1) {\n    var x = util.valData(xs[0]);\n    var y = util.valData(ys[0]);\n    if(typeof x == \"number\" && typeof y == \"number\")\n      return x - y;\n    if(x instanceof FP_TimeBase && y instanceof FP_Quantity)\n      return x.plus(new FP_Quantity(-y.value, y.unit));\n  }\n  throw new Error(\"Cannot \" + JSON.stringify(xs) + \" - \" + JSON.stringify(ys));\n};\n\n\nengine.mul = function(x, y){\n  return x * y;\n};\n\nengine.div = function(x, y){\n  if (y === 0) return [];\n  return x / y;\n};\n\nengine.intdiv = function(x, y){\n  if (y === 0) return [];\n  return Math.floor(x / y);\n};\n\nengine.mod = function(x, y){\n  if (y === 0) return [];\n  return x % y;\n};\n\nengine.abs = function(x){\n  if (isEmpty(x)){\n    return [];\n  }else{\n    let num = ensureNumberSingleton(x);\n    return Math.abs(num);\n  }\n};\n\nengine.ceiling = function(x){\n  if (isEmpty(x)){\n    return [];\n  }else{\n    let num = ensureNumberSingleton(x);\n    return Math.ceil(num);\n  }\n};\n\nengine.exp = function(x){\n  if (isEmpty(x)){\n    return [];\n  }else{\n    let num = ensureNumberSingleton(x);\n    return Math.exp(num);\n  }\n};\n\nengine.floor = function(x){\n  if (isEmpty(x)){\n    return [];\n  }else{\n    let num = ensureNumberSingleton(x);\n    return Math.floor(num);\n  }\n};\n\nengine.ln = function(x){\n  if (isEmpty(x)){\n    return [];\n  }else{\n    let num = ensureNumberSingleton(x);\n    return Math.log(num);\n  }\n};\n\nengine.log = function(x, base){\n  if (isEmpty(x) || isEmpty(base)){\n    return [];\n  }else{\n    let num = ensureNumberSingleton(x);\n    let num2 = ensureNumberSingleton(base);\n    return (Math.log(num) / Math.log(num2));\n  }\n};\n\nengine.power = function(x, degree){\n  if (isEmpty(x) || isEmpty(degree)){\n    return [];\n  }else{\n    let num = ensureNumberSingleton(x);\n    let num2 = ensureNumberSingleton(degree);\n    if (num < 0 && (Math.floor(num2) != num2)){\n      return [];\n    }else{\n      return Math.pow(num, num2);\n    }\n  }\n};\n\nengine.round = function(x, acc){\n  if (isEmpty(x)){\n    return [];\n  }else{\n    let num = ensureNumberSingleton(x);\n    if (isEmpty(acc)){\n      return (Math.round(num));\n    }else{\n      let num2 = ensureNumberSingleton(acc);\n      let degree = Math.pow(10, num2);\n      return (Math.round(num * degree) / degree);\n    }\n  }\n};\n\nengine.sqrt = function(x){\n  if (isEmpty(x)){\n    return [];\n  }else{\n    let num = ensureNumberSingleton(x);\n    if (num < 0) {\n      return [];\n    }else{\n      return Math.sqrt(num);\n    }\n  }\n};\n\nengine.truncate = function(x){\n  if (isEmpty(x)){\n    return [];\n  }else{\n    let num = ensureNumberSingleton(x);\n    return Math.trunc(num);\n  }\n};\n\nmodule.exports = engine;\n","\n// This file holds code to hande the FHIRPath Existence functions (5.1 in the\n// specification).\n\nvar util = require(\"./utilities\");\nvar types = require(\"./types\");\n\nconst { FP_Quantity } = types;\n\nvar engine = {};\n\nengine.iifMacro = function(data, cond, ok, fail) {\n  if(util.isTrue(cond(data))) {\n    return ok(data);\n  } else {\n    return fail ? fail(data) : [];\n  }\n};\n\nengine.traceFn = function(x, label) {\n  console.log(\"TRACE:[\" + (label || \"\") + \"]\", JSON.stringify(x, null, \" \"));\n  return x;\n};\n\nvar intRegex = /^[+-]?\\d+$/;\nengine.toInteger = function(coll){\n  if(coll.length !== 1) { return []; }\n  var v = util.valData(coll[0]);\n  if(v === false) {return 0;}\n  if(v === true) {return 1;}\n  if(typeof v === \"number\") {\n    if(Number.isInteger(v)) {\n      return v;\n    } else {\n      return [];\n    }\n  }\n  if(typeof v === \"string\" && intRegex.test(v)) {\n    return parseInt(v);\n  }\n  return [];\n};\n\nconst quantityRegex = /^((\\+|-)?\\d+(\\.\\d+)?)\\s*(('[^']+')|([a-zA-Z]+))?$/,\n  quantityRegexMap = {value:1,unit:5,time:6};\nengine.toQuantity = function (coll, toUnit) {\n  let result;\n  // Surround UCUM unit code in the toUnit parameter with single quotes\n  if (toUnit && !FP_Quantity.mapTimeUnitsToUCUMCode[toUnit]) {\n    toUnit = `'${toUnit}'`;\n  }\n\n  if (coll.length > 1) {\n    throw new Error(\"Could not convert to quantity: input collection contains multiple items\");\n  } else if (coll.length === 1) {\n    const item = coll[0],\n      v = util.valData(item);\n    let quantityRegexRes;\n\n    if (typeof v === \"number\") {\n      result = new FP_Quantity(v, '\\'1\\'');\n    } else if (v instanceof FP_Quantity) {\n      result = v;\n    } else if (typeof v === 'boolean') {\n      result = new FP_Quantity(v ? 1 : 0, '\\'1\\'');\n    } else if (typeof v === \"string\" && (quantityRegexRes = quantityRegex.exec(v)) ) {\n      const value = quantityRegexRes[quantityRegexMap.value],\n        unit = quantityRegexRes[quantityRegexMap.unit],\n        time = quantityRegexRes[quantityRegexMap.time];\n\n      // UCUM unit code in the input string must be surrounded with single quotes\n      if (!time || FP_Quantity.mapTimeUnitsToUCUMCode[time]) {\n        result = new FP_Quantity(Number(value), unit || time || '\\'1\\'');\n      }\n    }\n\n    if (result && toUnit && result.unit !== toUnit) {\n      result = FP_Quantity.convUnitTo(result.unit, result.value, toUnit);\n    }\n  }\n\n  return result || [];\n};\n\nvar numRegex = /^[+-]?\\d+(\\.\\d+)?$/;\nengine.toDecimal = function(coll){\n  if(coll.length !== 1) { return []; }\n  var v = util.valData(coll[0]);\n  if(v === false) {return 0;}\n  if(v === true) {return 1.0;}\n  if(typeof v === \"number\") {\n    return v;\n  }\n  if(typeof v === \"string\" && numRegex.test(v)) {\n    return parseFloat(v);\n  }\n  return [];\n};\n\nengine.toString = function(coll){\n  if(coll.length !== 1) { return []; }\n  var v = util.valData(coll[0]);\n  return v.toString();\n};\n\n\n/**\n *  Defines a function on engine called to+timeType (e.g., toDateTime, etc.).\n * @param timeType The string name of a class for a time type (e.g. \"FP_DateTime\").\n */\nfunction defineTimeConverter(timeType) {\n  let timeName = timeType.slice(3); // Remove 'FP_'\n  engine['to'+timeName] = function(coll) {\n    var rtn = [];\n    if (coll.length > 1)\n      throw Error('to '+timeName+' called for a collection of length '+coll.length);\n    if (coll.length === 1) {\n      var t = types[timeType].checkString(util.valData(coll[0]));\n      if (t)\n        rtn = t;\n    }\n    return rtn;\n  };\n}\ndefineTimeConverter('FP_DateTime');\ndefineTimeConverter('FP_Time');\n\n// Possible string values convertible to the true boolean value\nconst trueStrings = ['true', 't', 'yes', 'y', '1', '1.0'].reduce((acc, val) => {\n  acc[val] = true;\n  return acc;\n}, {});\n\n// Possible string values convertible to the false boolean value\nconst falseStrings = ['false', 'f', 'no', 'n', '0', '0.0'].reduce((acc, val) => {\n  acc[val] = true;\n  return acc;\n}, {});\n\nengine.toBoolean = function (coll) {\n  if(coll.length !== 1) {\n    return [];\n  }\n\n  const v = util.valData(coll[0]);\n  switch (typeof v) {\n    case 'boolean':\n      return v;\n    case 'number':\n      if (v === 1) {\n        return true;\n      }\n      if (v === 0) {\n        return false;\n      }\n      break;\n    case 'string':\n      // eslint-disable-next-line no-case-declarations\n      const lowerCaseValue = v.toLowerCase();\n      if (trueStrings[lowerCaseValue]) {\n        return true;\n      }\n      if (falseStrings[lowerCaseValue]) {\n        return false;\n      }\n  }\n  return [];\n};\n\n/**\n * Creates function that checks if toFunction returns specified type\n * @param {function(coll: array): <type|[]>} toFunction\n * @param {string|class} type - specifies type, for example: 'string' or FP_Quantity\n * @return {function(coll: array)}\n */\nengine.createConvertsToFn = function (toFunction, type) {\n  if (typeof type === 'string') {\n    return function (coll) {\n      if (coll.length !== 1) {\n        return [];\n      }\n\n      return typeof toFunction(coll) === type;\n    };\n  }\n\n  return function (coll) {\n    if (coll.length !== 1) {\n      return [];\n    }\n\n    return toFunction(coll) instanceof type;\n  };\n};\n\nconst singletonEvalByType = {\n  \"Integer\": function(coll){\n    const d = util.valData(coll[0]);\n    if (Number.isInteger(d)) {\n      return d;\n    }\n  },\n  \"Boolean\": function(coll){\n    const d = util.valData(coll[0]);\n    if (d === true || d === false) {\n      return d;\n    } else if (coll.length === 1) {\n      return true;\n    }\n  },\n  \"Number\": function(coll) {\n    const d = util.valData(coll[0]);\n    if (typeof d === \"number\") {\n      return d;\n    }\n  },\n  \"String\": function(coll){\n    const d = util.valData(coll[0]);\n    if (typeof d === \"string\") {\n      return d;\n    }\n  }\n};\n\n/**\n * Converts a collection to a singleton of the specified type.\n * The result can be an empty array if input collection is empty.\n * See http://hl7.org/fhirpath/#singleton-evaluation-of-collections for details.\n * @param {Array} coll - collection\n * @param {string} type - 'Integer', 'Boolean', 'Number' or 'String'\n * @throws {Error}  if there is more than one item in input collection,\n *   or an item that is not a specified type\n * @return {*|[]} the value of specified type or empty array\n */\nengine.singleton = function (coll, type) {\n  if(coll.length > 1){\n    throw new Error(\"Unexpected collection\" + JSON.stringify(coll) +\n      \"; expected singleton of type \" + type);\n  } else if (coll.length === 0) {\n    return [];\n  }\n  const toSingleton = singletonEvalByType[type];\n  if (toSingleton) {\n    const value = toSingleton(coll);\n    if (value !== undefined) {\n      return value;\n    }\n    throw new Error(`Expected ${type.toLowerCase()}, but got: ${JSON.stringify(coll)}`);\n  }\n  throw new Error('Not supported type ' + type);\n};\n\nmodule.exports = engine;\n","const util = require(\"./utilities\");\nconst {ResourceNode}  = require(\"./types\");\nlet makeResNode = ResourceNode.makeResNode;\n\nvar engine = {};\n\nengine.children = function(coll){\n  let model = this.model; // \"this\" is the context object\n\n  return coll.reduce(function(acc, x){\n    let d = util.valData(x);\n    x = makeResNode(x);\n    if(typeof d === 'object'){\n      for (var prop of Object.keys(d)) {\n        var v = d[prop];\n        var childPath = x.path + '.' + prop;\n        if (model) {\n          let defPath = model.pathsDefinedElsewhere[childPath];\n          if (defPath)\n            childPath = defPath;\n        }\n        if(Array.isArray(v)){\n          acc.push.apply(acc, v.map((n)=>makeResNode(n, childPath)));\n        } else {\n          acc.push(makeResNode(v, childPath));\n        }\n      }\n      return acc;\n    } else {\n      return acc;\n    }\n  }, []);\n};\n\nengine.descendants = function(coll){\n  var ch = engine.children.call(this, coll); // \"this\" is the context object\n  var res = [];\n  while(ch.length > 0){\n    res.push.apply(res, ch);\n    ch = engine.children.call(this, ch);\n  }\n  return res;\n};\n\nmodule.exports = engine;\n","let numberFns = {};\n\n// Returns the number of digits in the number after the decimal point, ignoring\n// trailing zeros.\nfunction decimalPlaces(x) {\n  // Based on https://stackoverflow.com/a/9539746/360782\n  // Make sure it is a number and use the builtin number -> string.\n  const s = \"\" + (+x),\n    match = /(\\d+)(?:\\.(\\d+))?(?:[eE]([+-]?\\d+))?$/.exec(s);\n  // NaN or Infinity or integer.\n  // We arbitrarily decide that Infinity is integral.\n  if (!match) { return 0; }\n  // Count the number of digits in the fraction and subtract the\n  // exponent to simulate moving the decimal point left by exponent places.\n  // 1.234e+2 has 1 fraction digit and '234'.length -  2 == 1\n  // 1.234e-2 has 5 fraction digit and '234'.length - -2 == 5\n  //var wholeNum = match[1];\n  const fraction = match[2],\n    exponent = match[3];\n  return Math.max(\n    0,  // lower limit.\n    (fraction === '0' ? 0 : (fraction || '').length)  // fraction length\n    - (exponent || 0));  // exponent\n}\n\n/**\n *  Rounds a number to the specified number of decimal places.\n * @param x the decimal number to be rounded\n * @param n the (maximum) number of decimal places to preserve.  (The result\n *  could contain fewer if the decimal digits in x contain zeros).\n */\nfunction roundToDecimalPlaces (x, n) {\n  const scale = Math.pow(10, n);\n  return Math.round(x*scale)/scale;\n}\n\n/**\n *  The smallest representable number in FHIRPath.\n */\nconst PRECISION_STEP = 1e-8;\n\n/**\n *  Rounds a number to the nearest multiple of PRECISION_STEP.\n */\nconst roundToMaxPrecision = numberFns.roundToMaxPrecision = function (x) {\n  return Math.round(x/PRECISION_STEP)*PRECISION_STEP;\n};\n\n/**\n * Determines numbers equivalence\n * @param {number} actual\n * @param {number} expected\n * @return {boolean}\n */\nnumberFns.isEquivalent = function(actual, expected) {\n  if(Number.isInteger(actual) && Number.isInteger(expected)) {\n    return actual === expected;\n  }\n\n  const prec = Math.min(decimalPlaces(actual), decimalPlaces(expected));\n\n  if(prec === 0){\n    return Math.round(actual) === Math.round(expected);\n  } else {\n    // Note: parseFloat(0.00000011).toPrecision(7) ===  \"1.100000e-7\"\n    // It does # of significant digits, not decimal places.\n    return roundToDecimalPlaces(actual, prec) ===\n      roundToDecimalPlaces(expected, prec);\n  }\n};\n\n/**\n * Determines numbers equality\n * @param {number} actual\n * @param {number} expected\n * @return {boolean}\n */\nnumberFns.isEqual = function(actual, expected) {\n  return roundToMaxPrecision(actual) === roundToMaxPrecision(expected);\n};\n\nmodule.exports = numberFns;\n","// This is a modified version of antr4's index.js, in which\n// the \"require\" statements of two unused classes are commented out\n// to avoid introducing a dependency on Node.js' \"fs\" package.\n\n/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\nexports.atn = require('antlr4/src/antlr4/atn/index');\nexports.codepointat = require('antlr4/src/antlr4/polyfills/codepointat');\nexports.dfa = require('antlr4/src/antlr4/dfa/index');\nexports.fromcodepoint = require('antlr4/src/antlr4/polyfills/fromcodepoint');\nexports.tree = require('antlr4/src/antlr4/tree/index');\nexports.error = require('antlr4/src/antlr4/error/index');\nexports.Token = require('antlr4/src/antlr4/Token').Token;\n// Commented out to avoid the problem with 'fs' during the webpack build\n// exports.CharStreams = require('antlr4/src/antlr4/CharStreams');\nexports.CommonToken = require('antlr4/src/antlr4/Token').CommonToken;\nexports.InputStream = require('antlr4/src/antlr4/InputStream');\n// Commented out to avoid the problem with 'fs' during the webpack build\n// exports.FileStream = require('antlr4/src/antlr4/FileStream');\nexports.CommonTokenStream = require('antlr4/src/antlr4/CommonTokenStream');\nexports.Lexer = require('antlr4/src/antlr4/Lexer');\nexports.Parser = require('antlr4/src/antlr4/Parser');\nvar pc = require('antlr4/src/antlr4/PredictionContext');\nexports.PredictionContextCache = pc.PredictionContextCache;\nexports.ParserRuleContext = require('antlr4/src/antlr4/ParserRuleContext');\nexports.Interval = require('antlr4/src/antlr4/IntervalSet').Interval;\nexports.IntervalSet = require('antlr4/src/antlr4/IntervalSet').IntervalSet;\nexports.Utils = require('antlr4/src/antlr4/Utils');\nexports.LL1Analyzer = require('antlr4/src/antlr4/LL1Analyzer').LL1Analyzer;\n","// Generated from FHIRPath.g4 by ANTLR 4.9.3\n// jshint ignore: start\nconst antlr4 = require('../antlr4-index');\n\n\n\nconst serializedATN = [\"\\u0003\\u608b\\ua72a\\u8133\\ub9ed\\u417c\\u3be7\\u7786\",\n    \"\\u5964\\u0002A\\u0203\\b\\u0001\\u0004\\u0002\\t\\u0002\\u0004\\u0003\\t\\u0003\",\n    \"\\u0004\\u0004\\t\\u0004\\u0004\\u0005\\t\\u0005\\u0004\\u0006\\t\\u0006\\u0004\\u0007\",\n    \"\\t\\u0007\\u0004\\b\\t\\b\\u0004\\t\\t\\t\\u0004\\n\\t\\n\\u0004\\u000b\\t\\u000b\\u0004\",\n    \"\\f\\t\\f\\u0004\\r\\t\\r\\u0004\\u000e\\t\\u000e\\u0004\\u000f\\t\\u000f\\u0004\\u0010\",\n    \"\\t\\u0010\\u0004\\u0011\\t\\u0011\\u0004\\u0012\\t\\u0012\\u0004\\u0013\\t\\u0013\",\n    \"\\u0004\\u0014\\t\\u0014\\u0004\\u0015\\t\\u0015\\u0004\\u0016\\t\\u0016\\u0004\\u0017\",\n    \"\\t\\u0017\\u0004\\u0018\\t\\u0018\\u0004\\u0019\\t\\u0019\\u0004\\u001a\\t\\u001a\",\n    \"\\u0004\\u001b\\t\\u001b\\u0004\\u001c\\t\\u001c\\u0004\\u001d\\t\\u001d\\u0004\\u001e\",\n    \"\\t\\u001e\\u0004\\u001f\\t\\u001f\\u0004 \\t \\u0004!\\t!\\u0004\\\"\\t\\\"\\u0004#\",\n    \"\\t#\\u0004$\\t$\\u0004%\\t%\\u0004&\\t&\\u0004\\'\\t\\'\\u0004(\\t(\\u0004)\\t)\\u0004\",\n    \"*\\t*\\u0004+\\t+\\u0004,\\t,\\u0004-\\t-\\u0004.\\t.\\u0004/\\t/\\u00040\\t0\\u0004\",\n    \"1\\t1\\u00042\\t2\\u00043\\t3\\u00044\\t4\\u00045\\t5\\u00046\\t6\\u00047\\t7\\u0004\",\n    \"8\\t8\\u00049\\t9\\u0004:\\t:\\u0004;\\t;\\u0004<\\t<\\u0004=\\t=\\u0004>\\t>\\u0004\",\n    \"?\\t?\\u0004@\\t@\\u0004A\\tA\\u0004B\\tB\\u0004C\\tC\\u0004D\\tD\\u0003\\u0002\\u0003\",\n    \"\\u0002\\u0003\\u0003\\u0003\\u0003\\u0003\\u0004\\u0003\\u0004\\u0003\\u0005\\u0003\",\n    \"\\u0005\\u0003\\u0006\\u0003\\u0006\\u0003\\u0007\\u0003\\u0007\\u0003\\b\\u0003\",\n    \"\\b\\u0003\\t\\u0003\\t\\u0003\\t\\u0003\\t\\u0003\\n\\u0003\\n\\u0003\\n\\u0003\\n\\u0003\",\n    \"\\u000b\\u0003\\u000b\\u0003\\f\\u0003\\f\\u0003\\r\\u0003\\r\\u0003\\r\\u0003\\u000e\",\n    \"\\u0003\\u000e\\u0003\\u000f\\u0003\\u000f\\u0003\\u0010\\u0003\\u0010\\u0003\\u0010\",\n    \"\\u0003\\u0011\\u0003\\u0011\\u0003\\u0011\\u0003\\u0012\\u0003\\u0012\\u0003\\u0012\",\n    \"\\u0003\\u0013\\u0003\\u0013\\u0003\\u0014\\u0003\\u0014\\u0003\\u0015\\u0003\\u0015\",\n    \"\\u0003\\u0015\\u0003\\u0016\\u0003\\u0016\\u0003\\u0016\\u0003\\u0017\\u0003\\u0017\",\n    \"\\u0003\\u0017\\u0003\\u0018\\u0003\\u0018\\u0003\\u0018\\u0003\\u0018\\u0003\\u0018\",\n    \"\\u0003\\u0018\\u0003\\u0018\\u0003\\u0018\\u0003\\u0018\\u0003\\u0019\\u0003\\u0019\",\n    \"\\u0003\\u0019\\u0003\\u0019\\u0003\\u001a\\u0003\\u001a\\u0003\\u001a\\u0003\\u001b\",\n    \"\\u0003\\u001b\\u0003\\u001b\\u0003\\u001b\\u0003\\u001c\\u0003\\u001c\\u0003\\u001c\",\n    \"\\u0003\\u001c\\u0003\\u001c\\u0003\\u001c\\u0003\\u001c\\u0003\\u001c\\u0003\\u001d\",\n    \"\\u0003\\u001d\\u0003\\u001e\\u0003\\u001e\\u0003\\u001f\\u0003\\u001f\\u0003 \",\n    \"\\u0003 \\u0003!\\u0003!\\u0003!\\u0003!\\u0003!\\u0003\\\"\\u0003\\\"\\u0003\\\"\\u0003\",\n    \"\\\"\\u0003\\\"\\u0003\\\"\\u0003#\\u0003#\\u0003$\\u0003$\\u0003$\\u0003$\\u0003$\",\n    \"\\u0003$\\u0003%\\u0003%\\u0003%\\u0003%\\u0003%\\u0003%\\u0003%\\u0003&\\u0003\",\n    \"&\\u0003&\\u0003&\\u0003&\\u0003&\\u0003&\\u0003\\'\\u0003\\'\\u0003(\\u0003(\\u0003\",\n    \"(\\u0003(\\u0003(\\u0003)\\u0003)\\u0003)\\u0003)\\u0003)\\u0003)\\u0003*\\u0003\",\n    \"*\\u0003*\\u0003*\\u0003*\\u0003+\\u0003+\\u0003+\\u0003+\\u0003,\\u0003,\\u0003\",\n    \",\\u0003,\\u0003,\\u0003-\\u0003-\\u0003-\\u0003-\\u0003-\\u0003-\\u0003-\\u0003\",\n    \".\\u0003.\\u0003.\\u0003.\\u0003.\\u0003.\\u0003.\\u0003/\\u0003/\\u0003/\\u0003\",\n    \"/\\u0003/\\u0003/\\u0003/\\u0003/\\u0003/\\u0003/\\u0003/\\u0003/\\u00030\\u0003\",\n    \"0\\u00030\\u00030\\u00030\\u00030\\u00031\\u00031\\u00031\\u00031\\u00031\\u0003\",\n    \"1\\u00031\\u00032\\u00032\\u00032\\u00032\\u00032\\u00032\\u00033\\u00033\\u0003\",\n    \"3\\u00033\\u00033\\u00034\\u00034\\u00034\\u00034\\u00034\\u00034\\u00035\\u0003\",\n    \"5\\u00035\\u00035\\u00035\\u00035\\u00035\\u00035\\u00036\\u00036\\u00036\\u0003\",\n    \"6\\u00036\\u00036\\u00036\\u00036\\u00037\\u00037\\u00037\\u00037\\u00037\\u0003\",\n    \"7\\u00037\\u00037\\u00037\\u00037\\u00037\\u00037\\u00037\\u00038\\u00038\\u0003\",\n    \"8\\u00038\\u00038\\u00038\\u00038\\u00038\\u00038\\u00038\\u00038\\u00038\\u0003\",\n    \"8\\u00058\\u0183\\n8\\u00058\\u0185\\n8\\u00058\\u0187\\n8\\u00038\\u00058\\u018a\",\n    \"\\n8\\u00039\\u00039\\u00039\\u00039\\u0003:\\u0003:\\u0003:\\u0003:\\u0003:\\u0003\",\n    \":\\u0003:\\u0003:\\u0003:\\u0003:\\u0006:\\u019a\\n:\\r:\\u000e:\\u019b\\u0005\",\n    \":\\u019e\\n:\\u0005:\\u01a0\\n:\\u0005:\\u01a2\\n:\\u0003:\\u0003:\\u0003:\\u0003\",\n    \":\\u0003:\\u0003:\\u0003:\\u0005:\\u01ab\\n:\\u0003;\\u0005;\\u01ae\\n;\\u0003\",\n    \";\\u0007;\\u01b1\\n;\\f;\\u000e;\\u01b4\\u000b;\\u0003<\\u0003<\\u0003<\\u0007\",\n    \"<\\u01b9\\n<\\f<\\u000e<\\u01bc\\u000b<\\u0003<\\u0003<\\u0003=\\u0003=\\u0003\",\n    \"=\\u0007=\\u01c3\\n=\\f=\\u000e=\\u01c6\\u000b=\\u0003=\\u0003=\\u0003>\\u0006\",\n    \">\\u01cb\\n>\\r>\\u000e>\\u01cc\\u0003>\\u0003>\\u0006>\\u01d1\\n>\\r>\\u000e>\\u01d2\",\n    \"\\u0005>\\u01d5\\n>\\u0003?\\u0006?\\u01d8\\n?\\r?\\u000e?\\u01d9\\u0003?\\u0003\",\n    \"?\\u0003@\\u0003@\\u0003@\\u0003@\\u0007@\\u01e2\\n@\\f@\\u000e@\\u01e5\\u000b\",\n    \"@\\u0003@\\u0003@\\u0003@\\u0003@\\u0003@\\u0003A\\u0003A\\u0003A\\u0003A\\u0007\",\n    \"A\\u01f0\\nA\\fA\\u000eA\\u01f3\\u000bA\\u0003A\\u0003A\\u0003B\\u0003B\\u0003\",\n    \"B\\u0005B\\u01fa\\nB\\u0003C\\u0003C\\u0003C\\u0003C\\u0003C\\u0003C\\u0003D\\u0003\",\n    \"D\\u0003\\u01e3\\u0002E\\u0003\\u0003\\u0005\\u0004\\u0007\\u0005\\t\\u0006\\u000b\",\n    \"\\u0007\\r\\b\\u000f\\t\\u0011\\n\\u0013\\u000b\\u0015\\f\\u0017\\r\\u0019\\u000e\\u001b\",\n    \"\\u000f\\u001d\\u0010\\u001f\\u0011!\\u0012#\\u0013%\\u0014\\'\\u0015)\\u0016+\",\n    \"\\u0017-\\u0018/\\u00191\\u001a3\\u001b5\\u001c7\\u001d9\\u001e;\\u001f= ?!A\",\n    \"\\\"C#E$G%I&K\\'M(O)Q*S+U,W-Y.[/]0_1a2c3e4g5i6k7m8o9q:s\\u0002u;w<y={>}\",\n    \"?\\u007f@\\u0081A\\u0083\\u0002\\u0085\\u0002\\u0087\\u0002\\u0003\\u0002\\f\\u0003\",\n    \"\\u00022;\\u0004\\u0002--//\\u0005\\u0002C\\\\aac|\\u0006\\u00022;C\\\\aac|\\u0004\",\n    \"\\u0002^^bb\\u0003\\u0002))\\u0005\\u0002\\u000b\\f\\u000f\\u000f\\\"\\\"\\u0004\\u0002\",\n    \"\\f\\f\\u000f\\u000f\\n\\u0002))11^^bbhhppttvv\\u0005\\u00022;CHch\\u0002\\u0214\",\n    \"\\u0002\\u0003\\u0003\\u0002\\u0002\\u0002\\u0002\\u0005\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0002\\u0007\\u0003\\u0002\\u0002\\u0002\\u0002\\t\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0002\\u000b\\u0003\\u0002\\u0002\\u0002\\u0002\\r\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0002\\u000f\\u0003\\u0002\\u0002\\u0002\\u0002\\u0011\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0002\\u0013\\u0003\\u0002\\u0002\\u0002\\u0002\\u0015\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0002\\u0017\\u0003\\u0002\\u0002\\u0002\\u0002\\u0019\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0002\\u001b\\u0003\\u0002\\u0002\\u0002\\u0002\\u001d\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0002\\u001f\\u0003\\u0002\\u0002\\u0002\\u0002!\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0002#\\u0003\\u0002\\u0002\\u0002\\u0002%\\u0003\\u0002\\u0002\\u0002\\u0002\",\n    \"\\'\\u0003\\u0002\\u0002\\u0002\\u0002)\\u0003\\u0002\\u0002\\u0002\\u0002+\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0002-\\u0003\\u0002\\u0002\\u0002\\u0002/\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u00021\\u0003\\u0002\\u0002\\u0002\\u00023\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u00025\\u0003\\u0002\\u0002\\u0002\\u00027\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u00029\\u0003\\u0002\\u0002\\u0002\\u0002;\\u0003\\u0002\\u0002\\u0002\\u0002\",\n    \"=\\u0003\\u0002\\u0002\\u0002\\u0002?\\u0003\\u0002\\u0002\\u0002\\u0002A\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0002C\\u0003\\u0002\\u0002\\u0002\\u0002E\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u0002G\\u0003\\u0002\\u0002\\u0002\\u0002I\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u0002K\\u0003\\u0002\\u0002\\u0002\\u0002M\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0002O\\u0003\\u0002\\u0002\\u0002\\u0002Q\\u0003\\u0002\\u0002\\u0002\\u0002\",\n    \"S\\u0003\\u0002\\u0002\\u0002\\u0002U\\u0003\\u0002\\u0002\\u0002\\u0002W\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0002Y\\u0003\\u0002\\u0002\\u0002\\u0002[\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u0002]\\u0003\\u0002\\u0002\\u0002\\u0002_\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u0002a\\u0003\\u0002\\u0002\\u0002\\u0002c\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0002e\\u0003\\u0002\\u0002\\u0002\\u0002g\\u0003\\u0002\\u0002\\u0002\\u0002\",\n    \"i\\u0003\\u0002\\u0002\\u0002\\u0002k\\u0003\\u0002\\u0002\\u0002\\u0002m\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0002o\\u0003\\u0002\\u0002\\u0002\\u0002q\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u0002u\\u0003\\u0002\\u0002\\u0002\\u0002w\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u0002y\\u0003\\u0002\\u0002\\u0002\\u0002{\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0002}\\u0003\\u0002\\u0002\\u0002\\u0002\\u007f\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0002\\u0081\\u0003\\u0002\\u0002\\u0002\\u0003\\u0089\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0005\\u008b\\u0003\\u0002\\u0002\\u0002\\u0007\\u008d\\u0003\\u0002\\u0002\\u0002\",\n    \"\\t\\u008f\\u0003\\u0002\\u0002\\u0002\\u000b\\u0091\\u0003\\u0002\\u0002\\u0002\",\n    \"\\r\\u0093\\u0003\\u0002\\u0002\\u0002\\u000f\\u0095\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0011\\u0097\\u0003\\u0002\\u0002\\u0002\\u0013\\u009b\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0015\\u009f\\u0003\\u0002\\u0002\\u0002\\u0017\\u00a1\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0019\\u00a3\\u0003\\u0002\\u0002\\u0002\\u001b\\u00a6\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u001d\\u00a8\\u0003\\u0002\\u0002\\u0002\\u001f\\u00aa\\u0003\\u0002\\u0002\\u0002\",\n    \"!\\u00ad\\u0003\\u0002\\u0002\\u0002#\\u00b0\\u0003\\u0002\\u0002\\u0002%\\u00b3\",\n    \"\\u0003\\u0002\\u0002\\u0002\\'\\u00b5\\u0003\\u0002\\u0002\\u0002)\\u00b7\\u0003\",\n    \"\\u0002\\u0002\\u0002+\\u00ba\\u0003\\u0002\\u0002\\u0002-\\u00bd\\u0003\\u0002\",\n    \"\\u0002\\u0002/\\u00c0\\u0003\\u0002\\u0002\\u00021\\u00c9\\u0003\\u0002\\u0002\",\n    \"\\u00023\\u00cd\\u0003\\u0002\\u0002\\u00025\\u00d0\\u0003\\u0002\\u0002\\u0002\",\n    \"7\\u00d4\\u0003\\u0002\\u0002\\u00029\\u00dc\\u0003\\u0002\\u0002\\u0002;\\u00de\",\n    \"\\u0003\\u0002\\u0002\\u0002=\\u00e0\\u0003\\u0002\\u0002\\u0002?\\u00e2\\u0003\",\n    \"\\u0002\\u0002\\u0002A\\u00e4\\u0003\\u0002\\u0002\\u0002C\\u00e9\\u0003\\u0002\",\n    \"\\u0002\\u0002E\\u00ef\\u0003\\u0002\\u0002\\u0002G\\u00f1\\u0003\\u0002\\u0002\",\n    \"\\u0002I\\u00f7\\u0003\\u0002\\u0002\\u0002K\\u00fe\\u0003\\u0002\\u0002\\u0002\",\n    \"M\\u0105\\u0003\\u0002\\u0002\\u0002O\\u0107\\u0003\\u0002\\u0002\\u0002Q\\u010c\",\n    \"\\u0003\\u0002\\u0002\\u0002S\\u0112\\u0003\\u0002\\u0002\\u0002U\\u0117\\u0003\",\n    \"\\u0002\\u0002\\u0002W\\u011b\\u0003\\u0002\\u0002\\u0002Y\\u0120\\u0003\\u0002\",\n    \"\\u0002\\u0002[\\u0127\\u0003\\u0002\\u0002\\u0002]\\u012e\\u0003\\u0002\\u0002\",\n    \"\\u0002_\\u013a\\u0003\\u0002\\u0002\\u0002a\\u0140\\u0003\\u0002\\u0002\\u0002\",\n    \"c\\u0147\\u0003\\u0002\\u0002\\u0002e\\u014d\\u0003\\u0002\\u0002\\u0002g\\u0152\",\n    \"\\u0003\\u0002\\u0002\\u0002i\\u0158\\u0003\\u0002\\u0002\\u0002k\\u0160\\u0003\",\n    \"\\u0002\\u0002\\u0002m\\u0168\\u0003\\u0002\\u0002\\u0002o\\u0175\\u0003\\u0002\",\n    \"\\u0002\\u0002q\\u018b\\u0003\\u0002\\u0002\\u0002s\\u018f\\u0003\\u0002\\u0002\",\n    \"\\u0002u\\u01ad\\u0003\\u0002\\u0002\\u0002w\\u01b5\\u0003\\u0002\\u0002\\u0002\",\n    \"y\\u01bf\\u0003\\u0002\\u0002\\u0002{\\u01ca\\u0003\\u0002\\u0002\\u0002}\\u01d7\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u007f\\u01dd\\u0003\\u0002\\u0002\\u0002\\u0081\\u01eb\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0083\\u01f6\\u0003\\u0002\\u0002\\u0002\\u0085\\u01fb\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0087\\u0201\\u0003\\u0002\\u0002\\u0002\\u0089\\u008a\",\n    \"\\u00070\\u0002\\u0002\\u008a\\u0004\\u0003\\u0002\\u0002\\u0002\\u008b\\u008c\",\n    \"\\u0007]\\u0002\\u0002\\u008c\\u0006\\u0003\\u0002\\u0002\\u0002\\u008d\\u008e\",\n    \"\\u0007_\\u0002\\u0002\\u008e\\b\\u0003\\u0002\\u0002\\u0002\\u008f\\u0090\\u0007\",\n    \"-\\u0002\\u0002\\u0090\\n\\u0003\\u0002\\u0002\\u0002\\u0091\\u0092\\u0007/\\u0002\",\n    \"\\u0002\\u0092\\f\\u0003\\u0002\\u0002\\u0002\\u0093\\u0094\\u0007,\\u0002\\u0002\",\n    \"\\u0094\\u000e\\u0003\\u0002\\u0002\\u0002\\u0095\\u0096\\u00071\\u0002\\u0002\",\n    \"\\u0096\\u0010\\u0003\\u0002\\u0002\\u0002\\u0097\\u0098\\u0007f\\u0002\\u0002\",\n    \"\\u0098\\u0099\\u0007k\\u0002\\u0002\\u0099\\u009a\\u0007x\\u0002\\u0002\\u009a\",\n    \"\\u0012\\u0003\\u0002\\u0002\\u0002\\u009b\\u009c\\u0007o\\u0002\\u0002\\u009c\",\n    \"\\u009d\\u0007q\\u0002\\u0002\\u009d\\u009e\\u0007f\\u0002\\u0002\\u009e\\u0014\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u009f\\u00a0\\u0007(\\u0002\\u0002\\u00a0\\u0016\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u00a1\\u00a2\\u0007~\\u0002\\u0002\\u00a2\\u0018\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u00a3\\u00a4\\u0007>\\u0002\\u0002\\u00a4\\u00a5\",\n    \"\\u0007?\\u0002\\u0002\\u00a5\\u001a\\u0003\\u0002\\u0002\\u0002\\u00a6\\u00a7\",\n    \"\\u0007>\\u0002\\u0002\\u00a7\\u001c\\u0003\\u0002\\u0002\\u0002\\u00a8\\u00a9\",\n    \"\\u0007@\\u0002\\u0002\\u00a9\\u001e\\u0003\\u0002\\u0002\\u0002\\u00aa\\u00ab\",\n    \"\\u0007@\\u0002\\u0002\\u00ab\\u00ac\\u0007?\\u0002\\u0002\\u00ac \\u0003\\u0002\",\n    \"\\u0002\\u0002\\u00ad\\u00ae\\u0007k\\u0002\\u0002\\u00ae\\u00af\\u0007u\\u0002\",\n    \"\\u0002\\u00af\\\"\\u0003\\u0002\\u0002\\u0002\\u00b0\\u00b1\\u0007c\\u0002\\u0002\",\n    \"\\u00b1\\u00b2\\u0007u\\u0002\\u0002\\u00b2$\\u0003\\u0002\\u0002\\u0002\\u00b3\",\n    \"\\u00b4\\u0007?\\u0002\\u0002\\u00b4&\\u0003\\u0002\\u0002\\u0002\\u00b5\\u00b6\",\n    \"\\u0007\\u0080\\u0002\\u0002\\u00b6(\\u0003\\u0002\\u0002\\u0002\\u00b7\\u00b8\",\n    \"\\u0007#\\u0002\\u0002\\u00b8\\u00b9\\u0007?\\u0002\\u0002\\u00b9*\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u00ba\\u00bb\\u0007#\\u0002\\u0002\\u00bb\\u00bc\\u0007\\u0080\",\n    \"\\u0002\\u0002\\u00bc,\\u0003\\u0002\\u0002\\u0002\\u00bd\\u00be\\u0007k\\u0002\",\n    \"\\u0002\\u00be\\u00bf\\u0007p\\u0002\\u0002\\u00bf.\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u00c0\\u00c1\\u0007e\\u0002\\u0002\\u00c1\\u00c2\\u0007q\\u0002\\u0002\\u00c2\",\n    \"\\u00c3\\u0007p\\u0002\\u0002\\u00c3\\u00c4\\u0007v\\u0002\\u0002\\u00c4\\u00c5\",\n    \"\\u0007c\\u0002\\u0002\\u00c5\\u00c6\\u0007k\\u0002\\u0002\\u00c6\\u00c7\\u0007\",\n    \"p\\u0002\\u0002\\u00c7\\u00c8\\u0007u\\u0002\\u0002\\u00c80\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u00c9\\u00ca\\u0007c\\u0002\\u0002\\u00ca\\u00cb\\u0007p\\u0002\\u0002\",\n    \"\\u00cb\\u00cc\\u0007f\\u0002\\u0002\\u00cc2\\u0003\\u0002\\u0002\\u0002\\u00cd\",\n    \"\\u00ce\\u0007q\\u0002\\u0002\\u00ce\\u00cf\\u0007t\\u0002\\u0002\\u00cf4\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u00d0\\u00d1\\u0007z\\u0002\\u0002\\u00d1\\u00d2\\u0007\",\n    \"q\\u0002\\u0002\\u00d2\\u00d3\\u0007t\\u0002\\u0002\\u00d36\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u00d4\\u00d5\\u0007k\\u0002\\u0002\\u00d5\\u00d6\\u0007o\\u0002\\u0002\",\n    \"\\u00d6\\u00d7\\u0007r\\u0002\\u0002\\u00d7\\u00d8\\u0007n\\u0002\\u0002\\u00d8\",\n    \"\\u00d9\\u0007k\\u0002\\u0002\\u00d9\\u00da\\u0007g\\u0002\\u0002\\u00da\\u00db\",\n    \"\\u0007u\\u0002\\u0002\\u00db8\\u0003\\u0002\\u0002\\u0002\\u00dc\\u00dd\\u0007\",\n    \"*\\u0002\\u0002\\u00dd:\\u0003\\u0002\\u0002\\u0002\\u00de\\u00df\\u0007+\\u0002\",\n    \"\\u0002\\u00df<\\u0003\\u0002\\u0002\\u0002\\u00e0\\u00e1\\u0007}\\u0002\\u0002\",\n    \"\\u00e1>\\u0003\\u0002\\u0002\\u0002\\u00e2\\u00e3\\u0007\\u007f\\u0002\\u0002\",\n    \"\\u00e3@\\u0003\\u0002\\u0002\\u0002\\u00e4\\u00e5\\u0007v\\u0002\\u0002\\u00e5\",\n    \"\\u00e6\\u0007t\\u0002\\u0002\\u00e6\\u00e7\\u0007w\\u0002\\u0002\\u00e7\\u00e8\",\n    \"\\u0007g\\u0002\\u0002\\u00e8B\\u0003\\u0002\\u0002\\u0002\\u00e9\\u00ea\\u0007\",\n    \"h\\u0002\\u0002\\u00ea\\u00eb\\u0007c\\u0002\\u0002\\u00eb\\u00ec\\u0007n\\u0002\",\n    \"\\u0002\\u00ec\\u00ed\\u0007u\\u0002\\u0002\\u00ed\\u00ee\\u0007g\\u0002\\u0002\",\n    \"\\u00eeD\\u0003\\u0002\\u0002\\u0002\\u00ef\\u00f0\\u0007\\'\\u0002\\u0002\\u00f0\",\n    \"F\\u0003\\u0002\\u0002\\u0002\\u00f1\\u00f2\\u0007&\\u0002\\u0002\\u00f2\\u00f3\",\n    \"\\u0007v\\u0002\\u0002\\u00f3\\u00f4\\u0007j\\u0002\\u0002\\u00f4\\u00f5\\u0007\",\n    \"k\\u0002\\u0002\\u00f5\\u00f6\\u0007u\\u0002\\u0002\\u00f6H\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u00f7\\u00f8\\u0007&\\u0002\\u0002\\u00f8\\u00f9\\u0007k\\u0002\\u0002\",\n    \"\\u00f9\\u00fa\\u0007p\\u0002\\u0002\\u00fa\\u00fb\\u0007f\\u0002\\u0002\\u00fb\",\n    \"\\u00fc\\u0007g\\u0002\\u0002\\u00fc\\u00fd\\u0007z\\u0002\\u0002\\u00fdJ\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u00fe\\u00ff\\u0007&\\u0002\\u0002\\u00ff\\u0100\\u0007\",\n    \"v\\u0002\\u0002\\u0100\\u0101\\u0007q\\u0002\\u0002\\u0101\\u0102\\u0007v\\u0002\",\n    \"\\u0002\\u0102\\u0103\\u0007c\\u0002\\u0002\\u0103\\u0104\\u0007n\\u0002\\u0002\",\n    \"\\u0104L\\u0003\\u0002\\u0002\\u0002\\u0105\\u0106\\u0007.\\u0002\\u0002\\u0106\",\n    \"N\\u0003\\u0002\\u0002\\u0002\\u0107\\u0108\\u0007{\\u0002\\u0002\\u0108\\u0109\",\n    \"\\u0007g\\u0002\\u0002\\u0109\\u010a\\u0007c\\u0002\\u0002\\u010a\\u010b\\u0007\",\n    \"t\\u0002\\u0002\\u010bP\\u0003\\u0002\\u0002\\u0002\\u010c\\u010d\\u0007o\\u0002\",\n    \"\\u0002\\u010d\\u010e\\u0007q\\u0002\\u0002\\u010e\\u010f\\u0007p\\u0002\\u0002\",\n    \"\\u010f\\u0110\\u0007v\\u0002\\u0002\\u0110\\u0111\\u0007j\\u0002\\u0002\\u0111\",\n    \"R\\u0003\\u0002\\u0002\\u0002\\u0112\\u0113\\u0007y\\u0002\\u0002\\u0113\\u0114\",\n    \"\\u0007g\\u0002\\u0002\\u0114\\u0115\\u0007g\\u0002\\u0002\\u0115\\u0116\\u0007\",\n    \"m\\u0002\\u0002\\u0116T\\u0003\\u0002\\u0002\\u0002\\u0117\\u0118\\u0007f\\u0002\",\n    \"\\u0002\\u0118\\u0119\\u0007c\\u0002\\u0002\\u0119\\u011a\\u0007{\\u0002\\u0002\",\n    \"\\u011aV\\u0003\\u0002\\u0002\\u0002\\u011b\\u011c\\u0007j\\u0002\\u0002\\u011c\",\n    \"\\u011d\\u0007q\\u0002\\u0002\\u011d\\u011e\\u0007w\\u0002\\u0002\\u011e\\u011f\",\n    \"\\u0007t\\u0002\\u0002\\u011fX\\u0003\\u0002\\u0002\\u0002\\u0120\\u0121\\u0007\",\n    \"o\\u0002\\u0002\\u0121\\u0122\\u0007k\\u0002\\u0002\\u0122\\u0123\\u0007p\\u0002\",\n    \"\\u0002\\u0123\\u0124\\u0007w\\u0002\\u0002\\u0124\\u0125\\u0007v\\u0002\\u0002\",\n    \"\\u0125\\u0126\\u0007g\\u0002\\u0002\\u0126Z\\u0003\\u0002\\u0002\\u0002\\u0127\",\n    \"\\u0128\\u0007u\\u0002\\u0002\\u0128\\u0129\\u0007g\\u0002\\u0002\\u0129\\u012a\",\n    \"\\u0007e\\u0002\\u0002\\u012a\\u012b\\u0007q\\u0002\\u0002\\u012b\\u012c\\u0007\",\n    \"p\\u0002\\u0002\\u012c\\u012d\\u0007f\\u0002\\u0002\\u012d\\\\\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u012e\\u012f\\u0007o\\u0002\\u0002\\u012f\\u0130\\u0007k\\u0002\\u0002\",\n    \"\\u0130\\u0131\\u0007n\\u0002\\u0002\\u0131\\u0132\\u0007n\\u0002\\u0002\\u0132\",\n    \"\\u0133\\u0007k\\u0002\\u0002\\u0133\\u0134\\u0007u\\u0002\\u0002\\u0134\\u0135\",\n    \"\\u0007g\\u0002\\u0002\\u0135\\u0136\\u0007e\\u0002\\u0002\\u0136\\u0137\\u0007\",\n    \"q\\u0002\\u0002\\u0137\\u0138\\u0007p\\u0002\\u0002\\u0138\\u0139\\u0007f\\u0002\",\n    \"\\u0002\\u0139^\\u0003\\u0002\\u0002\\u0002\\u013a\\u013b\\u0007{\\u0002\\u0002\",\n    \"\\u013b\\u013c\\u0007g\\u0002\\u0002\\u013c\\u013d\\u0007c\\u0002\\u0002\\u013d\",\n    \"\\u013e\\u0007t\\u0002\\u0002\\u013e\\u013f\\u0007u\\u0002\\u0002\\u013f`\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0140\\u0141\\u0007o\\u0002\\u0002\\u0141\\u0142\\u0007\",\n    \"q\\u0002\\u0002\\u0142\\u0143\\u0007p\\u0002\\u0002\\u0143\\u0144\\u0007v\\u0002\",\n    \"\\u0002\\u0144\\u0145\\u0007j\\u0002\\u0002\\u0145\\u0146\\u0007u\\u0002\\u0002\",\n    \"\\u0146b\\u0003\\u0002\\u0002\\u0002\\u0147\\u0148\\u0007y\\u0002\\u0002\\u0148\",\n    \"\\u0149\\u0007g\\u0002\\u0002\\u0149\\u014a\\u0007g\\u0002\\u0002\\u014a\\u014b\",\n    \"\\u0007m\\u0002\\u0002\\u014b\\u014c\\u0007u\\u0002\\u0002\\u014cd\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u014d\\u014e\\u0007f\\u0002\\u0002\\u014e\\u014f\\u0007c\\u0002\",\n    \"\\u0002\\u014f\\u0150\\u0007{\\u0002\\u0002\\u0150\\u0151\\u0007u\\u0002\\u0002\",\n    \"\\u0151f\\u0003\\u0002\\u0002\\u0002\\u0152\\u0153\\u0007j\\u0002\\u0002\\u0153\",\n    \"\\u0154\\u0007q\\u0002\\u0002\\u0154\\u0155\\u0007w\\u0002\\u0002\\u0155\\u0156\",\n    \"\\u0007t\\u0002\\u0002\\u0156\\u0157\\u0007u\\u0002\\u0002\\u0157h\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u0158\\u0159\\u0007o\\u0002\\u0002\\u0159\\u015a\\u0007k\\u0002\",\n    \"\\u0002\\u015a\\u015b\\u0007p\\u0002\\u0002\\u015b\\u015c\\u0007w\\u0002\\u0002\",\n    \"\\u015c\\u015d\\u0007v\\u0002\\u0002\\u015d\\u015e\\u0007g\\u0002\\u0002\\u015e\",\n    \"\\u015f\\u0007u\\u0002\\u0002\\u015fj\\u0003\\u0002\\u0002\\u0002\\u0160\\u0161\",\n    \"\\u0007u\\u0002\\u0002\\u0161\\u0162\\u0007g\\u0002\\u0002\\u0162\\u0163\\u0007\",\n    \"e\\u0002\\u0002\\u0163\\u0164\\u0007q\\u0002\\u0002\\u0164\\u0165\\u0007p\\u0002\",\n    \"\\u0002\\u0165\\u0166\\u0007f\\u0002\\u0002\\u0166\\u0167\\u0007u\\u0002\\u0002\",\n    \"\\u0167l\\u0003\\u0002\\u0002\\u0002\\u0168\\u0169\\u0007o\\u0002\\u0002\\u0169\",\n    \"\\u016a\\u0007k\\u0002\\u0002\\u016a\\u016b\\u0007n\\u0002\\u0002\\u016b\\u016c\",\n    \"\\u0007n\\u0002\\u0002\\u016c\\u016d\\u0007k\\u0002\\u0002\\u016d\\u016e\\u0007\",\n    \"u\\u0002\\u0002\\u016e\\u016f\\u0007g\\u0002\\u0002\\u016f\\u0170\\u0007e\\u0002\",\n    \"\\u0002\\u0170\\u0171\\u0007q\\u0002\\u0002\\u0171\\u0172\\u0007p\\u0002\\u0002\",\n    \"\\u0172\\u0173\\u0007f\\u0002\\u0002\\u0173\\u0174\\u0007u\\u0002\\u0002\\u0174\",\n    \"n\\u0003\\u0002\\u0002\\u0002\\u0175\\u0176\\u0007B\\u0002\\u0002\\u0176\\u0177\",\n    \"\\t\\u0002\\u0002\\u0002\\u0177\\u0178\\t\\u0002\\u0002\\u0002\\u0178\\u0179\\t\\u0002\",\n    \"\\u0002\\u0002\\u0179\\u0186\\t\\u0002\\u0002\\u0002\\u017a\\u017b\\u0007/\\u0002\",\n    \"\\u0002\\u017b\\u017c\\t\\u0002\\u0002\\u0002\\u017c\\u0184\\t\\u0002\\u0002\\u0002\",\n    \"\\u017d\\u017e\\u0007/\\u0002\\u0002\\u017e\\u017f\\t\\u0002\\u0002\\u0002\\u017f\",\n    \"\\u0182\\t\\u0002\\u0002\\u0002\\u0180\\u0181\\u0007V\\u0002\\u0002\\u0181\\u0183\",\n    \"\\u0005s:\\u0002\\u0182\\u0180\\u0003\\u0002\\u0002\\u0002\\u0182\\u0183\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0183\\u0185\\u0003\\u0002\\u0002\\u0002\\u0184\\u017d\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0184\\u0185\\u0003\\u0002\\u0002\\u0002\\u0185\\u0187\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0186\\u017a\\u0003\\u0002\\u0002\\u0002\\u0186\\u0187\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0187\\u0189\\u0003\\u0002\\u0002\\u0002\\u0188\\u018a\\u0007\",\n    \"\\\\\\u0002\\u0002\\u0189\\u0188\\u0003\\u0002\\u0002\\u0002\\u0189\\u018a\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u018ap\\u0003\\u0002\\u0002\\u0002\\u018b\\u018c\\u0007\",\n    \"B\\u0002\\u0002\\u018c\\u018d\\u0007V\\u0002\\u0002\\u018d\\u018e\\u0005s:\\u0002\",\n    \"\\u018er\\u0003\\u0002\\u0002\\u0002\\u018f\\u0190\\t\\u0002\\u0002\\u0002\\u0190\",\n    \"\\u01a1\\t\\u0002\\u0002\\u0002\\u0191\\u0192\\u0007<\\u0002\\u0002\\u0192\\u0193\",\n    \"\\t\\u0002\\u0002\\u0002\\u0193\\u019f\\t\\u0002\\u0002\\u0002\\u0194\\u0195\\u0007\",\n    \"<\\u0002\\u0002\\u0195\\u0196\\t\\u0002\\u0002\\u0002\\u0196\\u019d\\t\\u0002\\u0002\",\n    \"\\u0002\\u0197\\u0199\\u00070\\u0002\\u0002\\u0198\\u019a\\t\\u0002\\u0002\\u0002\",\n    \"\\u0199\\u0198\\u0003\\u0002\\u0002\\u0002\\u019a\\u019b\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u019b\\u0199\\u0003\\u0002\\u0002\\u0002\\u019b\\u019c\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u019c\\u019e\\u0003\\u0002\\u0002\\u0002\\u019d\\u0197\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u019d\\u019e\\u0003\\u0002\\u0002\\u0002\\u019e\\u01a0\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u019f\\u0194\\u0003\\u0002\\u0002\\u0002\\u019f\\u01a0\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u01a0\\u01a2\\u0003\\u0002\\u0002\\u0002\\u01a1\\u0191\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u01a1\\u01a2\\u0003\\u0002\\u0002\\u0002\\u01a2\\u01aa\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u01a3\\u01ab\\u0007\\\\\\u0002\\u0002\\u01a4\\u01a5\\t\\u0003\\u0002\\u0002\\u01a5\",\n    \"\\u01a6\\t\\u0002\\u0002\\u0002\\u01a6\\u01a7\\t\\u0002\\u0002\\u0002\\u01a7\\u01a8\",\n    \"\\u0007<\\u0002\\u0002\\u01a8\\u01a9\\t\\u0002\\u0002\\u0002\\u01a9\\u01ab\\t\\u0002\",\n    \"\\u0002\\u0002\\u01aa\\u01a3\\u0003\\u0002\\u0002\\u0002\\u01aa\\u01a4\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u01aa\\u01ab\\u0003\\u0002\\u0002\\u0002\\u01abt\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u01ac\\u01ae\\t\\u0004\\u0002\\u0002\\u01ad\\u01ac\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u01ae\\u01b2\\u0003\\u0002\\u0002\\u0002\\u01af\\u01b1\\t\\u0005\",\n    \"\\u0002\\u0002\\u01b0\\u01af\\u0003\\u0002\\u0002\\u0002\\u01b1\\u01b4\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u01b2\\u01b0\\u0003\\u0002\\u0002\\u0002\\u01b2\\u01b3\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u01b3v\\u0003\\u0002\\u0002\\u0002\\u01b4\\u01b2\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u01b5\\u01ba\\u0007b\\u0002\\u0002\\u01b6\\u01b9\\u0005\\u0083\",\n    \"B\\u0002\\u01b7\\u01b9\\n\\u0006\\u0002\\u0002\\u01b8\\u01b6\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u01b8\\u01b7\\u0003\\u0002\\u0002\\u0002\\u01b9\\u01bc\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u01ba\\u01b8\\u0003\\u0002\\u0002\\u0002\\u01ba\\u01bb\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u01bb\\u01bd\\u0003\\u0002\\u0002\\u0002\\u01bc\\u01ba\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u01bd\\u01be\\u0007b\\u0002\\u0002\\u01bex\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u01bf\\u01c4\\u0007)\\u0002\\u0002\\u01c0\\u01c3\\u0005\\u0083B\\u0002\\u01c1\",\n    \"\\u01c3\\n\\u0007\\u0002\\u0002\\u01c2\\u01c0\\u0003\\u0002\\u0002\\u0002\\u01c2\",\n    \"\\u01c1\\u0003\\u0002\\u0002\\u0002\\u01c3\\u01c6\\u0003\\u0002\\u0002\\u0002\\u01c4\",\n    \"\\u01c2\\u0003\\u0002\\u0002\\u0002\\u01c4\\u01c5\\u0003\\u0002\\u0002\\u0002\\u01c5\",\n    \"\\u01c7\\u0003\\u0002\\u0002\\u0002\\u01c6\\u01c4\\u0003\\u0002\\u0002\\u0002\\u01c7\",\n    \"\\u01c8\\u0007)\\u0002\\u0002\\u01c8z\\u0003\\u0002\\u0002\\u0002\\u01c9\\u01cb\",\n    \"\\t\\u0002\\u0002\\u0002\\u01ca\\u01c9\\u0003\\u0002\\u0002\\u0002\\u01cb\\u01cc\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u01cc\\u01ca\\u0003\\u0002\\u0002\\u0002\\u01cc\\u01cd\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u01cd\\u01d4\\u0003\\u0002\\u0002\\u0002\\u01ce\\u01d0\",\n    \"\\u00070\\u0002\\u0002\\u01cf\\u01d1\\t\\u0002\\u0002\\u0002\\u01d0\\u01cf\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u01d1\\u01d2\\u0003\\u0002\\u0002\\u0002\\u01d2\\u01d0\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u01d2\\u01d3\\u0003\\u0002\\u0002\\u0002\\u01d3\\u01d5\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u01d4\\u01ce\\u0003\\u0002\\u0002\\u0002\\u01d4\\u01d5\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u01d5|\\u0003\\u0002\\u0002\\u0002\\u01d6\\u01d8\\t\\b\\u0002\",\n    \"\\u0002\\u01d7\\u01d6\\u0003\\u0002\\u0002\\u0002\\u01d8\\u01d9\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u01d9\\u01d7\\u0003\\u0002\\u0002\\u0002\\u01d9\\u01da\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u01da\\u01db\\u0003\\u0002\\u0002\\u0002\\u01db\\u01dc\\b?\\u0002\\u0002\",\n    \"\\u01dc~\\u0003\\u0002\\u0002\\u0002\\u01dd\\u01de\\u00071\\u0002\\u0002\\u01de\",\n    \"\\u01df\\u0007,\\u0002\\u0002\\u01df\\u01e3\\u0003\\u0002\\u0002\\u0002\\u01e0\",\n    \"\\u01e2\\u000b\\u0002\\u0002\\u0002\\u01e1\\u01e0\\u0003\\u0002\\u0002\\u0002\\u01e2\",\n    \"\\u01e5\\u0003\\u0002\\u0002\\u0002\\u01e3\\u01e4\\u0003\\u0002\\u0002\\u0002\\u01e3\",\n    \"\\u01e1\\u0003\\u0002\\u0002\\u0002\\u01e4\\u01e6\\u0003\\u0002\\u0002\\u0002\\u01e5\",\n    \"\\u01e3\\u0003\\u0002\\u0002\\u0002\\u01e6\\u01e7\\u0007,\\u0002\\u0002\\u01e7\",\n    \"\\u01e8\\u00071\\u0002\\u0002\\u01e8\\u01e9\\u0003\\u0002\\u0002\\u0002\\u01e9\",\n    \"\\u01ea\\b@\\u0002\\u0002\\u01ea\\u0080\\u0003\\u0002\\u0002\\u0002\\u01eb\\u01ec\",\n    \"\\u00071\\u0002\\u0002\\u01ec\\u01ed\\u00071\\u0002\\u0002\\u01ed\\u01f1\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u01ee\\u01f0\\n\\t\\u0002\\u0002\\u01ef\\u01ee\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u01f0\\u01f3\\u0003\\u0002\\u0002\\u0002\\u01f1\\u01ef\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u01f1\\u01f2\\u0003\\u0002\\u0002\\u0002\\u01f2\\u01f4\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u01f3\\u01f1\\u0003\\u0002\\u0002\\u0002\\u01f4\\u01f5\\bA\\u0002\",\n    \"\\u0002\\u01f5\\u0082\\u0003\\u0002\\u0002\\u0002\\u01f6\\u01f9\\u0007^\\u0002\",\n    \"\\u0002\\u01f7\\u01fa\\t\\n\\u0002\\u0002\\u01f8\\u01fa\\u0005\\u0085C\\u0002\\u01f9\",\n    \"\\u01f7\\u0003\\u0002\\u0002\\u0002\\u01f9\\u01f8\\u0003\\u0002\\u0002\\u0002\\u01fa\",\n    \"\\u0084\\u0003\\u0002\\u0002\\u0002\\u01fb\\u01fc\\u0007w\\u0002\\u0002\\u01fc\",\n    \"\\u01fd\\u0005\\u0087D\\u0002\\u01fd\\u01fe\\u0005\\u0087D\\u0002\\u01fe\\u01ff\",\n    \"\\u0005\\u0087D\\u0002\\u01ff\\u0200\\u0005\\u0087D\\u0002\\u0200\\u0086\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0201\\u0202\\t\\u000b\\u0002\\u0002\\u0202\\u0088\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u001a\\u0002\\u0182\\u0184\\u0186\\u0189\\u019b\\u019d\\u019f\",\n    \"\\u01a1\\u01aa\\u01ad\\u01b0\\u01b2\\u01b8\\u01ba\\u01c2\\u01c4\\u01cc\\u01d2\\u01d4\",\n    \"\\u01d9\\u01e3\\u01f1\\u01f9\\u0003\\u0002\\u0003\\u0002\"].join(\"\");\n\n\nconst atn = new antlr4.atn.ATNDeserializer().deserialize(serializedATN);\n\nconst decisionsToDFA = atn.decisionToState.map( (ds, index) => new antlr4.dfa.DFA(ds, index) );\n\nclass FHIRPathLexer extends antlr4.Lexer {\n\n    static grammarFileName = \"FHIRPath.g4\";\n    static channelNames = [ \"DEFAULT_TOKEN_CHANNEL\", \"HIDDEN\" ];\n\tstatic modeNames = [ \"DEFAULT_MODE\" ];\n\tstatic literalNames = [ null, \"'.'\", \"'['\", \"']'\", \"'+'\", \"'-'\", \"'*'\", \n                         \"'/'\", \"'div'\", \"'mod'\", \"'&'\", \"'|'\", \"'<='\", \n                         \"'<'\", \"'>'\", \"'>='\", \"'is'\", \"'as'\", \"'='\", \"'~'\", \n                         \"'!='\", \"'!~'\", \"'in'\", \"'contains'\", \"'and'\", \n                         \"'or'\", \"'xor'\", \"'implies'\", \"'('\", \"')'\", \"'{'\", \n                         \"'}'\", \"'true'\", \"'false'\", \"'%'\", \"'$this'\", \"'$index'\", \n                         \"'$total'\", \"','\", \"'year'\", \"'month'\", \"'week'\", \n                         \"'day'\", \"'hour'\", \"'minute'\", \"'second'\", \"'millisecond'\", \n                         \"'years'\", \"'months'\", \"'weeks'\", \"'days'\", \"'hours'\", \n                         \"'minutes'\", \"'seconds'\", \"'milliseconds'\" ];\n\tstatic symbolicNames = [ null, null, null, null, null, null, null, null, \n                          null, null, null, null, null, null, null, null, \n                          null, null, null, null, null, null, null, null, \n                          null, null, null, null, null, null, null, null, \n                          null, null, null, null, null, null, null, null, \n                          null, null, null, null, null, null, null, null, \n                          null, null, null, null, null, null, null, \"DATETIME\", \n                          \"TIME\", \"IDENTIFIER\", \"DELIMITEDIDENTIFIER\", \"STRING\", \n                          \"NUMBER\", \"WS\", \"COMMENT\", \"LINE_COMMENT\" ];\n\tstatic ruleNames = [ \"T__0\", \"T__1\", \"T__2\", \"T__3\", \"T__4\", \"T__5\", \"T__6\", \n                      \"T__7\", \"T__8\", \"T__9\", \"T__10\", \"T__11\", \"T__12\", \n                      \"T__13\", \"T__14\", \"T__15\", \"T__16\", \"T__17\", \"T__18\", \n                      \"T__19\", \"T__20\", \"T__21\", \"T__22\", \"T__23\", \"T__24\", \n                      \"T__25\", \"T__26\", \"T__27\", \"T__28\", \"T__29\", \"T__30\", \n                      \"T__31\", \"T__32\", \"T__33\", \"T__34\", \"T__35\", \"T__36\", \n                      \"T__37\", \"T__38\", \"T__39\", \"T__40\", \"T__41\", \"T__42\", \n                      \"T__43\", \"T__44\", \"T__45\", \"T__46\", \"T__47\", \"T__48\", \n                      \"T__49\", \"T__50\", \"T__51\", \"T__52\", \"T__53\", \"DATETIME\", \n                      \"TIME\", \"TIMEFORMAT\", \"IDENTIFIER\", \"DELIMITEDIDENTIFIER\", \n                      \"STRING\", \"NUMBER\", \"WS\", \"COMMENT\", \"LINE_COMMENT\", \n                      \"ESC\", \"UNICODE\", \"HEX\" ];\n\n    constructor(input) {\n        super(input)\n        this._interp = new antlr4.atn.LexerATNSimulator(this, atn, decisionsToDFA, new antlr4.PredictionContextCache());\n    }\n\n    get atn() {\n        return atn;\n    }\n}\n\nFHIRPathLexer.EOF = antlr4.Token.EOF;\nFHIRPathLexer.T__0 = 1;\nFHIRPathLexer.T__1 = 2;\nFHIRPathLexer.T__2 = 3;\nFHIRPathLexer.T__3 = 4;\nFHIRPathLexer.T__4 = 5;\nFHIRPathLexer.T__5 = 6;\nFHIRPathLexer.T__6 = 7;\nFHIRPathLexer.T__7 = 8;\nFHIRPathLexer.T__8 = 9;\nFHIRPathLexer.T__9 = 10;\nFHIRPathLexer.T__10 = 11;\nFHIRPathLexer.T__11 = 12;\nFHIRPathLexer.T__12 = 13;\nFHIRPathLexer.T__13 = 14;\nFHIRPathLexer.T__14 = 15;\nFHIRPathLexer.T__15 = 16;\nFHIRPathLexer.T__16 = 17;\nFHIRPathLexer.T__17 = 18;\nFHIRPathLexer.T__18 = 19;\nFHIRPathLexer.T__19 = 20;\nFHIRPathLexer.T__20 = 21;\nFHIRPathLexer.T__21 = 22;\nFHIRPathLexer.T__22 = 23;\nFHIRPathLexer.T__23 = 24;\nFHIRPathLexer.T__24 = 25;\nFHIRPathLexer.T__25 = 26;\nFHIRPathLexer.T__26 = 27;\nFHIRPathLexer.T__27 = 28;\nFHIRPathLexer.T__28 = 29;\nFHIRPathLexer.T__29 = 30;\nFHIRPathLexer.T__30 = 31;\nFHIRPathLexer.T__31 = 32;\nFHIRPathLexer.T__32 = 33;\nFHIRPathLexer.T__33 = 34;\nFHIRPathLexer.T__34 = 35;\nFHIRPathLexer.T__35 = 36;\nFHIRPathLexer.T__36 = 37;\nFHIRPathLexer.T__37 = 38;\nFHIRPathLexer.T__38 = 39;\nFHIRPathLexer.T__39 = 40;\nFHIRPathLexer.T__40 = 41;\nFHIRPathLexer.T__41 = 42;\nFHIRPathLexer.T__42 = 43;\nFHIRPathLexer.T__43 = 44;\nFHIRPathLexer.T__44 = 45;\nFHIRPathLexer.T__45 = 46;\nFHIRPathLexer.T__46 = 47;\nFHIRPathLexer.T__47 = 48;\nFHIRPathLexer.T__48 = 49;\nFHIRPathLexer.T__49 = 50;\nFHIRPathLexer.T__50 = 51;\nFHIRPathLexer.T__51 = 52;\nFHIRPathLexer.T__52 = 53;\nFHIRPathLexer.T__53 = 54;\nFHIRPathLexer.DATETIME = 55;\nFHIRPathLexer.TIME = 56;\nFHIRPathLexer.IDENTIFIER = 57;\nFHIRPathLexer.DELIMITEDIDENTIFIER = 58;\nFHIRPathLexer.STRING = 59;\nFHIRPathLexer.NUMBER = 60;\nFHIRPathLexer.WS = 61;\nFHIRPathLexer.COMMENT = 62;\nFHIRPathLexer.LINE_COMMENT = 63;\n\n\n\n\nmodule.exports = FHIRPathLexer;","// Generated from FHIRPath.g4 by ANTLR 4.9.3\n// jshint ignore: start\nconst antlr4 = require('../antlr4-index');\n\n// This class defines a complete listener for a parse tree produced by FHIRPathParser.\nclass FHIRPathListener extends antlr4.tree.ParseTreeListener {\n\n\t// Enter a parse tree produced by FHIRPathParser#entireExpression.\n\tenterEntireExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#entireExpression.\n\texitEntireExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#indexerExpression.\n\tenterIndexerExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#indexerExpression.\n\texitIndexerExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#polarityExpression.\n\tenterPolarityExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#polarityExpression.\n\texitPolarityExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#additiveExpression.\n\tenterAdditiveExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#additiveExpression.\n\texitAdditiveExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#multiplicativeExpression.\n\tenterMultiplicativeExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#multiplicativeExpression.\n\texitMultiplicativeExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#unionExpression.\n\tenterUnionExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#unionExpression.\n\texitUnionExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#orExpression.\n\tenterOrExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#orExpression.\n\texitOrExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#andExpression.\n\tenterAndExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#andExpression.\n\texitAndExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#membershipExpression.\n\tenterMembershipExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#membershipExpression.\n\texitMembershipExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#inequalityExpression.\n\tenterInequalityExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#inequalityExpression.\n\texitInequalityExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#invocationExpression.\n\tenterInvocationExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#invocationExpression.\n\texitInvocationExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#equalityExpression.\n\tenterEqualityExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#equalityExpression.\n\texitEqualityExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#impliesExpression.\n\tenterImpliesExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#impliesExpression.\n\texitImpliesExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#termExpression.\n\tenterTermExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#termExpression.\n\texitTermExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#typeExpression.\n\tenterTypeExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#typeExpression.\n\texitTypeExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#invocationTerm.\n\tenterInvocationTerm(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#invocationTerm.\n\texitInvocationTerm(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#literalTerm.\n\tenterLiteralTerm(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#literalTerm.\n\texitLiteralTerm(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#externalConstantTerm.\n\tenterExternalConstantTerm(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#externalConstantTerm.\n\texitExternalConstantTerm(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#parenthesizedTerm.\n\tenterParenthesizedTerm(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#parenthesizedTerm.\n\texitParenthesizedTerm(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#nullLiteral.\n\tenterNullLiteral(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#nullLiteral.\n\texitNullLiteral(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#booleanLiteral.\n\tenterBooleanLiteral(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#booleanLiteral.\n\texitBooleanLiteral(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#stringLiteral.\n\tenterStringLiteral(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#stringLiteral.\n\texitStringLiteral(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#numberLiteral.\n\tenterNumberLiteral(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#numberLiteral.\n\texitNumberLiteral(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#dateTimeLiteral.\n\tenterDateTimeLiteral(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#dateTimeLiteral.\n\texitDateTimeLiteral(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#timeLiteral.\n\tenterTimeLiteral(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#timeLiteral.\n\texitTimeLiteral(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#quantityLiteral.\n\tenterQuantityLiteral(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#quantityLiteral.\n\texitQuantityLiteral(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#externalConstant.\n\tenterExternalConstant(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#externalConstant.\n\texitExternalConstant(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#memberInvocation.\n\tenterMemberInvocation(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#memberInvocation.\n\texitMemberInvocation(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#functionInvocation.\n\tenterFunctionInvocation(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#functionInvocation.\n\texitFunctionInvocation(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#thisInvocation.\n\tenterThisInvocation(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#thisInvocation.\n\texitThisInvocation(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#indexInvocation.\n\tenterIndexInvocation(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#indexInvocation.\n\texitIndexInvocation(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#totalInvocation.\n\tenterTotalInvocation(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#totalInvocation.\n\texitTotalInvocation(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#functn.\n\tenterFunctn(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#functn.\n\texitFunctn(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#paramList.\n\tenterParamList(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#paramList.\n\texitParamList(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#quantity.\n\tenterQuantity(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#quantity.\n\texitQuantity(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#unit.\n\tenterUnit(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#unit.\n\texitUnit(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#dateTimePrecision.\n\tenterDateTimePrecision(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#dateTimePrecision.\n\texitDateTimePrecision(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#pluralDateTimePrecision.\n\tenterPluralDateTimePrecision(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#pluralDateTimePrecision.\n\texitPluralDateTimePrecision(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#typeSpecifier.\n\tenterTypeSpecifier(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#typeSpecifier.\n\texitTypeSpecifier(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#qualifiedIdentifier.\n\tenterQualifiedIdentifier(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#qualifiedIdentifier.\n\texitQualifiedIdentifier(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#identifier.\n\tenterIdentifier(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#identifier.\n\texitIdentifier(ctx) {\n\t}\n\n\n\n}\nmodule.exports = FHIRPathListener;","// Generated from FHIRPath.g4 by ANTLR 4.9.3\n// jshint ignore: start\nconst antlr4 = require('../antlr4-index');\nconst FHIRPathListener = require('./FHIRPathListener');\n\nconst serializedATN = [\"\\u0003\\u608b\\ua72a\\u8133\\ub9ed\\u417c\\u3be7\\u7786\",\n    \"\\u5964\\u0003A\\u009c\\u0004\\u0002\\t\\u0002\\u0004\\u0003\\t\\u0003\\u0004\\u0004\",\n    \"\\t\\u0004\\u0004\\u0005\\t\\u0005\\u0004\\u0006\\t\\u0006\\u0004\\u0007\\t\\u0007\",\n    \"\\u0004\\b\\t\\b\\u0004\\t\\t\\t\\u0004\\n\\t\\n\\u0004\\u000b\\t\\u000b\\u0004\\f\\t\\f\",\n    \"\\u0004\\r\\t\\r\\u0004\\u000e\\t\\u000e\\u0004\\u000f\\t\\u000f\\u0004\\u0010\\t\\u0010\",\n    \"\\u0003\\u0002\\u0003\\u0002\\u0003\\u0002\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\",\n    \"\\u0003\\u0003\\u0005\\u0003(\\n\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\",\n    \"\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\",\n    \"\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\",\n    \"\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\",\n    \"\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\",\n    \"\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\",\n    \"\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0007\\u0003\",\n    \"P\\n\\u0003\\f\\u0003\\u000e\\u0003S\\u000b\\u0003\\u0003\\u0004\\u0003\\u0004\\u0003\",\n    \"\\u0004\\u0003\\u0004\\u0003\\u0004\\u0003\\u0004\\u0003\\u0004\\u0005\\u0004\\\\\",\n    \"\\n\\u0004\\u0003\\u0005\\u0003\\u0005\\u0003\\u0005\\u0003\\u0005\\u0003\\u0005\",\n    \"\\u0003\\u0005\\u0003\\u0005\\u0003\\u0005\\u0005\\u0005f\\n\\u0005\\u0003\\u0006\",\n    \"\\u0003\\u0006\\u0003\\u0006\\u0005\\u0006k\\n\\u0006\\u0003\\u0007\\u0003\\u0007\",\n    \"\\u0003\\u0007\\u0003\\u0007\\u0003\\u0007\\u0005\\u0007r\\n\\u0007\\u0003\\b\\u0003\",\n    \"\\b\\u0003\\b\\u0005\\bw\\n\\b\\u0003\\b\\u0003\\b\\u0003\\t\\u0003\\t\\u0003\\t\\u0007\",\n    \"\\t~\\n\\t\\f\\t\\u000e\\t\\u0081\\u000b\\t\\u0003\\n\\u0003\\n\\u0005\\n\\u0085\\n\\n\",\n    \"\\u0003\\u000b\\u0003\\u000b\\u0003\\u000b\\u0005\\u000b\\u008a\\n\\u000b\\u0003\",\n    \"\\f\\u0003\\f\\u0003\\r\\u0003\\r\\u0003\\u000e\\u0003\\u000e\\u0003\\u000f\\u0003\",\n    \"\\u000f\\u0003\\u000f\\u0007\\u000f\\u0095\\n\\u000f\\f\\u000f\\u000e\\u000f\\u0098\",\n    \"\\u000b\\u000f\\u0003\\u0010\\u0003\\u0010\\u0003\\u0010\\u0002\\u0003\\u0004\\u0011\",\n    \"\\u0002\\u0004\\u0006\\b\\n\\f\\u000e\\u0010\\u0012\\u0014\\u0016\\u0018\\u001a\\u001c\",\n    \"\\u001e\\u0002\\u000e\\u0003\\u0002\\u0006\\u0007\\u0003\\u0002\\b\\u000b\\u0004\",\n    \"\\u0002\\u0006\\u0007\\f\\f\\u0003\\u0002\\u000e\\u0011\\u0003\\u0002\\u0014\\u0017\",\n    \"\\u0003\\u0002\\u0018\\u0019\\u0003\\u0002\\u001b\\u001c\\u0003\\u0002\\u0012\\u0013\",\n    \"\\u0003\\u0002\\\"#\\u0003\\u0002)0\\u0003\\u000218\\u0005\\u0002\\u0012\\u0013\",\n    \"\\u0018\\u0019;<\\u0002\\u00ad\\u0002 \\u0003\\u0002\\u0002\\u0002\\u0004\\'\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0006[\\u0003\\u0002\\u0002\\u0002\\be\\u0003\\u0002\\u0002\",\n    \"\\u0002\\ng\\u0003\\u0002\\u0002\\u0002\\fq\\u0003\\u0002\\u0002\\u0002\\u000es\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0010z\\u0003\\u0002\\u0002\\u0002\\u0012\\u0082\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0014\\u0089\\u0003\\u0002\\u0002\\u0002\\u0016\\u008b\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0018\\u008d\\u0003\\u0002\\u0002\\u0002\\u001a\\u008f\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u001c\\u0091\\u0003\\u0002\\u0002\\u0002\\u001e\\u0099\",\n    \"\\u0003\\u0002\\u0002\\u0002 !\\u0005\\u0004\\u0003\\u0002!\\\"\\u0007\\u0002\\u0002\",\n    \"\\u0003\\\"\\u0003\\u0003\\u0002\\u0002\\u0002#$\\b\\u0003\\u0001\\u0002$(\\u0005\",\n    \"\\u0006\\u0004\\u0002%&\\t\\u0002\\u0002\\u0002&(\\u0005\\u0004\\u0003\\r\\'#\\u0003\",\n    \"\\u0002\\u0002\\u0002\\'%\\u0003\\u0002\\u0002\\u0002(Q\\u0003\\u0002\\u0002\\u0002\",\n    \")*\\f\\f\\u0002\\u0002*+\\t\\u0003\\u0002\\u0002+P\\u0005\\u0004\\u0003\\r,-\\f\\u000b\",\n    \"\\u0002\\u0002-.\\t\\u0004\\u0002\\u0002.P\\u0005\\u0004\\u0003\\f/0\\f\\n\\u0002\",\n    \"\\u000201\\u0007\\r\\u0002\\u00021P\\u0005\\u0004\\u0003\\u000b23\\f\\t\\u0002\\u0002\",\n    \"34\\t\\u0005\\u0002\\u00024P\\u0005\\u0004\\u0003\\n56\\f\\u0007\\u0002\\u00026\",\n    \"7\\t\\u0006\\u0002\\u00027P\\u0005\\u0004\\u0003\\b89\\f\\u0006\\u0002\\u00029:\",\n    \"\\t\\u0007\\u0002\\u0002:P\\u0005\\u0004\\u0003\\u0007;<\\f\\u0005\\u0002\\u0002\",\n    \"<=\\u0007\\u001a\\u0002\\u0002=P\\u0005\\u0004\\u0003\\u0006>?\\f\\u0004\\u0002\",\n    \"\\u0002?@\\t\\b\\u0002\\u0002@P\\u0005\\u0004\\u0003\\u0005AB\\f\\u0003\\u0002\\u0002\",\n    \"BC\\u0007\\u001d\\u0002\\u0002CP\\u0005\\u0004\\u0003\\u0004DE\\f\\u000f\\u0002\",\n    \"\\u0002EF\\u0007\\u0003\\u0002\\u0002FP\\u0005\\f\\u0007\\u0002GH\\f\\u000e\\u0002\",\n    \"\\u0002HI\\u0007\\u0004\\u0002\\u0002IJ\\u0005\\u0004\\u0003\\u0002JK\\u0007\\u0005\",\n    \"\\u0002\\u0002KP\\u0003\\u0002\\u0002\\u0002LM\\f\\b\\u0002\\u0002MN\\t\\t\\u0002\",\n    \"\\u0002NP\\u0005\\u001a\\u000e\\u0002O)\\u0003\\u0002\\u0002\\u0002O,\\u0003\\u0002\",\n    \"\\u0002\\u0002O/\\u0003\\u0002\\u0002\\u0002O2\\u0003\\u0002\\u0002\\u0002O5\\u0003\",\n    \"\\u0002\\u0002\\u0002O8\\u0003\\u0002\\u0002\\u0002O;\\u0003\\u0002\\u0002\\u0002\",\n    \"O>\\u0003\\u0002\\u0002\\u0002OA\\u0003\\u0002\\u0002\\u0002OD\\u0003\\u0002\\u0002\",\n    \"\\u0002OG\\u0003\\u0002\\u0002\\u0002OL\\u0003\\u0002\\u0002\\u0002PS\\u0003\\u0002\",\n    \"\\u0002\\u0002QO\\u0003\\u0002\\u0002\\u0002QR\\u0003\\u0002\\u0002\\u0002R\\u0005\",\n    \"\\u0003\\u0002\\u0002\\u0002SQ\\u0003\\u0002\\u0002\\u0002T\\\\\\u0005\\f\\u0007\",\n    \"\\u0002U\\\\\\u0005\\b\\u0005\\u0002V\\\\\\u0005\\n\\u0006\\u0002WX\\u0007\\u001e\\u0002\",\n    \"\\u0002XY\\u0005\\u0004\\u0003\\u0002YZ\\u0007\\u001f\\u0002\\u0002Z\\\\\\u0003\",\n    \"\\u0002\\u0002\\u0002[T\\u0003\\u0002\\u0002\\u0002[U\\u0003\\u0002\\u0002\\u0002\",\n    \"[V\\u0003\\u0002\\u0002\\u0002[W\\u0003\\u0002\\u0002\\u0002\\\\\\u0007\\u0003\\u0002\",\n    \"\\u0002\\u0002]^\\u0007 \\u0002\\u0002^f\\u0007!\\u0002\\u0002_f\\t\\n\\u0002\\u0002\",\n    \"`f\\u0007=\\u0002\\u0002af\\u0007>\\u0002\\u0002bf\\u00079\\u0002\\u0002cf\\u0007\",\n    \":\\u0002\\u0002df\\u0005\\u0012\\n\\u0002e]\\u0003\\u0002\\u0002\\u0002e_\\u0003\",\n    \"\\u0002\\u0002\\u0002e`\\u0003\\u0002\\u0002\\u0002ea\\u0003\\u0002\\u0002\\u0002\",\n    \"eb\\u0003\\u0002\\u0002\\u0002ec\\u0003\\u0002\\u0002\\u0002ed\\u0003\\u0002\\u0002\",\n    \"\\u0002f\\t\\u0003\\u0002\\u0002\\u0002gj\\u0007$\\u0002\\u0002hk\\u0005\\u001e\",\n    \"\\u0010\\u0002ik\\u0007=\\u0002\\u0002jh\\u0003\\u0002\\u0002\\u0002ji\\u0003\",\n    \"\\u0002\\u0002\\u0002k\\u000b\\u0003\\u0002\\u0002\\u0002lr\\u0005\\u001e\\u0010\",\n    \"\\u0002mr\\u0005\\u000e\\b\\u0002nr\\u0007%\\u0002\\u0002or\\u0007&\\u0002\\u0002\",\n    \"pr\\u0007\\'\\u0002\\u0002ql\\u0003\\u0002\\u0002\\u0002qm\\u0003\\u0002\\u0002\",\n    \"\\u0002qn\\u0003\\u0002\\u0002\\u0002qo\\u0003\\u0002\\u0002\\u0002qp\\u0003\\u0002\",\n    \"\\u0002\\u0002r\\r\\u0003\\u0002\\u0002\\u0002st\\u0005\\u001e\\u0010\\u0002tv\",\n    \"\\u0007\\u001e\\u0002\\u0002uw\\u0005\\u0010\\t\\u0002vu\\u0003\\u0002\\u0002\\u0002\",\n    \"vw\\u0003\\u0002\\u0002\\u0002wx\\u0003\\u0002\\u0002\\u0002xy\\u0007\\u001f\\u0002\",\n    \"\\u0002y\\u000f\\u0003\\u0002\\u0002\\u0002z\\u007f\\u0005\\u0004\\u0003\\u0002\",\n    \"{|\\u0007(\\u0002\\u0002|~\\u0005\\u0004\\u0003\\u0002}{\\u0003\\u0002\\u0002\",\n    \"\\u0002~\\u0081\\u0003\\u0002\\u0002\\u0002\\u007f}\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u007f\\u0080\\u0003\\u0002\\u0002\\u0002\\u0080\\u0011\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0081\\u007f\\u0003\\u0002\\u0002\\u0002\\u0082\\u0084\\u0007>\\u0002\\u0002\",\n    \"\\u0083\\u0085\\u0005\\u0014\\u000b\\u0002\\u0084\\u0083\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0084\\u0085\\u0003\\u0002\\u0002\\u0002\\u0085\\u0013\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0086\\u008a\\u0005\\u0016\\f\\u0002\\u0087\\u008a\\u0005\\u0018\\r\\u0002\\u0088\",\n    \"\\u008a\\u0007=\\u0002\\u0002\\u0089\\u0086\\u0003\\u0002\\u0002\\u0002\\u0089\",\n    \"\\u0087\\u0003\\u0002\\u0002\\u0002\\u0089\\u0088\\u0003\\u0002\\u0002\\u0002\\u008a\",\n    \"\\u0015\\u0003\\u0002\\u0002\\u0002\\u008b\\u008c\\t\\u000b\\u0002\\u0002\\u008c\",\n    \"\\u0017\\u0003\\u0002\\u0002\\u0002\\u008d\\u008e\\t\\f\\u0002\\u0002\\u008e\\u0019\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u008f\\u0090\\u0005\\u001c\\u000f\\u0002\\u0090\\u001b\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0091\\u0096\\u0005\\u001e\\u0010\\u0002\\u0092\\u0093\",\n    \"\\u0007\\u0003\\u0002\\u0002\\u0093\\u0095\\u0005\\u001e\\u0010\\u0002\\u0094\\u0092\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0095\\u0098\\u0003\\u0002\\u0002\\u0002\\u0096\\u0094\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0096\\u0097\\u0003\\u0002\\u0002\\u0002\\u0097\\u001d\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0098\\u0096\\u0003\\u0002\\u0002\\u0002\\u0099\\u009a\",\n    \"\\t\\r\\u0002\\u0002\\u009a\\u001f\\u0003\\u0002\\u0002\\u0002\\u000e\\'OQ[ejqv\",\n    \"\\u007f\\u0084\\u0089\\u0096\"].join(\"\");\n\n\nconst atn = new antlr4.atn.ATNDeserializer().deserialize(serializedATN);\n\nconst decisionsToDFA = atn.decisionToState.map( (ds, index) => new antlr4.dfa.DFA(ds, index) );\n\nconst sharedContextCache = new antlr4.PredictionContextCache();\n\nclass FHIRPathParser extends antlr4.Parser {\n\n    static grammarFileName = \"FHIRPath.g4\";\n    static literalNames = [ null, \"'.'\", \"'['\", \"']'\", \"'+'\", \"'-'\", \"'*'\", \n                            \"'/'\", \"'div'\", \"'mod'\", \"'&'\", \"'|'\", \"'<='\", \n                            \"'<'\", \"'>'\", \"'>='\", \"'is'\", \"'as'\", \"'='\", \n                            \"'~'\", \"'!='\", \"'!~'\", \"'in'\", \"'contains'\", \n                            \"'and'\", \"'or'\", \"'xor'\", \"'implies'\", \"'('\", \n                            \"')'\", \"'{'\", \"'}'\", \"'true'\", \"'false'\", \"'%'\", \n                            \"'$this'\", \"'$index'\", \"'$total'\", \"','\", \"'year'\", \n                            \"'month'\", \"'week'\", \"'day'\", \"'hour'\", \"'minute'\", \n                            \"'second'\", \"'millisecond'\", \"'years'\", \"'months'\", \n                            \"'weeks'\", \"'days'\", \"'hours'\", \"'minutes'\", \n                            \"'seconds'\", \"'milliseconds'\" ];\n    static symbolicNames = [ null, null, null, null, null, null, null, null, \n                             null, null, null, null, null, null, null, null, \n                             null, null, null, null, null, null, null, null, \n                             null, null, null, null, null, null, null, null, \n                             null, null, null, null, null, null, null, null, \n                             null, null, null, null, null, null, null, null, \n                             null, null, null, null, null, null, null, \"DATETIME\", \n                             \"TIME\", \"IDENTIFIER\", \"DELIMITEDIDENTIFIER\", \n                             \"STRING\", \"NUMBER\", \"WS\", \"COMMENT\", \"LINE_COMMENT\" ];\n    static ruleNames = [ \"entireExpression\", \"expression\", \"term\", \"literal\", \n                         \"externalConstant\", \"invocation\", \"functn\", \"paramList\", \n                         \"quantity\", \"unit\", \"dateTimePrecision\", \"pluralDateTimePrecision\", \n                         \"typeSpecifier\", \"qualifiedIdentifier\", \"identifier\" ];\n\n    constructor(input) {\n        super(input);\n        this._interp = new antlr4.atn.ParserATNSimulator(this, atn, decisionsToDFA, sharedContextCache);\n        this.ruleNames = FHIRPathParser.ruleNames;\n        this.literalNames = FHIRPathParser.literalNames;\n        this.symbolicNames = FHIRPathParser.symbolicNames;\n    }\n\n    get atn() {\n        return atn;\n    }\n\n    sempred(localctx, ruleIndex, predIndex) {\n    \tswitch(ruleIndex) {\n    \tcase 1:\n    \t    \t\treturn this.expression_sempred(localctx, predIndex);\n        default:\n            throw \"No predicate with index:\" + ruleIndex;\n       }\n    }\n\n    expression_sempred(localctx, predIndex) {\n    \tswitch(predIndex) {\n    \t\tcase 0:\n    \t\t\treturn this.precpred(this._ctx, 10);\n    \t\tcase 1:\n    \t\t\treturn this.precpred(this._ctx, 9);\n    \t\tcase 2:\n    \t\t\treturn this.precpred(this._ctx, 8);\n    \t\tcase 3:\n    \t\t\treturn this.precpred(this._ctx, 7);\n    \t\tcase 4:\n    \t\t\treturn this.precpred(this._ctx, 5);\n    \t\tcase 5:\n    \t\t\treturn this.precpred(this._ctx, 4);\n    \t\tcase 6:\n    \t\t\treturn this.precpred(this._ctx, 3);\n    \t\tcase 7:\n    \t\t\treturn this.precpred(this._ctx, 2);\n    \t\tcase 8:\n    \t\t\treturn this.precpred(this._ctx, 1);\n    \t\tcase 9:\n    \t\t\treturn this.precpred(this._ctx, 13);\n    \t\tcase 10:\n    \t\t\treturn this.precpred(this._ctx, 12);\n    \t\tcase 11:\n    \t\t\treturn this.precpred(this._ctx, 6);\n    \t\tdefault:\n    \t\t\tthrow \"No predicate with index:\" + predIndex;\n    \t}\n    };\n\n\n\n\n\tentireExpression() {\n\t    let localctx = new EntireExpressionContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 0, FHIRPathParser.RULE_entireExpression);\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 30;\n\t        this.expression(0);\n\t        this.state = 31;\n\t        this.match(FHIRPathParser.EOF);\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\texpression(_p) {\n\t\tif(_p===undefined) {\n\t\t    _p = 0;\n\t\t}\n\t    const _parentctx = this._ctx;\n\t    const _parentState = this.state;\n\t    let localctx = new ExpressionContext(this, this._ctx, _parentState);\n\t    let _prevctx = localctx;\n\t    const _startState = 2;\n\t    this.enterRecursionRule(localctx, 2, FHIRPathParser.RULE_expression, _p);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 37;\n\t        this._errHandler.sync(this);\n\t        switch(this._input.LA(1)) {\n\t        case FHIRPathParser.T__15:\n\t        case FHIRPathParser.T__16:\n\t        case FHIRPathParser.T__21:\n\t        case FHIRPathParser.T__22:\n\t        case FHIRPathParser.T__27:\n\t        case FHIRPathParser.T__29:\n\t        case FHIRPathParser.T__31:\n\t        case FHIRPathParser.T__32:\n\t        case FHIRPathParser.T__33:\n\t        case FHIRPathParser.T__34:\n\t        case FHIRPathParser.T__35:\n\t        case FHIRPathParser.T__36:\n\t        case FHIRPathParser.DATETIME:\n\t        case FHIRPathParser.TIME:\n\t        case FHIRPathParser.IDENTIFIER:\n\t        case FHIRPathParser.DELIMITEDIDENTIFIER:\n\t        case FHIRPathParser.STRING:\n\t        case FHIRPathParser.NUMBER:\n\t            localctx = new TermExpressionContext(this, localctx);\n\t            this._ctx = localctx;\n\t            _prevctx = localctx;\n\n\t            this.state = 34;\n\t            this.term();\n\t            break;\n\t        case FHIRPathParser.T__3:\n\t        case FHIRPathParser.T__4:\n\t            localctx = new PolarityExpressionContext(this, localctx);\n\t            this._ctx = localctx;\n\t            _prevctx = localctx;\n\t            this.state = 35;\n\t            _la = this._input.LA(1);\n\t            if(!(_la===FHIRPathParser.T__3 || _la===FHIRPathParser.T__4)) {\n\t            this._errHandler.recoverInline(this);\n\t            }\n\t            else {\n\t            \tthis._errHandler.reportMatch(this);\n\t                this.consume();\n\t            }\n\t            this.state = 36;\n\t            this.expression(11);\n\t            break;\n\t        default:\n\t            throw new antlr4.error.NoViableAltException(this);\n\t        }\n\t        this._ctx.stop = this._input.LT(-1);\n\t        this.state = 79;\n\t        this._errHandler.sync(this);\n\t        var _alt = this._interp.adaptivePredict(this._input,2,this._ctx)\n\t        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {\n\t            if(_alt===1) {\n\t                if(this._parseListeners!==null) {\n\t                    this.triggerExitRuleEvent();\n\t                }\n\t                _prevctx = localctx;\n\t                this.state = 77;\n\t                this._errHandler.sync(this);\n\t                var la_ = this._interp.adaptivePredict(this._input,1,this._ctx);\n\t                switch(la_) {\n\t                case 1:\n\t                    localctx = new MultiplicativeExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n\t                    this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n\t                    this.state = 39;\n\t                    if (!( this.precpred(this._ctx, 10))) {\n\t                        throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 10)\");\n\t                    }\n\t                    this.state = 40;\n\t                    _la = this._input.LA(1);\n\t                    if(!((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << FHIRPathParser.T__5) | (1 << FHIRPathParser.T__6) | (1 << FHIRPathParser.T__7) | (1 << FHIRPathParser.T__8))) !== 0))) {\n\t                    this._errHandler.recoverInline(this);\n\t                    }\n\t                    else {\n\t                    \tthis._errHandler.reportMatch(this);\n\t                        this.consume();\n\t                    }\n\t                    this.state = 41;\n\t                    this.expression(11);\n\t                    break;\n\n\t                case 2:\n\t                    localctx = new AdditiveExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n\t                    this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n\t                    this.state = 42;\n\t                    if (!( this.precpred(this._ctx, 9))) {\n\t                        throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 9)\");\n\t                    }\n\t                    this.state = 43;\n\t                    _la = this._input.LA(1);\n\t                    if(!((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << FHIRPathParser.T__3) | (1 << FHIRPathParser.T__4) | (1 << FHIRPathParser.T__9))) !== 0))) {\n\t                    this._errHandler.recoverInline(this);\n\t                    }\n\t                    else {\n\t                    \tthis._errHandler.reportMatch(this);\n\t                        this.consume();\n\t                    }\n\t                    this.state = 44;\n\t                    this.expression(10);\n\t                    break;\n\n\t                case 3:\n\t                    localctx = new UnionExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n\t                    this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n\t                    this.state = 45;\n\t                    if (!( this.precpred(this._ctx, 8))) {\n\t                        throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 8)\");\n\t                    }\n\t                    this.state = 46;\n\t                    this.match(FHIRPathParser.T__10);\n\t                    this.state = 47;\n\t                    this.expression(9);\n\t                    break;\n\n\t                case 4:\n\t                    localctx = new InequalityExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n\t                    this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n\t                    this.state = 48;\n\t                    if (!( this.precpred(this._ctx, 7))) {\n\t                        throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 7)\");\n\t                    }\n\t                    this.state = 49;\n\t                    _la = this._input.LA(1);\n\t                    if(!((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << FHIRPathParser.T__11) | (1 << FHIRPathParser.T__12) | (1 << FHIRPathParser.T__13) | (1 << FHIRPathParser.T__14))) !== 0))) {\n\t                    this._errHandler.recoverInline(this);\n\t                    }\n\t                    else {\n\t                    \tthis._errHandler.reportMatch(this);\n\t                        this.consume();\n\t                    }\n\t                    this.state = 50;\n\t                    this.expression(8);\n\t                    break;\n\n\t                case 5:\n\t                    localctx = new EqualityExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n\t                    this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n\t                    this.state = 51;\n\t                    if (!( this.precpred(this._ctx, 5))) {\n\t                        throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 5)\");\n\t                    }\n\t                    this.state = 52;\n\t                    _la = this._input.LA(1);\n\t                    if(!((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << FHIRPathParser.T__17) | (1 << FHIRPathParser.T__18) | (1 << FHIRPathParser.T__19) | (1 << FHIRPathParser.T__20))) !== 0))) {\n\t                    this._errHandler.recoverInline(this);\n\t                    }\n\t                    else {\n\t                    \tthis._errHandler.reportMatch(this);\n\t                        this.consume();\n\t                    }\n\t                    this.state = 53;\n\t                    this.expression(6);\n\t                    break;\n\n\t                case 6:\n\t                    localctx = new MembershipExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n\t                    this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n\t                    this.state = 54;\n\t                    if (!( this.precpred(this._ctx, 4))) {\n\t                        throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 4)\");\n\t                    }\n\t                    this.state = 55;\n\t                    _la = this._input.LA(1);\n\t                    if(!(_la===FHIRPathParser.T__21 || _la===FHIRPathParser.T__22)) {\n\t                    this._errHandler.recoverInline(this);\n\t                    }\n\t                    else {\n\t                    \tthis._errHandler.reportMatch(this);\n\t                        this.consume();\n\t                    }\n\t                    this.state = 56;\n\t                    this.expression(5);\n\t                    break;\n\n\t                case 7:\n\t                    localctx = new AndExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n\t                    this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n\t                    this.state = 57;\n\t                    if (!( this.precpred(this._ctx, 3))) {\n\t                        throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 3)\");\n\t                    }\n\t                    this.state = 58;\n\t                    this.match(FHIRPathParser.T__23);\n\t                    this.state = 59;\n\t                    this.expression(4);\n\t                    break;\n\n\t                case 8:\n\t                    localctx = new OrExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n\t                    this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n\t                    this.state = 60;\n\t                    if (!( this.precpred(this._ctx, 2))) {\n\t                        throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 2)\");\n\t                    }\n\t                    this.state = 61;\n\t                    _la = this._input.LA(1);\n\t                    if(!(_la===FHIRPathParser.T__24 || _la===FHIRPathParser.T__25)) {\n\t                    this._errHandler.recoverInline(this);\n\t                    }\n\t                    else {\n\t                    \tthis._errHandler.reportMatch(this);\n\t                        this.consume();\n\t                    }\n\t                    this.state = 62;\n\t                    this.expression(3);\n\t                    break;\n\n\t                case 9:\n\t                    localctx = new ImpliesExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n\t                    this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n\t                    this.state = 63;\n\t                    if (!( this.precpred(this._ctx, 1))) {\n\t                        throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 1)\");\n\t                    }\n\t                    this.state = 64;\n\t                    this.match(FHIRPathParser.T__26);\n\t                    this.state = 65;\n\t                    this.expression(2);\n\t                    break;\n\n\t                case 10:\n\t                    localctx = new InvocationExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n\t                    this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n\t                    this.state = 66;\n\t                    if (!( this.precpred(this._ctx, 13))) {\n\t                        throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 13)\");\n\t                    }\n\t                    this.state = 67;\n\t                    this.match(FHIRPathParser.T__0);\n\t                    this.state = 68;\n\t                    this.invocation();\n\t                    break;\n\n\t                case 11:\n\t                    localctx = new IndexerExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n\t                    this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n\t                    this.state = 69;\n\t                    if (!( this.precpred(this._ctx, 12))) {\n\t                        throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 12)\");\n\t                    }\n\t                    this.state = 70;\n\t                    this.match(FHIRPathParser.T__1);\n\t                    this.state = 71;\n\t                    this.expression(0);\n\t                    this.state = 72;\n\t                    this.match(FHIRPathParser.T__2);\n\t                    break;\n\n\t                case 12:\n\t                    localctx = new TypeExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n\t                    this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n\t                    this.state = 74;\n\t                    if (!( this.precpred(this._ctx, 6))) {\n\t                        throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 6)\");\n\t                    }\n\t                    this.state = 75;\n\t                    _la = this._input.LA(1);\n\t                    if(!(_la===FHIRPathParser.T__15 || _la===FHIRPathParser.T__16)) {\n\t                    this._errHandler.recoverInline(this);\n\t                    }\n\t                    else {\n\t                    \tthis._errHandler.reportMatch(this);\n\t                        this.consume();\n\t                    }\n\t                    this.state = 76;\n\t                    this.typeSpecifier();\n\t                    break;\n\n\t                } \n\t            }\n\t            this.state = 81;\n\t            this._errHandler.sync(this);\n\t            _alt = this._interp.adaptivePredict(this._input,2,this._ctx);\n\t        }\n\n\t    } catch( error) {\n\t        if(error instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = error;\n\t\t        this._errHandler.reportError(this, error);\n\t\t        this._errHandler.recover(this, error);\n\t\t    } else {\n\t\t    \tthrow error;\n\t\t    }\n\t    } finally {\n\t        this.unrollRecursionContexts(_parentctx)\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tterm() {\n\t    let localctx = new TermContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 4, FHIRPathParser.RULE_term);\n\t    try {\n\t        this.state = 89;\n\t        this._errHandler.sync(this);\n\t        switch(this._input.LA(1)) {\n\t        case FHIRPathParser.T__15:\n\t        case FHIRPathParser.T__16:\n\t        case FHIRPathParser.T__21:\n\t        case FHIRPathParser.T__22:\n\t        case FHIRPathParser.T__34:\n\t        case FHIRPathParser.T__35:\n\t        case FHIRPathParser.T__36:\n\t        case FHIRPathParser.IDENTIFIER:\n\t        case FHIRPathParser.DELIMITEDIDENTIFIER:\n\t            localctx = new InvocationTermContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 1);\n\t            this.state = 82;\n\t            this.invocation();\n\t            break;\n\t        case FHIRPathParser.T__29:\n\t        case FHIRPathParser.T__31:\n\t        case FHIRPathParser.T__32:\n\t        case FHIRPathParser.DATETIME:\n\t        case FHIRPathParser.TIME:\n\t        case FHIRPathParser.STRING:\n\t        case FHIRPathParser.NUMBER:\n\t            localctx = new LiteralTermContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 2);\n\t            this.state = 83;\n\t            this.literal();\n\t            break;\n\t        case FHIRPathParser.T__33:\n\t            localctx = new ExternalConstantTermContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 3);\n\t            this.state = 84;\n\t            this.externalConstant();\n\t            break;\n\t        case FHIRPathParser.T__27:\n\t            localctx = new ParenthesizedTermContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 4);\n\t            this.state = 85;\n\t            this.match(FHIRPathParser.T__27);\n\t            this.state = 86;\n\t            this.expression(0);\n\t            this.state = 87;\n\t            this.match(FHIRPathParser.T__28);\n\t            break;\n\t        default:\n\t            throw new antlr4.error.NoViableAltException(this);\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tliteral() {\n\t    let localctx = new LiteralContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 6, FHIRPathParser.RULE_literal);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.state = 99;\n\t        this._errHandler.sync(this);\n\t        var la_ = this._interp.adaptivePredict(this._input,4,this._ctx);\n\t        switch(la_) {\n\t        case 1:\n\t            localctx = new NullLiteralContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 1);\n\t            this.state = 91;\n\t            this.match(FHIRPathParser.T__29);\n\t            this.state = 92;\n\t            this.match(FHIRPathParser.T__30);\n\t            break;\n\n\t        case 2:\n\t            localctx = new BooleanLiteralContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 2);\n\t            this.state = 93;\n\t            _la = this._input.LA(1);\n\t            if(!(_la===FHIRPathParser.T__31 || _la===FHIRPathParser.T__32)) {\n\t            this._errHandler.recoverInline(this);\n\t            }\n\t            else {\n\t            \tthis._errHandler.reportMatch(this);\n\t                this.consume();\n\t            }\n\t            break;\n\n\t        case 3:\n\t            localctx = new StringLiteralContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 3);\n\t            this.state = 94;\n\t            this.match(FHIRPathParser.STRING);\n\t            break;\n\n\t        case 4:\n\t            localctx = new NumberLiteralContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 4);\n\t            this.state = 95;\n\t            this.match(FHIRPathParser.NUMBER);\n\t            break;\n\n\t        case 5:\n\t            localctx = new DateTimeLiteralContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 5);\n\t            this.state = 96;\n\t            this.match(FHIRPathParser.DATETIME);\n\t            break;\n\n\t        case 6:\n\t            localctx = new TimeLiteralContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 6);\n\t            this.state = 97;\n\t            this.match(FHIRPathParser.TIME);\n\t            break;\n\n\t        case 7:\n\t            localctx = new QuantityLiteralContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 7);\n\t            this.state = 98;\n\t            this.quantity();\n\t            break;\n\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\texternalConstant() {\n\t    let localctx = new ExternalConstantContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 8, FHIRPathParser.RULE_externalConstant);\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 101;\n\t        this.match(FHIRPathParser.T__33);\n\t        this.state = 104;\n\t        this._errHandler.sync(this);\n\t        switch(this._input.LA(1)) {\n\t        case FHIRPathParser.T__15:\n\t        case FHIRPathParser.T__16:\n\t        case FHIRPathParser.T__21:\n\t        case FHIRPathParser.T__22:\n\t        case FHIRPathParser.IDENTIFIER:\n\t        case FHIRPathParser.DELIMITEDIDENTIFIER:\n\t            this.state = 102;\n\t            this.identifier();\n\t            break;\n\t        case FHIRPathParser.STRING:\n\t            this.state = 103;\n\t            this.match(FHIRPathParser.STRING);\n\t            break;\n\t        default:\n\t            throw new antlr4.error.NoViableAltException(this);\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tinvocation() {\n\t    let localctx = new InvocationContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 10, FHIRPathParser.RULE_invocation);\n\t    try {\n\t        this.state = 111;\n\t        this._errHandler.sync(this);\n\t        var la_ = this._interp.adaptivePredict(this._input,6,this._ctx);\n\t        switch(la_) {\n\t        case 1:\n\t            localctx = new MemberInvocationContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 1);\n\t            this.state = 106;\n\t            this.identifier();\n\t            break;\n\n\t        case 2:\n\t            localctx = new FunctionInvocationContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 2);\n\t            this.state = 107;\n\t            this.functn();\n\t            break;\n\n\t        case 3:\n\t            localctx = new ThisInvocationContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 3);\n\t            this.state = 108;\n\t            this.match(FHIRPathParser.T__34);\n\t            break;\n\n\t        case 4:\n\t            localctx = new IndexInvocationContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 4);\n\t            this.state = 109;\n\t            this.match(FHIRPathParser.T__35);\n\t            break;\n\n\t        case 5:\n\t            localctx = new TotalInvocationContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 5);\n\t            this.state = 110;\n\t            this.match(FHIRPathParser.T__36);\n\t            break;\n\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tfunctn() {\n\t    let localctx = new FunctnContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 12, FHIRPathParser.RULE_functn);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 113;\n\t        this.identifier();\n\t        this.state = 114;\n\t        this.match(FHIRPathParser.T__27);\n\t        this.state = 116;\n\t        this._errHandler.sync(this);\n\t        _la = this._input.LA(1);\n\t        if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << FHIRPathParser.T__3) | (1 << FHIRPathParser.T__4) | (1 << FHIRPathParser.T__15) | (1 << FHIRPathParser.T__16) | (1 << FHIRPathParser.T__21) | (1 << FHIRPathParser.T__22) | (1 << FHIRPathParser.T__27) | (1 << FHIRPathParser.T__29))) !== 0) || ((((_la - 32)) & ~0x1f) == 0 && ((1 << (_la - 32)) & ((1 << (FHIRPathParser.T__31 - 32)) | (1 << (FHIRPathParser.T__32 - 32)) | (1 << (FHIRPathParser.T__33 - 32)) | (1 << (FHIRPathParser.T__34 - 32)) | (1 << (FHIRPathParser.T__35 - 32)) | (1 << (FHIRPathParser.T__36 - 32)) | (1 << (FHIRPathParser.DATETIME - 32)) | (1 << (FHIRPathParser.TIME - 32)) | (1 << (FHIRPathParser.IDENTIFIER - 32)) | (1 << (FHIRPathParser.DELIMITEDIDENTIFIER - 32)) | (1 << (FHIRPathParser.STRING - 32)) | (1 << (FHIRPathParser.NUMBER - 32)))) !== 0)) {\n\t            this.state = 115;\n\t            this.paramList();\n\t        }\n\n\t        this.state = 118;\n\t        this.match(FHIRPathParser.T__28);\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tparamList() {\n\t    let localctx = new ParamListContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 14, FHIRPathParser.RULE_paramList);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 120;\n\t        this.expression(0);\n\t        this.state = 125;\n\t        this._errHandler.sync(this);\n\t        _la = this._input.LA(1);\n\t        while(_la===FHIRPathParser.T__37) {\n\t            this.state = 121;\n\t            this.match(FHIRPathParser.T__37);\n\t            this.state = 122;\n\t            this.expression(0);\n\t            this.state = 127;\n\t            this._errHandler.sync(this);\n\t            _la = this._input.LA(1);\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tquantity() {\n\t    let localctx = new QuantityContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 16, FHIRPathParser.RULE_quantity);\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 128;\n\t        this.match(FHIRPathParser.NUMBER);\n\t        this.state = 130;\n\t        this._errHandler.sync(this);\n\t        var la_ = this._interp.adaptivePredict(this._input,9,this._ctx);\n\t        if(la_===1) {\n\t            this.state = 129;\n\t            this.unit();\n\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tunit() {\n\t    let localctx = new UnitContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 18, FHIRPathParser.RULE_unit);\n\t    try {\n\t        this.state = 135;\n\t        this._errHandler.sync(this);\n\t        switch(this._input.LA(1)) {\n\t        case FHIRPathParser.T__38:\n\t        case FHIRPathParser.T__39:\n\t        case FHIRPathParser.T__40:\n\t        case FHIRPathParser.T__41:\n\t        case FHIRPathParser.T__42:\n\t        case FHIRPathParser.T__43:\n\t        case FHIRPathParser.T__44:\n\t        case FHIRPathParser.T__45:\n\t            this.enterOuterAlt(localctx, 1);\n\t            this.state = 132;\n\t            this.dateTimePrecision();\n\t            break;\n\t        case FHIRPathParser.T__46:\n\t        case FHIRPathParser.T__47:\n\t        case FHIRPathParser.T__48:\n\t        case FHIRPathParser.T__49:\n\t        case FHIRPathParser.T__50:\n\t        case FHIRPathParser.T__51:\n\t        case FHIRPathParser.T__52:\n\t        case FHIRPathParser.T__53:\n\t            this.enterOuterAlt(localctx, 2);\n\t            this.state = 133;\n\t            this.pluralDateTimePrecision();\n\t            break;\n\t        case FHIRPathParser.STRING:\n\t            this.enterOuterAlt(localctx, 3);\n\t            this.state = 134;\n\t            this.match(FHIRPathParser.STRING);\n\t            break;\n\t        default:\n\t            throw new antlr4.error.NoViableAltException(this);\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tdateTimePrecision() {\n\t    let localctx = new DateTimePrecisionContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 20, FHIRPathParser.RULE_dateTimePrecision);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 137;\n\t        _la = this._input.LA(1);\n\t        if(!(((((_la - 39)) & ~0x1f) == 0 && ((1 << (_la - 39)) & ((1 << (FHIRPathParser.T__38 - 39)) | (1 << (FHIRPathParser.T__39 - 39)) | (1 << (FHIRPathParser.T__40 - 39)) | (1 << (FHIRPathParser.T__41 - 39)) | (1 << (FHIRPathParser.T__42 - 39)) | (1 << (FHIRPathParser.T__43 - 39)) | (1 << (FHIRPathParser.T__44 - 39)) | (1 << (FHIRPathParser.T__45 - 39)))) !== 0))) {\n\t        this._errHandler.recoverInline(this);\n\t        }\n\t        else {\n\t        \tthis._errHandler.reportMatch(this);\n\t            this.consume();\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tpluralDateTimePrecision() {\n\t    let localctx = new PluralDateTimePrecisionContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 22, FHIRPathParser.RULE_pluralDateTimePrecision);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 139;\n\t        _la = this._input.LA(1);\n\t        if(!(((((_la - 47)) & ~0x1f) == 0 && ((1 << (_la - 47)) & ((1 << (FHIRPathParser.T__46 - 47)) | (1 << (FHIRPathParser.T__47 - 47)) | (1 << (FHIRPathParser.T__48 - 47)) | (1 << (FHIRPathParser.T__49 - 47)) | (1 << (FHIRPathParser.T__50 - 47)) | (1 << (FHIRPathParser.T__51 - 47)) | (1 << (FHIRPathParser.T__52 - 47)) | (1 << (FHIRPathParser.T__53 - 47)))) !== 0))) {\n\t        this._errHandler.recoverInline(this);\n\t        }\n\t        else {\n\t        \tthis._errHandler.reportMatch(this);\n\t            this.consume();\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\ttypeSpecifier() {\n\t    let localctx = new TypeSpecifierContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 24, FHIRPathParser.RULE_typeSpecifier);\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 141;\n\t        this.qualifiedIdentifier();\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tqualifiedIdentifier() {\n\t    let localctx = new QualifiedIdentifierContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 26, FHIRPathParser.RULE_qualifiedIdentifier);\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 143;\n\t        this.identifier();\n\t        this.state = 148;\n\t        this._errHandler.sync(this);\n\t        var _alt = this._interp.adaptivePredict(this._input,11,this._ctx)\n\t        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {\n\t            if(_alt===1) {\n\t                this.state = 144;\n\t                this.match(FHIRPathParser.T__0);\n\t                this.state = 145;\n\t                this.identifier(); \n\t            }\n\t            this.state = 150;\n\t            this._errHandler.sync(this);\n\t            _alt = this._interp.adaptivePredict(this._input,11,this._ctx);\n\t        }\n\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tidentifier() {\n\t    let localctx = new IdentifierContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 28, FHIRPathParser.RULE_identifier);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 151;\n\t        _la = this._input.LA(1);\n\t        if(!((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << FHIRPathParser.T__15) | (1 << FHIRPathParser.T__16) | (1 << FHIRPathParser.T__21) | (1 << FHIRPathParser.T__22))) !== 0) || _la===FHIRPathParser.IDENTIFIER || _la===FHIRPathParser.DELIMITEDIDENTIFIER)) {\n\t        this._errHandler.recoverInline(this);\n\t        }\n\t        else {\n\t        \tthis._errHandler.reportMatch(this);\n\t            this.consume();\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n}\n\nFHIRPathParser.EOF = antlr4.Token.EOF;\nFHIRPathParser.T__0 = 1;\nFHIRPathParser.T__1 = 2;\nFHIRPathParser.T__2 = 3;\nFHIRPathParser.T__3 = 4;\nFHIRPathParser.T__4 = 5;\nFHIRPathParser.T__5 = 6;\nFHIRPathParser.T__6 = 7;\nFHIRPathParser.T__7 = 8;\nFHIRPathParser.T__8 = 9;\nFHIRPathParser.T__9 = 10;\nFHIRPathParser.T__10 = 11;\nFHIRPathParser.T__11 = 12;\nFHIRPathParser.T__12 = 13;\nFHIRPathParser.T__13 = 14;\nFHIRPathParser.T__14 = 15;\nFHIRPathParser.T__15 = 16;\nFHIRPathParser.T__16 = 17;\nFHIRPathParser.T__17 = 18;\nFHIRPathParser.T__18 = 19;\nFHIRPathParser.T__19 = 20;\nFHIRPathParser.T__20 = 21;\nFHIRPathParser.T__21 = 22;\nFHIRPathParser.T__22 = 23;\nFHIRPathParser.T__23 = 24;\nFHIRPathParser.T__24 = 25;\nFHIRPathParser.T__25 = 26;\nFHIRPathParser.T__26 = 27;\nFHIRPathParser.T__27 = 28;\nFHIRPathParser.T__28 = 29;\nFHIRPathParser.T__29 = 30;\nFHIRPathParser.T__30 = 31;\nFHIRPathParser.T__31 = 32;\nFHIRPathParser.T__32 = 33;\nFHIRPathParser.T__33 = 34;\nFHIRPathParser.T__34 = 35;\nFHIRPathParser.T__35 = 36;\nFHIRPathParser.T__36 = 37;\nFHIRPathParser.T__37 = 38;\nFHIRPathParser.T__38 = 39;\nFHIRPathParser.T__39 = 40;\nFHIRPathParser.T__40 = 41;\nFHIRPathParser.T__41 = 42;\nFHIRPathParser.T__42 = 43;\nFHIRPathParser.T__43 = 44;\nFHIRPathParser.T__44 = 45;\nFHIRPathParser.T__45 = 46;\nFHIRPathParser.T__46 = 47;\nFHIRPathParser.T__47 = 48;\nFHIRPathParser.T__48 = 49;\nFHIRPathParser.T__49 = 50;\nFHIRPathParser.T__50 = 51;\nFHIRPathParser.T__51 = 52;\nFHIRPathParser.T__52 = 53;\nFHIRPathParser.T__53 = 54;\nFHIRPathParser.DATETIME = 55;\nFHIRPathParser.TIME = 56;\nFHIRPathParser.IDENTIFIER = 57;\nFHIRPathParser.DELIMITEDIDENTIFIER = 58;\nFHIRPathParser.STRING = 59;\nFHIRPathParser.NUMBER = 60;\nFHIRPathParser.WS = 61;\nFHIRPathParser.COMMENT = 62;\nFHIRPathParser.LINE_COMMENT = 63;\n\nFHIRPathParser.RULE_entireExpression = 0;\nFHIRPathParser.RULE_expression = 1;\nFHIRPathParser.RULE_term = 2;\nFHIRPathParser.RULE_literal = 3;\nFHIRPathParser.RULE_externalConstant = 4;\nFHIRPathParser.RULE_invocation = 5;\nFHIRPathParser.RULE_functn = 6;\nFHIRPathParser.RULE_paramList = 7;\nFHIRPathParser.RULE_quantity = 8;\nFHIRPathParser.RULE_unit = 9;\nFHIRPathParser.RULE_dateTimePrecision = 10;\nFHIRPathParser.RULE_pluralDateTimePrecision = 11;\nFHIRPathParser.RULE_typeSpecifier = 12;\nFHIRPathParser.RULE_qualifiedIdentifier = 13;\nFHIRPathParser.RULE_identifier = 14;\n\nclass EntireExpressionContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_entireExpression;\n    }\n\n\texpression() {\n\t    return this.getTypedRuleContext(ExpressionContext,0);\n\t};\n\n\tEOF() {\n\t    return this.getToken(FHIRPathParser.EOF, 0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterEntireExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitEntireExpression(this);\n\t\t}\n\t}\n\n\n}\n\n\n\nclass ExpressionContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_expression;\n    }\n\n\n\t \n\t\tcopyFrom(ctx) {\n\t\t\tsuper.copyFrom(ctx);\n\t\t}\n\n}\n\n\nclass IndexerExpressionContext extends ExpressionContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texpression = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(ExpressionContext);\n\t    } else {\n\t        return this.getTypedRuleContext(ExpressionContext,i);\n\t    }\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterIndexerExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitIndexerExpression(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.IndexerExpressionContext = IndexerExpressionContext;\n\nclass PolarityExpressionContext extends ExpressionContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texpression() {\n\t    return this.getTypedRuleContext(ExpressionContext,0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterPolarityExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitPolarityExpression(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.PolarityExpressionContext = PolarityExpressionContext;\n\nclass AdditiveExpressionContext extends ExpressionContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texpression = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(ExpressionContext);\n\t    } else {\n\t        return this.getTypedRuleContext(ExpressionContext,i);\n\t    }\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterAdditiveExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitAdditiveExpression(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.AdditiveExpressionContext = AdditiveExpressionContext;\n\nclass MultiplicativeExpressionContext extends ExpressionContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texpression = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(ExpressionContext);\n\t    } else {\n\t        return this.getTypedRuleContext(ExpressionContext,i);\n\t    }\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterMultiplicativeExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitMultiplicativeExpression(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.MultiplicativeExpressionContext = MultiplicativeExpressionContext;\n\nclass UnionExpressionContext extends ExpressionContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texpression = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(ExpressionContext);\n\t    } else {\n\t        return this.getTypedRuleContext(ExpressionContext,i);\n\t    }\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterUnionExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitUnionExpression(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.UnionExpressionContext = UnionExpressionContext;\n\nclass OrExpressionContext extends ExpressionContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texpression = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(ExpressionContext);\n\t    } else {\n\t        return this.getTypedRuleContext(ExpressionContext,i);\n\t    }\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterOrExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitOrExpression(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.OrExpressionContext = OrExpressionContext;\n\nclass AndExpressionContext extends ExpressionContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texpression = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(ExpressionContext);\n\t    } else {\n\t        return this.getTypedRuleContext(ExpressionContext,i);\n\t    }\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterAndExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitAndExpression(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.AndExpressionContext = AndExpressionContext;\n\nclass MembershipExpressionContext extends ExpressionContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texpression = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(ExpressionContext);\n\t    } else {\n\t        return this.getTypedRuleContext(ExpressionContext,i);\n\t    }\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterMembershipExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitMembershipExpression(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.MembershipExpressionContext = MembershipExpressionContext;\n\nclass InequalityExpressionContext extends ExpressionContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texpression = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(ExpressionContext);\n\t    } else {\n\t        return this.getTypedRuleContext(ExpressionContext,i);\n\t    }\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterInequalityExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitInequalityExpression(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.InequalityExpressionContext = InequalityExpressionContext;\n\nclass InvocationExpressionContext extends ExpressionContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texpression() {\n\t    return this.getTypedRuleContext(ExpressionContext,0);\n\t};\n\n\tinvocation() {\n\t    return this.getTypedRuleContext(InvocationContext,0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterInvocationExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitInvocationExpression(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.InvocationExpressionContext = InvocationExpressionContext;\n\nclass EqualityExpressionContext extends ExpressionContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texpression = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(ExpressionContext);\n\t    } else {\n\t        return this.getTypedRuleContext(ExpressionContext,i);\n\t    }\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterEqualityExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitEqualityExpression(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.EqualityExpressionContext = EqualityExpressionContext;\n\nclass ImpliesExpressionContext extends ExpressionContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texpression = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(ExpressionContext);\n\t    } else {\n\t        return this.getTypedRuleContext(ExpressionContext,i);\n\t    }\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterImpliesExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitImpliesExpression(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.ImpliesExpressionContext = ImpliesExpressionContext;\n\nclass TermExpressionContext extends ExpressionContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\tterm() {\n\t    return this.getTypedRuleContext(TermContext,0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterTermExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitTermExpression(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.TermExpressionContext = TermExpressionContext;\n\nclass TypeExpressionContext extends ExpressionContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texpression() {\n\t    return this.getTypedRuleContext(ExpressionContext,0);\n\t};\n\n\ttypeSpecifier() {\n\t    return this.getTypedRuleContext(TypeSpecifierContext,0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterTypeExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitTypeExpression(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.TypeExpressionContext = TypeExpressionContext;\n\nclass TermContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_term;\n    }\n\n\n\t \n\t\tcopyFrom(ctx) {\n\t\t\tsuper.copyFrom(ctx);\n\t\t}\n\n}\n\n\nclass ExternalConstantTermContext extends TermContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texternalConstant() {\n\t    return this.getTypedRuleContext(ExternalConstantContext,0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterExternalConstantTerm(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitExternalConstantTerm(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.ExternalConstantTermContext = ExternalConstantTermContext;\n\nclass LiteralTermContext extends TermContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\tliteral() {\n\t    return this.getTypedRuleContext(LiteralContext,0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterLiteralTerm(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitLiteralTerm(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.LiteralTermContext = LiteralTermContext;\n\nclass ParenthesizedTermContext extends TermContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texpression() {\n\t    return this.getTypedRuleContext(ExpressionContext,0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterParenthesizedTerm(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitParenthesizedTerm(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.ParenthesizedTermContext = ParenthesizedTermContext;\n\nclass InvocationTermContext extends TermContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\tinvocation() {\n\t    return this.getTypedRuleContext(InvocationContext,0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterInvocationTerm(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitInvocationTerm(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.InvocationTermContext = InvocationTermContext;\n\nclass LiteralContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_literal;\n    }\n\n\n\t \n\t\tcopyFrom(ctx) {\n\t\t\tsuper.copyFrom(ctx);\n\t\t}\n\n}\n\n\nclass TimeLiteralContext extends LiteralContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\tTIME() {\n\t    return this.getToken(FHIRPathParser.TIME, 0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterTimeLiteral(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitTimeLiteral(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.TimeLiteralContext = TimeLiteralContext;\n\nclass NullLiteralContext extends LiteralContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterNullLiteral(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitNullLiteral(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.NullLiteralContext = NullLiteralContext;\n\nclass DateTimeLiteralContext extends LiteralContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\tDATETIME() {\n\t    return this.getToken(FHIRPathParser.DATETIME, 0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterDateTimeLiteral(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitDateTimeLiteral(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.DateTimeLiteralContext = DateTimeLiteralContext;\n\nclass StringLiteralContext extends LiteralContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\tSTRING() {\n\t    return this.getToken(FHIRPathParser.STRING, 0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterStringLiteral(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitStringLiteral(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.StringLiteralContext = StringLiteralContext;\n\nclass BooleanLiteralContext extends LiteralContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterBooleanLiteral(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitBooleanLiteral(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.BooleanLiteralContext = BooleanLiteralContext;\n\nclass NumberLiteralContext extends LiteralContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\tNUMBER() {\n\t    return this.getToken(FHIRPathParser.NUMBER, 0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterNumberLiteral(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitNumberLiteral(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.NumberLiteralContext = NumberLiteralContext;\n\nclass QuantityLiteralContext extends LiteralContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\tquantity() {\n\t    return this.getTypedRuleContext(QuantityContext,0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterQuantityLiteral(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitQuantityLiteral(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.QuantityLiteralContext = QuantityLiteralContext;\n\nclass ExternalConstantContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_externalConstant;\n    }\n\n\tidentifier() {\n\t    return this.getTypedRuleContext(IdentifierContext,0);\n\t};\n\n\tSTRING() {\n\t    return this.getToken(FHIRPathParser.STRING, 0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterExternalConstant(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitExternalConstant(this);\n\t\t}\n\t}\n\n\n}\n\n\n\nclass InvocationContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_invocation;\n    }\n\n\n\t \n\t\tcopyFrom(ctx) {\n\t\t\tsuper.copyFrom(ctx);\n\t\t}\n\n}\n\n\nclass TotalInvocationContext extends InvocationContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterTotalInvocation(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitTotalInvocation(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.TotalInvocationContext = TotalInvocationContext;\n\nclass ThisInvocationContext extends InvocationContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterThisInvocation(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitThisInvocation(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.ThisInvocationContext = ThisInvocationContext;\n\nclass IndexInvocationContext extends InvocationContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterIndexInvocation(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitIndexInvocation(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.IndexInvocationContext = IndexInvocationContext;\n\nclass FunctionInvocationContext extends InvocationContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\tfunctn() {\n\t    return this.getTypedRuleContext(FunctnContext,0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterFunctionInvocation(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitFunctionInvocation(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.FunctionInvocationContext = FunctionInvocationContext;\n\nclass MemberInvocationContext extends InvocationContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\tidentifier() {\n\t    return this.getTypedRuleContext(IdentifierContext,0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterMemberInvocation(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitMemberInvocation(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.MemberInvocationContext = MemberInvocationContext;\n\nclass FunctnContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_functn;\n    }\n\n\tidentifier() {\n\t    return this.getTypedRuleContext(IdentifierContext,0);\n\t};\n\n\tparamList() {\n\t    return this.getTypedRuleContext(ParamListContext,0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterFunctn(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitFunctn(this);\n\t\t}\n\t}\n\n\n}\n\n\n\nclass ParamListContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_paramList;\n    }\n\n\texpression = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(ExpressionContext);\n\t    } else {\n\t        return this.getTypedRuleContext(ExpressionContext,i);\n\t    }\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterParamList(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitParamList(this);\n\t\t}\n\t}\n\n\n}\n\n\n\nclass QuantityContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_quantity;\n    }\n\n\tNUMBER() {\n\t    return this.getToken(FHIRPathParser.NUMBER, 0);\n\t};\n\n\tunit() {\n\t    return this.getTypedRuleContext(UnitContext,0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterQuantity(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitQuantity(this);\n\t\t}\n\t}\n\n\n}\n\n\n\nclass UnitContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_unit;\n    }\n\n\tdateTimePrecision() {\n\t    return this.getTypedRuleContext(DateTimePrecisionContext,0);\n\t};\n\n\tpluralDateTimePrecision() {\n\t    return this.getTypedRuleContext(PluralDateTimePrecisionContext,0);\n\t};\n\n\tSTRING() {\n\t    return this.getToken(FHIRPathParser.STRING, 0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterUnit(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitUnit(this);\n\t\t}\n\t}\n\n\n}\n\n\n\nclass DateTimePrecisionContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_dateTimePrecision;\n    }\n\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterDateTimePrecision(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitDateTimePrecision(this);\n\t\t}\n\t}\n\n\n}\n\n\n\nclass PluralDateTimePrecisionContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_pluralDateTimePrecision;\n    }\n\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterPluralDateTimePrecision(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitPluralDateTimePrecision(this);\n\t\t}\n\t}\n\n\n}\n\n\n\nclass TypeSpecifierContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_typeSpecifier;\n    }\n\n\tqualifiedIdentifier() {\n\t    return this.getTypedRuleContext(QualifiedIdentifierContext,0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterTypeSpecifier(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitTypeSpecifier(this);\n\t\t}\n\t}\n\n\n}\n\n\n\nclass QualifiedIdentifierContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_qualifiedIdentifier;\n    }\n\n\tidentifier = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(IdentifierContext);\n\t    } else {\n\t        return this.getTypedRuleContext(IdentifierContext,i);\n\t    }\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterQualifiedIdentifier(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitQualifiedIdentifier(this);\n\t\t}\n\t}\n\n\n}\n\n\n\nclass IdentifierContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_identifier;\n    }\n\n\tIDENTIFIER() {\n\t    return this.getToken(FHIRPathParser.IDENTIFIER, 0);\n\t};\n\n\tDELIMITEDIDENTIFIER() {\n\t    return this.getToken(FHIRPathParser.DELIMITEDIDENTIFIER, 0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterIdentifier(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitIdentifier(this);\n\t\t}\n\t}\n\n\n}\n\n\n\n\nFHIRPathParser.EntireExpressionContext = EntireExpressionContext; \nFHIRPathParser.ExpressionContext = ExpressionContext; \nFHIRPathParser.TermContext = TermContext; \nFHIRPathParser.LiteralContext = LiteralContext; \nFHIRPathParser.ExternalConstantContext = ExternalConstantContext; \nFHIRPathParser.InvocationContext = InvocationContext; \nFHIRPathParser.FunctnContext = FunctnContext; \nFHIRPathParser.ParamListContext = ParamListContext; \nFHIRPathParser.QuantityContext = QuantityContext; \nFHIRPathParser.UnitContext = UnitContext; \nFHIRPathParser.DateTimePrecisionContext = DateTimePrecisionContext; \nFHIRPathParser.PluralDateTimePrecisionContext = PluralDateTimePrecisionContext; \nFHIRPathParser.TypeSpecifierContext = TypeSpecifierContext; \nFHIRPathParser.QualifiedIdentifierContext = QualifiedIdentifierContext; \nFHIRPathParser.IdentifierContext = IdentifierContext; \n\nmodule.exports = FHIRPathParser;","const antlr4 = require(\"./antlr4-index\");\nconst Lexer = require(\"./generated/FHIRPathLexer\");\nconst Parser = require(\"./generated/FHIRPathParser\");\nconst Listener = require(\"./generated/FHIRPathListener\");\n\n\nclass ErrorListener extends antlr4.error.ErrorListener {\n  constructor(errors) {\n    super();\n    this.errors = errors;\n  }\n  syntaxError(rec, sym, line, col, msg, e) {\n    this.errors.push([rec, sym, line, col, msg, e]);\n  }\n}\n\nvar parse = function(path){\n  var chars = new antlr4.InputStream(path);\n  var lexer = new Lexer(chars);\n\n  var tokens  = new antlr4.CommonTokenStream(lexer);\n\n\n  var parser = new Parser(tokens);\n  parser.buildParseTrees = true;\n  var errors = [];\n  var listener = new ErrorListener(errors);\n\n  lexer.removeErrorListeners();\n  lexer.addErrorListener(listener);\n  parser.removeErrorListeners();\n  parser.addErrorListener(listener);\n\n  var tree = parser.entireExpression();\n\n  class PathListener extends Listener{\n    constructor() {\n      super();\n    }\n  }\n\n  var ast = {};\n  var node;\n  var parentStack = [ast];\n  for (let p of Object.getOwnPropertyNames(Listener.prototype)) {\n    if (p.startsWith(\"enter\")) {\n      PathListener.prototype[p] = function(ctx) {\n        let parentNode = parentStack[parentStack.length - 1];\n        let nodeType = p.slice(5); // remove \"enter\"\n        node = {type: nodeType};\n        node.text = ctx.getText();\n        if (!parentNode.children)\n          parentNode.children = [];\n        parentNode.children.push(node);\n        parentStack.push(node);\n        // Also collect this node's terminal nodes, if any.  Terminal nodes are\n        // not walked with the rest of the tree, but include things like \"+\" and\n        // \"-\", which we need.\n        node.terminalNodeText = [];\n        for (let c of ctx.children) {\n          // Test for node type \"TerminalNodeImpl\".  Minimized code no longer\n          // has the original function names, so we can't rely on\n          // c.constructor.name.  It appears the TerminalNodeImpl is the only\n          // node with a \"symbol\" property, so test for that.\n          if (c.symbol)\n            node.terminalNodeText.push(c.getText());\n        }\n      };\n    }\n    else if (p.startsWith(\"exit\")) {\n      PathListener.prototype[p] = function() {\n        parentStack.pop();\n      };\n    }\n  }\n\n  var printer = new PathListener();\n  antlr4.tree.ParseTreeWalker.DEFAULT.walk(printer, tree);\n\n  if (errors.length > 0) {\n    let errMsgs = [];\n    for (let i=0, len=errors.length; i<len; ++i) {\n      let err = errors[i];\n      let msg = \"line: \"+err[2]+\"; column: \"+ err[3]+\"; message: \"+err[4];\n      errMsgs.push(msg);\n    }\n    var e = new Error(errMsgs.join(\"\\n\"));\n    e.errors = errors;\n    throw e;\n  }\n  return ast;\n};\n\n\nmodule.exports = {\n  parse: parse\n};\n","// Binding the function Array.prototype.slice.call for convert Array-like objects/collections to a new Array.\nconst slice = Function.prototype.call.bind(Array.prototype.slice);\n\n// isInteger (not in IE)\n// From Mozilla docs\nNumber.isInteger = Number.isInteger || function(value) {\n  return typeof value === 'number' &&\n    isFinite(value) &&\n    Math.floor(value) === value;\n};\n\n\nif (!String.prototype.startsWith) {\n  // From Mozilla docs with little changes\n  Object.defineProperty(String.prototype, 'startsWith', {\n    value: function(searchString, position) {\n      position = position || 0;\n      return this.indexOf(searchString, position) === position;\n    }\n  });\n}\n\nif (!String.prototype.endsWith) {\n  // From Mozilla docs with little changes\n  Object.defineProperty(String.prototype, 'endsWith', {\n    value: function(searchString, position) {\n      var subjectString = this.toString();\n      if (position === undefined || position > subjectString.length) {\n        position = subjectString.length;\n      }\n      position -= searchString.length;\n      var lastIndex = subjectString.indexOf(searchString, position);\n      return lastIndex !== -1 && lastIndex === position;\n    }\n  });\n}\n\nif (!String.prototype.includes) {\n  Object.defineProperty(String.prototype, 'includes', {\n    value: function() {\n      return this.indexOf.apply(this, arguments) !== -1;\n    }\n  });\n}\n\nif (!Object.assign) {\n  // From Mozilla docs with little changes\n  Object.defineProperty(Object, 'assign', {\n    value: function(target) {\n      if (target === undefined || target === null) {\n        throw new TypeError('Cannot convert undefined or null to object');\n      }\n\n      return slice(arguments, 1).reduce(function (to, nextSource) {\n        Object.keys(Object(nextSource)).forEach(function (nextKey) {\n          to[nextKey] = nextSource[nextKey];\n        });\n        return to;\n      },  Object(target));\n    }\n  });\n}","const util = require(\"./utilities\");\nconst misc = require(\"./misc\");\n\nconst engine = {};\n\n// Cache for rewritten RegExp patterns\nconst cachedRegExp = {};\n\n/**\n * Rewrites RegExp pattern to support single-line mode (dotAll) in IE11:\n * To do that we replace \".\" with \"[^]\" in source RegExp pattern,\n * except where \".\" is escaped or is inside unescaped [].\n * Another way to do the same is using package regexpu-core\n * or packages regjsparser/regjsgen.\n * @param {string} pattern - source RegExp pattern\n * @return {string}\n */\nfunction rewritePatternForDotAll(pattern) {\n  if (!cachedRegExp[pattern]) {\n    cachedRegExp[pattern] = pattern.replace(/\\./g, (_, offset, entirePattern) => {\n      // The preceding part of the string\n      const precedingPart = entirePattern.substr(0, offset);\n      // The preceding part of the string without escaped characters: '\\', '[' or ']'\n      const cleanPrecedingPart = precedingPart\n        .replace(/\\\\\\\\/g, '')\n        .replace(/\\\\[\\][]/g, '');\n      // Check if '.' is escaped\n      const escaped = cleanPrecedingPart[cleanPrecedingPart.length - 1] === '\\\\';\n      // The last index of unescaped '['\n      const lastIndexOfOpenBracket = cleanPrecedingPart.lastIndexOf('[');\n      // The last index of unescaped ']'\n      const lastIndexOfCloseBracket = cleanPrecedingPart.lastIndexOf(']');\n      return escaped ||\n      (lastIndexOfOpenBracket > lastIndexOfCloseBracket)\n        ? '.'\n        : '[^]';\n    });\n  }\n\n  return cachedRegExp[pattern];\n}\n\nengine.indexOf = function(coll, substr){\n  const str = misc.singleton(coll, 'String');\n  return util.isEmpty(substr) || util.isEmpty(str) ? [] : str.indexOf(substr);\n};\n\nengine.substring = function(coll, start, length){\n  const str = misc.singleton(coll, 'String');\n  if (util.isEmpty(str) || util.isEmpty(start) || start < 0 || start >= str.length) {\n    return  [];\n  }\n  if (length === undefined || util.isEmpty(length)) {\n    return str.substring(start);\n  }\n  return str.substring(start, start + length);\n};\n\nengine.startsWith = function(coll, prefix){\n  const str = misc.singleton(coll, 'String');\n  return util.isEmpty(prefix) || util.isEmpty(str) ? [] : str.startsWith(prefix);\n};\n\nengine.endsWith = function(coll, postfix) {\n  const str = misc.singleton(coll, 'String');\n  return util.isEmpty(postfix) || util.isEmpty(str) ? [] : str.endsWith(postfix);\n};\n\nengine.containsFn = function(coll, substr){\n  const str = misc.singleton(coll, 'String');\n  return util.isEmpty(substr) || util.isEmpty(str) ? [] : str.includes(substr);\n};\n\nengine.upper = function(coll){\n  const str = misc.singleton(coll, 'String');\n  return util.isEmpty(str) ? [] : str.toUpperCase();\n};\n\n\nengine.lower = function(coll){\n  const str = misc.singleton(coll, 'String');\n  return util.isEmpty(str) ? [] : str.toLowerCase();\n};\n\n// Check if dotAll is supported.\n// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/dotAll for details.\nconst dotAllIsSupported = (new RegExp('')).dotAll === false;\n\nif (dotAllIsSupported) {\n  engine.matches = function(coll, regex) {\n    const str = misc.singleton(coll, 'String');\n    if (util.isEmpty(regex) || util.isEmpty(str)) {\n      return [];\n    }\n    const reg = new RegExp(regex, 's');\n    return reg.test(str);\n  };\n} else {\n  engine.matches = function(coll, regex) {\n    const str = misc.singleton(coll, 'String');\n    if (util.isEmpty(regex) || util.isEmpty(str)) {\n      return [];\n    }\n    const reg = new RegExp(rewritePatternForDotAll(regex));\n    return reg.test(str);\n  };\n}\n\nengine.replace = function(coll, pattern, repl){\n  const str = misc.singleton(coll, 'String');\n  if (util.isEmpty(pattern) || util.isEmpty(repl) || util.isEmpty(str)) {\n    return [];\n  }\n  const reg = new RegExp(util.escapeStringForRegExp(pattern), 'g');\n  return str.replace(reg, repl);\n};\n\nengine.replaceMatches = function(coll, regex, repl){\n  const str = misc.singleton(coll, 'String');\n  if (util.isEmpty(regex) || util.isEmpty(repl) || util.isEmpty(str)) {\n    return [];\n  }\n  const reg = new RegExp(regex, 'g');\n  return str.replace(reg, repl);\n};\n\nengine.length = function(coll){\n  const str = misc.singleton(coll, 'String');\n  return util.isEmpty(str) ? [] : str.length;\n};\n\nengine.toChars = function(coll){\n  const str = misc.singleton(coll, 'String');\n  return util.isEmpty(str) ? [] : str.split('');\n};\n\nmodule.exports = engine;\n","const addMinutes = require('date-fns/add_minutes');\nconst ucumUtils = require('@lhncbc/ucum-lhc').UcumLhcUtils.getInstance();\nconst numbers = require('./numbers');\n\nconst ucumSystemUrl = 'http://unitsofmeasure.org';\nlet timeFormat =\n  '[0-9][0-9](\\\\:[0-9][0-9](\\\\:[0-9][0-9](\\\\.[0-9]+)?)?)?(Z|(\\\\+|-)[0-9][0-9]\\\\:[0-9][0-9])?';\nlet timeRE = new RegExp('^T?'+timeFormat+'$');\nlet dateTimeRE = new RegExp(\n  '^[0-9][0-9][0-9][0-9](-[0-9][0-9](-[0-9][0-9](T'+timeFormat+')?)?)?Z?$');\n// FHIR date/time regular expressions are slightly different.  For now, we will\n// stick with the FHIRPath regular expressions.\n//let fhirTimeRE = /([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\\.[0-9]+)?/;\n//let fhirDateTimeRE =\n///([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\\.[0-9]+)?(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?/;\n\n/**\n *   Class FP_Type is the superclass for FHIRPath types that required special\n *   handling.\n */\nclass FP_Type {\n  /**\n   *  Tests whether this object is equal to another.  Returns either true,\n   *  false, or undefined (where in the FHIRPath specification empty would be\n   *  returned).  The undefined return value indicates that the values were the\n   *  same to the shared precision, but that they had differnent levels of\n   *  precision.\n   */\n  equals(/* otherObj */) {\n    return false;\n  }\n\n  /**\n   *  Tests whether this object is equivalant to another.  Returns either true,\n   *  false, or undefined (where in the FHIRPath specification empty would be\n   *  returned).\n   */\n  equivalentTo(/* otherObj */) {\n    return false;\n  }\n\n  toString() {\n    return this.asStr ? this.asStr : super.toString();\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n\n  /**\n   *  Returns -1, 0, or 1 if this object is less then, equal to, or greater\n   *  than otherObj.\n   */\n  compare(/* otherObj */) {\n    throw 'Not implemented';\n  }\n}\n\n\n/**\n *  A class for Quantities.\n */\nclass FP_Quantity extends FP_Type {\n  constructor(value, unit) {\n    super();\n    this.asStr = value + ' ' + unit;\n    this.value = value;\n    this.unit = unit;\n  }\n\n  equals(otherQuantity) {\n    if (!(otherQuantity instanceof this.constructor)) {\n      return false;\n    }\n\n    if (this.unit === otherQuantity.unit) {\n      return numbers.isEqual(this.value, otherQuantity.value);\n    }\n\n    // Special year/month comparison case: 1 year = 12 month\n    const compareYearsAndMonths = this._compareYearsAndMonths(otherQuantity);\n    if (compareYearsAndMonths) {\n      return compareYearsAndMonths.isEqual;\n    }\n\n    // General comparison case\n    const thisQuantity = FP_Quantity.toUcumQuantity(this.value, this.unit),\n      normalizedOtherQuantity = FP_Quantity.toUcumQuantity(otherQuantity.value, otherQuantity.unit),\n      convResult = ucumUtils.convertUnitTo(normalizedOtherQuantity.unit, normalizedOtherQuantity.value, thisQuantity.unit);\n\n    if (convResult.status !== 'succeeded') {\n      return false;\n    }\n\n    return numbers.isEqual(thisQuantity.value, convResult.toVal);\n  }\n\n  equivalentTo(otherQuantity) {\n    if (!(otherQuantity instanceof this.constructor)) {\n      return false;\n    }\n\n    if (this.unit === otherQuantity.unit) {\n      return numbers.isEquivalent(this.value, otherQuantity.value);\n    }\n\n    const ucumUnitCode = FP_Quantity.getEquivalentUcumUnitCode(this.unit),\n      otherUcumUnitCode = FP_Quantity.getEquivalentUcumUnitCode(otherQuantity.unit),\n      convResult = ucumUtils.convertUnitTo(otherUcumUnitCode, otherQuantity.value, ucumUnitCode);\n\n    if (convResult.status !== 'succeeded') {\n      return false;\n    }\n\n    return numbers.isEquivalent(this.value, convResult.toVal);\n  }\n\n  /**\n   * If both quantities have one of these units: year or month,\n   * then a special case will apply; otherwise returns null.\n   * In the special case of comparison, the fact that 1 year = 12 months is used.\n   *\n   * Just note: in general, for a calendar duration:\n   * 1 year = 365 days\n   * 12 month = 12*30 days = 360 days\n   * so, 1 year != 12 month\n   * That's why this special case is needed\n   *\n   * @param {FP_Quantity} otherQuantity\n   * @return {null|{isEqual: boolean}}\n   * @private\n   */\n  _compareYearsAndMonths(otherQuantity) {\n    const magnitude1 = FP_Quantity._yearMonthConversionFactor[this.unit],\n      magnitude2 = FP_Quantity._yearMonthConversionFactor[otherQuantity.unit];\n\n    if ( magnitude1 && magnitude2) {\n      return {\n        isEqual: numbers.isEqual(this.value*magnitude1, otherQuantity.value*magnitude2)\n      };\n    }\n\n    return null;\n  }\n\n}\n\nconst  surroundingApostrophesRegex = /^'|'$/g;\n/**\n * Converts a FHIR path unit to a UCUM unit code by converting a calendar duration keyword to an equivalent UCUM unit code\n * or removing single quotes for a UCUM unit.\n * @param {string} unit\n * @return {string}\n */\nFP_Quantity.getEquivalentUcumUnitCode = function (unit) {\n  return FP_Quantity.mapTimeUnitsToUCUMCode[unit] || unit.replace(surroundingApostrophesRegex, '');\n};\n\n/**\n * Converts FHIR path value/unit to UCUM value/unit. Usable for comparison.\n * @param {number} value\n * @param {string} unit\n * @returns { {value: number, unit: string} }\n */\nFP_Quantity.toUcumQuantity = function (value, unit) {\n  const magnitude = FP_Quantity._calendarDuration2Seconds[unit];\n  if (magnitude) {\n    return {\n      value: magnitude * value,\n      unit: 's'\n    };\n  }\n\n  return {\n    value,\n    unit: unit.replace(surroundingApostrophesRegex, '')\n  };\n};\n\n/**\n * Converts FHIRPath value/unit to other FHIRPath value/unit.\n * @param {string} fromUnit\n * @param {number} value\n * @param {string} toUnit\n * @return {FP_Quantity|null}\n */\nFP_Quantity.convUnitTo = function (fromUnit, value, toUnit) {\n  // 1 Year <-> 12 Months\n  const fromYearMonthMagnitude = FP_Quantity._yearMonthConversionFactor[fromUnit],\n    toYearMonthMagnitude = FP_Quantity._yearMonthConversionFactor[toUnit];\n  if (fromYearMonthMagnitude && toYearMonthMagnitude) {\n    return new FP_Quantity( fromYearMonthMagnitude*value/toYearMonthMagnitude, toUnit);\n  }\n\n  const fromMagnitude = FP_Quantity._calendarDuration2Seconds[fromUnit],\n    toMagnitude = FP_Quantity._calendarDuration2Seconds[toUnit];\n\n  // To FHIR path calendar duration\n  if (toMagnitude) {\n    if (fromMagnitude) {\n      return new FP_Quantity( fromMagnitude*value/toMagnitude, toUnit);\n    } else {\n      const convResult = ucumUtils.convertUnitTo(fromUnit.replace(/^'|'$/g, ''), value, 's');\n\n      if (convResult.status === 'succeeded') {\n        return new FP_Quantity(convResult.toVal/toMagnitude, toUnit);\n      }\n    }\n  // To Ucum unit\n  } else {\n    const convResult = fromMagnitude ? ucumUtils.convertUnitTo('s', fromMagnitude*value, toUnit.replace(/^'|'$/g, ''))\n      : ucumUtils.convertUnitTo(fromUnit.replace(/^'|'$/g, ''), value, toUnit.replace(/^'|'$/g, ''));\n\n    if(convResult.status === 'succeeded') {\n      return new FP_Quantity(convResult.toVal, toUnit);\n    }\n  }\n\n  return null;\n};\n\n// Defines conversion factors for calendar durations\nFP_Quantity._calendarDuration2Seconds = {\n  'years': 365*24*60*60,\n  'months': 30*24*60*60,\n  'weeks': 7*24*60*60,\n  'days': 24*60*60,\n  'hours': 60*60,\n  'minutes': 60,\n  'seconds': 1,\n  'milliseconds': .001,\n  'year': 365*24*60*60,\n  'month': 30*24*60*60,\n  'week': 7*24*60*60,\n  'day': 24*60*60,\n  'hour': 60*60,\n  'minute': 60,\n  'second': 1,\n  'millisecond': .001\n};\n\n// Defines special case to compare years with months for calendar durations\nFP_Quantity._yearMonthConversionFactor = {\n  'years': 12,\n  'months': 1,\n  'year': 12,\n  'month': 1\n};\n\n/**\n *  Defines a map from time units that are supported for arithmetic (including\n *  some UCUM time based units) to FHIRPath time units.\n */\nFP_Quantity.arithmeticDurationUnits = {\n  'years': \"year\",\n  'months': \"month\",\n  'weeks': \"week\",\n  'days': \"day\",\n  'hours': \"hour\",\n  'minutes': \"minute\",\n  'seconds': \"second\",\n  'milliseconds': \"millisecond\",\n  'year': \"year\",\n  'month': \"month\",\n  'week': \"week\",\n  'day': \"day\",\n  'hour': \"hour\",\n  'minute': \"minute\",\n  'second': \"second\",\n  'millisecond': \"millisecond\",\n  \"'wk'\": \"week\",\n  \"'d'\": \"day\",\n  \"'h'\": \"hour\",\n  \"'min'\": \"minute\",\n  \"'s'\": \"second\",\n  \"'ms'\": \"millisecond\"\n};\n\n/**\n *  Defines a map from UCUM code to FHIRPath time units.\n */\nFP_Quantity.mapUCUMCodeToTimeUnits = {\n  'a': \"year\",\n  'mo': \"month\",\n  'wk': \"week\",\n  'd': \"day\",\n  'h': \"hour\",\n  'min': \"minute\",\n  's': \"second\",\n  'ms': \"millisecond\",\n};\n\n/**\n *  Defines a map from FHIRPath time units to UCUM code.\n */\nFP_Quantity.mapTimeUnitsToUCUMCode = Object.keys(FP_Quantity.mapUCUMCodeToTimeUnits)\n  .reduce(function (res, key) {\n    res[FP_Quantity.mapUCUMCodeToTimeUnits[key]] = key;\n    res[FP_Quantity.mapUCUMCodeToTimeUnits[key]+'s'] = key;\n    return res;\n  }, {});\n\nclass FP_TimeBase extends FP_Type {\n  constructor(timeStr) {\n    super();\n    this.asStr = timeStr;\n  }\n\n  /**\n   *  Adds a time-based quantity to this date/time.\n   * @param timeQuantity a quantity to be added to this date/time.  See the\n   *  FHIRPath specification for supported units.\n   */\n  plus(timeQuantity) {\n    const unit = timeQuantity.unit;\n    let timeUnit = FP_Quantity.arithmeticDurationUnits[unit];\n    if (!timeUnit) {\n      throw new Error('For date/time arithmetic, the unit of the quantity ' +\n        'must be one of the following time-based units: ' +\n        Object.keys(FP_Quantity.arithmeticDurationUnits));\n    }\n    const cls = this.constructor;\n    const unitPrecision = cls._timeUnitToDatePrecision[timeUnit];\n    if (unitPrecision === undefined) {\n      throw new Error('Unsupported unit for +.  The unit should be one of ' +\n        Object.keys(cls._timeUnitToDatePrecision).join(', ') + '.');\n    }\n    let qVal = timeQuantity.value;\n    const isTime = (cls === FP_Time);\n\n    // From the FHIRPath specification: \"For precisions above seconds, the\n    // decimal portion of the time-valued quantity is ignored, since date/time\n    // arithmetic above seconds is performed with calendar duration semantics.\"\n    if (isTime ? unitPrecision < 2 : unitPrecision < 5) {\n      qVal = Math.trunc(qVal);\n    }\n\n    // If the precision of the time quantity is higher than the precision of the\n    // date, we need to convert the time quantity to the precision of the date.\n    if (this._getPrecision() < unitPrecision) {\n      const neededUnit = cls._datePrecisionToTimeUnit[\n        this._getPrecision()];\n      if (neededUnit !== 'second') {\n        const newQuantity = FP_Quantity.convUnitTo(timeUnit, qVal, neededUnit);\n        timeUnit = newQuantity.unit;\n        qVal = Math.trunc(newQuantity.value);\n      }\n    }\n    const newDate = FP_TimeBase.timeUnitToAddFn[timeUnit](this._getDateObj(), qVal);\n    // newDate is a Date.  We need to make a string with the correct precision.\n    let precision = this._getPrecision();\n    if (isTime)\n      precision += 3; // based on dateTimeRE, not timeRE\n    let newDateStr = FP_DateTime.isoDateTime(newDate, precision);\n    if (isTime) {\n      // FP_Time just needs the time part of the string\n      newDateStr = newDateStr.slice(newDateStr.indexOf('T') + 1);\n    }\n\n    return new cls(newDateStr);\n  }\n\n\n  /**\n   *  Tests whether this object is equal to another.  Returns either true,\n   *  false, or undefined (where in the FHIRPath specification empty would be\n   *  returned).  The undefined return value indicates that the values were the\n   *  same to the shared precision, but that they had differnent levels of\n   *  precision.\n   * @param otherDateTime any sub-type of FP_TimeBase, but it should be the same\n   *  as the type of \"this\".\n   */\n  equals(otherDateTime) {\n    // From the 2019May ballot:\n    // For Date, DateTime and Time equality, the comparison is performed by\n    // considering each precision in order, beginning with years (or hours for\n    // time values), and respecting timezone offsets. If the values are the\n    // same, comparison proceeds to the next precision; if the values are\n    // different, the comparison stops and the result is false. If one input has\n    // a value for the precision and the other does not, the comparison stops\n    // and the result is empty ({ }); if neither input has a value for the\n    // precision, or the last precision has been reached, the comparison stops\n    // and the result is true.\n    // Note:  Per the spec above\n    //   2012-01 = 2012 //  empty\n    //   2012-01 = 2011 //  false\n    //   2012-01 ~ 2012 //  false\n    var rtn;\n    if (!(otherDateTime instanceof this.constructor))\n      rtn = false;\n    else {\n      var thisPrec  = this._getPrecision();\n      var otherPrec = otherDateTime._getPrecision();\n\n      if (thisPrec == otherPrec) {\n        rtn = this._getDateObj().getTime() == otherDateTime._getDateObj().getTime();\n      }\n      else {\n        // The dates are not equal, but decide whether to return empty or false.\n        var commonPrec  = thisPrec <= otherPrec ? thisPrec : otherPrec;\n        // Adjust for timezone offsets, if any, so they are at a common timezone\n        var thisUTCStr  = this._getDateObj().toISOString();\n        var otherUTCStr = otherDateTime._getDateObj().toISOString();\n\n        if (this.constructor === FP_Time) {\n          commonPrec += 3; // because we now have year, month, and day\n          thisPrec += 3;\n          otherPrec += 3;\n        }\n\n        // Now parse the strings and compare the adjusted time parts.\n        // Dates without time specify no timezone and should be treated as already normalized to UTC. So we do not adjust the timezone, as this would change the date\n        var thisAdj  = thisPrec > 2 ? (new FP_DateTime(thisUTCStr))._getTimeParts() : this._getTimeParts();\n        var otherAdj = otherPrec > 2 ? (new FP_DateTime(otherUTCStr))._getTimeParts() : otherDateTime._getTimeParts();\n\n        for (var i = 0; i <= commonPrec && rtn !== false; ++i) {\n          rtn = thisAdj[i] == otherAdj[i];\n        }\n        // if rtn is still true, then return empty to indicate the difference in\n        // precision.\n        if (rtn)\n          rtn = undefined;\n      }\n    }\n    // else return undefined (empty)\n    return rtn;\n  }\n\n\n  /**\n   *  Tests whether this object is equivalant to another.  Returns either true\n   *  or false.\n   */\n  equivalentTo(otherDateTime) {\n    var rtn = otherDateTime instanceof this.constructor;\n    if (rtn) {\n      var thisPrec = this._getPrecision();\n      var otherPrec = otherDateTime._getPrecision();\n      rtn = thisPrec == otherPrec;\n      if (rtn) {\n        rtn = this._getDateObj().getTime() ==\n          otherDateTime._getDateObj().getTime();\n      }\n    }\n    return rtn;\n  }\n\n\n  /**\n   *  Returns a number less than 0, equal to 0 or greater than 0\n   *  if this (date) time is less than, equal to, or greater than otherTime.\n   *  Comparisons are made at the lesser of the two time precisions.\n   *  @param {FP_TimeBase} otherTime\n   *  @return {number}\n   */\n  compare(otherTime) {\n    var thisPrecision = this._getPrecision();\n    var otherPrecision = otherTime._getPrecision();\n    var thisTimeInt = thisPrecision <= otherPrecision ?\n      this._getDateObj().getTime(): this._dateAtPrecision(otherPrecision).getTime();\n    var otherTimeInt = otherPrecision <= thisPrecision ?\n      otherTime._getDateObj().getTime(): otherTime._dateAtPrecision(thisPrecision).getTime();\n    if (thisPrecision !== otherPrecision && thisTimeInt === otherTimeInt) {\n      return null;\n    }\n    return thisTimeInt - otherTimeInt;\n  }\n\n\n  /**\n   *  Returns a number representing the precision of the time string given to\n   *  the constructor.  (Higher means more precise).  The number is the number\n   *  of components of the time string (ignoring the time zone) produced by\n   *  matching against the time regular expression, except that milliseconds\n   *  and seconds are counted together as a single of level of precision.\n   *  @return {number}\n   */\n  _getPrecision() {\n    if (this.precision === undefined)\n      this._getMatchData();\n    return this.precision;\n  }\n\n  /**\n   *  Returns the match data from matching the given RegExp against the\n   *  date/time string given to the constructor.\n   *  Also sets this.precision.\n   * @param regEx The regular expression to match against the date/time string.\n   * @param maxPrecision the maximum precision possible for the type\n   */\n  _getMatchData(regEx, maxPrecision) {\n    if (this.timeMatchData === undefined) {\n      this.timeMatchData = this.asStr.match(regEx);\n      if (this.timeMatchData) {\n        for (let i=maxPrecision; i>=0 && this.precision === undefined; --i) {\n          if (this.timeMatchData[i])\n            this.precision = i;\n        }\n      }\n    }\n    return this.timeMatchData;\n  }\n\n  /**\n   *  Returns an array of the pieces of the given time string, for use in\n   *  constructing lower precision versions of the time. The returned array will\n   *  contain separate elements for the hour, minutes, seconds, and milliseconds\n   *  (or as many of those are as present).  The length of the returned array\n   *  will therefore be an indication of the precision.\n   *  It will not include the timezone.\n   * @timeMatchData the result of matching the time portion of the string passed\n   *  into the constructor against the \"timeRE\" regular expression.\n   */\n  _getTimeParts(timeMatchData) {\n    var timeParts = [];\n    // Finish parsing the data into pieces, for later use in building\n    // lower-precision versions of the date if needed.\n    timeParts = [timeMatchData[0]];\n    var timeZone = timeMatchData[4];\n    if (timeZone) { // remove time zone from hours\n      let hours = timeParts[0];\n      timeParts[0] = hours.slice(0, hours.length-timeZone.length);\n    }\n    var min = timeMatchData[1];\n    if (min) { // remove minutes from hours\n      let hours = timeParts[0];\n      timeParts[0] = hours.slice(0, hours.length-min.length);\n      timeParts[1] = min;\n      var sec = timeMatchData[2];\n      if (sec) { // remove seconds from minutes\n        timeParts[1] = min.slice(0, min.length-sec.length);\n        timeParts[2] = sec;\n        var ms = timeMatchData[3];\n        if (ms) { // remove milliseconds from seconds\n          timeParts[2] = sec.slice(0, sec.length-ms.length);\n          timeParts[3] = ms;\n        }\n      }\n    }\n    return timeParts;\n  }\n\n\n  /**\n   *  Returns a date object representing this time on a certain date.\n   */\n  _getDateObj() {\n    if (!this.dateObj) {\n      var precision = this._getPrecision();\n      // We cannot directly pass the string into the date constructor because\n      // (1) we don't want to introduce a time-dependent system date and (2) the\n      // time string might not have contained minutes, which are required by the\n      // Date constructor.\n      this.dateObj = this._dateAtPrecision(precision);\n    }\n    return this.dateObj;\n  }\n\n\n  /**\n   *  Creates a date object for the given timezone.  The returned date object\n   *  will have the specified date and time in the specified timezone.\n   * @param year...ms Just as in the Date constructor.\n   * @param timezoneOffset (optional) a string in the format (+-)HH:mm or Z, representing the\n   *  timezone offset.  If not provided, the local timzone will be assumed (as the\n   *  Date constructor does).\n   */\n  _createDate(year, month, day, hour, minutes, seconds, ms, timezoneOffset) {\n    var d = new Date(year, month, day, hour, minutes, seconds, ms);\n    if (timezoneOffset) {\n      // d is in local time.  Adjust for the timezone offset.\n      // First adjust the date by the timezone offset before reducing its\n      // precision.  Otherwise,\n      // @2018-11-01T-04:00 < @2018T-05:00\n      var localTimezoneMinutes = d.getTimezoneOffset();\n      var timezoneMinutes = 0; // if Z\n      if (timezoneOffset != 'Z') {\n        var timezoneParts = timezoneOffset.split(':'); // (+-)hours:minutes\n        var hours = parseInt(timezoneParts[0]);\n        timezoneMinutes = parseInt(timezoneParts[1]);\n        if (hours < 0)\n          timezoneMinutes = -timezoneMinutes;\n        timezoneMinutes += 60*hours;\n      }\n      // localTimezoneMinutes has the inverse sign of its timezone offset\n      d = addMinutes(d, -localTimezoneMinutes-timezoneMinutes);\n    }\n    return d;\n  }\n}\n\n/**\n *  A map from a FHIRPath time units to a function used to add that\n *  quantity to a date/time.\n */\nFP_TimeBase.timeUnitToAddFn = {\n  \"year\": require('date-fns/add_years'),\n  \"month\": require('date-fns/add_months'),\n  \"week\": require('date-fns/add_weeks'),\n  \"day\": require('date-fns/add_days'),\n  \"hour\": require('date-fns/add_hours'),\n  \"minute\": require('date-fns/add_minutes'),\n  \"second\": require('date-fns/add_seconds'),\n  \"millisecond\": require('date-fns/add_milliseconds')\n};\n\n\nclass FP_DateTime extends FP_TimeBase {\n  /**\n   *  Constructs an FP_DateTime, assuming dateStr is valid.  If you don't know\n   *  whether a string is a valid DateTime, use FP_DateTime.checkString instead.\n   */\n  constructor(dateStr) {\n    super(dateStr);\n  }\n\n\n  /**\n   *  Returns -1, 0, or 1 if this date time is less then, equal to, or greater\n   *  than otherDateTime.  Comparisons are made at the lesser of the two date time\n   *  precisions.\n   */\n  compare(otherDateTime) {\n    if (!(otherDateTime instanceof FP_DateTime))\n      throw 'Invalid comparison of a DateTime with something else';\n    return super.compare(otherDateTime);\n  }\n\n\n  /**\n   *  Returns the match data from matching dateTimeRE against the datetime string.\n   *  Also sets this.precision.\n   */\n  _getMatchData() {\n    return super._getMatchData(dateTimeRE, 5);\n  }\n\n  /**\n   *  Returns an array of the pieces of the date time string passed into the\n   *  constructor, for use in constructing lower precision versions of the\n   *  date time. The returned array will contain separate elements for the year,\n   *  month, day, hour, minutes, seconds, and milliseconds (or as many of those\n   *  are as present).  The length of the returned array will therefore be an\n   *  indication of the precision.  It will not include the timezone.\n   */\n  _getTimeParts() {\n    if (!this.timeParts) {\n      let timeMatchData =  this._getMatchData();\n      let year = timeMatchData[0];\n      this.timeParts = [year];\n      var month = timeMatchData[1];\n      if (month) { // Remove other information from year\n        this.timeParts[0] = year.slice(0, year.length-month.length);\n        this.timeParts[1] = month;\n        let day = timeMatchData[2];\n        if (day) { // Remove day information from month\n          this.timeParts[1] = month.slice(0, month.length-day.length);\n          this.timeParts[2] = day;\n          let time = timeMatchData[3];\n          if (time) { // Remove time from day\n            this.timeParts[2] = day.slice(0, day.length-time.length);\n            if (time[0] === 'T') // remove T from hour\n              timeMatchData[3] = time.slice(1);\n            this.timeParts = this.timeParts.concat(\n              super._getTimeParts(timeMatchData.slice(3)));\n          }\n        }\n      }\n    }\n    return this.timeParts;\n  }\n\n\n  /**\n   *  Returns a new Date object for a time equal to what this time would be if\n   *  the string passed into the constructor had the given precision.\n   * @param precision the new precision, which is assumed to be less than\n   *  or equal to the current precision.\n   */\n  _dateAtPrecision(precision) {\n    var timeParts = this._getTimeParts();\n    var timezoneOffset = this._getMatchData()[7];\n    // Get the date object first at the current precision.\n    var thisPrecision = this._getPrecision();\n    var year = parseInt(timeParts[0]);\n    var month = thisPrecision > 0 ? parseInt(timeParts[1].slice(1)) - 1 : 0;\n    var day = thisPrecision > 1 ? parseInt(timeParts[2].slice(1)) : 1;\n    var hour = thisPrecision > 2 ? parseInt(timeParts[3]) : 0;\n    var minutes = thisPrecision > 3 ? parseInt(timeParts[4].slice(1)): 0;\n    var seconds = thisPrecision > 4 ? parseInt(timeParts[5].slice(1)): 0;\n    var ms = timeParts.length > 6 ? parseInt(timeParts[6].slice(1)): 0;\n    var d = this._createDate(year, month, day, hour, minutes, seconds, ms,\n      timezoneOffset);\n    if (precision < thisPrecision) {\n      // Adjust the precision\n      year = d.getFullYear();\n      month = precision > 0 ? d.getMonth() : 0;\n      day = precision > 1 ? d.getDate() : 1;\n      hour = precision > 2 ? d.getHours() : 0;\n      minutes = precision > 3 ? d.getMinutes(): 0;\n      // Here the precision will always be less than the maximum\n      // due to the condition in the if statement: \"precision < thisPrecision\"\n      d = new Date(year, month, day, hour, minutes);\n    }\n    return d;\n  }\n}\n\n/**\n *  Tests str to see if it is convertible to a DateTime.\n * @return If str is convertible to a DateTime, returns an FP_DateTime;\n *  otherwise returns null.\n */\nFP_DateTime.checkString = function(str) {\n  let d = new FP_DateTime(str);\n  if (!d._getMatchData())\n    d = null;\n  return d;\n};\n\n/**\n *  A map from FHIRPath time units to the internal DateTime \"precision\" number.\n */\nFP_DateTime._timeUnitToDatePrecision = {\n  \"year\": 0,\n  \"month\": 1,\n  \"week\": 2, // wk is just 7*d\n  \"day\": 2,\n  \"hour\": 3,\n  \"minute\": 4,\n  \"second\": 5,\n  \"millisecond\": 6\n};\n\n/**\n *  The inverse of _timeUnitToDatePrecision.\n */\nFP_DateTime._datePrecisionToTimeUnit = [\n  \"year\", \"month\", \"day\", \"hour\", \"minute\", \"second\", \"millisecond\"\n];\n\n\n\nclass FP_Time extends FP_TimeBase {\n  /**\n   *  Constructs an FP_Time, assuming dateStr is valid.  If you don't know\n   *  whether a string is a valid DateTime, use FP_Time.checkString instead.\n   */\n  constructor(timeStr) {\n    if (timeStr[0] == 'T')\n      timeStr = timeStr.slice(1);\n    super(timeStr);\n  }\n\n\n  /**\n   *  Returns -1, 0, or 1 if this time is less then, equal to, or greater\n   *  than otherTime.  Comparisons are made at the lesser of the two time\n   *  precisions.\n   */\n  compare(otherTime) {\n    if (!(otherTime instanceof FP_Time))\n      throw 'Invalid comparison of a time with something else';\n    return super.compare(otherTime);\n  }\n\n\n  /**\n   *  Returns a new Date object for a time equal to what this time would be if\n   *  the string passed into the constructor had the given precision.\n   *  The \"date\" portion of the returned Date object is not meaningful, and\n   *  should be ignored.\n   * @param precision the new precision, which is assumed to be less than the\n   *  or equal to the current precision.  A precision of 0 means the hour.\n   */\n  _dateAtPrecision(precision) {\n    var timeParts = this._getTimeParts();\n    var timezoneOffset = this._getMatchData()[4];\n    // Get the date object first at the current precision.\n    var thisPrecision = this._getPrecision();\n    var year = 2010; // Have to pick some year for the date object\n    var month = 0;\n    var day = 1;\n    var hour = parseInt(timeParts[0]);\n    var minutes = thisPrecision > 0 ? parseInt(timeParts[1].slice(1)): 0;\n    var seconds = thisPrecision > 1 ? parseInt(timeParts[2].slice(1)): 0;\n    var ms = timeParts.length > 3 ? parseInt(timeParts[3].slice(1)): 0;\n    var d = this._createDate(year, month, day, hour, minutes, seconds, ms,\n      timezoneOffset);\n    if (timezoneOffset) {\n      // Keep the date the same (in the local timezone), so it is not a relevant\n      // factor when comparing different times.\n      d.setYear(year);\n      d.setMonth(month);\n      d.setDate(day);\n    }\n    if (precision < thisPrecision) {\n      // Adjust the precision\n      hour = d.getHours();\n      minutes = precision > 0 ? d.getMinutes(): 0;\n      // Here the precision will always be less than the maximum\n      // due to the condition in the if statement: \"precision < thisPrecision\"\n      d = new Date(year, month, day, hour, minutes);\n    }\n    return d;\n  }\n\n\n  /**\n   *  Returns the match data from matching timeRE against the time string.\n   *  Also sets this.precision.\n   */\n  _getMatchData() {\n    return super._getMatchData(timeRE, 2);\n  }\n\n  /**\n   *  Returns an array of the pieces of the time string passed into the\n   *  constructor, for use in constructing lower precision versions of the\n   *  time. The returned array will contain separate elements for the hour,\n   *  minutes, seconds, and milliseconds (or as many of those are as present).\n   *  The length of the returned array will therefore be an indication of the\n   *  precision.  It will not include the timezone.\n   */\n  _getTimeParts() {\n    if (!this.timeParts) {\n      this.timeParts = super._getTimeParts(this._getMatchData());\n    }\n    return this.timeParts;\n  }\n}\n\n/**\n *  Tests str to see if it is convertible to a Time.\n * @return If str is convertible to a Time, returns an FP_Time;\n *  otherwise returns null.\n */\nFP_Time.checkString = function(str) {\n  let d = new FP_Time(str);\n  if (!d._getMatchData())\n    d = null;\n  return d;\n};\n\n/**\n *  A map from FHIRPath time units to the internal DateTime \"precision\" number.\n */\nFP_Time._timeUnitToDatePrecision = {\n  \"hour\": 0,\n  \"minute\": 1,\n  \"second\": 2,\n  \"millisecond\": 3\n};\n\n/**\n *  The inverse of _timeUnitToDatePrecision.\n */\nFP_Time._datePrecisionToTimeUnit = [\"hour\", \"minute\", \"second\", \"millisecond\"];\n\n\n/**\n *  Returns either the given number or a string with the number prefixed by\n *  zeros if the given number is less than the given length.\n * @param num the nubmer to format\n * @param len the number of returned digits.  For now this must either be 2 or\n *  3. (Optional-- default is 2).\n */\nfunction formatNum(num, len) {\n  // Could use String.repeat, but that requires convertin num to an string first\n  // to get its length.  This might be slightly faster given that we only need 2\n  // or three 3 digit return values.\n  var rtn = num;\n  if (len === 3 && num < 100)\n    rtn = '0' + num;\n  if (num < 10)\n    rtn = '0' + rtn;\n  return rtn;\n}\n\n\n/**\n *  Formats the given date object into an ISO8601 datetime string, expressing it\n *  in the local timezone.\n * @date the date to format\n * @precision the precision at which to terminate string string.  (This is\n *  optional). If present, it will be an integer into the matching components of\n *  dateTimeRE.\n * @return a string in ISO8601 format.\n */\nFP_DateTime.isoDateTime = function(date, precision) {\n  if (precision === undefined)\n    precision = 5; // maximum\n  // YYYY-MM-DDTHH:mm:ss.sss[+-]HH:mm\n  // Note:  Date.toISOString sets the timezone at 'Z', which I did not want.\n  // Actually, I wanted to keep the original timezone given in the constructor,\n  // but that is difficult due to daylight savings time changes.  (For instance,\n  // if you add 6 months, the timezone offset could change).\n  var rtn = '' + date.getFullYear();\n  if (precision > 0) {\n    rtn += '-' + formatNum(date.getMonth() + 1);\n    if (precision > 1) {\n      rtn += '-' + formatNum(date.getDate());\n      if (precision > 2) {\n        rtn += 'T' + FP_DateTime.isoTime(date, precision - 3);\n      }\n    }\n  }\n  // FHIRPath STU1 does not allow a timezone offset on a dateTime that does not\n  // have a time part (except that the grammar allows 'Z', which is\n  // inconsistent).\n  if (precision > 2) {\n    // Note:  getTimezoneoffset returns the offset for the local system at the\n    // given date.\n    var tzOffset = date.getTimezoneOffset();\n    // tzOffset is a number of minutes, and is positive for negative timezones,\n    // and negative for positive timezones.\n    var tzSign = tzOffset < 0 ? '+' : '-';\n    tzOffset = Math.abs(tzOffset);\n    var tzMin = tzOffset % 60;\n    var tzHour = (tzOffset - tzMin) / 60;\n    rtn += tzSign + formatNum(tzHour) + ':' + formatNum(tzMin);\n  }\n  return rtn;\n};\n\n\n/**\n *  Returns a date string in ISO format at the given precision level.\n * @date the date to format\n * @precision the precision at which to terminate string.  (This is\n *  optional). If present, it will be an integer into the matching components of\n *  dateTimeRE.\n * @return a string in ISO8601 format.\n */\nFP_DateTime.isoDate = function(date, precision) {\n  if (precision === undefined || precision > 2)\n    precision = 2;\n  return FP_DateTime.isoDateTime(date, precision);\n};\n\n\n/**\n *  Returns a time string in ISO format at the given precision level.\n * @date the date to format\n * @precision the precision at which to terminate string.  (This is\n *  optional). If present, it will be an integer into the matching components of\n *  timeRE.\n * @return a string in ISO 8601 format.\n */\nFP_DateTime.isoTime = function(date, precision) {\n  if (precision === undefined)\n    precision = 2; // maximum\n\n  let rtn = '' + formatNum(date.getHours());\n  if (precision > 0) {\n    rtn += ':' + formatNum(date.getMinutes());\n    if (precision > 1) {\n      rtn += ':' + formatNum(date.getSeconds() );\n      if (date.getMilliseconds())\n        rtn += '.' + formatNum(date.getMilliseconds(), 3);\n    }\n  }\n  return rtn;\n};\n\n\n/**\n *  A class that represents a node in a FHIR resource, with path and possibly type\n *  information.\n */\nclass ResourceNode {\n  /**\n   *  Constructs a instance for the given node (\"data\") of a resource.  If the\n   *  data is the top-level node of a resouce, the path and type parameters will\n   *  be ignored in favor of the resource's resourceType field.\n   * @param data the node's data or value (which might be an object with\n   *  sub-nodes, an array, or FHIR data type)\n   * @param path the node's path in the resource (e.g. Patient.name).  If the\n   *  data's type can be determined from data, that will take precedence over\n   *  this parameter.\n   * @param _data additional data stored in a property named with \"_\" prepended,\n   *  see https://www.hl7.org/fhir/element.html#json for details.\n   */\n  constructor(data, path, _data) {\n    // If data is a resource (maybe a contained resource) reset the path\n    // information to the resource type.\n    if (data.resourceType)\n      path = data.resourceType;\n    this.path = path;\n    this.data = getResourceNodeData(data, path);\n    this._data = _data || {};\n  }\n\n  /**\n   * Returns resource node type info.\n   * @return {TypeInfo}\n   */\n  getTypeInfo() {\n    const namespace = TypeInfo.FHIR;\n\n    // TODO: Here we should use property index which we will extract from the specification\n\n    if (this.path.indexOf('.') === -1) {\n      return new TypeInfo({namespace, name: this.path});\n    }\n    return TypeInfo.createByValueInNamespace({namespace, value: this.data});\n  }\n\n  toJSON() {\n    return JSON.stringify(this.data);\n  }\n}\n\n/**\n * Prepare data for ResourceNode:\n * Converts value from FHIR Quantity to FHIRPath System.Quantity.\n * The Mapping from FHIR Quantity to FHIRPath System.Quantity is explained here:\n * https://www.hl7.org/fhir/fhirpath.html#quantity\n * @param {Object|...} data\n * @param {string} path\n * @return {FP_Quantity|Object|...}\n */\nfunction getResourceNodeData(data, path) {\n  if (path === 'Quantity' && data.system === ucumSystemUrl) {\n    if (typeof data.value === 'number' && typeof data.code === 'string') {\n      data = new FP_Quantity(data.value, FP_Quantity.mapUCUMCodeToTimeUnits[data.code] || '\\'' + data.code + '\\'');\n    }\n  }\n\n  return data;\n}\n\n/**\n *  Returns a ResourceNode for the given data node, checking first to see if the\n *  given node is already a ResourceNode.  Takes the same arguments as the\n *  constructor for ResourceNode.\n */\nResourceNode.makeResNode = function(data, path, _data) {\n  return (data instanceof ResourceNode) ? data : new ResourceNode(data, path, _data);\n};\n\n/**\n * Object class defining type information.\n * Used for minimal type support.\n * (see http://hl7.org/fhirpath/#types-and-reflection)\n */\nclass TypeInfo {\n  constructor({name, namespace}) {\n    this.name = name;\n    this.namespace = namespace;\n  }\n\n  /**\n   * Checks for equality with another TypeInfo object, or that another TypeInfo\n   * object specifies a superclass for the type specified by this object.\n   * @param {TypeInfo} other\n   * @return {boolean}\n   */\n  is(other) {\n    // TODO: Here we should use type hierarchy index which we will extract from the specification\n    return other instanceof TypeInfo && this.name === other.name\n      && (!this.namespace || !other.namespace || this.namespace === other.namespace);\n  }\n}\n\n// Available namespaces:\nTypeInfo.System = 'System';\nTypeInfo.FHIR = 'FHIR';\n\n/**\n * Creates new TypeInfo object for specified namespace and value\n * @param {String} namespace\n * @param {*} value\n * @return {TypeInfo}\n */\nTypeInfo.createByValueInNamespace = function({namespace, value}) {\n  let name = typeof value;\n\n  if (Number.isInteger(value)) {\n    name = 'integer';\n  } else if (name === \"number\") {\n    name = 'decimal';\n  } else if (value instanceof FP_DateTime) {\n    name = 'dateTime';\n  } else if (value instanceof FP_Time) {\n    name = 'time';\n  } else if (value instanceof FP_Quantity) {\n    name = 'Quantity';\n  }\n\n  if (namespace === TypeInfo.System) {\n    name = name.replace(/^\\w/, c => c.toUpperCase());\n  }\n\n  // TODO: currently can return name = 'object\" or \"Object\" which is probably wrong\n  return new TypeInfo({namespace, name}) ;\n};\n\n/**\n * Retrieves TypeInfo by value\n * @param {*} value\n * @return {TypeInfo}\n */\nTypeInfo.fromValue = function (value) {\n  return value instanceof ResourceNode\n    ? value.getTypeInfo()\n    : TypeInfo.createByValueInNamespace({namespace: TypeInfo.System, value});\n};\n\n/**\n * Basic \"type()\" function implementation\n * (see http://hl7.org/fhirpath/#reflection)\n * @param {Array<*>} coll - input collection\n * @return {Array<*>}\n */\nfunction typeFn(coll) {\n  return coll.map(value => {\n    return TypeInfo.fromValue(value);\n  });\n}\n\n/**\n * Implementation of function \"is(type : type specifier)\" and operator \"is\"\n * (see http://hl7.org/fhirpath/#is-type-specifier)\n * @param {Array<*>} coll - input collection\n * @param {TypeInfo} typeInfo\n * @return {boolean|[]}\n */\nfunction isFn(coll, typeInfo) {\n  if(coll.length === 0) {\n    return [];\n  }\n\n  if(coll.length > 1) {\n    throw new Error(\"Expected singleton on left side of is, got \" + JSON.stringify(coll));\n  }\n\n  return TypeInfo.fromValue(coll[0]).is(typeInfo);\n}\n\nmodule.exports = {\n  FP_Type: FP_Type,\n  FP_TimeBase: FP_TimeBase,\n  FP_DateTime: FP_DateTime,\n  FP_Time: FP_Time,\n  FP_Quantity: FP_Quantity,\n  timeRE: timeRE,\n  dateTimeRE: dateTimeRE,\n  ResourceNode: ResourceNode,\n  TypeInfo: TypeInfo,\n  typeFn,\n  isFn\n};\n","// This file holds utility functions used in implementing the public functions.\n\nconst util =  {};\nconst types = require('./types');\nlet {ResourceNode} = types;\n\n/**\n *  Reports and error to the calling environment and stops processing.\n * @param message the error message\n * @param fnName the name of the function raising the error (optional)\n */\nutil.raiseError = function(message, fnName) {\n  fnName = fnName ? fnName + \": \" : \"\";\n  throw fnName + message;\n};\n\n/**\n *  Throws an exception if the collection contains more than one value.\n * @param collection the collection to be checked.\n * @param errorMsgPrefix An optional prefix for the error message to assist in\n *  debugging.\n */\nutil.assertAtMostOne = function (collection, errorMsgPrefix) {\n  if (collection.length > 1) {\n    util.raiseError(\"Was expecting no more than one element but got \" +\n      JSON.stringify(collection), errorMsgPrefix);\n  }\n};\n\n/**\n *  Throws an exception if the data is not one of the expected types.\n * @param data the value to be checked.  This may be a ResourceNode.\n * @param types an array of the permitted types\n * @param errorMsgPrefix An optional prefix for the error message to assist in\n *  debugging.\n * @return the value that was checked.  If \"data\" was a ResourceNode, this will\n *  be the ReourceNode's data.\n */\nutil.assertType = function(data, types, errorMsgPrefix) {\n  let val = this.valData(data);\n  if (types.indexOf(typeof val) < 0) {\n    let typeList = types.length > 1 ? \"one of \"+types.join(\", \") : types[0];\n    util.raiseError(\"Found type '\"+(typeof data)+\"' but was expecting \" +\n      typeList, errorMsgPrefix);\n  }\n  return val;\n};\n\nutil.isEmpty = function(x){\n  return Array.isArray(x) && x.length == 0;\n};\n\nutil.isSome = function(x){\n  return x !== null && x !== undefined && !util.isEmpty(x);\n};\n\nutil.isTrue = function(x){\n  return x !== null && x !== undefined && (x === true || (x.length == 1 && x[0] === true));\n};\n\nutil.isFalse = function(x){\n  return x !== null && x !== undefined && (x === false || (x.length == 1 && x[0] === false));\n};\n\nutil.isCapitalized = function(x){\n  return x && (x[0] === x[0].toUpperCase());\n};\n\nutil.flatten = function(x){\n  return x.reduce(function(acc, x) {\n    if(Array.isArray(x)){\n      // todo replace with array modification\n      acc = acc.concat(x);\n    } else {\n      acc.push(x);\n    }\n    return acc;\n  }, []);\n};\n\nutil.arraify = function(x){\n  if(Array.isArray(x)){ return x; }\n  if(util.isSome(x)){ return [x]; }\n  return [];\n};\n\n/**\n *  Returns the data value of the given parameter, which might be a ResourceNode.\n *  Otherwise, it returns the value that was passed in.\n */\nutil.valData = function(val) {\n  return (val instanceof ResourceNode) ? val.data : val;\n};\n\n/**\n * Prepares a string for insertion into a regular expression\n * @param {string} str\n * @return {string}\n */\nutil.escapeStringForRegExp = function (str) {\n  return str.replace(/[-[\\]{}()*+?.,\\\\/^$|#\\s]/g, '\\\\$&');\n};\n\nmodule.exports = util;\n","module.exports = LForms.ucumPkg;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// Definitions for things needed by both importing and exporting.\n\nexport let LOINC_URI = 'http://loinc.org';\n","/**\n * A package to handle FHIR DiagnosticReport for LForms\n * https://www.hl7.org/fhir/diagnosticreport.html\n *\n * Note that this was written for DSTU2 and has not been updated.\n *\n * It provides the following functions:\n * createDiagnosticReport()\n * -- Convert existing LOINC panels/forms data in LForms format into FHIR DiagnosticReport data\n * mergeDiagnosticReportToLForms()\n * -- Merge FHIR SDC DiagnosticReport data into corresponding LForms data\n */\n\nvar dr = {\n\n  // a prefix for references to Observation resources\n  _OBX_REF_PREFIX: \"Observation/\",\n\n\n  /**\n   * Functions for creating a DiagnosticReport instance from an LFormsData object\n   */\n\n  /** Get date in a standard string format\n   * @param dateObj, a date object\n   * @returns {string} a formatted date string\n   * @private\n   */\n  _getFormattedDate : function (dateObj) {\n    //\"2013-01-27T11:45:33+11:00\",\n    return dateObj ? LForms.Util.dateToDTMString(dateObj) : \"\";\n  },\n\n\n  /**\n   * A recursive function that generates the DiagnosticReport content by\n   * going through the LForms form data structure\n   * @param item an LForms item\n   * @param contained the \"contained\" field in a DiagnosticReport where all the Observation instances are kept.\n   * @returns {{result: Array, resultObj: Array}} the content part of a Diagnostic Report instance\n   * @private\n   */\n  _createDiagnosticReportContent : function (item, contained) {\n    // return the content of \"result\" and \"contained\"\n    var content = {\n      result: [],\n      resultObj: []\n    };\n\n    for(var i=0, iLen=item.items.length; i<iLen; i++) {\n      var subItem = item.items[i];\n      if (subItem) {\n        var obx = this._commonExport._createObservation(subItem, true);\n        if (subItem.items && subItem.items.length>0) {\n          // single obx returned if it is a header item\n          obx[0].related = [];\n          var ret = this._createDiagnosticReportContent(subItem, contained);\n          for(var j=0, jLen=ret.result.length; j<jLen; j++) {\n            var subObxRef = ret.result[j];\n            obx[0].related.push({\n              type: \"has-member\",\n              target: {\n                reference: subObxRef.reference\n              }\n            });\n          }\n        }\n        for (var l=0, lLen=obx.length; l<lLen; l++) {\n          contained.push(obx[l]);\n          content.result.push({\n            reference: \"#\" + obx[l].id\n          });\n          content.resultObj.push(obx[l]);\n        }\n      }\n    }\n    return content;\n  },\n\n\n  /**\n   * Convert a DiagnosticReport resource with contained Observation resources to\n   * a FHIR Bundle resource that includes a DiagnosticReport resource and associated Observation resources\n   * @param dr a DiagnosticReport resource with contained Observation resources\n   * @param bundleType the FHIR Bundle type. Only \"transaction\" and \"collection\" types are allowed.\n   * @returns {{}} a Bundle resource that includes a DiagnosticReport resource and associated Observation resources\n   */\n  _convertFromContainedToBundle: function (dr, bundleType) {\n    var bundleDr = {};\n\n    // default bundleType\n    if (!bundleType) {\n      bundleType = \"transaction\";\n    }\n    if (dr) {\n      switch(bundleType) {\n        case \"transaction\":\n          bundleDr = this._convertContainedToTransactionBundle(dr);\n          break;\n        case \"collection\":\n          bundleDr = this._convertContainedToCollectionBundle(dr);\n          break;\n        default:\n          console.log(\"Bundle type not supported: \" + bundleType);\n      }\n    }\n    return bundleDr;\n  },\n\n\n  /**\n   * Convert a DiagnosticReport resource with contained Observation resources to\n   * a FHIR \"transaction\" typed Bundle resource that includes a DiagnosticReport resource\n   * and associated Observation resources\n   * @param dr a DiagnosticReport resource with contained Observation resources\n   * @returns {{}} a Bundle resource that includes a DiagnosticReport resource and associated Observation resources\n   * @private\n   */\n  _convertContainedToTransactionBundle: function(dr) {\n\n    var bundleDr = {\n      resourceType:\"Bundle\",\n      type: \"transaction\",\n      entry: []\n    };\n\n    var contained = dr.contained;\n    delete dr.contained;\n\n    // update reference to Observation resources\n    for (var i=0, iLen=dr.result.length; i<iLen; i++) {\n      var ref = dr.result[i];\n      ref.reference = this._OBX_REF_PREFIX + ref.reference.slice(1);\n    }\n    // add DiagnosticReport resource into Bundle entry\n    bundleDr.entry.push({\n      resource: dr,\n      request: {\n        method: \"POST\",\n        url: \"DiagnosticReport\"\n      }\n    });\n\n    // add Observation resources into Bundle entry\n    for (var j=0, jLen=contained.length; j<jLen; j++) {\n      var res = contained[j];\n\n      // if it has related Observation resources (as it is a section in LForms)\n      // update values of the references to the related Observation resources\n      if (res.related) {\n        for (var k=0, kLen=res.related.length; k<kLen; k++) {\n          var targetObservation = res.related[k];\n          targetObservation.target.reference = this._OBX_REF_PREFIX + targetObservation.target.reference.slice(1);\n        }\n      }\n\n      // add to the Bundle entry\n      bundleDr.entry.push({\n        resource: res,\n        request: {\n          method: \"POST\",\n          url: \"Observation\"\n        }\n      });\n    }\n\n    return bundleDr;\n  },\n\n\n  /**\n   * Convert a DiagnosticReport resource with contained Observation resources to\n   * a FHIR \"collection\" typed Bundle resource that includes a DiagnosticReport resource\n   * and associated Observation resources\n   * @param dr a DiagnosticReport resource with contained Observation resources\n   * @returns {{}} a Bundle resource that includes a DiagnosticReport resource and associated Observation resources\n   * @private\n   */\n  _convertContainedToCollectionBundle: function(dr) {\n    var bundleDr = {\n      resourceType:\"Bundle\",\n      type: \"collection\",\n      entry: []\n    };\n\n    var contained = dr.contained;\n    delete dr.contained;\n\n    // add DiagnosticReport resource into Bundle entry\n    bundleDr.entry.push({\n      resource: dr\n    });\n\n    // add Observation resources into Bundle entry\n    for (var j=0, jLen=contained.length; j<jLen; j++) {\n      var res = contained[j];\n      // add to the Bundle entry\n      bundleDr.entry.push({\n        resource: res\n      });\n    }\n\n    return bundleDr;\n  },\n\n\n  /**\n   * Generate FHIR DiagnosticReport data from an LForms form data\n   * @param formData an LFormsData object\n   * @param subject optional, A local FHIR resource that is the subject for this\n   *  DiagnoticReport.\n   * @param inBundle optional, a flag that a DiagnosticReport resources and associated Observation resources\n   *        should be placed into a FHIR Bundle. The default is false.\n   * @param bundleType, optional, the FHIR Bundle type if inBundle is true.\n   *        Only \"transaction\" and \"collection\" types are allowed.\n   * @returns {{}} a Diagnostic Report instance\n   */\n  createDiagnosticReport : function(formData, subject, inBundle, bundleType) {\n    var dr = null, contained =[];\n    if (formData) {\n\n      var formAndUserData = formData.getFormData(true,true,true);\n\n      var drContent = this._createDiagnosticReportContent(formAndUserData, contained);\n\n      dr = {\n        resourceType: \"DiagnosticReport\",\n        id: this._commonExport._getUniqueId(formAndUserData.code),\n        status: \"final\",\n        code: {\n          \"coding\": [\n            {\n              \"system\": \"http://loinc.org\",\n              \"code\": formAndUserData.code,\n              \"display\": formAndUserData.name\n            }\n          ],\n          \"text\": formAndUserData.name\n        },\n        result: drContent.result,\n        contained: contained\n      };\n      this._commonExport._addVersionTag(dr);\n\n      if (subject)\n        dr.subject = LForms.Util.createLocalFHIRReference(subject);\n\n      // issued\n      dr[\"issued\"] = this._getFormattedDate(new Date());\n    }\n\n    var ret = inBundle ? this._convertFromContainedToBundle(dr, bundleType) : dr;\n    LForms.Util.pruneNulls(ret);\n    return ret;\n  },\n\n\n  /**\n   * Functions for merging a DiagnosticReport instance into an LFormsData object\n   */\n\n  /**\n   * Find an observation from the \"contained\" list by an observation id\n   * @param refId an observation instance's id\n   * @param contained the \"contained\" field in a DiagnosticReport instance\n   * @returns {{}} an observation instance\n   * @private\n   */\n  _findObxById : function(refId, contained) {\n    var obx = null;\n    if (refId) {\n      var id = refId[0] === \"#\" ? refId.slice(1) : refId;\n      for(var i=0, iLen=contained.length; i<iLen; i++) {\n        if (contained[i].id === id) {\n          obx = contained[i];\n          break;\n        }\n      }\n    }\n    return obx;\n  },\n\n\n  /**\n   * Merge an Observation instance into an item object\n   * @param obx an observation instance\n   * @param item an item in an LForms object\n   * @private\n   */\n  _setupItemValueAndUnit : function(obx, item) {\n    if (item && obx.code.coding[0].code === item.questionCode) {\n      var dataType = item.dataType;\n      // any one has a unit must be a numerical type, let use REAL for now.\n      // dataType conversion should be handled when panel data are added to lforms-service.\n      if ((!dataType || dataType===\"ST\") && item.units && item.units.length>0 ) {\n        dataType = \"REAL\";\n      }\n\n      switch (dataType) {\n        case \"INT\":\n          if (obx.valueInteger) {\n            item.value = obx.valueInteger;\n            break;\n          }\n          // else handle as Quantity\n        case \"REAL\": // handle as Quantity\n        case \"QTY\":\n          let qty = obx.valueQuantity;\n          item.value = qty.value;\n          let unitName = qty.unit || qty.code;\n          if (unitName || qty.code || qty.system) {\n            item.unit = {};\n            if (unitName)\n              item.unit.name = unitName;\n            if (qty.code)\n              item.unit.code = qty.code;\n            if (qty.system)\n              item.unit.system = qty.system;\n          }\n          break;\n        case \"DT\":\n          item.value = LForms.Util.stringToDTDateISO(obx.valueDate);\n          break;\n        case \"DTM\":\n          item.value = LForms.Util.stringToDate(obx.valueDateTime);\n          break;\n        case \"CNE\":\n        case \"CWE\":\n          // get the value from Observation resource.\n          // for multiple-selected answers/values in LForms, each selected answer is exported as\n          // a separated Observation resource\n          var itemValue;\n          if (obx.valueCodeableConcept) {\n            itemValue = {\n              \"code\": obx.valueCodeableConcept.coding[0].code,\n              \"text\": obx.valueCodeableConcept.coding[0].display,\n              \"codeSystem\": obx.valueCodeableConcept.coding[0].system\n            };\n          }\n          else if (obx.valueString) {\n            itemValue = obx.valueString;\n          }\n\n          if (item.answerCardinality &&\n              (item.answerCardinality.max === \"*\" || parseInt(item.answerCardinality.max) > 1)) {\n            if (!item.value) {\n              item.value = [];\n            }\n            item.value.push(itemValue)\n          }\n          else {\n            item.value = itemValue;\n          }\n          break;\n        case \"SECTION\":\n        case \"TITLE\":\n        case \"\":\n          // do nothing\n          break;\n        default:\n          item.value = obx.valueString;\n      }\n    }\n  },\n\n\n  /**\n   * Find the number of the repeating items that have the same code\n   * in the \"contained\" field of a DiagnosticReport instance\n   * @param refIdList a list Observation instance IDs to be checked\n   * @param code an item code\n   * @param contained a list of Observation instances (in the \"contained\")\n   * @returns a structural info object for a repeating item\n   * of the repeating items\n   * @private\n   */\n  _findTotalRepeatingNum : function(refIdList, code, contained) {\n\n    var total = 0;\n    var refIds = [];\n    for (var i=0, iLen=refIdList.length; i<iLen; i++) {\n      var obx = this._findObxById(refIdList[i], contained);\n      if (obx.code.coding[0].code === code) {\n        refIds.push(refIdList[i]);\n        total += 1;\n      }\n    }\n\n    return {\n      total: total,\n      refIds: refIds\n    }\n  },\n\n\n  /**\n   * Get structural info of a DiagnosticReport by going though each level of observations\n   * @param parentObxInfo the structural info of a parent Observation\n   * @param parentRefId the instance ID of a parent Observation\n   * @param diagnosticReport a DiagnosticReport instance\n   * @private\n   */\n  _checkRepeatingItems : function(parentObxInfo, parentRefId, diagnosticReport) {\n\n    var obxInfoList = [];\n    var repeatingItemInfo = {};\n    var obxIdList = [];\n\n    // the report level\n    if (!parentRefId && diagnosticReport.result) {\n      for (var i=0, iLen=diagnosticReport.result.length; i<iLen; i++) {\n        obxIdList.push(diagnosticReport.result[i].reference);\n      }\n    }\n    // obx level\n    else {\n      var parentObx = this._findObxById(parentRefId, diagnosticReport.contained);\n      if (parentObx && parentObx.related) {\n        for (var i=0, iLen=parentObx.related.length; i<iLen; i++) {\n          obxIdList.push(parentObx.related[i].target.reference);\n        }\n      }\n    }\n\n    // go through each observation instance\n    for (var i=0, iLen=obxIdList.length; i<iLen; i++) {\n      var refId = obxIdList[i];\n      var obx = this._findObxById(refId, diagnosticReport.contained);\n      var itemCode =  obx.code.coding[0].code;\n      // first obx that has the same item code, either repeating or non-repeating\n      if (!repeatingItemInfo[itemCode]) {\n        var repeatingInfo = this._findTotalRepeatingNum(obxIdList, itemCode, diagnosticReport.contained);\n        repeatingItemInfo[itemCode] = {\n          total: repeatingInfo.total,\n          refIds: repeatingInfo.refIds\n        };\n      }\n      // create structure info for the obx\n      var repeatingRefIds = repeatingItemInfo[itemCode].refIds;\n      for (var j=0, jLen=repeatingRefIds.length; j<jLen; j++) {\n        if (refId === repeatingRefIds[j]) {\n          var obxInfo = {\n            code: itemCode,\n            refId: refId,\n            index: j,\n            total: repeatingItemInfo[itemCode].total\n          };\n          // check observation instances in the sub level\n          this._checkRepeatingItems(obxInfo, refId, diagnosticReport);\n          obxInfoList.push(obxInfo);\n        }\n      }\n    }\n    parentObxInfo.obxInfoList = obxInfoList;\n  },\n\n\n  /**\n   * Get structure information of a DiagnosticReport instance\n   * @param diagnosticReport a DiagnosticReport instance\n   * @returns {{}} a Diagnostic Report data structure object\n   * @private\n   */\n  _getReportStructure : function(diagnosticReport) {\n    var reportStructure = {\n      obxInfoList: []\n    };\n\n    if (diagnosticReport) {\n      this._checkRepeatingItems(reportStructure, null, diagnosticReport);\n    }\n    return reportStructure;\n  },\n\n\n  /**\n   * Find a matching repeating item\n   * @param parentItem a parent item\n   * @param itemCode code of a repeating (or non-repeating) item\n   * @param index index of the item in the sub item array of the parent item\n   * @returns {{}} a matching item\n   * @private\n   */\n  _findTheMatchingItemByCodeAndIndex : function(parentItem, itemCode, index) {\n    var item = null;\n    var idx = 0;\n    if (parentItem.items) {\n      for(var i=0, iLen=parentItem.items.length; i<iLen; i++) {\n        var subItem = parentItem.items[i];\n        if (itemCode === subItem.questionCode) {\n          if ((subItem.dataType === \"CNE\" || subItem.dataType === \"CWE\") &&\n              subItem.answerCardinality && (subItem.answerCardinality.max ===\"*\" || parseInt(subItem.answerCardinality.max)>1) ) {\n            item = subItem;\n            break;\n\n          }\n          else if (idx === index) {\n            item = subItem;\n            break;\n          }\n          else {\n            idx += 1;\n          }\n        }\n      }\n    }\n    return item;\n  },\n\n\n  /**\n   * Add repeating items\n   * @param parentItem a parent item\n   * @param itemCode code of a repeating item\n   * @param total total number of the repeating item with the same code\n   * @private\n   */\n  _addRepeatingItems : function(parentItem, itemCode, total) {\n    // find the first (and the only one) item\n    var item = null;\n    if (parentItem.items) {\n      for(var i=0, iLen=parentItem.items.length; i<iLen; i++) {\n        if (itemCode === parentItem.items[i].questionCode) {\n          item = parentItem.items[i];\n          break;\n        }\n      }\n      // insert new items unless it is a CNE/CWE and has multiple answers.\n      if (item && !((item.dataType === \"CNE\" || item.dataType ===\"CWE\") &&\n          item.answerCardinality &&\n          (item.answerCardinality.max === \"*\" || parseInt(item.answerCardinality.max) > 1))) {\n        while(total > 1) {\n          var newItem = LForms.Util.deepCopy(item);\n          parentItem.items.splice(i, 0, newItem);\n          total -= 1;\n        }\n      }\n    }\n  },\n\n\n  /**\n   * Merge Observation instances into items on the same level\n   * @param parentObxInfo structural information of a parent item\n   * @param parentItem a parent item\n   * @param diagnosticReport a DiagnosticReport instance\n   * @private\n   */\n  _processObxAndItem : function(parentObxInfo, parentItem, diagnosticReport) {\n    for(var i=0, iLen=parentObxInfo.obxInfoList.length; i<iLen; i++) {\n\n      var obxInfo = parentObxInfo.obxInfoList[i];\n      var obx = this._findObxById(obxInfo.refId, diagnosticReport.contained);\n      if (obx) {\n        // first repeating obx\n        if (obxInfo.total > 1 && obxInfo.index === 0) {\n          // add repeating items in form data\n          this._addRepeatingItems(parentItem, obxInfo.code, obxInfo.total);\n        }\n\n        var item = this._findTheMatchingItemByCodeAndIndex(parentItem, obxInfo.code, obxInfo.index);\n        this._setupItemValueAndUnit(obx, item);\n\n        // process items on sub level\n        if (obxInfo.obxInfoList && obxInfo.obxInfoList.length>0) {\n          this._processObxAndItem(obxInfo, item, diagnosticReport);\n        }\n      }\n    }\n  },\n\n  /**\n   * Convert a FHIR Bundle resource that includes a DiagnosticReport resource and associated Observation resources\n   * to a DiagnosticReport resource with contained Observation resources\n   * @param bundleDr a Bundle that includes a DiagnosticReport resource and associated Observation resources.\n   *        Only \"searchset\" type is allowed.\n   * @returns {{}} a DiagnosticReport resource with contained Observation resources\n   */\n  _convertFromBundleToContained: function (bundleDr) {\n\n    var containedDr;\n    // \"searchset\" is the only supported type at this point.\n    if (bundleDr && bundleDr.type === \"searchset\") {\n      var entry = bundleDr.entry;\n      // find the DiagnosticReport in the bundle\n      for (var i=0, iLen=entry.length; i<iLen; i++) {\n        if (entry[i].resource.resourceType === \"DiagnosticReport\") {\n          containedDr = entry[i].resource;\n          // change reference ids in result\n          for (var j=0, jLen=containedDr.result.length; j<jLen; j++) {\n            var ref = containedDr.result[j];\n            if (ref.reference && ref.reference.match(new RegExp(this._OBX_REF_PREFIX))) {\n              ref.reference = ref.reference.slice(this._OBX_REF_PREFIX.length);\n            }\n          }\n          containedDr.contained =[];\n          break;\n        }\n      }\n      // if DiagnosticReport is found\n      if (containedDr) {\n        // Move all Observation resource into \"contained\" field of the DiagnosticReport resource\n        for (var i=0, iLen=entry.length; i<iLen; i++) {\n          if (entry[i].resource.resourceType === \"Observation\") {\n            var obx = entry[i].resource;\n            // change reference ids in related\n            if (obx.related) {\n              for (var j=0, jLen=obx.related.length; j<jLen; j++) {\n                var related = obx.related[j];\n                if (related.target && related.target.reference &&\n                    related.target.reference.match(new RegExp(this._OBX_REF_PREFIX))) {\n                  related.target.reference = related.target.reference.slice(this._OBX_REF_PREFIX.length);\n                }\n              }\n            }\n            containedDr.contained.push(obx)\n          }\n        }\n      }\n    }\n\n    return containedDr;\n  },\n\n\n  /**\n   * Merge a DiagnosticReport instance into an LForms form definition or LFormsData object\n   * @param formData an LForms form definition or LFormsData object.\n   * @param diagnosticReport a DiagnosticReport resource with contained Observation resources,\n   * or a Bundle that includes a DiagnosticReport resource and associated Observation resources\n   * @param bundleType, optional, the FHIR Bundle type if inBundle is true.\n   * @returns {{}} an updated LForms form definition, with answer data\n   */\n  mergeDiagnosticReportToLForms : function(formData, diagnosticReport) {\n\n    if (!(formData instanceof LForms.LFormsData)) {\n      // get the default settings in case they are missing in the form data\n      // not to set item values by default values for saved forms with user data\n      formData.hasSavedData = true;\n      formData = (new LForms.LFormsData(formData)).getFormData();\n    }\n\n    var inBundle = diagnosticReport && diagnosticReport.resourceType === \"Bundle\";\n\n    // move Observation resources in Bundle to be in \"contained\" in DiagnosticReport resource\n    // as a base data structure for converting\n    var dr = inBundle ? this._convertFromBundleToContained(diagnosticReport) : diagnosticReport;\n\n    var reportStructure = this._getReportStructure(dr);\n\n    this._processObxAndItem(reportStructure, formData, dr);\n\n    return formData;\n  }\n\n};\n\nexport default dr;\n","/* jshint -W097 */ // suppress jshint warning about strict\n/* jshint node: true */ // suppress warning about \"require\"\n\"use strict\";\n\nimport {LOINC_URI} from './fhir-common';\n\nvar _versionTagStr = 'lformsVersion: ';\n\n/**\n *  Defines export functions that are the same across the different FHIR\n *  versions and that are used by both the SDC and DiagnosticReport exports.\n */\nvar self = {\n\n  /**\n   *  Creates Observation resources from an LForms item object\n   * @param item an LForms item object\n   * @param setId (optional) a flag indicating if a unique ID should be set on the Observation resource\n   * @returns {{}} an array of observation resources representing the values\n   *  stored in the item.\n   * @private\n   */\n  _createObservation: function(item, setId) {\n\n    var values = [];\n\n    var dataType = item.dataType;\n    // any item has a unit must be a numerical type, let use REAL for now.\n    if ((!dataType || dataType===\"ST\") && item.units && item.units.length>0 ) {\n      dataType = \"REAL\";\n    }\n    switch (dataType) {\n      case \"INT\":\n        values = [this._createObsIntValue(item)];\n        break;\n      case \"REAL\":\n        // A \"real\" data type should be exported as valueQuantity, because\n        // there is no valueDecimal for Observation (as of R4).\n      case \"QTY\":\n        var valValue = {value: item.value};\n        this._setFHIRQuantityUnit(valValue, item.unit);\n        values = [{\n          key: \"valueQuantity\",\n          val: valValue\n        }];\n        break;\n      case \"DT\":\n        values = [{\n          key:  \"valueDate\",\n          val: item.value\n        }];\n        break;\n      case \"DTM\":\n        values = [{\n          key:  \"valueDateTime\",\n          val: item.value\n        }];\n        break;\n      case \"CNE\":\n      case \"CWE\":\n        var max = item.answerCardinality.max;\n        // multiple values, each value creates a separate Observation resource\n        var itemValues;\n        if (max && (max === \"*\" || parseInt(max) > 1)) {\n          itemValues = item.value;\n        }\n        else {\n          itemValues = [item.value];\n        }\n        for (var j=0,jLen=itemValues.length; j<jLen; j++) {\n          var val = itemValues[j];\n          if (typeof val === \"object\") {\n            var coding = {};\n            if (val.code) coding.code = val.code;\n            if (val.text) coding.display = val.text;\n            var codeSystem = val.system;\n            if (codeSystem) coding.system = LForms.Util.getCodeSystem(codeSystem);\n            values.push(\n                { key: \"valueCodeableConcept\",\n                  val: {\n                    \"coding\" : [coding],\n                    \"text\": coding.display\n                  }\n                }\n            );\n          }\n          else if (typeof val === \"string\") {\n            if (val !== \"\") {\n              values.push(\n                  { key: \"valueString\",\n                    val: val\n                  }\n              );\n            }\n          }\n        }\n        break;\n      case \"attachment\":\n        values = [{\n          key: \"valueAttachment\",\n          val: item.value\n        }];\n        break;\n      case \"BL\":\n        values = [{\n          key: \"valueBoolean\",\n          val: item.value // undefined, null, or '' values should have been skipped before calling this function\n        }];\n        break;\n      default:\n        values = [{\n          key: \"valueString\",\n          val: item.value\n        }];\n    }\n\n    var obxs = [];\n    for(var i=0, iLen=values.length; i<iLen; i++) {\n      var obx = {\n        \"resourceType\": \"Observation\",\n        \"status\": \"final\",\n        \"code\": {\n          \"coding\": item.codeList,\n          \"text\": item.question\n        }\n      };\n      this._addVersionTag(obx);\n      if (setId) {\n        obx.id = this._getUniqueId(item.questionCode);\n      }\n      if (!item.header) {\n        obx[values[i].key] = values[i].val;\n      }\n      obxs.push(obx);\n    }\n    return obxs;\n  },\n\n\n  /**\n   * Generate an almost unique ID for a given Observation code\n   * @param prefix A prefix for the ID (e.g. a code or resource name)\n   * @returns {string} a unique id\n   * @private\n   */\n  _getUniqueId: function(prefix) {\n    this._idCtr || (this._idCtr = 0);\n    return prefix + \"-\" + Date.now() + '-' + ++this._idCtr + '-' +\n      Math.random().toString(16).substr(2);\n  },\n\n\n  /**\n   *  Sets the unit for a Quantity.\n   * @param qty the FHIR Quantity structure whose unit will be set.  This\n   *  function assumes there is no unit information already set.\n   * @param unit An LForms unit object.\n   */\n  _setFHIRQuantityUnit: function(qty, unit) {\n    if (unit) {\n      if (unit.name) qty.unit = unit.name;\n      if (unit.code) qty.code = unit.code;\n      if (unit.system) qty.system = unit.system;\n    }\n  },\n\n\n  /**\n   *  Returns and creates if necessary the tag array object on the resource.  If\n   *  created, the given resource will be modified.\n   * @param res the resource whose tag array is needed.\n   */\n  _resTags: function(res) {\n    var meta = res.meta;\n    if (!meta)\n      meta = (res.meta = {});\n    var tag = meta.tag;\n    if (!tag)\n      tag = (meta.tag = []);\n    return tag;\n  },\n\n\n  /**\n   *  Sets the LForms version tag on a FHIR resource to indicate the LForms version used to\n   *  export it.  This will replace any version tag already present.\n   * @param res the resource object to be tagged.\n   */\n  _setVersionTag: function(res) {\n    var tags = this._resTags(res);\n    // Delete any lformsVersion tag present.  There should be at most one\n    for (var i=0, len=tags.length; i<len; ++i) {\n      var t = tags[i];\n      if (t.code && t.code.indexOf(_versionTagStr)===0) {\n        tags.splice(i, 1);\n        break;\n      }\n    }\n    this._addVersionTag(res);\n  },\n\n\n  /**\n   *  Adds a tag to a FHIR resource to indicate the LForms version used to\n   *  export it.  Assumes the version tag does not already exist.\n   * @param res the resource object to be tagged.\n   */\n  _addVersionTag: function(res) {\n    var tag = this._resTags(res);\n    tag.push({code: _versionTagStr+LForms.lformsVersion});\n  }\n};\n\nexport default self;\n","// STU3-specific export code common to DiagnosticReport and SDC.\n\nimport commonExport from '../export-common.js';\n\nlet self = Object.create(commonExport); // copies properties to self.prototype\nObject.assign(self, {\n  /**\n   *  Creates a structure for use by _createObservation() in constructing an\n   *  Observation value for the given integer value.\n   * @param item an LForms item with the integer value to be represented in an Observation.\n   *  It is assumed that the caller has already checked the data type.\n   * @return an object with a \"key\" property that will be the property name for\n   *  the value in the Observation object, and a \"val\" property that holds the\n   *  value (formatted for the Observation).\n   */\n  _createObsIntValue: function(item) {\n    // In STU3, there is no valueInteger in Observation, so we use\n    // valueQuantity.\n    let quantity = {value: item.value};\n    this._setFHIRQuantityUnit(quantity, item.unit);\n    let rtn = {key: 'valueQuantity', val: quantity};\n\n    return rtn;\n  }\n});\n\nexport default self;\n","/**\n * A package to handle FHIR Questionnaire and SDC (STU2) Questionnaire and QuestionnaireResponse for LForms\n *\n * FHIR Questionnaire:\n * https://www.hl7.org/fhir/questionnaire.html\n *\n * STU2 SDC Ballot:\n * http://hl7.org/fhir/us/sdc/sdc-questionnaire.html\n * http://hl7.org/fhir/us/sdc/sdc-questionnaireresponse.html\n *\n * It provides the following functions:\n * convertLFormsToQuestionnaire()\n * -- Convert existing LOINC panels/forms data in LForms format into FHIR (standard or SDC) Questionnaire data\n * convertLFormsToQuestionnaireResponse()\n * -- Generate FHIR (standard or SDC) QuestionnaireResponse data from captured data in LForms\n */\nvar sdcVersion = '2.0';\nvar fhirVersionNum = '3.0';\n\nvar self = {\n\n  SDCVersion: sdcVersion,\n  QProfile: 'http://hl7.org/fhir/us/sdc/StructureDefinition/sdc-questionnaire|'+sdcVersion,\n  QRProfile: 'http://hl7.org/fhir/us/sdc/StructureDefinition/sdc-questionnaireresponse|'+sdcVersion,\n  stdQProfile: 'http://hl7.org/fhir/'+fhirVersionNum+'/StructureDefinition/Questionnaire',\n  stdQRProfile: 'http://hl7.org/fhir/'+fhirVersionNum+'/StructureDefinition/QuestionnaireResponse',\n\n\n  /**\n   *  Convert LForms captured data to a bundle consisting of a FHIR SDC\n   *  QuestionnaireResponse and any extractable resources. (Currently this means\n   *  any Observations that can be extracted via the observationLinkPeriod\n   *  extension).\n   *\n   * @param lfData a LForms form object\n   * @param noExtensions a flag that a standard FHIR Questionnaire is to be created without any extensions.\n   *  The default is false.\n   * @param subject A local FHIR resource that is the subject of the output resource.\n   *  If provided, a reference to this resource will be added to the output FHIR\n   *  resource when applicable.\n   * @returns an array of QuestionnaireResponse and Observations.  The caller may\n   *  wish to put all of the returned resources into a transaction Bundle for\n   *  creating them on a FHIR server.\n   */\n   convertLFormsToQRAndExtracFHIRData: function(lfData, noExtensions, subject) {\n    var qr = this.convertLFormsToQuestionnaireResponse(lfData, noExtensions, subject);\n    if (!qr.id) {\n      qr.id = this._commonExport._getUniqueId(qr.code && qr.code[0] && qr.code[0].code ||\n        qr.identifier || 'QR')\n    }\n\n    var qrRef = 'QuestionnaireResponse/'+qr.id;\n    var rtn = [qr];\n    var objPerformers = ['Practitioner', 'Patient', 'RelatedPerson']; // intersected with qr.author\n    for (var i=0, len=lfData.itemList.length; i<len; ++i) {\n      var item = lfData.itemList[i];\n      if (self._getExtractValue(item) && self._hasItemValue(item)) {\n        var obs = this._commonExport._createObservation(item);\n        for (var j=0, jLen=obs.length; j<jLen; j++) {\n          // Following\n          // http://hl7.org/fhir/uv/sdc/2019May/extraction.html#observation-based-extraction\n          if (qr.basedOn)\n            obs[j].basedOn = qr.basedOn;\n          if (qr.subject)\n            obs[j].subject = qr.subject;\n          if (qr.context)\n            obs[j].context = qr.context;\n          if (qr.authored) {\n            obs[j].effectiveDateTime = qr.authored;\n            obs[j].issued = qr.authored;\n          }\n          if (qr.author && objPerformers.indexOf(qr.author.type)>=0)\n            obs[j].performer = qr.author;\n\n          rtn.push(obs[j]);\n        }\n      }\n    }\n    return rtn;\n  },\n\n\n  /**\n   *  Proceses the LForms questionCardinality into FHIR.\n   * @param targetItem an item in Questionnaire\n   * @param item a LForms item\n   */\n  _processQuestionCardinality: function(targetItem, item) {\n    if (item.questionCardinality) {\n      if (item.questionCardinality.max === \"*\") {\n        targetItem.repeats = true;\n      }\n      else if (parseInt(item.questionCardinality.max) > 1) {\n        targetItem.repeats = true;\n        targetItem.extension.push({\n          \"url\": \"http://hl7.org/fhir/StructureDefinition/questionnaire-maxOccurs\",\n          \"valueInteger\": parseInt(item.questionCardinality.max)\n        });\n      }\n    }\n    else {\n      targetItem.repeats = false;\n    }\n  },\n\n\n  /**\n   * Handle special requirements for 'display' items\n   * @param targetItem an item in Questionnaire\n   * @param item a LForms item\n   * @private\n   */\n  _handleSpecialConstraints: function(targetItem, item) {\n    //Display items cannot have a \"code\" asserted\n    //Required and repeat aren't permitted for display items\n    //Read-only can't be specified for \"display\" items\n    if (targetItem && item.dataType === \"TITLE\") {\n      delete targetItem.code;\n      delete targetItem.required;\n      delete targetItem.repeats;\n      delete targetItem.readOnly;\n    }\n  },\n\n\n  /**\n   * Process various restriction settings\n   * @param targetItem an item in FHIR SDC Questionnaire object\n   * @param item an item in LForms form object\n   * @private\n   */\n  _handleRestrictions: function(targetItem, item) {\n    // http://hl7.org/fhir/StructureDefinition/minLength\n    // http://hl7.org/fhir/StructureDefinition/regex\n    // http://hl7.org/fhir/StructureDefinition/minValue\n    // http://hl7.org/fhir/StructureDefinition/maxValue\n    // http://hl7.org/fhir/StructureDefinition/maxDecimalPlaces, not supported yet\n    // http://hl7.org/fhir/StructureDefinition/maxSize, for attachment, not supported yet\n    // maxLength\n    if (item.restrictions) {\n      for (var key in item.restrictions) {\n        var value = item.restrictions[key];\n        var extValue = null;\n        var dataType = this._getAssumedDataTypeForExport(item);\n        var valueKey = this._getValueKeyByDataType(\"value\", item);\n\n        switch (key) {\n          // http://hl7.org/fhir/StructureDefinition/minValue\n          // { // Must be >= this value\n          //   // from Element: extension\n          //   \"url\" : \"http://hl7.org/fhir/StructureDefinition/minValue\", // R!\n          //   // value[x]: Value of extension. One of these 6:\n          //   \"valueDate\" : \"<date>\" // R! Value of extension\n          //   \"valueDateTime\" : \"<dateTime>\", // R! Value of extension\n          //   \"valueTime\" : \"<time>\", // R! Value of extension\n          //   \"valueInstant\" : \"<instant>\", // R! Value of extension\n          //   \"valueDecimal\" : <decimal>, // R! Value of extension\n          //   \"valueInteger\" : <integer>, // R! Value of extension\n          // }\n          case \"minExclusive\":\n          case \"minInclusive\":\n          // http://hl7.org/fhir/StructureDefinition/maxValue\n          case \"maxExclusive\":\n          case \"maxInclusive\":\n            extValue = this._exportMinMax(dataType, value, valueKey, key);\n            break;\n          // http://hl7.org/fhir/StructureDefinition/minLength\n          case \"minLength\":\n            if (dataType === \"ST\" || dataType === \"TX\" || dataType === \"URL\" ||\n              dataType === \"QTY\") {\n              extValue = {\n                \"url\":\"http://hl7.org/fhir/StructureDefinition/minLength\",\n                \"valueInteger\": parseInt(value)\n              };\n            }\n            break;\n          // maxLength, not an extension, directly on item\n          case \"maxLength\":\n            if (dataType === \"ST\" || dataType === \"TX\" || dataType === \"URL\" ||\n              dataType === \"QTY\") {\n              targetItem.maxLength = parseInt(value);\n            }\n            break;\n          // http://hl7.org/fhir/StructureDefinition/regex\n          case \"pattern\":\n            if (dataType === \"ST\" || dataType === \"TX\" ) {\n              extValue = {\n                \"url\":\"http://hl7.org/fhir/StructureDefinition/regex\",\n                \"valueString\": value\n              };\n            }\n            break\n        }\n        if (extValue) {\n          targetItem.extension.push(extValue);\n        }\n      }\n    }\n  },\n\n\n  /**\n   *  Processes settings for a list field with choices.\n   * @param targetItem an item in FHIR SDC Questionnaire object\n   * @param item an item in the LForms form object\n   * @param noExtensions a flag that a standard FHIR Questionnaire is to be created without any extensions.\n   *        The default is false.\n   */\n  _handleChoiceField: function(targetItem, item, noExtensions) {\n    // an extension for the search url of the auto-complete field.\n    if(item.externallyDefined) {\n      this._handleExternallyDefined(targetItem, item);\n    }\n    // option, for answer list\n    else if (item.answers && !item.answerValueSet) {\n      // Make sure the answers did not come from answerExpression.\n      if (!item._fhirExt || !item._fhirExt[this.fhirExtAnswerExp])\n        targetItem.option = this._handleAnswers(item, noExtensions);\n    }\n    else if (item.answerValueSet)\n      targetItem.options = item.answerValueSet;\n  },\n\n\n  /**\n   * Process an item's answer list\n   * @param item an item in the LForms form object\n   * @param noExtensions a flag that a standard FHIR Questionnaire is to be created without any extensions.\n   *        The default is false.\n   * @returns {Array}\n   * @private\n   */\n  _handleAnswers: function(item, noExtensions) {\n    var optionArray = [];\n    for (var i=0, iLen=item.answers.length; i<iLen; i++) {\n      var answer = item.answers[i];\n      var option = {};\n\n      // needs an extension for label\n      if (!noExtensions) {\n        var ext = [];\n        if(answer.label) {\n          ext.push({\n            \"url\" : \"http://hl7.org/fhir/StructureDefinition/questionnaire-optionPrefix\",\n            \"valueString\" : answer.label\n          });\n        }\n\n        if (answer.score !== null && answer.score !== undefined) {\n          ext.push({\n            \"url\" : \"http://hl7.org/fhir/StructureDefinition/questionnaire-ordinalValue\",\n            \"valueDecimal\" : parseFloat(answer.score)\n          });\n        }\n        if(ext.length > 0) {\n          option.extension = ext;\n        }\n      }\n      // option's value supports integer, date, time, string and Coding\n      // for LForms, all answers are Coding\n      option.valueCoding = {};\n      if (answer.code) option.valueCoding.code = answer.code;\n      if (answer.text) option.valueCoding.display = answer.text;\n\n      if (answer.system) {\n        option.valueCoding.system = LForms.Util.getCodeSystem(answer.system);\n      }\n\n      optionArray.push(option);\n    }\n    return optionArray;\n  },\n\n\n  /**\n   * Process default values\n   * @param targetItem an item in FHIR SDC Questionnaire object\n   * @param item an item in LForms form object\n   * @private\n   */\n  _handleInitialValues: function(targetItem, item) {\n    // dataType:\n    // boolean, decimal, integer, date, dateTime, instant, time, string, uri,\n    // Attachment, Coding, Quantity, Reference(Resource)\n\n    if (item.defaultAnswer !== null && item.defaultAnswer !== undefined && item.defaultAnswer !== '') {\n\n      var dataType = this._getAssumedDataTypeForExport(item);\n      var valueKey = this._getValueKeyByDataType(\"initial\", item);\n      // for Coding\n      // multiple selections, item.value is an array\n      // NO support of multiple selections in FHIR SDC, just pick one\n      if (dataType === 'CWE' || dataType === 'CNE' ) {\n        var codeSystem = null, coding = null;\n\n        // item.defaultAnswer could be an array of multiple default values or a single value.\n        // in STU3 'initial[x]' is a single value. pick the first one if defaultAnswer is an array.\n        var defaultAnswer = (this._answerRepeats(item) && Array.isArray(item.defaultAnswer)) ?\n            item.defaultAnswer[0] : item.defaultAnswer;\n        if (typeof defaultAnswer === 'object') {\n          coding = {\n            \"code\": defaultAnswer.code,\n          };\n          if(defaultAnswer !== undefined) {\n            coding.display = defaultAnswer.text;\n          }\n          // code system\n          codeSystem = defaultAnswer.system || item.answerCodeSystem;\n          if (codeSystem) {\n            coding.system = LForms.Util.getCodeSystem(codeSystem);\n          }\n          targetItem[valueKey] = coding;\n        }\n        // user typed answer that is not on the answer list.\n        else if (typeof defaultAnswer === 'string') {\n          targetItem[\"initialString\"] = defaultAnswer\n        }\n      }\n      // for Quantity,\n      // [{\n      //   // from Element: extension\n      //   \"value\" : <decimal>, // Numerical value (with implicit precision)\n      //   \"comparator\" : \"<code>\", // < | <= | >= | > - how to understand the value\n      //   \"unit\" : \"<string>\", // Unit representation\n      //   \"system\" : \"<uri>\", // Code System that defines coded unit form\n      //   \"code\" : \"<code>\" // Coded form of the unit\n      // }]\n      else if (dataType === 'QTY') { // for now, handling only simple quantities without the comparators.\n        var fhirQuantity = this._makeQuantity(item.defaultAnswer, item.units);\n        if(fhirQuantity) {\n          targetItem[valueKey] = fhirQuantity;\n        }\n      }\n      // for boolean, decimal, integer, date, dateTime, instant, time, string, uri\n      else if (dataType === \"BL\" || dataType === \"REAL\" || dataType === \"INT\" ||\n        dataType === \"TM\" || dataType === \"ST\" || dataType === \"TX\" || dataType === \"URL\") {\n        targetItem[valueKey] = item.defaultAnswer;\n      }\n      else if (dataType === \"DT\" || dataType === \"DTM\") { // transform to FHIR date/datetime format.\n        var dateValue = LForms.Util.stringToDate(item.defaultAnswer);\n        if(dateValue) {\n          dateValue = dataType === \"DTM\"?\n            LForms.Util.dateToDTMString(dateValue): LForms.Util.dateToDTStringISO(dateValue);\n          targetItem[valueKey] = dateValue;\n        }\n        else { // LForms.Util.stringToDate returns null on invalid string\n          //TODO: should save the errors or emitting events.\n          console.error(item.defaultAnswer + ': Invalid date/datetime string as defaultAnswer for ' + item.questionCode);\n        }\n      }\n      // no support for reference\n    }\n  },\n\n\n  /**\n   * Process units list\n   * @param targetItem an item in FHIR SDC Questionnaire object\n   * @param item an item in LForms form object\n   * @private\n   */\n  _handleLFormsUnits: function(targetItem, item) {\n    if (item.units && item.units.length > 0) {\n      var dataType = this._getAssumedDataTypeForExport(item);\n      if(dataType === \"REAL\" || dataType === \"INT\") {\n\n        targetItem.extension.push({\n          \"url\": this.fhirExtUrlUnit,\n          // Datatype with multiple units is quantity. There is only one unit here.\n          \"valueCoding\" : self._createFhirUnitCoding(item.units[0])\n        });\n      }\n      else if(dataType === 'QTY') {\n        var defUnit = this._getDefaultUnit(item.units);\n        if ((defUnit && defUnit.default) || targetItem.initialQuantity) {\n          // Use initial[].valueQuantity.unit to export the default unit.\n          if (!targetItem.initialQuantity) {\n            targetItem.initialQuantity = {};\n          }\n          self._setUnitAttributesToFhirQuantity(targetItem.initialQuantity, defUnit);\n        }\n        for (var i=0, iLen=item.units.length; i<iLen; i++) {\n          var unit = item.units[i];\n          var fhirUnitExt = {\n            \"url\": this.fhirExtUrlUnitOption,\n            \"valueCoding\": self._createFhirUnitCoding(unit)\n          };\n          targetItem.extension.push(fhirUnitExt);\n        }\n      }\n    }\n  },\n\n\n  /**\n   * Process skip logic\n   * @param targetItem an item in FHIR SDC Questionnaire object\n   * @param item an item in LForms form object\n   * @param source a LForms form object\n   * @private\n   */\n  _handleSkipLogic: function(targetItem, item, source) {\n    if (item.skipLogic) {\n      var enableWhen = [];\n\n      // ignore \"ANY\", \"ALL\" on item.skipLogic.logic\n      // ignore \"show\" on item.skipLogic.action\n\n      for (var i=0, iLen=item.skipLogic.conditions.length; i<iLen; i++) {\n        var condition = item.skipLogic.conditions[i];\n        var sourceItem = source._getSkipLogicSourceItem(item,condition.source);\n\n        var enableWhenRule = {\n          \"question\": sourceItem.linkId\n        };\n        // dataTypes:\n        // boolean, decimal, integer, date, dateTime, instant, time, string, uri,\n        // Attachment, Coding, Quantity, Reference(Resource)\n        var valueKey = this._getValueKeyByDataType(\"answer\", sourceItem);\n        var dataType = this._getAssumedDataTypeForExport(sourceItem);\n\n        if(condition.trigger.hasOwnProperty('exists')) {\n          enableWhenRule.hasAnswer = condition.trigger.exists;\n        }\n        // for Coding\n        // multiple selections, item.value is an array\n        // NO support of multiple selections in FHIR SDC, just pick one\n        else if (dataType === 'CWE' || dataType === 'CNE' ) {\n          let answerCoding = self._copyTriggerCoding(condition.trigger.value, null, true);\n          if (answerCoding) {\n            enableWhenRule[valueKey] = answerCoding;\n          }\n          else {\n            throw new Error(\"Unable to convert trigger to answerCoding: \" + condition.trigger.value);\n          }\n        }\n        // for Quantity,\n        // [{\n        //   // from Element: extension\n        //   \"value\" : <decimal>, // Numerical value (with implicit precision)\n        //   \"comparator\" : \"<code>\", // < | <= | >= | > - how to understand the value\n        //   \"unit\" : \"<string>\", // Unit representation\n        //   \"system\" : \"<uri>\", // Code System that defines coded unit form\n        //   \"code\" : \"<code>\" // Coded form of the unit\n        // }]\n        else if (dataType === 'QTY') { // for now, handling only simple quantities without the comparators.\n          let fhirQuantity = this._makeQuantity(condition.trigger.value, sourceItem.units);\n          if(fhirQuantity) {\n            enableWhenRule[valueKey] = fhirQuantity;\n          }\n        }\n        // for boolean, decimal, integer, date, dateTime, instant, time, string, uri\n        else if (dataType === \"BL\" || dataType === \"REAL\" || dataType === \"INT\" ||\n          dataType === \"DT\" || dataType === \"DTM\" || dataType === \"TM\" ||\n          dataType === \"ST\" || dataType === \"TX\" || dataType === \"URL\") {\n          enableWhenRule[valueKey] = condition.trigger.value;\n          // TODO luanx2: similarly, REAL, INT with unit should be valueQuantity? Leave as is for now.\n        }\n        // add a rule to enableWhen\n        enableWhen.push(enableWhenRule)\n      }\n      targetItem.enableWhen = enableWhen;\n    }\n  },\n\n\n};\n\nexport default self;\n","/**\n *  Defines SDC export functions that are the same across the different FHIR\n *  versions.  The function takes the SDC namespace object defined in the sdc export\n *  code, and adds additional functions to it.\n */\nfunction addCommonSDCExportFns(ns) {\n\"use strict\";\n\n  var self = ns;\n\n  /**\n   * Convert LForms captured data to FHIR SDC QuestionnaireResponse\n   * @param lfData a LForms form object\n   * @param noExtensions a flag that a standard FHIR Questionnaire is to be created without any extensions.\n   *  The default is false.\n   * @param subject A local FHIR resource that is the subject of the output resource.\n   *  If provided, a reference to this resource will be added to the output FHIR\n   *  resource when applicable.\n   * @returns {{}}\n   */\n  self.convertLFormsToQuestionnaireResponse = function(lfData, noExtensions, subject) {\n    var target = {};\n    if (lfData) {\n      var source = lfData.getFormData(true,true,true);\n      this._processRepeatingItemValues(source);\n      this._setResponseFormLevelFields(target, source, noExtensions);\n\n      if (source.items && Array.isArray(source.items)) {\n        var tmp = this._processResponseItem(source, true);\n        if(tmp && tmp.item && tmp.item.length) {\n          target.item = tmp.item;\n        }\n      }\n    }\n    // FHIR doesn't allow null values, strip them out.\n    LForms.Util.pruneNulls(target);\n\n    if (subject)\n      target[\"subject\"] = LForms.Util.createLocalFHIRReference(subject);\n\n    this._commonExport._setVersionTag(target);\n    return target;\n  };\n\n\n  /**\n   * Convert LForms form definition to standard FHIR Questionnaire or FHIR SDC Questionnaire\n   * @param lfData a LForms form object\n   * @param noExtensions a flag that a standard FHIR Questionnaire is to be created without any extensions.\n   *        The default is false.\n   * @returns {{}}\n   */\n  self.convertLFormsToQuestionnaire = function(lfData, noExtensions) {\n    var target = {};\n\n    if (lfData) {\n      var source = LForms.Util.deepCopy(lfData);\n      if(! (source instanceof LForms.LFormsData)) {\n        source = new LForms.LFormsData(source);\n      }\n      this._removeRepeatingItems(source);\n      this._setFormLevelFields(target, lfData, noExtensions);\n\n      if (source.items && Array.isArray(source.items)) {\n        target.item = [];\n        for (var i=0, iLen=source.items.length; i<iLen; i++) {\n          var newItem = this._processItem(source.items[i], source, noExtensions);\n          target.item.push(newItem);\n        }\n      }\n    }\n\n    // FHIR doesn't allow null values, strip them out.\n    LForms.Util.pruneNulls(target);\n    this._commonExport._setVersionTag(target);\n    return target;\n  };\n\n\n  /**\n   * Process an item of the form\n   * @param item an item in LForms form object\n   * @param source a LForms form object\n   * @param noExtensions a flag that a standard FHIR Questionnaire is to be created without any extensions.\n   *        The default is false.\n   * @returns {{}}\n   * @private\n   */\n  self._processItem = function(item, source, noExtensions) {\n    var targetItem = {};\n\n    // type\n    targetItem.type = this._getFhirDataType(item);\n\n    // id (empty for new record)\n\n    // code\n    targetItem.code = item.codeList;\n\n    // extension\n    targetItem.extension = item.extension || []; // later we delete if empty\n\n    // required\n    if (item._answerRequired === true || item._answerRequired === false) {\n      targetItem.required = item._answerRequired;\n    }\n\n    // http://hl7.org/fhir/StructureDefinition/questionnaire-minOccurs\n    if (targetItem.required) {\n      var minOccurInt = parseInt(item.questionCardinality.min);\n      if(minOccurInt > 1) {\n        targetItem.extension.push({\n          \"url\" : \"http://hl7.org/fhir/StructureDefinition/questionnaire-minOccurs\",\n          \"valueInteger\" : minOccurInt\n        });\n      }\n    }\n\n    // question/answer repeats\n    // http://hl7.org/fhir/StructureDefinition/questionnaire-maxOccurs\n    this._processQuestionAndAnswerCardinality(targetItem, item);\n\n    // http://hl7.org/fhir/StructureDefinition/questionnaire-itemControl\n    this._handleItemControl(targetItem, item);\n\n    // check restrictions\n    this._handleRestrictions(targetItem, item);\n\n    // http://hl7.org/fhir/StructureDefinition/entryFormat\n    // looks like tooltip, TBD\n\n    if(item._isHiddenInDef) {\n      targetItem.extension.push({\n        url: \"http://hl7.org/fhir/StructureDefinition/questionnaire-hidden\",\n        valueBoolean: true\n      });\n    }\n\n\n    // linkId\n    targetItem.linkId = item.linkId;\n\n    // Text & prefix\n    targetItem.text = item.question;\n    if (item.prefix) {\n      targetItem.prefix = item.prefix;\n    }\n    // Copy item extensions\n    for (let extField of ['_prefix', '_text']) {\n      let extFieldData = item['obj'+extField];\n      if (extFieldData)\n        targetItem[extField] = extFieldData;\n    }\n\n    // enableWhen\n    if (item.skipLogic) {\n      this._handleSkipLogic(targetItem, item, source)\n    }\n\n    // repeats, handled above\n    // readonly, (editable)\n    if (item.dataType !== \"SECTION\" && item.dataType !== \"TITLE\" && item.editable === \"0\") {\n      targetItem.readOnly = true;\n    }\n\n    this._handleChoiceField(targetItem, item, noExtensions);\n    this._handleTerminologyServer(targetItem, item);\n\n    // initialValue, for default values\n    this._handleInitialValues(targetItem, item);\n    // add LForms Extension to units list. Process units after handling initial values.\n    if (item.units) {\n      this._handleLFormsUnits(targetItem, item);\n    }\n    // data control\n    this._handleDataControl(targetItem, item);\n\n    if (item.items && Array.isArray(item.items)) {\n      targetItem.item = [];\n      for (var i=0, iLen=item.items.length; i<iLen; i++) {\n        var newItem = this._processItem(item.items[i], source, noExtensions);\n        targetItem.item.push(newItem);\n      }\n    }\n\n    // the coding instruction is a sub item with a \"display\" type, and an item-control value as \"help\"\n    // it is added as a sub item of this item.\n    // http://hl7.org/fhir/StructureDefinition/questionnaire-itemControl, for instructions\n    if (item.codingInstructions) {\n      let helpItem = {\n        \"text\": item.codingInstructionsPlain ? item.codingInstructionsPlain : item.codingInstructions,\n        \"type\": \"display\",\n        \"linkId\": targetItem.linkId + \"-help\",\n        \"extension\": [{\n          \"url\": \"http://hl7.org/fhir/StructureDefinition/questionnaire-itemControl\",\n          \"valueCodeableConcept\": {\n            \"text\": \"Help-Button\",\n            \"coding\": [{\n              \"code\": \"help\",\n              \"display\": \"Help-Button\",\n              \"system\": \"http://hl7.org/fhir/questionnaire-item-control\"\n            }]\n          }\n        }]\n      };\n\n      // format could be 'html' or 'text'\n      if (item.codingInstructionsFormat === 'html') {\n        // add a \"_text\" field to contain the extension for the string value in the 'text' field\n        // see http://hl7.org/fhir/R4/json.html#primitive\n        helpItem._text = {\n          \"extension\": [{\n            \"url\": \"http://hl7.org/fhir/StructureDefinition/rendering-xhtml\",\n            \"valueString\": item.codingInstructions\n          }]\n        }\n      }\n\n      if (Array.isArray(targetItem.item)) {\n        targetItem.item.push(helpItem)\n      }\n      else {\n        targetItem.item = [\n          helpItem\n        ]\n      }\n    }\n\n    if (item.maxAttachmentSize) {\n      var exts = (targetItem.extension || (targetItem.extension = []));\n      exts.push({url: self.fhirExtMaxSize, valueDecimal: item.maxAttachmentSize});\n    }\n\n    if (item.allowedAttachmentTypes) {\n      exts = (targetItem.extension || (targetItem.extension = []));\n      for (let type of item.allowedAttachmentTypes) {\n        exts.push({url: self.fhirExtMimeType, valueCode: type});\n      }\n    }\n\n    // handle special constraints for \"display\" item\n    this._handleSpecialConstraints(targetItem, item);\n\n    // if no extensions are allowed or there is no extension, remove it\n    if (noExtensions || targetItem.extension.length === 0)\n      delete targetItem.extension;\n\n    this.copyFields(item, targetItem, this.itemLevelIgnoredFields);\n    return targetItem\n  };\n\n\n  /**\n   * Process the LForms questionCardinality and answerCardinality into FHIR.\n   * @param targetItem an item in Questionnaire\n   * @param item a LForms item\n   */\n  self._processQuestionAndAnswerCardinality = function(targetItem, item) {\n    var maxOccurs = 0;\n\n    var qCard = item.questionCardinality, aCard = item.answerCardinality;\n    var qCardMax = (qCard && qCard.max !== undefined) ? qCard.max : null;\n    var aCardMax = (aCard && aCard.max !== undefined) ? aCard.max : null;\n\n    // unlimited repeats, no need to set maxOccurs\n    if (qCardMax === \"*\" || aCardMax === \"*\") {\n      if (item.dataType !== \"TITLE\") {\n        targetItem.repeats = true;\n      }\n    }\n    // not unlimited repeats\n    else {\n      var intQCardMax = parseInt(qCardMax), intACardMax = parseInt(aCardMax);\n      // has a maxOcurrs value\n      if(intQCardMax > 1 || intACardMax > 1) {\n        if (item.dataType !== \"TITLE\") {\n          targetItem.repeats = true;\n\n          // get the maxOccurs value\n          if (!isNaN(intQCardMax) && !isNaN(intACardMax)) {\n            maxOccurs = Math.max(intQCardMax, intACardMax);\n          }\n          else if (!isNaN(intQCardMax)) {\n            maxOccurs = intQCardMax;\n          }\n          else if (!isNaN(intACardMax)) {\n            maxOccurs = intACardMax\n          }\n\n          if (maxOccurs > 1) {\n            targetItem.extension.push({\n              \"url\": self.fhirExtUrlCardinalityMax,\n              \"valueInteger\": maxOccurs\n            });\n          }\n        }\n      }\n    }\n\n  };\n\n\n  /**\n   * Process an item's externally defined answer list\n   * @param targetItem an item in FHIR SDC Questionnaire object\n   * @param item an item in the LForms form object\n   * @returns {*}\n   * @private\n   */\n  self._handleExternallyDefined = function(targetItem, item) {\n    if (item.externallyDefined) {\n      targetItem.extension.push({\n        \"url\": \"http://hl7.org/fhir/StructureDefinition/questionnaire-externallydefined\",\n        \"valueUri\": item.externallyDefined\n      });\n    }\n  };\n\n\n  /**\n   * Process an item's data control\n   * @param targetItem an item in FHIR SDC Questionnaire object\n   * @param item an item in the LForms form object\n   * @returns {*}\n   * @private\n   */\n  self._handleDataControl = function(targetItem, item) {\n    if (item.dataControl) {\n      targetItem.extension.push({\n        \"url\": \"http://lhcforms.nlm.nih.gov/fhirExt/dataControl\",\n        \"valueString\": JSON.stringify(item.dataControl)\n      })\n    }\n  };\n\n\n  /**\n   * Remove repeating items in a form data object\n   * @param source a LForms form data object\n   * @private\n   */\n  self._removeRepeatingItems = function(source) {\n\n    if (source.items && Array.isArray(source.items)) {\n      for (var i= source.items.length-1; i>=0; i--) {\n        // if it is a repeating item, whose _id is not 1\n        if (source.items[i]._id > 1) {\n          source.items.splice(i,1);\n        }\n        else {\n          this._removeRepeatingItems(source.items[i]);\n        }\n      }\n    }\n  };\n\n\n  /**\n   * Set form level attributes\n   * @param target a Questionnaire object\n   * @param source a LForms form object\n   * @param noExtensions  a flag that a standard FHIR Questionnaire is to be created without any extensions.\n   *        The default is false.\n   * @private\n   */\n  self._setFormLevelFields = function(target, source, noExtensions) {\n    this.copyFields(source, target, this.formLevelFields);\n    // Handle title and name.  In LForms, \"name\" is the \"title\", but FHIR\n    // defines both.\n    target.name = source.shortName; // computer friendly\n    target.title = source.name;\n\n    // Handle extensions on title\n    if (source.obj_title)\n      target._title = source.obj_title;\n\n    target.code = source.codeList;\n\n    // resourceType\n    target.resourceType = \"Questionnaire\";\n    target.status = target.status ? target.status : \"draft\";\n\n    // meta\n    var profile = noExtensions ? this.stdQProfile : this.QProfile;\n\n    target.meta = target.meta ? target.meta : {};\n    target.meta.profile = target.meta.profile ? target.meta.profile : [profile];\n  };\n\n\n  /**\n   * Process itemControl based on LForms item's answerLayout and questionLayout\n   * @param targetItem an item in FHIR SDC Questionnaire object\n   * @param item an item in LForms form object\n   * @private\n   */\n  self._handleItemControl = function(targetItem, item) {\n    // http://hl7.org/fhir/StructureDefinition/questionnaire-itemControl\n    var itemControlType = \"\";\n    var itemControlDisplay, answerChoiceOrientation;\n    // Fly-over, Table, Checkbox, Combo-box, Lookup\n    if (!jQuery.isEmptyObject(item.displayControl)) {\n      var dataType = this._getAssumedDataTypeForExport(item);\n      // for answers\n      if (item.displayControl.answerLayout &&\n        (dataType === \"CNE\" || dataType === \"CWE\")) {\n        // search field\n        if (item.externallyDefined || (item.answerValueSet && item.isSearchAutocomplete)) {\n          itemControlType = \"autocomplete\";\n          itemControlDisplay = \"Auto-complete\";\n        }\n        // prefetch list\n        // combo-box\n        else if (item.displayControl.answerLayout.type === \"COMBO_BOX\") {\n          itemControlType = \"drop-down\";\n          itemControlDisplay = \"Drop down\";\n        }\n        // radio or checkbox\n        else if (item.displayControl.answerLayout.type === \"RADIO_CHECKBOX\") {\n          if (item.answerCardinality &&\n            (item.answerCardinality.max === \"*\" || parseInt(item.answerCardinality.max) > 1)) {\n            itemControlType = \"check-box\";\n            itemControlDisplay = \"Check-box\";\n          }\n          else {\n            itemControlType = \"radio-button\";\n            itemControlDisplay = \"Radio Button\";\n          }\n          // answer choice orientation\n          if (item.displayControl.answerLayout.columns === \"0\") {\n            answerChoiceOrientation = \"horizontal\";\n          }\n          else if (item.displayControl.answerLayout.columns === \"1\") {\n            answerChoiceOrientation = \"vertical\";\n          }\n\n        }\n      }\n      // for section item\n      else if (item.displayControl.questionLayout && dataType === \"SECTION\") {\n        if (item.displayControl.questionLayout === \"horizontal\") {\n          itemControlType = \"gtable\"; // Not in STU3, but the binding is extensible, so we can use it\n          itemControlDisplay = \"Group Table\";\n        }\n        else if (item.displayControl.questionLayout === \"matrix\") {\n          itemControlType = \"table\";\n          itemControlDisplay = \"Vertical Answer Table\";\n        }\n        // else {\n        //   itemControlType = \"List\";\n        // }\n      }\n\n      if (itemControlType) {\n        targetItem.extension.push(\n          {\n            \"url\": \"http://hl7.org/fhir/StructureDefinition/questionnaire-itemControl\",\n            \"valueCodeableConcept\": {\n              \"coding\": [{\n                //\"system\" : \"<uri>\", // Identity of the terminology system\n                //\"version\" : \"<string>\", // Version of the system - if relevant\n                //\"code\" : \"<code>\", // Symbol in syntax defined by the system\n                //\"display\" : \"<string>\", // Representation defined by the system\n                //\"userSelected\" : <boolean> // If this coding was chosen directly by the user\n                \"system\": \"http://hl7.org/fhir/questionnaire-item-control\",\n                \"code\": itemControlType,\n                \"display\": itemControlDisplay\n              }],\n              \"text\": itemControlDisplay || itemControlType\n            }\n          });\n        // answer choice orientation\n        if (answerChoiceOrientation) {\n          targetItem.extension.push(\n            {\n              \"url\": \"http://hl7.org/fhir/StructureDefinition/questionnaire-choiceOrientation\",\n              \"valueCode\": answerChoiceOrientation\n            });\n        }\n      }\n    }\n  };\n\n\n  /**\n   * Process an item's terminology server setting.\n   * @param targetItem a QuestionnaireResponse object\n   * @param item an item in the LForms form object\n   * @returns {*}\n   * @private\n   */\n  self._handleTerminologyServer = function(targetItem, item) {\n    if (item.terminologyServer) {\n      targetItem.extension.push({\n        \"url\": self.fhirExtTerminologyServer,\n        \"valueUrl\": item.terminologyServer\n      });\n    }\n  };\n\n\n\n  /**\n   * Convert LForms data type to FHIR SDC data type\n   * @param item an item in the LForms form object\n   * @returns {string}\n   * @private\n   */\n  self._getFhirDataType = function(item) {\n\n    var dataType = this._getAssumedDataTypeForExport(item);\n    var type = this._lformsTypesToFHIRTypes[dataType];\n    // default is string\n    if (!type) {\n      type = 'string';\n    }\n    return type;\n  };\n\n\n  /**\n   * Determine how an item's data type should be for export.\n\n   If number type has multiple units, change it to quantity type. In such a case,\n   multiple units are converted to quesionnaire-unitOption extension and the default unit\n   would go into initial.valueQuantity.unit.\n   For single unit numbers, use the same type, whose unit will be in questionnaire-unit extension.\n\n   * @param item an item in the LForms form object\n   * @returns {string} dataType - Data type in lforms\n   * @private\n   */\n  self._getAssumedDataTypeForExport = function (item) {\n    var dataType = item.dataType;\n    if((item.dataType === 'REAL' || item.dataType === 'INT') && item.units && item.units.length > 1) {\n      dataType = 'QTY';\n    }\n    return dataType;\n  };\n\n\n  /**\n   * Make a FHIR Quantity for the given value and unit info.\n   * @param value optional, must be an integer or decimal\n   * @param itemUnit optional, lform data item.unit (that has a name property)\n   * @param unitSystem optional, overrides any system in itemUnit.\n   * @return a FHIR quantity or null IFF the given value is not a number (parseFloat() returns NaN).\n   * @private\n   */\n  self._makeValueQuantity = function(value, itemUnit, unitSystem) {\n    let fhirQuantity = {};\n    let floatValue = parseFloat(value);\n\n    if(! isNaN(floatValue)) {\n      fhirQuantity.value = floatValue;\n    }\n\n    if(itemUnit) {\n      self._setUnitAttributesToFhirQuantity(fhirQuantity, itemUnit);\n      if(unitSystem) {\n        fhirQuantity.system = unitSystem;\n      }\n    }\n\n    return (Object.keys(fhirQuantity).length > 0) ? fhirQuantity : null;\n  };\n\n\n  /**\n   * Make a FHIR Quantity for the given value and unit info.\n   * @param value required, must be an integer or decimal\n   * @param itemUnits optional, lform data item.units (An array of units)\n   * @param unitSystem optional.\n   * @return a FHIR quantity or null IFF the given value is not a number (parseFloat() returns NaN).\n   * @private\n   */\n  self._makeQuantity = function(value, itemUnits, unitSystem) {\n    var defaultUnit = this._getDefaultUnit(itemUnits);\n    return this._makeValueQuantity(value, defaultUnit, unitSystem);\n  };\n\n\n  /**\n   * Pick a default unit if found, otherwise return first one as default. Will return\n   * null, if passed with empty list.\n   * @param lformsUnits - Array of lforms units i.e with {name, default}\n   * @returns {*} Return lforms unit if found otherwise null.\n   * @private\n   */\n  self._getDefaultUnit = function (lformsUnits) {\n    if(!lformsUnits || lformsUnits.length === 0) {\n      return null;\n    }\n\n    var ret = null;\n    for(var i = 0; i < lformsUnits.length; i++) {\n      if (lformsUnits[i].default) {\n        ret = lformsUnits[i];\n        break;\n      }\n    }\n\n    if(!ret) {\n      ret = lformsUnits[0];\n    }\n\n    return ret;\n  };\n\n\n  /**\n   * Create a key from data type to be used in a hash\n   * @param prefix a prefix to be added to the key\n   * @param item a LForms item\n   * @returns {*}\n   * @private\n   */\n  self._getValueKeyByDataType = function(prefix, item) {\n\n    // prefix could be 'value', 'initial', 'answer'\n    if (!prefix) {\n      prefix = \"value\"\n    }\n\n    var fhirType = this._getFhirDataType(item);\n    var dataType = fhirType === 'quantity' ? 'QTY' : item.dataType;\n    var valueKey = this._lformsTypesToFHIRFields[dataType];\n\n    return prefix + valueKey;\n  };\n\n\n  /**\n   * Convert the minInclusive/minExclusive, maxInclusive/maxExclusive to FHIR. See the\n   * the function _handleRestrictions() in sdc-export.js for more details on the context.\n   * @param dataType Lforms data type, currently supporting DT, DTM, TM, REAL, and INT.\n   * @param value the value (in the lforms system, either a number or a string).\n   * @param valueKey the valueKey in FHIR minValue/maxValue extension (e.g., valueInteger)\n   * @param minMaxKey must be one of minInclusive, minExclusive, maxInclusive, maxExclusive\n   * @return The FHIR extension element. Specifically, undefined is returned if:\n   *         - the given value is null or undefined, or\n   *         - the dataType is not one of those listed above, or\n   *         - the minMaxKey is not one of those listed above\n   * @private\n   */\n  self._MIN_MAX_TYPES = ['DT', 'DTM', 'TM', 'REAL', 'INT']\n    .reduce((map, t) => {map[t] = t; return map;}, {});\n  self._MIN_MAX_KEYS = ['minExclusive', 'minInclusive', 'maxExclusive', 'maxInclusive']\n    .reduce((map, t) => {map[t] = t; return map;}, {});\n\n  self._exportMinMax = function(dataType, value, valueKey, minMaxKey) {\n    if(value === null || value === undefined\n      || ! self._MIN_MAX_TYPES[dataType] || ! self._MIN_MAX_KEYS[minMaxKey]) {\n      return undefined;\n    }\n\n    var isoDateStr = (dataType === \"DT\" || dataType === \"DTM\")? new Date(value).toISOString():\n      dataType == \"TM\"? new Date('1970-01-01T' + value + 'Z').toISOString(): null;\n\n    var fhirValue =\n      dataType === \"DT\"? isoDateStr.substring(0, 10):\n      dataType === \"DTM\"? isoDateStr:\n      dataType === \"TM\"? isoDateStr.substring(11, isoDateStr.length-1):\n      dataType === \"REAL\"? parseFloat(value): parseInt(value);\n\n    var fhirExtUrl = minMaxKey.indexOf('min') === 0?\n      'http://hl7.org/fhir/StructureDefinition/minValue':\n      'http://hl7.org/fhir/StructureDefinition/maxValue';\n\n    return {\n      url: fhirExtUrl,\n      [valueKey]: fhirValue\n    };\n  };\n\n\n  // known source data types (besides CNE/CWE) in skip logic export handling,\n  // see _createEnableWhenRulesForSkipLogicCondition below\n  self._skipLogicValueDataTypes = [\"BL\", \"REAL\", \"INT\", 'QTY', \"DT\", \"DTM\", \"TM\", \"ST\", \"TX\", \"URL\"]\n    .reduce((map, type) => {map[type] = type; return map;}, {});\n\n\n  /**\n   * @param skipLogicCondition - Lforms skip logic condition object\n   * @param sourceItem - Skip logic source item in lforms.\n   * @return {Array} FHIR enableWhen array\n   * @private\n   */\n  self._createEnableWhenRulesForSkipLogicCondition = function (skipLogicCondition, sourceItem) {\n    // dataTypes:\n    // boolean, decimal, integer, date, dateTime, instant, time, string, uri,\n    // Attachment, Coding, Quantity, Reference(Resource)\n    let sourceDataType = this._getAssumedDataTypeForExport(sourceItem);\n    let sourceValueKey = this._getValueKeyByDataType(\"answer\", sourceItem);\n    let enableWhenRules = [];\n\n    // Per lforms spec, the trigger keys can be:\n    // exists, value, minExclusive, minInclusive, maxExclusive, maxInclusive\n    Object.keys(skipLogicCondition.trigger).forEach(function(key) {\n      let operator = self._operatorMapping[key];\n      let triggerValue = skipLogicCondition.trigger[key];\n      if(! operator || triggerValue !== 0 && triggerValue !== false && ! triggerValue) {\n        throw new Error('Invalid lforms skip logic trigger: ' + JSON.stringify(skipLogicCondition.trigger, null, 4));\n      }\n\n      let rule = null;\n      if (operator === 'exists') {\n        rule = { answerBoolean: triggerValue };\n      }\n      // for Coding\n      // multiple selections, item.value is an array\n      // NO support of multiple selections in FHIR SDC, just pick one\n      else if ( sourceDataType === 'CWE' || sourceDataType === 'CNE' ) {\n        let answerCoding = self._copyTriggerCoding(triggerValue, null, true);\n        if (! answerCoding) {\n          throw new Error('Invalid CNE/CWE trigger, key=' + key + '; value=' + triggerValue);\n        }\n        rule = { answerCoding: answerCoding };\n      }\n      else if (sourceDataType && self._skipLogicValueDataTypes[sourceDataType]) {\n        let answer = triggerValue;\n        if(sourceValueKey === 'answerQuantity') {\n          answer = self._makeQuantity(answer, sourceItem.units);\n        }\n        if(answer === 0 || answer === false || answer) {\n          rule = { [sourceValueKey]: answer };\n        }\n        else {\n          throw new Error('Invalid value for trigger ' + key + ': ' + triggerValue);\n        }\n      }\n      else {\n        throw new Error('Unsupported data type for skip logic export: ' + sourceDataType);\n      }\n\n      rule.question = sourceItem.linkId;\n      rule.operator = operator;\n      enableWhenRules.push(rule);\n    });\n\n    return enableWhenRules;\n  };\n\n\n  /**\n   * Set form level attribute\n   * @param target a QuestionnaireResponse object\n   * @param noExtensions  a flag that a standard FHIR Questionnaire is to be created without any extensions.\n   *        The default is false.\n   * @param source a LForms form object\n\n   * @private\n   */\n  self._setResponseFormLevelFields = function(target, source, noExtensions) {\n\n    // resourceType\n    target.resourceType = \"QuestionnaireResponse\";\n\n    // meta\n    var profile = noExtensions ? this.stdQRProfile : this.QRProfile;\n    target.meta = target.meta ? target.meta : {};\n    target.meta.profile = target.meta.profile ? target.meta.profile : [profile];\n\n    // \"identifier\": - not including identifier in QuestionnaireResponse per LF-1183\n    //target.identifier = {\n    //  \"system\": LForms.Util.getCodeSystem(source.codeSystem),\n    //  \"value\": source.code\n    //};\n\n    // status, required\n    // \"in-progress\", \"completed\", \"amended\"\n    target.status = \"completed\";\n\n    // authored, required\n    target.authored = LForms.Util.dateToDTMString(new Date());\n\n    // questionnaire , required\n    // We do not have the ID at this point, so leave it unset for now.  Note\n    // that the fomat has also changed from Reference to canonical in R4.\n    /*\n    target.questionnaire = {\n      // questionnaireId should be an id of a related existing questionnaire resource stored in the server\n      \"reference\": \"Questionnaire/{{questionnaireId}}\"\n    };\n    */\n  };\n\n\n  /**\n   * Set unit attributes to a given FHIR quantity.\n   *\n   * @param fhirQuantity - FHIR Quantity object\n   * @param lfUnit - Lforms unit, which includes name, code and system.\n   * @private\n   */\n  self._setUnitAttributesToFhirQuantity = function(fhirQuantity, lfUnit) {\n    if(fhirQuantity && lfUnit) {\n      if(lfUnit.name) {\n        fhirQuantity.unit = lfUnit.name;\n      }\n\n      if(lfUnit.code) {\n        fhirQuantity.code = lfUnit.code;\n      }\n\n      // Unit system is optional. It was using a default system before,\n      // Now we have an defined system field, read it from data and\n      // not assume a default.\n      if(lfUnit.system) {\n        fhirQuantity.system = lfUnit.system;\n      }\n    }\n  };\n\n\n  /**\n   * Create a FHIR coding object for a unit.\n   *\n   * @param lfUnit - Lforms unit, which includes name, code and system.\n   * @returns FHIR coding object\n   * @private\n   */\n  self._createFhirUnitCoding = function(lfUnit) {\n    var ret = null;\n    if(lfUnit) {\n      ret = {};\n      if(lfUnit.code) {\n        ret.code = lfUnit.code;\n      }\n      if(lfUnit.name) {\n        ret.display = lfUnit.name;\n      }\n      if(lfUnit.system) {\n        ret.system = lfUnit.system;\n      }\n    }\n    return ret;\n  };\n\n\n  /**\n   * Converting the given item's value to FHIR QuestionaireResponse.answer (an array).\n   * This is almost straightly refactored out of the original function self._handleAnswerValues.\n   * This function only looks at the item value itself and not its sub-items, if any.\n   * Here are the details for a single value's conversion (to an element in the returned answer array)\n   * - For item data type quantity (QTY), a valueQuantity answer element will be created IF\n   *   either (or both) item value or item unit is available.\n   * - For item data types boolean, decimal, integer, date, dateTime, instant, time, string, attachment, and url,\n   *   it will be converted to a FHIR value{TYPE} entry if the value is not null, not undefined, and not\n   *   an empty string.\n   * - For CNE and CWE, a valueCoding entry is created IF at least one of the item value's code, text, or system\n   *   is available\n   * - No answer entry will be created in all other cases, e.g., for types reference, title, section, etc.\n   * @param item the item whose value is to be converted\n   * @return the converted FHIR QuestionnaireResponse answer (an array), or null if the value is not converted -\n   *         see the function description above for more details.\n   * @private\n   */\n  self._lfItemValueToFhirAnswer = function(item) {\n\n    // item could have an empty value if its sub-item has a value\n    if (item.value === undefined || item.value === null || item.value === '')\n       return null;\n\n    var dataType = this._getAssumedDataTypeForExport(item);\n    var values = this._answerRepeats(item)? item.value: [item.value];\n    var answers = [];\n    for(var i=0; i < values.length; ++i) {\n      var itemValue = values[i];\n      if(itemValue !== undefined && itemValue !== null && itemValue !== '') {\n        var answer = null;\n        // for Coding\n        if (dataType === 'CWE' || dataType === 'CNE') {\n          // for CWE, the value could be string if it is a user typed, not-on-list value\n          if (dataType === 'CWE' && typeof itemValue === 'string') {\n            answer = { \"valueString\" : itemValue };\n          }\n          else if (!jQuery.isEmptyObject(itemValue)) {\n            var answerCoding = this._setIfHasValue(null, 'system', LForms.Util.getCodeSystem(itemValue.system));\n            answerCoding = this._setIfHasValue(answerCoding, 'code', itemValue.code);\n            answerCoding = this._setIfHasValue(answerCoding, 'display', itemValue.text);\n            answer = this._setIfHasValue(null, 'valueCoding', answerCoding);\n          }\n        }\n        // for Quantity\n        else if (dataType === \"QTY\") {\n          // For now, handling only simple quantities without the comparators.\n          // [{\n          //   // from Element: extension\n          //   \"value\" : <decimal>, // Numerical value (with implicit precision)\n          //   \"comparator\" : \"<code>\", // < | <= | >= | > - how to understand the value\n          //   \"unit\" : \"<string>\", // Unit representation\n          //   \"system\" : \"<uri>\", // Code System that defines coded unit form\n          //   \"code\" : \"<code>\" // Coded form of the unit\n          // }]\n          answer = this._setIfHasValue(null, 'valueQuantity', this._makeValueQuantity(itemValue, item.unit));\n        }\n        // for boolean, decimal, integer, date, dateTime, instant, time, string, uri, attachment\n        else if (this._lformsTypesToFHIRFields[dataType]) {\n          var valueKey = this._getValueKeyByDataType(\"value\", item);\n          answer = {[valueKey]: itemValue};\n        }\n        if(answer !== null) {\n          answers.push(answer);\n        }\n      }\n    }\n\n    return answers.length === 0? null: answers;\n  };\n\n\n  /**\n   * Check if an lform item has sub-items, that is, having an \"items\" field whose value is an array with non-zero length.\n   * @param item the item to be checked for the presense of sub-items.\n   * @return {*|boolean} true if the item has sub-items, false otherwise.\n   * @private\n   */\n  self._lfHasSubItems = function(item) {\n    return item && item.items && Array.isArray(item.items) && item.items.length > 0;\n  };\n\n\n  /**\n   * Process an item of the form or the form itself - if it's the form itself, the form-level\n   * properties will not be set here and will need to be managed outside of this function.\n   * If the lforms item is repeatable, this function handles one particular occurrence of the item.\n   * @param lfItem an item in LForms form object, or the form object itself\n   * @param isForm optional, default false. If true, the given item is the form object itself.\n   * @returns {{}} the converted FHIR item\n   * @private\n   */\n  self._processResponseItem = function(lfItem, isForm) {\n    if(isForm && (typeof isForm) !== 'boolean') { // just in case some are invoking it the old way.\n      throw new Error('_processResponseItem function signature has been changed, please check/fix.');\n    }\n    var targetItem = (isForm || lfItem.dataType === 'TITLE')? {}: {\n        linkId: lfItem.linkId,\n        text: lfItem.question\n      };\n\n    // just handle/convert the current item's value, no-recursion to sub-items at this step.\n    if (!isForm && lfItem.dataType !== 'TITLE' && lfItem.dataType !== 'SECTION') {\n      this._setIfHasValue(targetItem, 'answer', this._lfItemValueToFhirAnswer(lfItem));\n    }\n\n    if(this._lfHasSubItems(lfItem)) {\n      var fhirItems = [];\n      for (var i=0; i < lfItem.items.length; ++i) {\n        var lfSubItem = lfItem.items[i];\n        if(! lfSubItem._isProcessed) {\n          var linkId = lfSubItem.linkId;\n          var repeats = lfItem._repeatingItems && lfItem._repeatingItems[linkId];\n          if(repeats) {      // Can only be questions here per _processRepeatingItemValues\n            let fhirItem = { // one FHIR item for all repeats with the same linkId\n              linkId: linkId,\n              text: lfSubItem.question,\n              answer: []\n            };\n            for(var rpt=0; rpt < repeats.length; ++rpt) {\n              var rptItem = repeats[rpt];\n              var tmpFhirItem = this._processResponseItem(rptItem);\n              if(tmpFhirItem.answer) {\n                // TODO: not sure how to handle cases when both (lforms) question and answer repeat.\n                // For now, just put all the answers from question and answer repeats into the answer (array).\n                Array.prototype.push.apply(fhirItem.answer, tmpFhirItem.answer);\n              }\n              rptItem._isProcessed = true;\n            }\n            fhirItems.push(fhirItem);\n            delete lfItem._repeatingItems[linkId]; // cleanup, no longer needed\n          }\n          else {\n            let fhirItem = this._processResponseItem(lfSubItem);\n            fhirItems.push(fhirItem);\n          }\n        }\n\n        if(lfSubItem._isProcessed) {\n          delete lfSubItem._isProcessed; // cleanup, no longer needed\n        }\n      }\n\n      if(fhirItems.length > 0) {\n        if(! isForm && lfItem.dataType !== 'SECTION') {\n          // Question repeat is handled at the \"parent level\"; TODO: not sure how to handle answer repeat here,\n          // assuming it isn't possible for an item to have answer repeat and sub-items at the same time.\n          targetItem.answer = targetItem.answer || [];\n          targetItem.answer[0] = targetItem.answer[0] || {};\n          targetItem.answer[0].item = fhirItems;\n        }\n        else {\n          targetItem.item = fhirItems;\n        }\n      }\n    }\n\n    return targetItem;\n  };\n\n\n  /**\n   * Group values of the questions that have the same linkId\n   * @param item an item in the LForms form object or a form item object\n   * @private\n   *\n   */\n  self._processRepeatingItemValues = function(item) {\n    if (item.items) {\n      for (var i=0, iLen=item.items.length; i<iLen; i++) {\n        var subItem = item.items[i];\n        // if it is a question and it repeats\n        if (subItem.dataType !== 'TITLE' && subItem.dataType !== 'SECTION' && this._questionRepeats(subItem)) {\n          var linkId = subItem.linkId;\n          item._repeatingItems = item._repeatingItems || {};\n          item._repeatingItems[linkId] = item._repeatingItems[linkId] || [];\n          item._repeatingItems[linkId].push(subItem);\n        }\n        // if it's a section or a question that has children items\n        if(this._lfHasSubItems(subItem)) {\n          this._processRepeatingItemValues(subItem);\n        }\n      }\n    }\n  };\n\n\n  /**\n   * Get the extract value for the item or the closest parent\n   * @param item an item in Questionnaire\n   */\n  self._getExtractValue = function (item) {\n    let currentItem = item;\n\n    while (true) {\n      if (currentItem._fhirExt && currentItem._fhirExt[this.fhirExtObsExtract]) {\n        return currentItem._fhirExt[this.fhirExtObsExtract][0].valueBoolean;\n      } else if (!currentItem._parentItem) {\n        return false;\n      }\n      currentItem = currentItem._parentItem;\n    }\n  };\n\n\n  /**\n   * Check if the item has a value\n   * @param {*} item  an item in lforms with attritues set by lforms\n   * @returns {boolean}\n   */\n  self._hasItemValue = function (item) {\n    // not a group item, or a display item\n    // not hidden by skip logic \n    // has values\n    return item.dataType!==\"SECTION\" && item.dataType!==\"TITLE\" &&\n           item._skipLogicStatus!== \"target-disabled\" &&\n           !LForms.Util.isItemValueEmpty(item.value) ? true : false;\n  };\n\n  \n}\n\nexport default addCommonSDCExportFns;\n","/**\n * A package to handle conversion from FHIR SDC (STU2) Questionnaire to LForms\n * STU2 Ballot:\n * http://hl7.org/fhir/us/sdc/sdc-questionnaire.html\n * http://hl7.org/fhir/us/sdc/sdc-questionnaireresponse.html\n *\n * It provides the following functions:\n * convertQuestionnaireToLForms()\n * -- Convert FHIR SDC QuestionnaireResponse data into corresponding LForms data\n * mergeQuestionnaireResponseToLForms()  (defined in sdc-import-common.js)\n * -- Merge FHIR SDC QuestionnaireResponse data into corresponding LForms data\n */\nfunction addSDCImportFns(ns) {\n\"use strict\";\n\n  var self = ns;\n\n  self.fhirExtUrlOptionScore = \"http://hl7.org/fhir/StructureDefinition/questionnaire-ordinalValue\";\n  self.fhirExtUrlValueSetScore = \"http://hl7.org/fhir/StructureDefinition/valueset-ordinalValue\";\n\n\n  /**\n   * Extract contained VS (if any) from the given questionnaire resource object.\n   * @param questionnaire the FHIR questionnaire resource object\n   * @return when there are contained value sets, returns a hash from \"#<ValueSet.id>\" (the character \"#\"\n   *         followed by the ValueSet id) to the answers options object, which, in turn, is a hash with 4 entries:\n   *         - \"answers\" is the list of LF answers converted from the value set.\n   *         - \"systems\" is the list of code systems for each answer item; and\n   *         returns undefined if no contained value set is present.\n   * @private\n   */\n  self._extractContainedVS = function (questionnaire) {\n    var answersVS;\n\n    if(questionnaire.contained && questionnaire.contained.length > 0) {\n      answersVS = {};\n      questionnaire.contained.forEach(function(vs) {\n        if(vs.resourceType === 'ValueSet' && vs.expansion && vs.expansion.contains && vs.expansion.contains.length > 0) {\n          var answers = self.answersFromVS(vs);\n          if (!answers)\n            answers = []; // continuing with previous default; not sure if needed\n\n          // support both id and url based lookup. STU3 reference is quite vague.\n          var lfVS = {answers: answers};\n          if(vs.id) {\n            answersVS['#' + vs.id] = lfVS;\n          }\n          if(vs.url) {\n            answersVS[vs.url] = lfVS;\n          }\n        }\n      });\n    }\n\n    return answersVS;\n  };\n\n  /**\n   * Process questionnaire item recursively\n   *\n   * @param qItem - item object as defined in FHIR Questionnaire.\n   * @param linkIdItemMap - Map of items from link ID to item from the imported resource.\n   * @param containedVS - contained ValueSet info, see _extractContainedVS() for data format details\n   * @returns {{}} - Converted 'item' field object as defined by LForms definition.\n   * @private\n   */\n  self._processQuestionnaireItem = function (qItem, containedVS, linkIdItemMap) {\n\n    var targetItem = {};\n    //A lot of parsing depends on data type. Extract it first.\n    self._processDataType(targetItem, qItem);\n    self._processTextAndPrefix(targetItem, qItem);\n    self._processCodeAndLinkId(targetItem, qItem);\n    _processDisplayItemCode(targetItem, qItem);\n    _processEditable(targetItem, qItem);\n    self._processFHIRQuestionAndAnswerCardinality(targetItem, qItem);\n    self._processDisplayControl(targetItem, qItem);\n    self._processDataControl(targetItem, qItem);\n    self._processRestrictions(targetItem, qItem);\n    self._processHiddenItem(targetItem, qItem);\n    self._processUnitList(targetItem, qItem);\n    _processAnswers(targetItem, qItem, containedVS);\n    self._processDefaultAnswer(targetItem, qItem);\n    _processExternallyDefined(targetItem, qItem);\n    self._processTerminologyServer(targetItem, qItem);\n    _processSkipLogic(targetItem, qItem, linkIdItemMap);\n    self._processExtensions(targetItem, qItem);\n    self._processChildItems(targetItem, qItem, containedVS, linkIdItemMap);\n\n    return targetItem;\n  };\n\n\n  /**\n   * Parse questionnaire object for answer cardinality\n   *\n   * @param lfItem {object} - LForms item object to assign answer cardinality\n   * @param qItem {object} - Questionnaire item object\n   * @private\n   */\n  function _processAnswerCardinality(lfItem, qItem) {\n    if(qItem.required) {\n      lfItem.answerCardinality = {min: '1'};\n    }\n    else {\n      lfItem.answerCardinality = {min: '0'};\n    }\n\n    var answerRepeats = LForms.Util.findObjectInArray(qItem.extension, 'url', self.fhirExtUrlAnswerRepeats);\n    if(answerRepeats && answerRepeats.valueBoolean) {\n      lfItem.answerCardinality.max = '*';\n    }\n    else {\n      lfItem.answerCardinality.max = '1';\n    }\n  }\n\n\n  /**\n   * Parse questionnaire object for skip logic information\n   *\n   * @param lfItem {object} - LForms item object to assign the skip logic\n   * @param qItem {object} - Questionnaire item object\n   * @param sourceQuestionnaire - Questionnaire resource object. This is to provide top level\n   *                              item to navigate the tree for skip logic source items.\n   * @private\n   */\n  function _processSkipLogic(lfItem, qItem, linkIdItemMap) {\n    if(qItem.enableWhen) {\n      lfItem.skipLogic = {conditions: [], action: 'show'};\n      for(var i = 0; i < qItem.enableWhen.length; i++) {\n\n        var dataType = self._getDataType(linkIdItemMap[qItem.enableWhen[i].question]);\n        var condition = {source: qItem.enableWhen[i].question};\n        if(qItem.enableWhen[i].hasOwnProperty('hasAnswer')) {\n          condition.trigger = {exists: qItem.enableWhen[i].hasAnswer};\n        }\n        else {\n          var answer = self._getFHIRValueWithPrefixKey(qItem.enableWhen[i], /^answer/);\n          if(dataType === 'CWE' || dataType === 'CNE') {\n            condition.trigger = {value: self._copyTriggerCoding(answer, null, false)};\n          }\n          else if(dataType === 'QTY') {\n            condition.trigger = {value: answer.value};\n          }\n          else {\n            condition.trigger = {value: answer};\n          }\n        }\n        lfItem.skipLogic.conditions.push(condition);\n      }\n    }\n  }\n\n\n  /**\n   * Parse Questionnaire item for externallyDefined url\n   *\n   * @param lfItem - LForms item object to assign externallyDefined\n   * @param qItem - Questionnaire item object\n   * @private\n   */\n  function _processExternallyDefined(lfItem, qItem) {\n    var externallyDefined = LForms.Util.findObjectInArray(qItem.extension, 'url', self.fhirExtUrlExternallyDefined);\n    if (externallyDefined && externallyDefined.valueUri) {\n      lfItem.externallyDefined = externallyDefined.valueUri;\n    }\n  }\n\n\n  /**\n   * Parse questionnaire item for \"hidden\" extension\n   *\n   * @param lfItem {object} - LForms item object to be assigned the _isHiddenInDef flag if the item is to be hidden.\n   * @param qItem {object} - Questionnaire item object\n   * @private\n   * @return true if the item is hidden or if its ancestor is hidden, false otherwise\n   */\n  self._processHiddenItem = function (lfItem, qItem) {\n    var ci = LForms.Util.findObjectInArray(qItem.extension, 'url', self.fhirExtUrlHidden);\n    if(ci) {\n      lfItem._isHiddenInDef = typeof ci.valueBoolean === 'boolean'? ci.valueBoolean: ci.valueBoolean === 'true';\n    }\n    return lfItem._isHiddenInDef;\n  };\n\n\n  /**\n   * Parse questionnaire item for answers list\n   *\n   * @param lfItem {object} - LForms item object to assign answer list\n   * @param qItem {object} - Questionnaire item object\n   * @param containedVS - contained ValueSet info, see _extractContainedVS() for data format details\n   * @private\n   */\n  function _processAnswers(lfItem, qItem, containedVS) {\n    if(qItem.option) {\n      lfItem.answers = [];\n      for(var i = 0; i < qItem.option.length; i++) {\n        var answer = {};\n        var option = qItem.option[i];\n        var label = LForms.Util.findObjectInArray(option.extension, 'url', self.fhirExtUrlOptionPrefix);\n        if(label) {\n          answer.label = label.valueString;\n        }\n        var score = LForms.Util.findObjectInArray(option.extension, 'url', self.fhirExtUrlOptionScore);\n        // Look for argonaut extension.\n        score = !score ? LForms.Util.findObjectInArray(option.extension, 'url', self.argonautExtUrlExtensionScore) : score;\n        if(score) {\n          answer.score = score.valueDecimal.toString();\n        }\n        var optionKey = Object.keys(option).filter(function(key) {return (key.indexOf('value') === 0);});\n        if(optionKey && optionKey.length > 0) {\n          if(optionKey[0] === 'valueCoding') { // Only one value[x] is expected\n            if(option[optionKey[0]].code    !== undefined) answer.code = option[optionKey[0]].code;\n            if(option[optionKey[0]].display !== undefined) answer.text = option[optionKey[0]].display;\n            // TBD- Lforms has answer code system at item level, expects all options to have one code system!\n            if(option[optionKey[0]].system  !== undefined) {\n              answer.system = option[optionKey[0]].system;\n            }\n          }\n          else {\n            answer.text = option[optionKey[0]].toString();\n          }\n        }\n\n        lfItem.answers.push(answer);\n      }\n    }\n    else if (qItem.options) {\n      if (containedVS)\n        var vs = containedVS[qItem.options.reference];\n      if(vs) {\n        lfItem.answers = vs.answers;\n      }\n      else\n        lfItem.answerValueSet = qItem.options.reference;\n    }\n  }\n\n\n\n  /**\n   * Parse questionnaire item for editable\n   *\n   * @param lfItem {object} - LForms item object to assign editable\n   * @param qItem {object} - Questionnaire item object\n   * @private\n   */\n  function _processEditable(lfItem, qItem) {\n    if (qItem.readOnly) {\n      lfItem.editable = '0';\n    }\n  }\n\n\n  /**\n   * Parse questionnaire item for default answer\n   *\n   * @param lfItem {object} - LForms item object to assign default answer\n   * @param qItem {object} - Questionnaire item object\n   * @private\n   */\n  self._processDefaultAnswer = function (lfItem, qItem) {\n\n    var val = LForms.Util.deepCopy(qItem.initialCoding);\n    if (val)\n      val._type = 'Coding';\n    else\n      val = self._getFHIRValueWithPrefixKey(qItem, /^initial/);\n    if (val !== undefined && val !== null) {\n      this._processFHIRValues(lfItem, [val], true);\n    }\n  };\n\n\n  /**\n   *  Returns the first initial quanitity for the given Questionnaire item, or\n   *  null if there isn't one.\n   */\n  self.getFirstInitialQuantity = function(qItem) {\n    return qItem.initialQuantity || null;\n  };\n\n\n  /**\n   * Parse 'linkId' for the LForms questionCode of a 'display' item, which does not have a 'code'\n   *\n   * @param lfItem {object} - LForms item object to assign questionCode\n   * @param qItem {object} - Questionnaire item object\n   * @private\n   */\n  function _processDisplayItemCode(lfItem, qItem) {\n    if (qItem.type === \"display\" && qItem.linkId) {\n      var codes = qItem.linkId.split(\"/\");\n      if (codes && codes[codes.length-1]) {\n        lfItem.questionCode = codes[codes.length-1];\n      }\n    }\n  }\n\n\n  /**\n   * Parse questionnaire item for data type\n   *\n   * @param lfItem {object} - LForms item object to assign data type\n   * @param qItem {object} - Questionnaire item object\n   * @private\n   */\n  self._processDataType = function (lfItem, qItem) {\n    var type = self._getDataType(qItem);\n    if(type === 'SECTION' || type === 'TITLE') {\n      lfItem.header = true;\n    }\n    lfItem.dataType = type;\n  };\n\n\n\n  // QuesitonnaireResponse Import\n  self._mergeQR = {\n\n    /**\n     * Get structure information of a QuestionnaireResponse instance\n     * @param qr a QuestionnaireResponse instance\n     * @returns {{}} a QuestionnaireResponse data structure object\n     * @private\n     */\n    _getQRStructure : function(qr) {\n      var qrInfo = {\n        qrItemsInfo: []\n      };\n      if (qr) {\n        this._checkQRItems(qrInfo, qr);\n      }\n      return qrInfo;\n    },\n\n\n    /**\n     * Get structural info of a QuestionnaireResponse by going though each level of items\n     * @param parentQRItemInfo the structural info of a parent item\n     * @param parentItem a parent item in a QuestionnaireResponse object\n     * @private\n     */\n    _checkQRItems : function(parentQRItemInfo, parentQRItem) {\n\n      var qrItemsInfo = [];\n      var repeatingItemProcessed = {};\n\n      if (parentQRItem && parentQRItem.item) {\n        for (var i=0, iLen=parentQRItem.item.length; i<iLen; i++) {\n          var item = parentQRItem.item[i];\n          var linkId = item.linkId; //code is not necessary included in linkId\n          // first item that has the same code, either repeating or non-repeating\n          if (!repeatingItemProcessed[linkId]) {\n            var repeatingInfo = this._findTotalRepeatingNum(linkId, parentQRItem);\n\n            // create structure info for the item\n            var repeatingItems = repeatingInfo.repeatingItems;\n            for (var j=0, jLen=repeatingItems.length; j<jLen; j++) {\n              var qrItemInfo = {\n                linkId: linkId,\n                item: repeatingItems[j],\n                index: j,\n                total: repeatingInfo.total\n              };\n              // check observation instances in the sub level\n              this._checkQRItems(qrItemInfo, repeatingItems[j]);\n              self._checkQRItemAnswerItems(qrItemInfo, repeatingItems[j]);\n              qrItemsInfo.push(qrItemInfo);\n            }\n            repeatingItemProcessed[linkId] = true;\n          }\n        }\n        parentQRItemInfo.qrItemsInfo = qrItemsInfo;\n      }\n    },\n\n\n    /**\n     * Find the number of the repeating items that have the same code\n     * @param linkId an item's linkId\n     * @param parentQRItem a parent item in a QuestionnaireResponse object\n     * @returns a structural info object for a repeating item\n     * @private\n     */\n    _findTotalRepeatingNum : function(linkId, parentQRItem) {\n\n      var total = 0;\n      var repeatingItems = [];\n      for (var i=0, iLen=parentQRItem.item.length; i<iLen; i++) {\n        var item = parentQRItem.item[i];\n        if (linkId === item.linkId) {\n          repeatingItems.push(item);\n          if (Array.isArray(item.answer)) {\n            total += item.answer.length; // answers for repeating questions and repeating answers\n          }\n          else {\n            total += 1;\n          }\n        }\n      }\n\n      return {\n        total: total,\n        repeatingItems: repeatingItems\n      };\n    },\n\n\n    /**\n     * Add repeating items into LForms definition data object\n     * @param parentItem a parent item\n     * @param linkId code of a repeating item\n     * @param total total number of the repeating item with the same code\n     * @private\n     */\n    _addRepeatingItems : function(parentItem, linkId, total) {\n      // find the first (and the only one) item\n      var item = null;\n      if (parentItem.items) {\n        for(var i=0, iLen=parentItem.items.length; i<iLen; i++) {\n          if (linkId === parentItem.items[i].linkId) {\n            item = parentItem.items[i];\n            break;\n          }\n        }\n        // insert new items\n        if (item) {\n          while(total > 1) {\n            var newItem = LForms.Util.deepCopy(item);\n            parentItem.items.splice(i, 0, newItem);\n            total -= 1;\n          }\n        }\n      }\n    },\n\n\n    /**\n     * Find a matching repeating item by item code and the index in the items array\n     * @param parentItem a parent item\n     * @param linkId linkId of a repeating (or non-repeating) item\n     * @param index index of the item in the sub item array of the parent item\n     * @returns {{}} a matching item\n     * @private\n     */\n    _findTheMatchingItemByLinkIdAndIndex : function(parentItem, linkId, index) {\n      var item = null;\n      var idx = 0;\n      if (parentItem.items) {\n        for(var i=0, iLen=parentItem.items.length; i<iLen; i++) {\n          if (linkId === parentItem.items[i].linkId) {\n            if (idx === index) {\n              item = parentItem.items[i];\n              break;\n            }\n            else {\n              idx += 1;\n            }\n          }\n        }\n      }\n      return item;\n    },\n\n\n    /**\n     * Find a matching repeating item by item code alone\n     * When used on the LForms definition data object, there is no repeating items yet.\n     * @param parentItem a parent item\n     * @param linkId linkId of an item\n     * @returns {{}} a matching item\n     * @private\n     */\n    _findTheMatchingItemByLinkId : function(parentItem, linkId) {\n      var item = null;\n      if (parentItem.items) {\n        for(var i=0, iLen=parentItem.items.length; i<iLen; i++) {\n          if (linkId === parentItem.items[i].linkId) {\n            item = parentItem.items[i];\n            break;\n          }\n        }\n      }\n      return item;\n    }\n\n  }\n\n}\n\nexport default addSDCImportFns;\n","// A module for Observation-based pre-population.\n\n\n/**\n *  Starts the (likely asynchronous) requests to retrieve linked Observation\n *  resources for pre-population.  When the resources have been retrieved,\n *  prepoluation will be performed.\n * @param lfData the LFormsData object for the form being prepopulated.\n * @return a promise resolving after the resources have been retrieved and\n *  any prepopulation has been performed.\n */\nexport function requestLinkedObs(lfData) {\n  if (LForms.fhirContext?.client && lfData._fhir) {\n    // We will need to know what version of FHIR the server is using.  Make\n    // sure that is available before continuing.\n    if (!LForms._serverFHIRReleaseID) {\n      // Go fetch the server's FHIR version first before continuing\n      return new Promise(function(resolve, reject) {\n        LForms.Util.getServerFHIRReleaseID(function(relID) {\n          if (!relID)\n            reject(\"Unable to obtain the server's FHIR version\");\n          else\n            resolve(requestLinkedObs(lfData));\n        });\n      });\n    }\n    else {\n      var pendingPromises = [];\n      LForms.Util.validateFHIRVersion(LForms._serverFHIRReleaseID);\n      var serverFHIR = LForms.FHIR[LForms._serverFHIRReleaseID];\n      let obsLinkURI = lfData._fhir.SDC.fhirExtObsLinkPeriod;\n      for (var i=0, len=lfData.itemList.length; i<len; ++i) {\n        let item = lfData.itemList[i];\n        const obsExt = item._fhirExt && item._fhirExt[obsLinkURI];\n        if (obsExt) { // an array of at least 1 if present\n          var duration = obsExt[0].valueDuration; // optional\n          var fhirClient = LForms.fhirContext.client;\n\n          // Get a comma separated list of codes\n          const codeQuery = item.codeList.map((code) => {\n            const codeSystem = code.system === 'LOINC' ? serverFHIR.LOINC_URI : code.system;\n            return [codeSystem, code.code].join('|');\n          }).join(',');\n\n          const queryParams = {\n            code: codeQuery, _sort: '-date',\n            status: 'final,amended,corrected',\n            _count: 5  // only need one, but we need to filter out focus=true below\n          };\n          // Temporarily disabling the addition of the focus search\n          // parameter, because of support issues.  Instead, for now, we\n          // will check the focus parameter when the Observation is\n          // returned.  Later, we might query the server to find out whether\n          // :missing is supported.\n          //if (LForms._serverFHIRReleaseID != 'STU3') // STU3 does not know about \"focus\"\n          //  queryParams.focus = {$missing: true}; // TBD -- sometimes :missing is not supported\n\n          // Constrain the date range\n          if (duration && duration.value && duration.code) {\n            // Convert value to milliseconds\n            var result = LForms.ucumPkg.UcumLhcUtils.getInstance().convertUnitTo(duration.code, duration.value, 'ms');\n            if (result.status === 'succeeded') {\n              var date = new Date(new Date() - result.toVal);\n              queryParams.date = 'gt'+date.toISOString();\n            }\n          }\n          pendingPromises.push(\n            fhirClient.patient.request(lfData._buildURL(['Observation'],\n              queryParams)\n            ).then(function(successData) {\n              var bundle = successData;\n              if (bundle.entry) {\n                var foundObs;\n                for (var j=0, jLen=bundle.entry.length; j<jLen && !foundObs; ++j) {\n                  var obs = bundle.entry[j].resource;\n                  if (!obs.focus) { // in case we couldn't use focus:missing above\n                    serverFHIR.SDC.importObsValue(item, obs);\n                    if (item.value) { // obs.value[x] could be missing\n                      foundObs = true;\n                      if (item.unit)\n                        lfData._setUnitDisplay(item.unit);\n                    }\n                  }\n                }\n              }\n              return item.questionCode; // code is not needed, but useful for debugging\n            })\n          );\n        }\n      }\n      return Promise.all(pendingPromises);\n    }\n  }\n};\n\n\n\n","import {requestLinkedObs} from './obs-prepop.mjs';\n\n/**\n *  Defines SDC functions (used by both import and export, or for other\n *  SDC-related purposes) that are the same across the different FHIR versions.\n *  The function takes SDC namespace object defined in the sdc export code,\n *  and adds additional functions to it.\n */\nfunction addCommonSDCFns(ns) {\n\"use strict\";\n\n  var self = ns;\n  self.requestLinkedObs = requestLinkedObs;\n\n  // A mapping of data types of items from LHC-Forms to FHIR Questionnaire\n  self._lformsTypesToFHIRTypes = {\n    \"SECTION\": 'group',\n    \"TITLE\": 'display',\n    \"ST\": 'string',\n    \"BL\": 'boolean',\n    \"REAL\": 'decimal',\n    \"INT\": 'integer',\n    \"DT\": 'date',\n    \"DTM\": 'dateTime',\n    \"TM\": 'time',\n    \"TX\": 'text',\n    \"URL\": 'url',\n    \"CNE\": 'choice',\n    \"CWE\": 'open-choice',\n    \"QTY\": 'quantity',\n    \"attachment\": 'attachment'\n  };\n\n  // A mapping from LHC-Forms data types to the partial field names of the value fields\n  // and initial value fields in FHIR Questionnaire\n  self._lformsTypesToFHIRFields = {\n    \"attachment\": \"Attachment\",\n    \"INT\": 'Integer',\n    \"REAL\": 'Decimal',\n    \"DT\": 'Date',\n    \"DTM\": 'DateTime',\n    \"TM\": 'Time',\n    \"ST\": 'String',\n    \"TX\": 'String',\n    \"BL\": 'Boolean',\n    \"URL\": 'Url',\n    \"CNE\": 'Coding',\n    \"CWE\": 'Coding',\n    \"QTY\": 'Quantity'\n  };\n\n  self._operatorMapping = {\n    'minExclusive': '>',\n    'maxExclusive': '<',\n    'minInclusive': '>=',\n    'maxInclusive': '<=',\n    'value': '=',\n    'notEqual': '!=',\n    '>': 'minExclusive',\n    '<': 'maxExclusive',\n    '>=': 'minInclusive',\n    '<=': 'maxInclusive',\n    '=': 'value',\n    '!=': 'notEqual',\n    'exists': 'exists'\n  };\n\n  /**\n   * Check if a LForms item has repeating questions\n   * @param item a LForms item\n   * @returns {*|boolean}\n   * @private\n   */\n  self._questionRepeats = function(item) {\n    return item._questionRepeatable!==undefined ? item._questionRepeatable :\n      item.questionCardinality && item.questionCardinality.max &&\n      (item.questionCardinality.max === \"*\" || parseInt(item.questionCardinality.max) > 1);\n  };\n\n\n  /**\n   * Check if a LForms item has repeating answers\n   * @param item a LForms item\n   * @returns {*|boolean}\n   * @private\n   */\n  self._answerRepeats = function(item) {\n    return item._multipleAnswers!==undefined ? item._multipleAnswers :\n      item.answerCardinality && item.answerCardinality.max &&\n      (item.answerCardinality.max === \"*\" || parseInt(item.answerCardinality.max) > 1);\n  };\n\n\n  /**\n   * Do a shallow copy of specified fields from source to target.\n   *\n   * @param source - Source object\n   * @param target - Target object\n   * @param fieldList - Array of fields to copy from the source. If the field is\n   * not found in the source, it is ignored.\n   */\n  self.copyFields = function(source, target, fieldList) {\n    if(source && target && fieldList && fieldList.length > 0) {\n      fieldList.forEach(function(field) {\n        if(source.hasOwnProperty(field)) {\n          target[field] = source[field];\n        }\n      });\n    }\n  };\n\n\n  // Store the UCUM code system URI\n  self.UCUM_URI = 'http://unitsofmeasure.org';\n\n\n  /**\n   * Set the given key/value to the object if the value is not undefined, not null, and not an empty string.\n   * @param obj the object to set the key/value on. It can be null/undefined, and if so, a new object will\n   *        be created and returned (only if the value is valid).\n   * @param key the key for the given value to be set to the given object, required.\n   * @param value the value to be set to the given object using the given key.\n   * @return if the input object is not null/undefined, it will be returned;\n   *         if the input object is null/undefined:\n   *         - return the given object as is if the value is invalid, or\n   *         - a newly created object with the given key/value set.\n   * @private\n   */\n  self._setIfHasValue = function (obj, key, value) {\n    if(value !== undefined && value !== null && value !== '') {\n      if(! obj) {\n        obj = {};\n      }\n      obj[key] = value;\n    }\n    return obj;\n  };\n\n\n  /**\n   * Copy between lforms trigger value coding and FHIR enableWhen valueCoding. It only copies 3 fields:\n   * code, system, and display/text (called \"text\" in lforms, \"display\" in FHIR)\n   * @param srcCoding the coding object to copy from\n   * @param dstCoding the coding object to copy to, may be null/undefined, and if null/undefined, a new object\n   *        will be created but only if the srcCoding has at least one of code, system, display/text\n   * @param lforms2Fhir The direction of copying, can be true or false. The direction matters because in lforms,\n   *        the text/display field is called \"text\", while in FHIR, it's called \"display\"\n   * @return the resulting dstCoding object.\n   * @private\n   */\n  self._copyTriggerCoding = function(srcCoding, dstCoding, lforms2Fhir) {\n    let srcTextField = lforms2Fhir? 'text': 'display';\n    let dstTextField = lforms2Fhir? 'display': 'text';\n\n    dstCoding = self._setIfHasValue(dstCoding, 'code', srcCoding.code);\n    dstCoding = self._setIfHasValue(dstCoding, 'system', srcCoding.system);\n    dstCoding = self._setIfHasValue(dstCoding, dstTextField, srcCoding[srcTextField]);\n\n    return dstCoding;\n  };\n\n\n  /**\n   *  Returns true if the given item (or LFormsData) has an expression\n   *  which needs to be re-evaluated when the user changes their response.\n   * @param itemOrLFData the item or LFormsData to be checked.  It is assumed\n   *  that the relevant extensions will be in an _fhirExt hash where\n   *  the key is the URI of the extension and the values are arrays of the FHIR\n   *  extension structure.\n   */\n  self.hasResponsiveExpression = function(itemOrLFData) {\n    var ext = itemOrLFData._fhirExt;\n    return ext ? !!(ext[self.fhirExtCalculatedExp] || ext[self.fhirExtAnswerExp] ||\n       ext[self.fhirExtEnableWhenExp]) : false;\n  };\n\n\n  /**\n   *  Returns true if the given item has an expression\n   *  which sets the list.\n   * @param item the item to be checked.  It is assumed\n   *  that the relevant extensions will be in an _fhirExt hash where\n   *  the key is the URI of the extension and the values are arrays of the FHIR\n   *  extension structure.\n   */\n  self.hasListExpression = function(item) {\n    var ext = item._fhirExt;\n    // This should one day include a check for cqf-expression, when we add\n    // support for it\n    return ext ? !!(ext[self.fhirExtAnswerExp]) : false;\n  };\n\n\n  /**\n   *  Returns true if the given item (or LFormsData) has an expression\n   *  which needs to be evaluated only once, when form is first rendered.\n   * @param itemOrLFData the item or LFormsData to be checked.  It is assumed\n   *  that the relevant extensions will be in an _fhirExt hash where\n   *  the key is the URI of the extension and the values are arrays of the FHIR\n   *  extension structure.\n   */\n  self.hasInitialExpression = function(itemOrLFData) {\n    return !!(itemOrLFData._fhirExt && itemOrLFData._fhirExt[self.fhirExtInitialExp]);\n  };\n\n\n  /**\n   *  Builds a map from extension URIs to arrays of the FHIR extension\n   *  structures, and stores it on the item.  Also builds an array of all\n   *  Expression extensions.\n   *\n   * @param itemOrLFData a form item or an LFormsData which possibly contain\n   *  FHIR extensions (in an \"extension\" property).\n   */\n  self.buildExtensionMap = function(itemOrLFData) {\n    // Initialize a map for testing whether an extension is an Expression extension.\n    // The keys are the URIs, and the values are see to true.\n    if (!self.isExpressionExtension) {\n      self.isExpressionExtension = [self.fhirExtCalculatedExp,\n        self.fhirExtInitialExp, self.fhirExtAnswerExp, self.fhirExtVariable,\n        self.fhirExtEnableWhenExp].reduce((x, k)=>{x[k]=true; return x}, {});\n    }\n\n    if (itemOrLFData.extension) {\n      var m = {};\n      var exprExtensions = [];\n      for (let ext of itemOrLFData.extension) {\n        var extArray = m[ext.url];\n        if (!extArray)\n          extArray =  m[ext.url] = [];\n        extArray.push(ext);\n        if (self.isExpressionExtension[ext.url])\n          exprExtensions.push(ext);\n      }\n      itemOrLFData._fhirExt = m;\n      if (exprExtensions.length)\n        itemOrLFData._exprExtensions = exprExtensions;\n    }\n  };\n\n\n  /**\n   *  Requests launchContext resources.  Assumes LForms.Util.setFHIRContext() has\n   *  been called.\n   * @param lfData a LFormsData object for the form.\n   * @return an array of Promises which resolve when the attempt to load the\n   *  resources has completed (succesful or not, they resolve without being\n   *  rejected).\n   */\n  self.loadLaunchContext = function(lfData) {\n    // launchContext\n    var contextItems = LForms.Util.findObjectInArray(lfData.extension, 'url',\n      self.fhirExtLaunchContext, 0, true);\n    // Define a list of known, supported context variables, which we can get from the FHIR server,\n    // and they resources they are allowed to take.\n    const contextsFromServer = {patient: {Patient: 1}, encounter: {Encounter: 1},\n      user: {Patient: 1, Practitioner: 1, PractitionerRole: 1, RelatedPerson: 1}};\n    const pendingPromises = [];\n\n    /**\n     *  Checks to make sure that the type of the resource is what it should be\n     *  per FHIR's requirements, and if it is okay, assigns the resource to\n     *  the Questionnaires' variables map.\n     * @param name the name of the variable\n     * @param typeList the list of types for the name as specified in the\n     *  launchContext extension.\n     * @param resource the resource that was obtained as the value of the variable.\n     */\n    function addIfValid(name, typeList, resource) {\n      let resType = resource.resourceType;\n      // Validate the \"type\"\n      let permittedTypes = contextsFromServer[name];\n      if (permittedTypes && !permittedTypes[resType]) {\n        console.warn(\"a launch context resource of type \"+restype+\n          \" was found for name \"+name+\", but the supported types for name \"+\n          name + \" are: \"+ Object.keys(permittedTypes).join(\", \"));\n      }\n      else if (typeList.indexOf(resType) == -1) {\n        console.warn(\"Could not retrieve a resource of the requested\" +\n          \" types for launch context name \" +name);\n      }\n      else {\n        lfData._fhirVariables[name] = resource;\n      }\n    }\n\n    for (var i=0, len=contextItems.length; i<len; ++i) {\n      let contextItemExt = contextItems[i].extension;\n      let name=null, typeList=[];\n\n      for (var j=0, jLen=contextItemExt.length; j<jLen; ++j) {\n        var fieldExt = contextItemExt[j];\n        if (!name && fieldExt.url === 'name') {\n          if (fieldExt.valueId) { // Handle a change in the specification\n            console.log(\"Warning:  The type of the launchContext 'name' field should be 'Coding', not 'id'.\");\n            name = fieldExt.valueId;\n          }\n          else\n            name = fieldExt.valueCoding?.code;\n\n          lfData._checkFHIRVarName(name); // might throw if the name is not valid as a variable name\n        }\n        else if (fieldExt.url === 'type') { // there can be more than one\n          typeList.push(fieldExt.valueCode);\n        }\n      }\n      if (name && typeList.length) {\n        pendingPromises.push(new Promise(function(resolve, reject) {\n          let fromMap = LForms.fhirContext.vars?.[name];\n          let contextResource = LForms.fhirContext.client?.[name];\n          if (!fromMap && !contextResource.id) {\n            console.warn('A launch context resource of name '+name+\n              ' was requested by the form, but none was available');\n            // The loading of this resource should not be critical for the\n            // Questionnaire, because it is just for prepopulation.  Don't\n            // reject the promise.\n            resolve();\n          }\n          else {\n            if (fromMap) {\n              addIfValid(name, typeList, fromMap);\n              resolve();\n            }\n            else {\n              contextResource.read().then(function(resource) {\n                if (resource) {\n                  addIfValid(name, typeList, resource);\n                }\n                resolve();\n              },\n              function fail(reason) {\n                console.warn('A launch context of name '+name+' was requested, '+\n                  'but could not be read.');\n                console.error(reason);\n                resolve(); // per above, we are not rejecting the promise\n              });\n            }\n          }\n        }));\n      }\n    }\n    return pendingPromises;\n  };\n}\n\n\nexport default addCommonSDCFns;\n","/**\n *  Defines SDC import functions that are the same across the different FHIR\n *  versions.  The function takes SDC namespace object defined in the sdc export\n *  code, and adds additional functions to it.\n */\nfunction addCommonSDCImportFns(ns) {\n\"use strict\";\n\n  var self = ns;\n\n  var errorMessages = LForms.Util._internalUtil.errorMessages;\n\n  // FHIR extension urls\n  self.fhirExtUrlCardinalityMin = \"http://hl7.org/fhir/StructureDefinition/questionnaire-minOccurs\";\n  self.fhirExtUrlCardinalityMax = \"http://hl7.org/fhir/StructureDefinition/questionnaire-maxOccurs\";\n  self.fhirExtUrlItemControl = \"http://hl7.org/fhir/StructureDefinition/questionnaire-itemControl\";\n  self.fhirExtUrlUnit = \"http://hl7.org/fhir/StructureDefinition/questionnaire-unit\";\n  self.fhirExtUrlUnitOption = \"http://hl7.org/fhir/StructureDefinition/questionnaire-unitOption\";\n  self.fhirExtUrlOptionPrefix = \"http://hl7.org/fhir/StructureDefinition/questionnaire-optionPrefix\";\n  self.fhirExtVariable = \"http://hl7.org/fhir/StructureDefinition/variable\";\n  self.fhirExtUrlMinValue = \"http://hl7.org/fhir/StructureDefinition/minValue\";\n  self.fhirExtUrlMaxValue = \"http://hl7.org/fhir/StructureDefinition/maxValue\";\n  self.fhirExtUrlMinLength = \"http://hl7.org/fhir/StructureDefinition/minLength\";\n  self.fhirExtUrlRegex = \"http://hl7.org/fhir/StructureDefinition/regex\";\n  self.fhirExtUrlAnswerRepeats = \"http://hl7.org/fhir/StructureDefinition/questionnaire-answerRepeats\";\n  self.fhirExtUrlExternallyDefined = \"http://hl7.org/fhir/StructureDefinition/questionnaire-externallydefined\";\n  self.argonautExtUrlExtensionScore = \"http://fhir.org/guides/argonaut-questionnaire/StructureDefinition/extension-score\";\n  self.fhirExtUrlHidden = \"http://hl7.org/fhir/StructureDefinition/questionnaire-hidden\";\n  self.fhirExtTerminologyServer = \"http://hl7.org/fhir/StructureDefinition/terminology-server\";\n  self.fhirExtUrlDataControl = \"http://lhcforms.nlm.nih.gov/fhirExt/dataControl\";\n  self.fhirExtCalculatedExp = \"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-calculatedExpression\";\n  self.fhirExtInitialExp = \"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-initialExpression\";\n  self.fhirExtObsLinkPeriod = \"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-observationLinkPeriod\";\n  self.fhirExtObsExtract = 'http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-observationExtract';\n  self.fhirExtAnswerExp = \"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-answerExpression\";\n  self.fhirExtEnableWhenExp = \"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-enableWhenExpression\";\n  self.fhirExtChoiceOrientation = \"http://hl7.org/fhir/StructureDefinition/questionnaire-choiceOrientation\";\n  self.fhirExtLaunchContext = \"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-launchContext\";\n  self.fhirExtMaxSize = \"http://hl7.org/fhir/StructureDefinition/maxSize\";\n  self.fhirExtMimeType = \"http://hl7.org/fhir/StructureDefinition/mimeType\";\n\n  self.fhirExtUrlRestrictionArray = [\n    self.fhirExtUrlMinValue,\n    self.fhirExtUrlMaxValue,\n    self.fhirExtUrlMinLength,\n    self.fhirExtUrlRegex\n  ];\n\n  // One way or the other, the following extensions are converted to lforms internal fields.\n  // Any extensions not listed here (there are many) are recognized as lforms extensions as they are.\n  self.handledExtensionSet = new Set([\n    self.fhirExtUrlCardinalityMin,\n    self.fhirExtUrlCardinalityMax,\n    self.fhirExtUrlItemControl,\n    self.fhirExtUrlUnit,\n    self.fhirExtUrlUnitOption,\n    self.fhirExtUrlOptionPrefix,\n    self.fhirExtUrlMinValue,\n    self.fhirExtUrlMaxValue,\n    self.fhirExtUrlMinLength,\n    self.fhirExtUrlRegex,\n    self.fhirExtUrlAnswerRepeats,\n    self.fhirExtUrlExternallyDefined,\n    self.argonautExtUrlExtensionScore,\n    self.fhirExtUrlHidden,\n    self.fhirExtTerminologyServer,\n    self.fhirExtUrlDataControl,\n    self.fhirExtChoiceOrientation\n  ]);\n\n  // Simple functions for mapping extensions to properties in the internal structure.\n  // Parameters:\n  //   extension: the FHIR extension object\n  //   item:  The LForms item to be updated\n  // Returns:  true if the extension should still be added to the LForms item\n  //   extension array, and false/undefined otherwise.\n  //\n  self.extensionHandlers = {};\n  self.extensionHandlers[self.fhirExtMaxSize] = function(extension, item) {\n    item.maxAttachmentSize = extension.valueDecimal || extension.valueInteger; // not sure why it is decimal\n  };\n  self.extensionHandlers[self.fhirExtMimeType] = function(extension, item) {\n    item.allowedAttachmentTypes || (item.allowedAttachmentTypes = []);\n    item.allowedAttachmentTypes.push(extension.valueCode);\n  };\n  self.extensionHandlers[\n    \"http://hl7.org/fhir/StructureDefinition/questionnaire-initialExpression\"] = function(extension, item) {\n    // Update the URI to the current one.\n    extension.url = 'http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-initialExpression';\n    return true; // add extension to LForms item\n  };\n\n  self.formLevelFields = [\n    // Resource\n    'id',\n    'meta',\n    'implicitRules',\n    'language',\n\n\n    // Domain Resource\n    'text',\n    'contained',\n    'extension',\n    'modifiedExtension',\n\n    // Questionnaire\n    'date',\n    'version',\n    'identifier',\n    'code',  // code in FHIR clashes with previous definition in lforms. It needs special handling.\n    'subjectType',\n    'derivedFrom', // New in R4\n    'status',\n    'experimental',\n    'publisher',\n    'contact',\n    'description',\n    'useContext',\n    'jurisdiction',\n    'purpose',\n    'copyright',\n    'approvalDate',\n    'reviewDate',\n    'effectivePeriod',\n    'url'\n  ];\n\n  self.itemLevelIgnoredFields = [\n    'definition'\n  ];\n\n  /**\n   * Convert FHIR SQC Questionnaire to LForms definition\n   *\n   * @param fhirData - FHIR Questionnaire object\n   * @returns {{}} - LForms json object\n   */\n  self.convertQuestionnaireToLForms = function (fhirData) {\n    var target = null;\n\n    if(fhirData) {\n      target = LForms.Util.baseFormDef();\n      self._processFormLevelFields(target, fhirData);\n      var containedVS = self._extractContainedVS(fhirData);\n\n      if(fhirData.item && fhirData.item.length > 0) {\n        var linkIdItemMap = self._createLinkIdItemMap(fhirData);\n        target.items = [];\n        for( var i = 0; i < fhirData.item.length; i++) {\n          var item = self._processQuestionnaireItem(fhirData.item[i], containedVS, linkIdItemMap);\n          // no instructions on the questionnaire level\n          target.items.push(item);\n        }\n      }\n      target.fhirVersion = self.fhirVersion;\n    }\n    return target;\n  };\n\n\n  /**\n   * Parse form level fields from FHIR questionnaire and assign to LForms object.\n   *\n   * @param lfData - LForms object to assign the extracted fields\n   * @param questionnaire - FHIR questionnaire resource object to parse for the fields.\n   * @private\n   */\n  self._processFormLevelFields = function(lfData, questionnaire) {\n    self.copyFields(questionnaire, lfData, self.formLevelFields);\n\n    // Handle title and name.  In LForms, \"name\" is the \"title\", but FHIR\n    // defines both.\n    lfData.shortName = questionnaire.name; // computer friendly\n    lfData.name = questionnaire.title;\n\n    // Handle extensions on title\n    if (questionnaire._title)\n      lfData.obj_title = questionnaire._title;\n\n    // For backward compatibility, we keep lforms.code as it is, and use lforms.codeList\n    // for storing questionnaire.code. While exporting, merge lforms.code and lforms.codeList\n    // into questionnaire.code. While importing, convert first of questionnaire.code\n    // as lforms.code, and copy questionnaire.code to lforms.codeList.\n    if(questionnaire.code) {\n      // Rename questionnaire code to codeList\n      lfData.codeList = questionnaire.code;\n    }\n    var codeAndSystemObj = self._getCode(questionnaire);\n    if(codeAndSystemObj) {\n      lfData.code = codeAndSystemObj.code;\n      lfData.codeSystem = codeAndSystemObj.system;\n    }\n  };\n\n\n  /**\n   *  Returns the number of sinificant digits in the number after, ignoring\n   *  trailing zeros.  (I am including this on \"self\" so we can have tests for it.)\n   */\n  self._significantDigits = function(x) {\n    // Based on https://stackoverflow.com/a/9539746/360782\n    // Make sure it is a number and use the builtin number -> string.\n    var s = \"\" + (+x);\n    // The following RegExp include the exponent, which we don't need\n    //var match = /(\\d+)(?:\\.(\\d+))?(?:[eE]([+-]?\\d+))?$/.exec(s);\n    var match = /(\\d+)(?:\\.(\\d+))?/.exec(s);\n    // NaN or Infinity or integer.\n    // We arbitrarily decide that Infinity is integral.\n    if (!match) { return 0; }\n    var wholeNum = match[1];\n    var fraction = match[2];\n    //var exponent = match[3];\n    return wholeNum === '0' ? 0 : wholeNum.length + (fraction ? fraction.length : 0);\n  };\n\n\n  /**\n   *  Imports an observation's values into the given LForms item.\n   * @param lfItem the LForms item to which a value will be assigned.\n   * @param obs the observation whose value will be assigned to lfItem.  It\n   *  assumed that obs has an appropriate data type for its value.\n   */\n  self.importObsValue = function(lfItem, obs) {\n    // Get the value from obs, based on lfItem's data type.  (The altertnative\n    // seems to be looping through the keys on obs looking for something that\n    // starts with \"value\".\n    var val = null;\n    var lfDataType = lfItem.dataType;\n    var fhirValType = this._lformsTypesToFHIRFields[lfDataType];\n    // fhirValType is now the FHIR data type for a Questionnaire.  However,\n    // where Questionnaire uses Coding, Observation uses CodeableConcept.\n    if (fhirValType === 'Coding')\n      fhirValType = 'CodeableConcept';\n    if (fhirValType)\n      val = obs['value'+fhirValType];\n    if (!val && (lfDataType === 'REAL' || lfDataType === 'INT')) {\n      // Accept initial value of type Quantity for these types.\n      val = obs.valueQuantity;\n      if (val)\n        val._type = 'Quantity';\n    }\n\n    if (val) {\n      if (!val._type && typeof val === 'object')\n        val._type = fhirValType;\n\n      // Before importing, confirm val contains a valid unit from the\n      // item's unit list.\n      var unitOkay = true;\n      if (val._type === 'Quantity') {\n        if (lfItem.units) {\n          var matchingUnit;\n          var valSystem = val.system;\n          // On SMART sandbox, val.system might have a trailing slash (which is wrong, at least\n          // for UCUM).  For now, just remove it.\n          if (valSystem && valSystem[valSystem.length - 1] === '/')\n            valSystem = valSystem.slice(0, -1);\n          var isUCUMUnit = valSystem === self.UCUM_URI;\n          var ucumUnit;\n          for (var i=0, len=lfItem.units.length; i<len && !matchingUnit; ++i) {\n            var lfUnit = lfItem.units[i];\n            if (lfUnit.system && (lfUnit.system===valSystem && lfUnit.code===val.code) ||\n                !lfUnit.system && (lfUnit.name===val.unit)) {\n              matchingUnit = lfUnit;\n            }\n            if (isUCUMUnit && !matchingUnit && !ucumUnit && lfUnit.system === self.UCUM_URI)\n              ucumUnit = lfUnit;\n          }\n          if (!matchingUnit && ucumUnit) {\n            // See if we can convert to the ucumUnit we found\n            var result = LForms.ucumPkg.UcumLhcUtils.getInstance().convertUnitTo(val.code, val.value, ucumUnit.code);\n            if (result.status === 'succeeded') {\n              matchingUnit = ucumUnit;\n              // Round the result to the same number of significant digits as the\n              // input value.\n              var originalSD = this._significantDigits(val.value);\n              if (originalSD > 0)\n                val.value = parseFloat(result.toVal.toPrecision(originalSD));\n              else\n                val.value = result.toVal;\n              val.code = ucumUnit.code;\n              val.unit = ucumUnit.name || ucumUnit.code; // name can be undefined\n            }\n          }\n          if (!matchingUnit)\n            unitOkay = false;\n          else\n            lfItem.unit = matchingUnit;\n        }\n      }\n      if (unitOkay) {\n        this._processFHIRValues(lfItem, [val]);\n      }\n    }\n  };\n\n\n  /**\n   *   Converts FHIR values to an LForms item values, but does not assign the\n   *   values to the item.  (For a function that assigns values, call _processFHIRValues).\n   *  @param lfItem the LForms item to for which these are new values\n   *  @param fhirVals an array of FHIR values (e.g.  Quantity, Coding, string, etc.).\n   *   Complex types like Quantity should have _type set to the type, if\n   *   possible, or an attempt will be made to guess the FHIR type from the\n   *   lfItem's data type.\n   *  @param forDefault if true, the intented target of the values is the item's\n   *   default value instead of the item value.\n   *  @return an array of the processed/converted values, and an array of any error/warning/info\n   *   messages for each of those messages.  For each item in the messages\n   *   array, if there is a message there will be an object with keys \"errors\",\n   *   \"warnings\", and \"info\" (if those exist), the values of which will will be\n   *   an object with message ID keys (from error-messages.js) and message text\n   *   values in the currently selected language.  Regarding the answers, note\n   *   that Quantities will be returned as is, because those go into more than\n   *   one field on the item, but some error checking will be done for them.\n   */\n  self._convertFHIRValues = function(lfItem, fhirVals, forDefault) {\n    // Note that this is used by the import process, and so lfItem is an item\n    // from the lforms definition object in that case, not an item from LFormsData.\n    // On the other hand, it is also used by the ExpressionProcessor, an in that\n    // case lfItem is an item from LFormsData.\n    var lfDataType = lfItem.dataType;\n    var answers = [];\n    const messages = [];\n    for (let i=0, len=fhirVals.length; i<len; ++i) {\n      let fhirVal = fhirVals[i];\n      var answer = undefined; // reset back to undefined each iteration\n      let errors = {};\n      let hasMessages = false;\n      if (lfDataType === 'CWE' || lfDataType === 'CNE' ) {\n        var codings = null;\n        if (fhirVal._type === 'CodeableConcept') {\n          codings = fhirVal.coding;\n        }\n        else if (fhirVal._type === 'Coding' || typeof fhirVal === 'object') {\n          codings = [fhirVal];\n        }\n        if (!codings) {\n          // the value or the default value could be a string for 'open-choice'/CWE\n          if (lfDataType === 'CWE') {\n            answer = fhirVal;\n          }\n        }\n        else {\n          // Pick a Coding that is appropriate for this list item.\n          // Note:  It could be an off list Coding.\n          if (lfItem.answers) {\n            var itemAnswers = lfItem._modifiedAnswers || lfItem.answers; // _modified contains _displayText\n            for (var k=0, kLen=codings.length; k<kLen && !answer; ++k) {\n              var coding = codings[k];\n              for (var j=0, jLen=itemAnswers.length; j<jLen && !answer; ++j) {\n                var listAnswer = itemAnswers[j];\n                var listAnswerSystem = listAnswer.system ? LForms.Util.getCodeSystem(listAnswer.system) : null;\n                if ((!coding.system && !listAnswerSystem || coding.system === listAnswerSystem) &&\n                    ((coding.hasOwnProperty('code') && listAnswer.hasOwnProperty('code') &&\n                      coding.code===listAnswer.code) ||\n                     (coding.hasOwnProperty('display') && listAnswer.hasOwnProperty('text') &&\n                      coding.display === listAnswer.text))) {\n                  answer = itemAnswers[j]; // include label in answer text\n                }\n              }\n            }\n          }\n          if (!answer && lfDataType === 'CWE') { // no match in the list.\n            answer = self._processCWECNEValueInQR({valueCoding: fhirVal});\n            answer._notOnList = true;\n            answer._displayText = answer.text;\n          }\n        }\n      }\n      else if(fhirVal._type === 'Quantity' && (lfDataType === 'QTY' ||\n          lfDataType === 'REAL' || lfDataType === 'INT')) {\n        if (fhirVal.comparator !== undefined) {\n          errorMessages.addMsg(errors, 'comparatorInQuantity');\n          hasMessages = true;\n        }\n        answer = fhirVal;\n      }\n      // For date types, convert them to date objects, but only for values.\n      // If we're setting defaultAnswer, leave them as strings.\n      else if (!forDefault && lfItem.dataType === 'DTM' && typeof fhirVal === 'string')\n        answer = new Date(fhirVal);\n      else if (!forDefault && lfItem.dataType === 'DT' && typeof fhirVal === 'string')\n        answer = LForms.Util.stringToDTDateISO(fhirVal);\n      else {\n        answer = fhirVal;\n      }\n      answers.push(answer);\n      messages.push(hasMessages ? {errors} : null);\n    }\n    return [answers, messages];\n  };\n\n\n  /**\n   *   Assigns FHIR values to an LForms item.\n   *  @param lfItem the LForms item to receive the values from fhirVals\n   *  @param fhirVals an array of FHIR values (e.g.  Quantity, Coding, string, etc.).\n   *   Complex types like Quantity should have _type set to the type, if\n   *   possible, or an attempt will be made to guess the FHIR type from the\n   *   lfItem's data type.\n   *  @param setDefault if true, the default value in lfItem will be set instead\n   *   of the value.\n   */\n  self._processFHIRValues = function(lfItem, fhirVals, setDefault) {\n    // Currently this is called for:\n    //   - importing an Observation value (prepop) (a single value, but could\n    //     have components referred to by child items)\n    //   - processing default answers during an import.  For default answers, we\n    //     do not assign the value here, but just put it in defaultAnswer.\n    // Note that when importing, we are creating a LForms form definition, but\n    // not and LFormsData object.\n    let [answers, messages] = this._convertFHIRValues(lfItem, fhirVals, setDefault);\n    let val = LForms.Util._hasMultipleAnswers(lfItem) ? answers : answers[0];\n    if (setDefault) {\n      lfItem.defaultAnswer = val;\n      LForms.Util._internalUtil.setItemMessagesArray(lfItem, messages, 'default answers');\n    }\n    else {\n      LForms.Util._internalUtil.assignValueToItem(lfItem, val);\n      LForms.Util._internalUtil.setItemMessagesArray(lfItem, messages, '_processFHIRValues');\n    }\n  };\n\n\n  /**\n   * Get a FHIR value from an object given a partial string of hash key.\n   * Use it where at most only one key matches.\n   *\n   * @param obj {object} - Object to search\n   * @param keyRegex {regex} - Regular expression to match a key.  This should\n   *  be the beginning part of the key up to the type (e.g., /^value/, to match\n   *  \"valueQuantity\").\n   * @returns {*} - Corresponding value of matching key.  For complex types,\n   *  such as Quantity, the type of the returned object will be present under\n   *  a _type attribute.\n   * @private\n   */\n  self._getFHIRValueWithPrefixKey = function(obj, keyRegex) {\n    var ret = null;\n    if(typeof obj === 'object') {\n      for(var key in obj) {\n        var matchData = key.match(keyRegex);\n        if (matchData) {\n          ret = obj[key];\n          if (ret && typeof ret === 'object') {\n            ret = LForms.Util.deepCopy(ret); // Work with clone\n            ret._type = key.substring(matchData[0].length);\n          }\n          break;\n        }\n      }\n    }\n\n    return ret;\n  };\n\n\n  /**\n   *  Process the text and prefix data.\n   * @param lfItem {object} - LForms item object to receive the data\n   * @param qItem {object} - Questionnaire item object (as the source)\n   */\n  self._processTextAndPrefix = function(lfItem, qItem) {\n    // prefix\n    if (qItem.prefix)\n      lfItem.prefix = qItem.prefix;\n    // text\n    lfItem.question = qItem.text;\n\n    // Copy item extensions\n    for (let extField of ['_prefix', '_text']) {\n      let extFieldData = qItem[extField];\n      if (extFieldData)\n        lfItem['obj'+extField] = extFieldData;\n    }\n  };\n\n\n  /**\n   * Parse questionnaire item for code and code system\n   * @param lfItem {object} - LForms item object to assign question code\n   * @param qItem {object} - Questionnaire item object\n   * @private\n   */\n  self._processCodeAndLinkId = function (lfItem, qItem) {\n    if(qItem.code) {\n      lfItem.codeList = qItem.code;\n    }\n    var code = self._getCode(qItem);\n    if (code) {\n      lfItem.questionCode = code.code;\n      lfItem.questionCodeSystem = code.system;\n    }\n    // use linkId as questionCode, which should not be exported as code\n    else {\n      lfItem.questionCode = qItem.linkId;\n      lfItem.questionCodeSystem = \"LinkId\";\n    }\n\n    lfItem.linkId = qItem.linkId;\n  };\n\n\n  /**\n   * Parse questionnaire item for question cardinality and answer cardinality\n   *\n   * @param lfItem {object} - LForms item object to assign question cardinality\n   * @param qItem {object} - Questionnaire item object\n   * @private\n   */\n  self._processFHIRQuestionAndAnswerCardinality = function(lfItem, qItem) {\n    var min = LForms.Util.findObjectInArray(qItem.extension, 'url', self.fhirExtUrlCardinalityMin);\n    var max = LForms.Util.findObjectInArray(qItem.extension, 'url', self.fhirExtUrlCardinalityMax);\n    var repeats = qItem.repeats;\n    var required = qItem.required;\n    var answerCardinality, questionCardinality;\n    // CNE/CWE, repeats handled by autocompleter with multiple answers in one question\n    if (lfItem.dataType === 'CNE' || lfItem.dataType === 'CWE') {\n      if (repeats) {\n        answerCardinality = max ? {max: max.valueInteger.toString()} : {max: \"*\"};\n      }\n      else {\n        answerCardinality = {max: \"1\"};\n      }\n      if (required) {\n        answerCardinality.min = min ? min.valueInteger.toString() : \"1\";\n      }\n      else {\n        answerCardinality.min = \"0\";\n      }\n    }\n    // not CNE/CWE, question repeats\n    else {\n      // repeats\n      if (repeats) {\n        questionCardinality = max ? {max: max.valueInteger.toString()} : {max: \"*\"};\n      }\n      else {\n        questionCardinality = {max: \"1\"};\n      }\n      // required\n      if (required) {\n        questionCardinality.min = min ? min.valueInteger.toString() : \"1\";\n        answerCardinality = {min: \"1\"};\n      }\n      else {\n        questionCardinality.min = \"1\";\n      }\n    }\n\n    if (questionCardinality)\n      lfItem.questionCardinality = questionCardinality;\n    if (answerCardinality)\n      lfItem.answerCardinality = answerCardinality;\n  };\n\n\n  /**\n   * Parse questionnaire item for units list\n   *\n   * @param lfItem {object} - LForms item object to assign units\n   * @param qItem {object} - Questionnaire item object\n   * @private\n   */\n  self._processUnitList = function (lfItem, qItem) {\n\n    var lformsUnits = [];\n    var lformsDefaultUnit = null;\n    // The questionnaire-unitOption extension is only for item.type = quantity\n    var unitOption = LForms.Util.findObjectInArray(qItem.extension, 'url', self.fhirExtUrlUnitOption, 0, true);\n    if(unitOption && unitOption.length > 0) {\n      if (qItem.type !== 'quantity') {\n        throw new Error('The extension '+self.fhirExtUrlUnitOption+\n          ' can only be used with type quantity.  Question \"'+\n          qItem.text+'\" is of type '+qItem.type);\n      }\n      for(var i = 0; i < unitOption.length; i++) {\n        var coding = unitOption[i].valueCoding;\n        var lUnit = {\n          name: coding.display,\n          code: coding.code,\n          system: coding.system\n        };\n        lformsUnits.push(lUnit);\n      }\n    }\n\n    // The questionnaire-unit extension is only for item.type = integer or decimal\n    var unit = LForms.Util.findObjectInArray(qItem.extension, 'url', self.fhirExtUrlUnit);\n    if (unit) {\n      if (qItem.type !== 'integer' && qItem.type !== 'decimal') {\n        throw new Error('The extension '+self.fhirExtUrlUnit+\n          ' can only be used with types integer or decimal.  Question \"'+\n          qItem.text+'\" is of type '+qItem.type);\n      }\n      lformsDefaultUnit = {\n        name: unit.valueCoding.display,\n        code: unit.valueCoding.code,\n        system: unit.valueCoding.system,\n        default: true\n      };\n      lformsUnits.push(lformsDefaultUnit);\n    }\n\n    if (qItem.type === 'quantity') {\n      let initialQ = this.getFirstInitialQuantity(qItem);\n      if (initialQ && initialQ.unit) {\n        lformsDefaultUnit = LForms.Util.findItem(lformsUnits, 'name', initialQ.unit);\n        if(lformsDefaultUnit) {\n          lformsDefaultUnit.default = true;\n        }\n        else {\n          lformsDefaultUnit = {\n            name: initialQ.unit,\n            code: initialQ.code,\n            system: initialQ.system,\n            default: true\n          };\n          lformsUnits.push(lformsDefaultUnit);\n        }\n      }\n    }\n\n    if(lformsUnits.length > 0) {\n      if (!lformsDefaultUnit) {\n        lformsUnits[0].default = true;\n      }\n      lfItem.units = lformsUnits;\n    }\n  };\n\n\n  /**\n   * Parse questionnaire item for display control\n   *\n   * @param lfItem {object} - LForms item object to assign display control\n   * @param qItem {object} - Questionnaire item object\n   * @private\n   */\n  self._processDisplayControl = function (lfItem, qItem) {\n    var itemControlType = LForms.Util.findObjectInArray(qItem.extension, 'url', self.fhirExtUrlItemControl);\n\n    if(itemControlType) {\n      var displayControl = {};\n      switch (itemControlType.valueCodeableConcept.coding[0].code) {\n        case 'Lookup': // backward-compatibility with old export\n        case 'Combo-box': // backward-compatibility with old export\n        case 'autocomplete':\n          lfItem.isSearchAutocomplete = true;\n          // continue to drop-down case\n        case 'drop-down':\n          displayControl.answerLayout = {type: 'COMBO_BOX'};\n          break;\n        case 'Checkbox': // backward-compatibility with old export\n        case 'check-box':\n        case 'Radio': // backward-compatibility with old export\n        case 'radio-button':\n          displayControl.answerLayout = {type: 'RADIO_CHECKBOX'};\n          var answerChoiceOrientation = LForms.Util.findObjectInArray(qItem.extension, 'url', self.fhirExtChoiceOrientation);\n          if (answerChoiceOrientation) {\n            if (answerChoiceOrientation.valueCode === \"vertical\") {\n              displayControl.answerLayout.columns = \"1\"\n            }\n            else if (answerChoiceOrientation.valueCode === \"horizontal\") {\n              displayControl.answerLayout.columns = \"0\"\n            }\n          }\n          break;\n        case 'Table': // backward-compatibility with old export\n        case 'gtable':  // Not in STU3, but we'll accept it\n          if(lfItem.dataType === 'SECTION') {\n            displayControl.questionLayout = \"horizontal\";\n          }\n          break;\n        case 'Matrix': // backward-compatibility with old export\n        case 'table':\n          if(lfItem.dataType === 'SECTION') {\n            displayControl.questionLayout = \"matrix\";\n          }\n          break;\n        default:\n          displayControl = null;\n      }\n\n      if(displayControl && !jQuery.isEmptyObject(displayControl)) {\n        lfItem.displayControl = displayControl;\n      }\n    }\n  };\n\n\n  /**\n   * Parse questionnaire item for data control\n   *\n   * @param lfItem {object} - LForms item object to assign data control\n   * @param qItem {object} - Questionnaire item object\n   * @private\n   */\n  self._processDataControl = function (lfItem, qItem) {\n    var dataControlType = LForms.Util.findObjectInArray(qItem.extension, 'url', self.fhirExtUrlDataControl);\n\n    if(dataControlType && dataControlType.valueString) {\n      try {\n        var dataControl = JSON.parse(dataControlType.valueString);\n        if (dataControl) {\n          lfItem.dataControl = dataControl;\n        }\n      }\n      catch(e){\n        console.log(\"Invalid dataControl data!\");\n      }\n    }\n  };\n\n\n  // ---------------- QuestionnaireResponse Import ---------------\n\n  var qrImport = self._mergeQR;\n\n  /**\n   * Merge a QuestionnaireResponse instance into an LForms form object\n   * @param formData an LForms form definition or LFormsData object.\n   * @param qr a QuestionnaireResponse instance\n   * @returns {{}} an updated LForms form definition, with answer data\n   */\n  qrImport.mergeQuestionnaireResponseToLForms = function(formData, qr) {\n    if (!(formData instanceof LForms.LFormsData)) {\n      // get the default settings in case they are missing in the form data\n      // not to set item values by default values for saved forms with user data\n      formData.hasSavedData = true;\n      formData = (new LForms.LFormsData(formData)).getFormData();\n    }\n    // The reference to _mergeQR below is here because this function gets copied to\n    // the containing object to be a part of the public API.\n    var qrInfo = qrImport._getQRStructure(qr);\n    qrImport._processQRItemAndLFormsItem(qrInfo, formData);\n    return formData;\n  };\n\n\n  /**\n   * Merge data into items on the same level\n   * @param parentQRItemInfo structural information of a parent item\n   * @param parentLFormsItem a parent item, could be a LForms form object or a form item object.\n   * @private\n   */\n  qrImport._processQRItemAndLFormsItem = function(parentQRItemInfo, parentLFormsItem) {\n\n    // note: parentQRItemInfo.qrItemInfo.length will increase when new data is inserted into the array\n    for(var i=0; i<parentQRItemInfo.qrItemsInfo.length; i++) {\n\n      var qrItemInfo = parentQRItemInfo.qrItemsInfo[i];\n      var qrItem = qrItemInfo.item;\n      if (qrItem) {\n        // first repeating qrItem\n        if (qrItemInfo.total > 1 && qrItemInfo.index === 0) {\n          var defItem = this._findTheMatchingItemByLinkId(parentLFormsItem, qrItemInfo.linkId);\n          // add repeating items in form data\n          // if it is a case of repeating questions, not repeating answers\n          if (ns._questionRepeats(defItem)) {\n            this._addRepeatingItems(parentLFormsItem, qrItemInfo.linkId, qrItemInfo.total);\n            // add missing qrItemInfo nodes for the newly added repeating LForms items (questions, not sections)\n            if (defItem.dataType !== 'SECTION' && defItem.dataType !== 'TITLE') {\n              for (var j=1; j<qrItemInfo.total; j++) {\n                var newQRItemInfo = LForms.Util.deepCopy(qrItemInfo);\n                newQRItemInfo.index = j;\n                newQRItemInfo.item.answer = [newQRItemInfo.item.answer[j]];\n                if(qrItemInfo.qrAnswersItemsInfo && qrItemInfo.qrAnswersItemsInfo[j]) {\n                  newQRItemInfo.qrAnswersItemsInfo = [qrItemInfo.qrAnswersItemsInfo[j]];\n                }\n                parentQRItemInfo.qrItemsInfo.splice(i+j, 0, newQRItemInfo);\n              }\n              // change the first qr item's answer too\n              qrItemInfo.item.answer = [qrItemInfo.item.answer[0]];\n              if(qrItemInfo.qrAnswersItemsInfo && qrItemInfo.qrAnswersItemsInfo[0]) {\n                qrItemInfo.qrAnswersItemsInfo = [qrItemInfo.qrAnswersItemsInfo[0]];\n              }\n              else {\n                delete qrItemInfo.qrAnswersItemsInfo;\n              }\n            }\n          }\n          // reset the total number of questions when it is the answers that repeats\n          else if (ns._answerRepeats(defItem)) {\n            qrItemInfo.total = 1;\n          }\n        }\n        // find the matching LForms item\n        var item = this._findTheMatchingItemByLinkIdAndIndex(parentLFormsItem, qrItemInfo.linkId, qrItemInfo.index);\n\n        // set up value and units if it is a question\n        if ((item.dataType !== 'SECTION' && item.dataType !== 'TITLE')) {\n          var qrAnswer = qrItem.answer;\n          if (qrAnswer && qrAnswer.length > 0) {\n            this._setupItemValueAndUnit(qrItem.linkId, qrAnswer, item);\n            // process item.answer.item, if applicable\n            if(qrItemInfo.qrAnswersItemsInfo) {\n              // _setupItemValueAndUnit seems to assume single-answer except for multiple choices on CNE/CWE\n              // moreover, each answer has already got its own item above if question repeats\n              if(qrItemInfo.qrAnswersItemsInfo.length > 1) {\n                throw new Error('item.answer.item with item.answer.length > 1 is not yet supported');\n              }\n              this._processQRItemAndLFormsItem(qrItemInfo.qrAnswersItemsInfo[0], item);\n            }\n          }\n        }\n\n        // process items on the sub-level\n        if (qrItemInfo.qrItemsInfo && qrItemInfo.qrItemsInfo.length>0) {\n          this._processQRItemAndLFormsItem(qrItemInfo, item);\n        }\n      }\n    }\n  };\n\n\n  /**\n   * Set value and units on a LForms item\n   * @param linkId an item's linkId\n   * @param answer value for the item\n   * @param item a LForms item\n   * @private\n   */\n  qrImport._setupItemValueAndUnit = function(linkId, answer, item) {\n\n    if (item && linkId === item.linkId && (item.dataType !== 'SECTION' && item.dataType !== 'TITLE')) {\n      var dataType = item.dataType;\n\n      // any one has a unit must be a numerical type, let use REAL for now.\n      // dataType conversion should be handled when panel data are added to lforms-service.\n      if ((!dataType || dataType===\"ST\") && item.units && item.units.length>0 ) {\n        item.dataType = dataType = \"REAL\";\n      }\n\n      var qrValue = answer[0];\n\n      switch (dataType) {\n        case \"BL\":\n          if (qrValue.valueBoolean === true || qrValue.valueBoolean === false) {\n            item.value = qrValue.valueBoolean;\n          }\n          break;\n        case \"INT\":\n          if (qrValue.valueQuantity) {\n            item.value = qrValue.valueQuantity.value;\n            if(qrValue.valueQuantity.code) {\n              item.unit = {name: qrValue.valueQuantity.code};\n            }\n          }\n          else if (qrValue.valueInteger) {\n            item.value = qrValue.valueInteger;\n          }\n          break;\n        case \"REAL\":\n        case \"QTY\":\n          if (qrValue.valueQuantity) {\n            item.value = qrValue.valueQuantity.value;\n            if(qrValue.valueQuantity.code) {\n              item.unit = {name: qrValue.valueQuantity.code};\n            }\n          }\n          else if (qrValue.valueDecimal) {\n            item.value = qrValue.valueDecimal;\n          }\n          break;\n        case \"DT\":\n          item.value = qrValue.valueDate;\n          break;\n        case \"DTM\":\n          item.value = qrValue.valueDateTime;\n          break;\n        case \"CNE\":\n        case \"CWE\":\n          if (ns._answerRepeats(item)) {\n            var value = [];\n            for (var j=0,jLen=answer.length; j<jLen; j++) {\n              var val = ns._processCWECNEValueInQR(answer[j]);\n              if (val) {\n                value.push(val);\n              }\n            }\n            item.value = value;\n          }\n          else {\n            var val = ns._processCWECNEValueInQR(qrValue);\n            if (val) {\n              item.value = val;\n            }\n          }\n          break;\n        case \"ST\":\n        case \"TX\":\n          item.value = qrValue.valueString;\n          break;\n        case \"attachment\":\n          item.value = qrValue.valueAttachment;\n          break;\n        case \"SECTION\":\n        case \"TITLE\":\n        case \"\":\n          // do nothing\n          break;\n        default:\n          item.value = qrValue.valueString;\n      }\n    }\n  }\n\n\n  /**\n   * Get LForms data type from questionnaire item\n   *\n   * @param qItem {object} - Questionnaire item object\n   * @private\n   */\n  self._getDataType = function (qItem) {\n    var type = 'string';\n\n    switch (qItem.type) {\n      case 'string':\n        type = 'ST';\n        break;\n      case 'group':\n        type = 'SECTION';\n        break;\n      case \"choice\":\n        type = 'CNE';\n        break;\n      case \"open-choice\":\n        type = 'CWE';\n        break;\n      case 'integer':\n        type = 'INT';\n        break;\n      case 'decimal':\n        type = 'REAL';\n        break;\n      case 'text':\n        type = 'TX';\n        break;\n      case \"boolean\":\n        type = 'BL';\n        break;\n      case \"date\":\n        //dataType = 'date';\n        type = 'DT';\n        break;\n      case \"dateTime\":\n        type = 'DTM';\n        break;\n      case \"time\":\n        type = 'TM';\n        break;\n      case \"display\":\n        type = 'TITLE';\n        break;\n      case \"url\":\n        type = 'URL';\n        break;\n      case \"quantity\":\n        type = 'QTY';\n        break;\n      case \"attachment\":\n        type = 'attachment';\n        break;\n    }\n    return type;\n  };\n\n\n  /**\n   * Build a map of items to linkid from a questionnaire resource.\n   * @param qResource - FHIR Questionnaire resource\n   * @returns {*} - Hash object with link id keys pointing to their respective items.\n   * @private\n   */\n  self._createLinkIdItemMap = function (qResource) {\n    var traverse = function (itemArray, collection) {\n        itemArray.forEach(function(item) {\n          collection[item.linkId] = item;\n          if(item.item) {\n            traverse(item.item, collection);\n          }\n        });\n\n      return collection;\n    };\n\n    var ret = {};\n    if(qResource.item) {\n      ret = traverse(qResource.item, ret);\n    }\n    return ret;\n  };\n\n\n  /**\n   * Get an object with code and code system\n   *\n   * @param questionnaireItemOrResource {object} - question\n   * @private\n   */\n  self._getCode = function (questionnaireItemOrResource) {\n    var code = null;\n    if(questionnaireItemOrResource &&\n      Array.isArray(questionnaireItemOrResource.code) &&\n      questionnaireItemOrResource.code.length) {\n      code = {\n        code: questionnaireItemOrResource.code[0].code,\n        system: self._toLfCodeSystem(questionnaireItemOrResource.code[0].system)\n      };\n    }\n    // If code is missing look for identifier.\n    else if(questionnaireItemOrResource &&\n      Array.isArray(questionnaireItemOrResource.identifier) &&\n      questionnaireItemOrResource.identifier.length) {\n      code = {\n        code: questionnaireItemOrResource.identifier[0].value,\n        system: self._toLfCodeSystem(questionnaireItemOrResource.identifier[0].system)\n      };\n    }\n\n    return code;\n  };\n\n\n  /**\n   *  Converts the given ValueSet into an array of answers that can be used with a prefetch autocompleter.\n   * @return the array of answers, or null if the extraction cannot be done.\n   */\n  self.answersFromVS = function (valueSet) {\n    var vs = valueSet;\n    var rtn = [];\n    if (vs.expansion && vs.expansion.contains && vs.expansion.contains.length > 0) {\n      vs.expansion.contains.forEach(function (vsItem) {\n        var answer = {code: vsItem.code, text: vsItem.display, system: vsItem.system};\n        var ordExt = LForms.Util.findObjectInArray(vsItem.extension, 'url',\n          self.fhirExtUrlValueSetScore);\n        if(ordExt) {\n          answer.score = ordExt.valueDecimal;\n        }\n        rtn.push(answer);\n      });\n    }\n    return rtn.length > 0 ? rtn : null;\n  };\n\n\n  /**\n   * Convert the given code system to LForms internal code system. Currently\n   * only converts 'http://loinc.org' to 'LOINC' and returns all other input as is.\n   * @param codeSystem\n   * @private\n   */\n  self._toLfCodeSystem = function(codeSystem) {\n    var ret = codeSystem;\n    switch(codeSystem) {\n      case 'http://loinc.org':\n        ret = 'LOINC';\n        break;\n    }\n\n    return ret;\n  };\n\n\n  // Copy the main merge function to preserve the same API usage.\n  self.mergeQuestionnaireResponseToLForms = qrImport.mergeQuestionnaireResponseToLForms;\n\n  /**\n   *  Processes the terminology server setting, if any.\n   *\n   * @param lfItem - LForms item object to assign externallyDefined\n   * @param qItem - Questionnaire item object\n   * @private\n   */\n  self._processTerminologyServer = function (lfItem, qItem) {\n    var tServer = LForms.Util.findObjectInArray(qItem.extension, 'url', self.fhirExtTerminologyServer);\n    if (tServer && tServer.valueUrl) {\n      lfItem.terminologyServer = tServer.valueUrl;\n    }\n  };\n\n\n  /**\n   *  Finds the terminology server URL (if any) for the given item.\n   * @param item a question, title, or group in the form (in the LFormsData\n   *  structure, not the Questionnaire).\n   * @return the base terminology server URL, or undefined if there isn't one\n   *  for this item.\n   */\n  self._getTerminologyServer = function(item) {\n    var terminologyServer = item.terminologyServer;\n    var parent = item._parentItem;\n    while (!terminologyServer && parent) {\n      terminologyServer = parent.terminologyServer;\n      parent = parent._parentItem;\n    }\n    return terminologyServer;\n  };\n\n\n  /**\n   *  Returns the URL for performing a ValueSet expansion for the given item,\n   *  if the given item has a terminology server and answerValueSet\n   *  configured; otherwise it returns undefined.\n   * @param item a question, title, or group in the form\n   */\n  self._getExpansionURL = function(item) {\n    var rtn;\n    if (item.answerValueSet) {\n      var terminologyServer = this._getTerminologyServer(item);\n      if (terminologyServer)\n        rtn = terminologyServer + '/ValueSet/$expand?url='+ item.answerValueSet;\n    }\n    return rtn;\n  };\n\n  /**\n   *  Loads answerValueSets for prefetched lists.\n   * @param lfData the LFormsData for the form\n   * @return an array of promise objects which resolve when the answer valuesets\n   * have been loaded and imported.\n   */\n  self.loadAnswerValueSets = function (lfData) {\n    var pendingPromises = [];\n    var items = lfData.itemList;\n    for (var i=0, len=items.length; i<len; ++i) {\n      let item = items[i];\n      if (item.answerValueSet && !item.isSearchAutocomplete) {\n        let expURL = this._getExpansionURL(item);\n        let vsKey = expURL ? expURL : item.answerValueSet;\n        item._answerValueSetKey = vsKey;\n        if (!LForms._valueSetAnswerCache)\n          LForms._valueSetAnswerCache = {};\n        let answers = LForms._valueSetAnswerCache[vsKey];\n        if (answers) {\n          item.answers = answers;\n          lfData._updateAutocompOptions(item, true);\n        }\n        else { // if not already loaded\n          if (expURL) {\n            pendingPromises.push(fetch(expURL).then(function(response) {\n              return response.json();\n            }).then(function(parsedJSON) {\n              if (parsedJSON.resourceType===\"OperationOutcome\" ) {\n                var errorOrFatal = parsedJSON.issue.find(item => item.severity===\"error\" || item.severity===\"fatal\")\n                if (errorOrFatal) {\n                  throw new Error(errorOrFatal.diagnostics)\n                }\n              }\n              else {\n                answers = self.answersFromVS(parsedJSON);\n                if (answers) {\n                  LForms._valueSetAnswerCache[expURL] = answers;\n                  item.answers = answers;\n                  lfData._updateAutocompOptions(item, true);\n                }\n              }\n            }).catch(function(error) {\n              throw new Error(\"Unable to load ValueSet from \"+expURL);\n            }));\n          }\n          else { // use FHIR context\n            var fhirClient = LForms.fhirContext.client;\n            pendingPromises.push(fhirClient.request(lfData._buildURL(\n              ['ValueSet','$expand'], {url: item.answerValueSet})\n            ).then(function(response) {\n              var valueSet = response;\n              var answers = self.answersFromVS(valueSet);\n              if (answers) {\n                LForms._valueSetAnswerCache[vsKey] = answers;\n                item.answers = answers;\n                lfData._updateAutocompOptions(item, true);\n              }\n            }).catch(function(error) {\n              throw new Error(\"Unable to load ValueSet \"+item.answerValueSet+ \" from FHIR server\");\n            }));\n          }\n        }\n      }\n    }\n    return pendingPromises;\n  };\n\n\n  /**\n   * Handle the item.value in QuestionnaireResponse for CWE/CNE typed items\n   * @param qrItemValue a value of item in QuestionnaireResponse\n   * @returns {{code: *, text: *}}\n   * @private\n   */\n  self._processCWECNEValueInQR = function(qrItemValue) {\n    var retValue;\n    // a valueCoding, which is one of the answers\n    if (qrItemValue.valueCoding) {\n      var c = qrItemValue.valueCoding;\n      retValue = {};\n      if (c.code)\n        retValue.code = c.code;\n      if (c.display)\n        retValue.text = c.display;\n      if (c.system)\n        retValue.system = c.sysetm;\n    }\n    // a valueString, which is a user supplied value that is not in the answers\n    else if (qrItemValue.valueString) {\n      retValue = qrItemValue.valueString;\n    }\n    return retValue;\n  };\n\n\n  /**\n   * Parse questionnaire item for coding instructions\n   *\n   * @param qItem {object} - Questionnaire item object\n   * @return {{}} an object contains the coding instructions info.\n   * @private\n   */\n  self._processCodingInstructions = function(qItem) {\n    // if the qItem is a \"display\" typed item with a item-control extension, then it meant to be a help message,\n    // which in LForms is an attribute of the parent item, not a separate item.\n    let ret = null;\n    let ci = LForms.Util.findObjectInArray(qItem.extension, 'url', self.fhirExtUrlItemControl);\n    let xhtmlFormat;\n    if ( qItem.type === \"display\" && ci) {\n      // only \"redering-xhtml\" is supported. others are default to text\n      if (qItem._text) {\n        xhtmlFormat = LForms.Util.findObjectInArray(qItem._text.extension, 'url', \"http://hl7.org/fhir/StructureDefinition/rendering-xhtml\");\n      }\n\n      // there is a xhtml extension\n      if (xhtmlFormat) {\n        ret = {\n          codingInstructionsFormat: \"html\",\n          codingInstructions: xhtmlFormat.valueString,\n          codingInstructionsPlain: qItem.text  // this always contains the coding instructions in plain text\n        };\n      }\n      // no xhtml extension, default to 'text'\n      else {\n        ret = {\n          codingInstructionsFormat: \"text\",\n          codingInstructions: qItem.text,\n          codingInstructionsPlain: qItem.text // this always contains the coding instructions in plain text\n        };\n      }\n    }\n\n    return ret;\n  };\n\n\n  /**\n   *  Processes the child items of the item.\n   * @param targetItem the LForms node being populated with data\n   * @param qItem the Questionnaire (item) node being imported\n   * @param linkIdItemMap - Map of items from link ID to item from the imported resource.\n   * @param containedVS - contained ValueSet info, see _extractContainedVS() for data format details\n   */\n  self._processChildItems = function(targetItem, qItem, containedVS, linkIdItemMap) {\n    if (Array.isArray(qItem.item)) {\n      targetItem.items = [];\n      for (var i=0; i < qItem.item.length; i++) {\n        var help = self._processCodingInstructions(qItem.item[i]);\n        // pick one coding instruction if there are multiple ones in Questionnaire\n        if (help !== null) {\n          targetItem.codingInstructions = help.codingInstructions;\n          targetItem.codingInstructionsFormat = help.codingInstructionsFormat;\n          targetItem.codingInstructionsPlain = help.codingInstructionsPlain;\n        }\n        else {\n          var item = self._processQuestionnaireItem(qItem.item[i], containedVS, linkIdItemMap);\n          targetItem.items.push(item);\n        }\n      }\n    }\n  };\n\n\n  /**\n   *  Copy extensions that haven't been handled before.\n   *\n   * @param lfItem the LForms node being populated with data\n   * @param qItem the Questionnaire (item) node being imported\n   */\n  self._processExtensions = function(lfItem, qItem) {\n    var extensions = [];\n    if (Array.isArray(qItem.extension)) {\n      for (var i=0; i < qItem.extension.length; i++) {\n        var ext = qItem.extension[i];\n        var extHandler = self.extensionHandlers[ext.url];\n        if ((extHandler && extHandler(ext, lfItem)) ||\n            !self.handledExtensionSet.has(qItem.extension[i].url)) {\n          extensions.push(qItem.extension[i]);\n        }\n      }\n    }\n    if(extensions.length > 0) {\n      lfItem.extension = extensions;\n    }\n  };\n\n\n  /**\n   * If the given entity is an array, it will return the array length, return -1 otherwise.\n   * @param entity the given entity (can be anything) that needs to be tested to see if it's an array\n   * @return {number} the array length or -1 if the given entity is not an array.\n   * @private\n   */\n  self._arrayLen = function(entity) {\n    return entity && Array.isArray(entity)? entity.length: -1;\n  };\n\n\n  /**\n   * Get structural info of a QuestionnaireResponse item.answer.item in a way similar to that of item.item.\n   * If any answer entry in item.answer has items, the qrItemInfo.qrAnswersItemsInfo will be assigned, which\n   * will be an array where each element corresponds to one answer element in item.answer. When an answer entry\n   * does not have any items, null will be used to fill the position.\n   * @param qrItemInfo the structural info of the given item\n   * @param item the item in a QuestionnaireResponse object whose answer.item structure is to be created.\n   * @private\n   */\n  self._checkQRItemAnswerItems = function(qrItemInfo, item) {\n    var answerLen = self._arrayLen(item.answer);\n    if(answerLen < 1) {\n      return;\n    }\n\n    var numAnswersWithItems = 0;\n    var answersItemsInfo = []; // one entry for each answer; each entry is an qrItemsInfo array for the answer.item\n    for (var i = 0; i < answerLen; i++) {\n      if(this._arrayLen(item.answer[i].item) > 0) {\n        answersItemsInfo.push({});\n        self._mergeQR._checkQRItems(answersItemsInfo[i], item.answer[i]);\n        ++ numAnswersWithItems;\n      }\n      else {\n        answersItemsInfo.push(null);\n      }\n    }\n\n    if(numAnswersWithItems > 0) {\n      qrItemInfo.numAnswersWithItems = numAnswersWithItems;\n      qrItemInfo.qrAnswersItemsInfo = answersItemsInfo;\n    }\n  };\n\n\n  /**\n   * Parse questionnaire item for restrictions\n   *\n   * @param lfItem {object} - LForms item object to assign restrictions\n   * @param qItem {object} - Questionnaire item object\n   * @private\n   */\n   self._processRestrictions = function (lfItem, qItem) {\n    var restrictions = {};\n    if(typeof qItem.maxLength !== 'undefined') {\n      restrictions['maxLength'] = qItem.maxLength.toString();\n    }\n\n    for(var i = 0; i < self.fhirExtUrlRestrictionArray.length; i++) {\n      var restriction = LForms.Util.findObjectInArray(qItem.extension, 'url', self.fhirExtUrlRestrictionArray[i]);\n      var val = self._getFHIRValueWithPrefixKey(restriction, /^value/);\n      if (val !== undefined && val !== null) {\n\n        if(restriction.url.match(/minValue$/)) {\n          // TODO -\n          // There is no distinction between inclusive and exclusive.\n          // Lforms looses this information when converting back and forth.\n          restrictions['minInclusive'] = val;\n        }\n        else if(restriction.url.match(/maxValue$/)) {\n          restrictions['maxInclusive'] = val;\n        }\n        else if(restriction.url.match(/minLength$/)) {\n          restrictions['minLength'] = val;\n        }\n        else if(restriction.url.match(/regex$/)) {\n          restrictions['pattern'] = val;\n        }\n      }\n    }\n\n    if(!jQuery.isEmptyObject(restrictions)) {\n      lfItem.restrictions = restrictions;\n    }\n  };\n\n}\n\nexport default addCommonSDCImportFns;\n","var extURL = 'http://hl7.org/fhir/StructureDefinition/rendering-style';\n\n/**\n *  A generic API for processing an extension found on some node in the\n *  Questionnaire structure being imported.\n *  (The parameter list will likely get more complicated in the future.)\n * @param lfNode the node in the LFormsData structure on which the information\n *  from the extension will be stored.\n * @param fieldName the field name  on which the extension was found (e.g.\n *  'item' or 'title').  This forms part of the field name on lfNode where the\n *  data from the extension will be stored.\n * @param extNode the extension's structure with its data.\n */\nfunction processExtension(lfNode, fieldName, extNode) {\n  var css = extNode.valueString;\n  if (css)\n    lfNode['_'+fieldName+'CSS'] = css;\n}\n\nexport default {\n  extURL: extURL,\n  processExtension: processExtension\n};\n","// Processes FHIR Expression Extensions\n// There are three types of expressions: FHIRPath, x-fhir-query (to a FHIR\n// server), and CQL (but we do not yet support CQL).\n// Various extensions have an Expression as a value, such as variable,\n// initialExpression, calculatedExpression, and answerExpression.  When the\n// Expression contains a name, that creates a variable which can be used by\n// other Expressions defined either on the same item or a child item.\n//\n// The general processing pattern is depth-first traversal of the \"tree\" of the\n// Questionnaire's items, and while we go through the expressions we keep track\n// of whether a field has changed and whether a variable has changed.  If there\n// are any changes, we traverse the tree again, but if the only things that\n// changed were variables, then we only have to traverse the parts of the tree\n// for which those variables are in scope.\n//\n// A further complication is that x-fhir-query Expressions require an\n// asynchronous call.  So, after each traversal, we have to wait for those to\n// complete before starting the next traversal (if one is needed).  This is also\n// why the main function, runCalculations, returns a promise that resolves\n// when the expression run has been completed.\n//\n// Also, because there is possibility of asynchronous queries, we have to handle\n// the fact that runCalculations might get called again while before the first\n// call has finished.\n\nexport let ExpressionProcessor;\nconst deepEqual = require('fast-deep-equal'); // faster than JSON.stringify\n\n(function() {\n  \"use strict\";\n  // A class whose instances handle the running of FHIR expressions.\n\n  /**\n   *   Constructor.\n   *  @param lfData an instance of LForms.LFormsData.  The _fhir attribute\n   *   should be set before this is called.\n   */\n  ExpressionProcessor = function(lfData) {\n    // A cache of x-fhir-query URIs to results\n    this._queryCache = {};\n\n    // An array of pending x-fhir-query results\n    this._pendingQueries = [];\n\n    // A hash of calculated values, where the keys are the part of item_.elememntId\n    // minus the final repetition number (so it is shared by instances of\n    // repeating fields).\n    this._calculatedValues = {};\n\n    // A hash of item._elementId values to \"repetition key\" values which can be used as\n    // keys in this._calcualtedValues.\n    this._repetitionKeys = {};\n\n    // Keeps track of whether a request to run the calculations has come in\n    // while we were already busy.\n    this._pendingRun = false;\n\n    // The promise returned by runCalculations, when a run is active.\n    this._currentRunPromise = undefined;\n\n    this._lfData = lfData;\n    if (!lfData._fhir)\n      throw new Error('lfData._fhir should be set');\n    this._fhir = lfData._fhir;\n    this._compiledExpressions = {};\n  };\n\n\n  ExpressionProcessor.prototype = {\n    /**\n     *   Runs the FHIR expressions in the form.  This the main function in this\n     *   module.\n     *  @param includeInitialExpr whether to include the \"initialExpression\"\n     *   expressions (which should only be run once, after asynchronous loads\n     *   from questionnaire-launchContext have been completed).\n     *  @return a Promise that resolves when the expressions have been run, and\n     *   there are no pending runs left to do.\n     */\n    runCalculations: function(includeInitialExpr) {\n      // Defer running calculations while we are waiting for earlier runs to\n      // finish.\n      if (this._currentRunPromise) // then we will just return that promise\n        this._pendingRun = true; // so we know to run them when we can\n      else {\n        this._pendingRun = false; // clear this because we are running them now\n        this._runStart = new Date();\n        // Create an export of Questionnaire for the %questionnaire variable in\n        // FHIRPath.  We only need to do this once per form.\n        var lfData = this._lfData;\n        if (!lfData._fhirVariables.questionnaire) {\n          lfData._fhirVariables.questionnaire =\n            this._fhir.SDC.convertLFormsToQuestionnaire(lfData);\n        }\n        this._regenerateQuestionnaireResp();\n        self = this;\n        this._currentRunPromise =\n          this._asyncRunCalculations(includeInitialExpr, false).then(()=>{\n            // At this point, every promise for the pending queries has been\n            // resolved, and we are done.\n            console.log(\"Ran expressions in \"+(new Date()-self._runStart)+\" ms\");\n            if (!self._firstExpressionRunComplete) // if this is the first run\n              self._firstExpressionRunComplete = true;\n            self._currentRunPromise = undefined;\n            if (self._pendingRun)\n              return self.runCalculations(false); // will set self._currentRunPromise again\n          },\n          (failureReason) => {\n            console.log(\"Run of expressions failed; reason follows\");\n            console.log(failureReason);\n            self._currentRunPromise = undefined;\n            self._pendingRun = false;\n            self._pendingQueries = []; // reset\n            throw failureReason;\n          });\n      }\n      return this._currentRunPromise;\n    },\n\n\n    /**\n     *  Waits for any pending queries.\n     * @return a Promise the resolves when everything is finished, including any\n     *  pending re-run request.  The returned promise will be rejected if something\n     *  goes wrong.\n     * @return the same map about changes as in _evaluateExpressions.\n     */\n    _handlePendingQueries: function() {\n      const self = this;\n      return Promise.allSettled(this._pendingQueries).then(function(results) {\n        self._pendingQueries = []; // reset\n        var varsChanged=false, fieldsChanged=false;\n        for (var i=0, len=results.length;\n             (!varsChanged || !fieldsChanged) && i<len; ++i) {\n          var changes = results[i].value;\n          if (changes) {\n            varsChanged = varsChanged || changes.variables;\n            fieldsChanged = fieldsChanged || changes.fields;\n          }\n          else if (results[i].status == 'rejected')\n            return Promise.reject(results[i].reason);\n        }\n        return {fields: fieldsChanged, variables: varsChanged};\n      });\n    },\n\n\n    /**\n     *  This is conceptually a part of runCalculations, but it is this part of\n     *  it that might need to call itself if fields or variables update.\n     *  The basic algorithm is a depth-first traversal of the items to run their\n     *  expressions.  Some of those might be asynchronous (e.g. x-fhir-query\n     *  variables), so we wait for those to complete before looking at what has\n     *  changed and deciding whether to run the expressions again.\n     * @param includeInitialExpr whether to include the \"initialExpression\"\n     *  expressions (which should only be run once, after asynchronous loads\n     *  from questionnaire-launchContext have been completed).\n     * @param changesByVarsOnly whether to run all field expressions, or just the ones\n     *  that are likely to have been affected by changes from variable expressions.\n     * @return a promise that resolves when all Expressions which needed to be\n     *  processed have been processed and the values have stablized.\n     */\n    _asyncRunCalculations: function(includeInitialExpr, changesByVarsOnly) {\n      const self = this;\n      const lfData = this._lfData;\n      var changes = null; // data about what the calculations changed\n      changes = this._evaluateExpressions(lfData, includeInitialExpr, changesByVarsOnly);\n      // Wait for any asynchronous queries to complete\n      return this._handlePendingQueries().then(function(queryChanges) {\n        // Two types of reported changes are possible -- variables and field values\n        let varsChanged = changes.variables || queryChanges.variables;\n        let fieldsChanged = changes.fields || queryChanges.fields;\n        if (varsChanged || fieldsChanged) {\n          // Run again\n          if (fieldsChanged)\n            self._regenerateQuestionnaireResp();\n          let onlyVarsChanged = !fieldsChanged;\n          return self._asyncRunCalculations(includeInitialExpr, onlyVarsChanged);\n        }\n      });\n    },\n\n\n    /**\n     *  Updates the value of an item's FHIR variable.  If the variable value has changed,\n     *  item._varChanged will be set to true.\n     * @param item the item on which the variable is defined\n     * @param varName the name of the variable\n     * @param newVal the new value of the variable.\n     * @return whether the value changed.\n     */\n    _updateItemVariable: function (item, varName, newVal) {\n      var oldVal = item._fhirVariables[varName];\n      item._fhirVariables[varName] = newVal;\n      if (!deepEqual(oldVal, newVal)) {\n        item._varChanged = true; // flag for re-running expressions.\n      }\n      return item._varChanged;\n    },\n\n\n\n    /**\n     *  Evaluates the expressions for a given item.\n     * @param item an LFormsData or item from LFormsData.\n     * @param includeInitialExpr whether or not to run expressions from\n     *  initialExpression extensions (which should only be run when the form is\n     *  loaded).\n     * @param changesByVarsOnly whether to run all field expressions, or just the ones\n     *  that are likely to have been affected by changes from variable expressions.\n     * @return a map with two fields, \"variables\" and \"fields\", which will be\n     *  present and set to true if the evaluation changed variables (including\n     *  implicit variables created by named expressions of some other\n     *  non-variable type) or field values, respectively.\n     */\n    _evaluateExpressions: function(item, includeInitialExpr, changesByVarsOnly) {\n      var rtn = {};\n      // If changesByVarsOnly, for any item that has _varChanged set, we run any field\n      // expressions that are within that group (or item).\n      if (changesByVarsOnly && item.items && item._varChanged) {\n        item._varChanged = false; // clear flag\n        changesByVarsOnly = false; // clear it, so we process this and all child items\n      }\n      if (!changesByVarsOnly) { // process this and all child items\n        item._varChanged = false; // clear flag in case it was set\n        var fhirExt = item._fhirExt;\n        if (fhirExt) {\n          var sdc = this._fhir.SDC;\n          var exts = item._exprExtensions;\n          if (exts) {\n            var fieldChanged = false;\n            var self = this;\n            for (let i=0, len=exts.length; i<len; ++i) {\n              let ext = exts[i];\n              // Skip initialExpressions if we are not including those.\n              let isInitialExp = ext.url == sdc.fhirExtInitialExp;\n              if (includeInitialExpr || !isInitialExp) {\n                let isCalcExp = ext.url == sdc.fhirExtCalculatedExp;\n                // We only run initialExpression or calculatedExpression\n                // on one of the repeating items of the repeating group (the\n                // last one, because there is a flag to mark the last one).\n                if ((isCalcExp || isInitialExp) && item._questionRepeatable && !item._lastRepeatingItem)\n                  continue; // skip to next expression extension for this item\n\n                // Skip calculated expressions of editable fields for which the user has\n                // edited the value.\n                // Compare the item.value to the last calculated value (if any).  If\n                // they differ, then the user has edited the field, and in that case we\n                // skip setting the value and halt further calculations for the field.\n                var calcVal = this._calculatedValues[this._getRepetitionKey(item)];\n                let currentVals;\n                if (isCalcExp && !item._userModifiedCalculatedValue && calcVal) {\n                  // Get the current values for the item, which might be\n                  // repeating.\n                  currentVals = this._lfData.getItemValues(item);\n                  if (!deepEqual(calcVal, currentVals))\n                    item._userModifiedCalculatedValue = true;\n                }\n\n                if (!isCalcExp || !item._userModifiedCalculatedValue) {\n                  let varName = ext.valueExpression.name; // i.e., a variable name\n                  var itemVars;\n                  if (varName)\n                    itemVars = this._getItemVariables(item); // creates item._fhirVariables if necessary\n                  var oldVal;\n                  let newVal;\n                  var updateValue = false;\n                  if (ext.valueExpression.language==\"text/fhirpath\") {\n                    if (varName) {\n                      // Temporarily delete the old value, so we don't have\n                      // circular references.\n                      oldVal = itemVars[varName];\n                      delete itemVars[varName];\n                    }\n                    newVal = this._evaluateFHIRPath(item,\n                      ext.valueExpression.expression);\n                    updateValue = true;\n                    if (varName)\n                      itemVars[varName] = oldVal; // update handled below\n                  }\n                  else if (ext.valueExpression.language==\"application/x-fhir-query\") {\n                    let queryURL = ext.valueExpression.expression;\n                    // The expression might have embedded FHIRPath in the URI, inside {{...}}\n                    // Use \"undefinedExprVal\" to keep track of whether one of\n                    // the embedded FHIRPath expressions returns undefined (or\n                    // null).\n                    let undefinedExprVal = false;\n                    queryURL = queryURL.replace(/\\{\\{([^}]+)\\}\\}/g, function(match, fpExp) {\n                      // Replace the FHIRPath with the evaluated expressions\n                      let result = self._evaluateFHIRPath(item, fpExp)[0];\n                      if (result === null || result === undefined)\n                        undefinedExprVal = true; // i.e., URL likely not usable\n                      return undefinedExprVal ? '' : '' + result;\n                    });\n                    if (!item._currentFhirQueryURLs)\n                      item._currentFhirQueryURLs = {};\n                    let oldQueryURL = item._currentFhirQueryURLs[varName];\n                    // If queryURL is not a new value, we don't need to do anything\n                    if (queryURL !== oldQueryURL) {\n                      item._currentFhirQueryURLs[varName] = queryURL;\n                      if (undefinedExprVal) {\n                        newVal = undefined;\n                        updateValue = true;\n                      }\n                      else {\n                        // Look for a cached result\n                        if (this._queryCache.hasOwnProperty(queryURL)) {\n                          newVal = this._queryCache[queryURL];\n                          updateValue = true;\n                        }\n                        else { // query not cached\n                          let fetchPromise = this._fetch(queryURL);\n                          // Store the promise that handles the response. We\n                          // will have to wait for it later.\n                          this._pendingQueries.push(fetchPromise.then(function(parsedJSON) {\n                            newVal = (self._queryCache[queryURL] = parsedJSON);\n                          }, function fail(e) {\n                            console.error(\"Unable to load FHIR data from \"+queryURL);\n                          }).then(function() {\n                            // Update the item with the fetched value, and\n                            // update the variable if there was a name defined.\n                            var fChanged = self._updateItemFromExp(\n                              item, ext.url, varName, newVal, isCalcExp, currentVals);\n                            if (varName) {\n                              var vChanged = self._updateItemVariable(item, varName,\n                                newVal);\n                            }\n                            return {fields: fChanged, variables: vChanged};\n                          }));\n                        }\n                      }\n                    }\n                  }\n                  // else CQL (TBD)\n\n                  if (updateValue) {\n                    // Update the item with the fetched value, and\n                    // update the variable if there was a name defined.\n                    var fChanged = this._updateItemFromExp(\n                      item, ext.url, varName, newVal, isCalcExp, currentVals);\n                    fieldChanged = fieldChanged || fChanged;\n                    if (varName)\n                      this._updateItemVariable(item, varName, newVal);\n                  }\n                }\n              }\n            }\n            rtn = {fields: fieldChanged, variables: item._varChanged};\n          }\n        }\n      }\n\n      // Process child items\n      if (item.items) {\n        var childChanges;\n        var childItems = item.items;\n        for (var j=0; j<childItems.length; ++j) { // childItem.length can change as we process expressions\n          // Note:  We need to process all the child items; we cannot do an\n          // early loop exit based on rtn.\n          childChanges = this._evaluateExpressions(item.items[j], includeInitialExpr, changesByVarsOnly);\n          if (childChanges.fields)\n            rtn.fields = true;\n          if (childChanges.variables)\n            rtn.variables = true;\n        }\n      }\n\n      return rtn;\n    },\n\n\n    /**\n     *  Regenerates the QuestionnaireResponse resource and the map from\n     *  LFormsData _elementIDs to items in the QuestionnaireResponse.\n     */\n    _regenerateQuestionnaireResp: function() {\n      var questResp = this._fhir.SDC.convertLFormsToQuestionnaireResponse(this._lfData);\n      this._lfData._fhirVariables.resource = questResp;\n      this._elemIDToQRItem = this._createIDtoQRItemMap(questResp);\n    },\n\n\n    /**\n     *  Returns the nearest ancestor of item (or item itelf) that has\n     *  _fhirVariables defined.\n     * @param item either an LFormsData or an item from an LFormsData.\n     */\n    _itemWithVars: function(item) {\n      var itemWithVars = item;\n      while (!itemWithVars._fhirVariables)\n        itemWithVars = itemWithVars._parentItem; // should terminate at lfData\n      return itemWithVars;\n    },\n\n\n    /**\n     *  Gets or creates if not yet initialized, the item's _fhirVariables\n     *  map (storing its variable values).  This should not be called until it is\n     *  known that the item should have a _fhirVariables map.\n     * @param item either an LFormsData or an item from an LFormsData.\n     * @return the item's _fhirVariables map\n     */\n    _getItemVariables: function(item) {\n      var rtn = item._fhirVariables;\n      if (!rtn) {\n        // Create a hash for variables that will have access to\n        // variables defined higher up in the tree.\n        rtn = item._fhirVariables = Object.create(\n          this._itemWithVars(item)._fhirVariables);\n      }\n      return rtn;\n    },\n\n\n    /**\n     *  Fetches an x-fhir-query URL.\n     * @param queryURL the URL (possibly relative) to fetch.\n     * @return a Promise that resolves to the (parsed) JSON response.\n     */\n    _fetch: function(queryURL) {\n      var fetchPromise;\n      // If the queryURL is a relative URL, then if there is a FHIR\n      // context (set via LForms.Util.setFHIRContext), use that to send\n      // the query; otherwise just use fetch.\n      // Also, set the format to JSON.\n      queryURL += (queryURL.indexOf('?')>0 ? '&' : '?')+'_format=json';\n      if (!/^https?:/.test(queryURL) && LForms.fhirContext?.client) {\n        fetchPromise = LForms.fhirContext.client.request(queryURL);\n      }\n      else {\n        fetchPromise = fetch(queryURL).then(function(response) {\n          return response.json();\n        });\n      }\n      return fetchPromise;\n    },\n\n\n    /**\n     *  Updates an item's data following the run of an expression.\n     * @param item either an LFormsData or an item from an LFormsData.\n     * @param expURL the URL of the expression\n     * @param varName variable name from the expression (if any)\n     * @param newVal the new value of the variable (if any)\n     * @param isCalcExp whether the expression was a calculated expression.\n     *  This could be detected from expURL, but the caller already knows it.\n     * @param currentVals (optional) the current values of item, if known\n     * @return true if the field value changed\n     */\n    _updateItemFromExp(item, expURL, varName, newVal, isCalcExp, currentVals) {\n      var fieldChanged = false;\n      var sdc = this._fhir.SDC;\n      if (isCalcExp || expURL != sdc.fhirExtVariable) {\n        if (expURL == sdc.fhirExtAnswerExp)\n          fieldChanged = this._setItemListFromFHIRPath(item, newVal);\n        else if (expURL == sdc.fhirExtEnableWhenExp) {\n          // The new value should be a boolean.  Coerce it to a boolean, and\n          // report a warning if it was not a boolean.\n          var actualNewVal = newVal[0];\n          newVal = !!actualNewVal;\n          if (newVal !== actualNewVal) {\n            LForms.Util.showWarning('An expression from enableWhenExpression '+\n              'did not resolve to a Boolean as required', item);\n          }\n          if (varName) { // if there is a variable name defined, a change in the value matters\n            var oldVal = !!item._enableWhenExpVal; // _enableWhenExpVal could be undefined\n            fieldChanged = oldVal != newVal;\n          }\n          item._enableWhenExpVal = newVal;\n        }\n        else // else initial or calculated expression\n          fieldChanged = this._setItemValueFromFHIRPath(item, newVal, isCalcExp, currentVals);\n      }\n      return fieldChanged;\n    },\n\n\n    /**\n     *  Evaluates the given FHIRPath expression defined in an extension on the\n     *  given item.\n     * @param item either an LFormsData or an item from an LFormsData.\n     * @param expression the FHIRPath to evaluate with the context of item's\n     *  equivalent node in the QuestionnaireResponse.\n     * @returns the result of the expression.\n     */\n    _evaluateFHIRPath: function(item, expression) {\n      var fhirPathVal;\n      // Find the item-level fhirpathVars\n      var itemVars = this._itemWithVars(item)._fhirVariables;\n      try {\n        // We need to flatten the fhirVariables chain into a simple hash of key/\n        // value pairs.\n        var fVars = {};\n        for (var k in itemVars)\n          fVars[k] = itemVars[k];\n        let contextNode, base;\n        if (item._elementId) {\n          contextNode = this._elemIDToQRItem[item._elementId];\n          contextNode ||= {}; // the item might not be present in the QR if there is no value\n          base = 'QuestionnaireResponse.item';\n        }\n        else {\n          contextNode = this._lfData._fhirVariables.resource;\n        }\n\n        var compiledExpr = this._compiledExpressions[expression];\n        if (!compiledExpr) {\n          if (base)\n            expression = {base, expression};\n          compiledExpr = this._compiledExpressions[expression] =\n            this._fhir.fhirpath.compile(expression, this._fhir.fhirpathModel);\n        }\n        fhirPathVal = compiledExpr(contextNode, fVars);\n      }\n      catch (e) {\n        // Sometimes an expression will rely on data that hasn't been filled in yet.\n        console.log(e);\n      }\n      return fhirPathVal;\n    },\n\n\n    /**\n     *  Returns a hash from the LForms _elementId of each item to the\n     *  corresponding QuestionnaireResponse item.\n     * @param qr the QuestionnaireResponse corresponding to the current\n     * LFormsData.\n     */\n    _createIDtoQRItemMap: function(qr) {\n      var map = {};\n      this._addToIDtoQRItemMap(this._lfData, qr, map);\n      return map;\n    },\n\n\n    /**\n     *  Adds to the map from LFormsData items to QuestionnaireResponse items and\n     *  returns the number of items added.\n     * @param lfItem an LFormsData, or an item within it.\n     * @param qrItem the corresponding QuestionnaireResponse or an item within\n     * it.\n     * @param map the map to which entries will be added.\n     * @return the number of items added to the map.\n     */\n    _addToIDtoQRItemMap: function(lfItem, qrItem, map) {\n      var added = 0;\n      if (lfItem.linkId === qrItem.linkId) {\n        if (lfItem.items) {\n          // lfItem.items might contain items that don't have values, but\n          // qrItem.item will not, so we need to skip the blank items.\n          //\n          // Also, for a repeating question, there will be multiple answers on an\n          // qrItem.item, but repeats of the item in lfItem.items with one answer\n          // each, unless answerCardinality is '*' (list items), in which case\n          // there can be multiple answers per lforms item.\n\n          // LForms does not currently support items that contain both answers\n          // and child items, but I am trying to accomodate that here for the\n          // future.\n          if (qrItem && qrItem.item && qrItem.item.length > 0) {\n            var lfItems = lfItem.items, qrItems = qrItem.item;\n            var numLFItems = lfItems.length;\n            for (var i=0, qrI=0, len=qrItems.length; qrI<len && i<numLFItems; ++qrI) {\n              // Answers are repeated in QR, but items are repeated in LForms\n              var qrIthItem = qrItems[qrI];\n              var lfIthItem = lfItems[i];\n              if (!qrIthItem.answer) {\n                // process item anyway to handle child items with data\n                let newlyAdded = this._addToIDtoQRItemMap(lfIthItem, qrIthItem, map);\n                if (newlyAdded === 0) {\n                  // lfIthItem was blank, so qrIthItem must be for a following\n                  // item.\n                  --qrI; // so we try qrIthItem with the next lfIthItem\n                }\n                else\n                  added += newlyAdded;\n                ++i;\n              }\n              else { // there are answers on the qrIthItem item\n                var numAnswers = qrIthItem.answer ? qrIthItem.answer.length : 0;\n                for (var a=0; a<numAnswers; ++i) {\n                  if (i >= numLFItems)\n                    throw new Error('Logic error in _addToIDtoQRITemMap; ran out of lfItems');\n                  let lfIthItem = lfItems[i];\n                  let newlyAdded = this._addToIDtoQRItemMap(lfIthItem, qrIthItem, map);\n                  if (newlyAdded != 0) { // lfItems[i] was not blank\n                    if (Array.isArray(lfIthItem.value))\n                      a += lfIthItem.value.length;\n                    else\n                      a += 1;\n                  }\n                  added += newlyAdded;\n                }\n              }\n            }\n          }\n        }\n\n        // this item has _elementId and has a value\n        if (lfItem._elementId && (added || lfItem.value !== undefined && lfItem.value !== null && lfItem.value !== \"\")) {\n          if (!qrItem) { // if there is data in lfItem, there should be a qrItem\n            throw new Error('Logic error in _addToIDtoQRItemMap; missing qrItem');\n          }\n          else {\n            map[lfItem._elementId] = qrItem;\n            added += 1;\n          }\n        }\n      }\n      return added;\n    },\n\n\n    /**\n     *  Assigns the given list result to the item.  If the list has changed, the\n     *  field is cleared.\n     * @param list an array of list items computed from a FHIRPath expression.\n     * @return true if the list changed\n     */\n    _setItemListFromFHIRPath: function(item, list) {\n      let currentList = item.answers;\n      let hasCurrentList = !!currentList && Array.isArray(currentList);\n      let listHasData = !!list && Array.isArray(list);\n      let changed = (hasCurrentList != listHasData) ||\n        listHasData && (list.length != currentList.length);\n      let newList = []; // a reformatted version of \"list\"\n      const scoreURI = this._fhir.SDC.fhirExtUrlOptionScore;\n      if (listHasData) {\n        // list should be an array of any item type, including Coding.\n        // (In R5, FHIR will start suppoing lists of types other than Coding.)\n        for (let i=0, len=list.length; i<len; ++i) {\n          // Assume type \"object\" means a coding, and that otherwise what we have\n          // is something useable as display text. It is probably necessary to\n          // convert them to strings in that case, which means that in the future\n          // (R5), we might have to save/re-create the original data type and value.\n          // Work will need to be done to autocomplete-lhc to support data objects\n          // associated with list values.\n          let entry = list[i], newEntry = (newList[i] = {});\n          if (typeof entry === 'object') {\n            let code = entry.code;\n            if (code !== undefined)\n              newEntry.code = code;\n            let display = entry.display;\n            if (display !== undefined)\n              newEntry.text = display;\n            let system = entry.system;\n            if (system !== undefined)\n              newEntry.system = system;\n            // A Coding can have the extension for scores\n            let scoreExt = item._fhirExt && item._fhirExt[scoreURI];\n            if (scoreExt)\n              newEntry.score = scoreExt[0].valueDecimal;\n          }\n          else\n            newEntry.text = '' + entry;\n          if (!changed) {\n            changed = (!hasCurrentList ||\n              !this._lfData._objectEqual(newEntry, currentList[i]));\n          }\n        }\n      }\n\n      if (changed) {\n        item.answers = newList;\n        this._lfData._updateAutocompOptions(item, true);\n        this._lfData._resetItemValueWithModifiedAnswers(item);\n      }\n      return changed;\n    },\n\n\n    /**\n     *  Assigns the given FHIRPath result to the given item.\n     * @param item the item from the LFormsData object that is receiving the new\n     *  value.\n     * @param fhirPathRes the result of a FHIRPath evaluation.\n     * @param isCalcExp whether this is from a calculated expression, in which\n     *  case a decision will be made whether to skip setting the value.\n     * @param oldVal (optional) the item current item values, if known\n     * @return true if the value changed\n     */\n    _setItemValueFromFHIRPath: function(item, fhirPathRes, isCalcExp, oldVal) {\n      if (oldVal === undefined)\n        oldVal = this._lfData.getItemValues(item);\n      // If the FHIRPath expression resulted in an error, fhirPathRes is\n      // undefined.  TBD - show an error to the user.  I think the safest thing\n      // to do here is to leave the item untouched.\n      var changed = false;\n      if (fhirPathRes !== undefined) {\n        var [newVal, messages] = this._fhir.SDC._convertFHIRValues(item, fhirPathRes);\n        var nonEmptyNewVal = newVal.filter(x=>!LForms.Util.isItemValueEmpty(x));\n        const msgSource = 'FHIRPath value expression';\n        changed = !deepEqual(oldVal, nonEmptyNewVal);\n        // If this is the first run of the expressions, and there is\n        // saved user data, then we check whether the calculated value matches\n        // what the user entered (or erased) and if it doesn't, we halt further\n        // calculations for this field and restore the saved value.\n        if (changed && isCalcExp && !this._firstExpressionRunComplete\n            && this._lfData.hasSavedData) {\n          item._userModifiedCalculatedValue = true;\n          changed = false;\n        }\n        else if (changed) {\n          var newLastItem = this._lfData.setRepeatingItems(item, newVal, messages, msgSource);\n        }\n        else { // the messages might have changed\n          this._lfData.setRepeatingItemMessages(item, messages, msgSource);\n        }\n\n        // Store the calculated value.\n        this._calculatedValues[this._getRepetitionKey(item)] = nonEmptyNewVal;\n      }\n      return changed;\n    },\n\n\n    /**\n     *  Returns the key used to store/retrieve the calculated value for a given\n     *  item's repetitions.\n     * @param item an instance of a repeating item.\n     */\n    _getRepetitionKey: function(item) {\n      var rtn = this._repetitionKeys[item._elementId];\n      if (!rtn && item._elementId) {\n        var found = item._elementId.match(/\\/\\d+$/);\n        if (found) {\n          rtn = this._repetitionKeys[item._elementId] = item._elementId.substring(0, found.index);\n        }\n      }\n      return rtn;\n    }\n  };\n\n})();\n","import renderingStyle from './extensions/rendering-style';\nvar extProcessors = {};\nextProcessors[renderingStyle.extURL] = renderingStyle.processExtension;\n\nexport function addCommonRuntimeFns(ns) {\n  var self = ns;\n\n  /**\n   *  Processes the extensions on either lfNode, or lfNode[lfFieldName], if\n   *  lfFieldName is provided.  Only the extensions for which processors\n   *  are written (in the \"extensions\" sub-directory) are considered.\n   * @param lfNode the node in the LFormsData structure on which the information\n   *  from the extension will be stored.\n   * @param lfFieldName (optional).  Sometimes the extension information is on a\n   *  sub-node, (e.g. 'obj_text') in which case this should be the field for\n   *  retrieving that sub-node.\n   */\n  self.processExtensions = function(lfNode, lfFieldName) {\n    var fieldData = lfFieldName ? lfNode[lfFieldName] : lfNode;\n    if (fieldData) {\n      var extensions = fieldData.extension;\n      if (extensions) {\n        for (var i=0, len=extensions.length; i<len; ++i) {\n          var extData = extensions[i];\n          var extURL = extData.url;\n          var processor = extProcessors[extURL];\n          if (processor)\n            processor(lfNode, lfFieldName, extData);\n        }\n      }\n    }\n  };\n}\n","// Initializes the FHIR structure for STU3\nlet fhirVersion = 'STU3';\nif (!LForms.FHIR)\n  LForms.FHIR = {};\nimport {LOINC_URI} from '../fhir-common';\nvar fhir = LForms.FHIR[fhirVersion] = {\n  LOINC_URI: LOINC_URI\n}\nfhir.fhirpath = require('fhirpath');\nfhir.fhirpathModel = require('fhirpath/fhir-context/stu3');\nimport dr from '../diagnostic-report.js';\n// Because we are assigning ./export.js to dr below, we need our own copy of the\n// dr object.\nconst drCopy = Object.assign({}, dr);\nfhir.DiagnosticReport = drCopy;\nimport commonExport from './export.js';\nfhir.DiagnosticReport._commonExport = commonExport;\nimport fhir_sdc from './sdc-export.js';\nfhir.SDC = fhir_sdc;\nfhir.SDC._commonExport = commonExport;\nimport addCommonSDCExportFns from '../sdc-export-common.js'\naddCommonSDCExportFns(fhir.SDC);\nimport addSDCImportFns from './sdc-import.js';\naddSDCImportFns(fhir.SDC);\nimport addCommonSDCFns from '../sdc-common.js';\naddCommonSDCFns(fhir.SDC);\nimport addCommonSDCImportFns from '../sdc-import-common.js';\naddCommonSDCImportFns(fhir.SDC);\nimport { addCommonRuntimeFns } from '../runtime-common.js';\naddCommonRuntimeFns(fhir.SDC);\nimport { ExpressionProcessor } from '../expression-processor.js';\nfhir.SDC.ExpressionProcessor = ExpressionProcessor;\nfhir.SDC.fhirVersion = fhirVersion; // Needed by lfData for fhirpath, etc.\n\nfhir.reservedVarNames = {};\n['context', 'resource'].forEach(function(name) {\n  fhir.reservedVarNames[name] = true;\n});\n\n"],"names":["Token","require","Lexer","Interval","BufferedTokenStream","tokenSource","tokens","index","fetchedEOF","marker","this","seek","lazyInit","adjustSeekIndex","length","LA","EOF","sync","i","n","fetch","t","nextToken","tokenIndex","push","type","start","stop","types","undefined","subset","contains","LT","k","LB","setup","channel","token","nextOnChannel","nextTokenOnChannel","DEFAULT_TOKEN_CHANNEL","from_","to","filterForChannel","prevOnChannel","previousTokenOnChannel","left","right","hidden","getSourceName","interval","fill","s","text","TokenStream","module","exports","CommonToken","CommonTokenFactory","copyText","source","line","column","getText","TokenFactory","DEFAULT","CommonTokenStream","lexer","DEFAULT_CHANNEL","InputStream","data","decodeToUnicodeCodePoints","name","strdata","_index","codePoint","codePointAt","Array","codeUnit","charCodeAt","_size","offset","pos","Math","min","result","String","fromCodePoint","slice","item","toString","IntervalSet","intervals","readOnly","v","INVALID_TYPE","addInterval","l","h","toAdd","clone","existing","splice","max","reduce","other","forEach","current","next","toRemove","removeRange","removeOne","x","value","replace","literalNames","symbolicNames","elemsAreChar","toTokenString","toCharString","toIndexString","names","fromCharCode","join","j","elementName","EPSILON","map","acc","val","Set","BitSet","ATNConfig","RuleStopState","RuleTransition","NotSetTransition","WildcardTransition","AbstractPredicateTransition","predictionContextFromRuleContext","PredictionContext","SingletonPredictionContext","LL1Analyzer","atn","count","transitions","look","alt","lookBusy","_LOOK","transition","target","EMPTY","HIT_PRED","stopState","ctx","r","lookContext","calledRuleStack","seeThruPreds","addEOF","c","state","context","add","addOne","isEmpty","removed","ruleIndex","remove","returnState","states","getReturnState","getParent","constructor","newContext","create","followState","stateNumber","isEpsilon","addRange","MIN_USER_TOKEN_TYPE","maxTokenType","set","label","complement","addSet","Recognizer","RecognitionException","LexerNoViableAltException","input","_input","_factory","_tokenFactorySourcePair","_interp","_token","_tokenStartCharIndex","_tokenStartLine","_tokenStartColumn","_hitEOF","_channel","_type","_modeStack","_mode","DEFAULT_MODE","_text","reset","tokenStartMarker","mark","emitEOF","continueOuter","ttype","SKIP","match","e","console","log","stack","notifyListeners","recover","MORE","emit","release","m","debug","mode","pop","getCharIndex","emitToken","cpos","lpos","eof","msg","getErrorDisplay","getErrorListenerDispatch","syntaxError","d","getErrorDisplayForChar","re","consume","sourceName","HIDDEN","HIDDEN_CHANNEL","MIN_CHAR_VALUE","MAX_CHAR_VALUE","ParseTreeListener","TerminalNode","ErrorNode","DefaultErrorStrategy","ATNDeserializer","ATNDeserializationOptions","TraceListener","parser","ruleNames","node","symbol","_ctx","Parser","_errHandler","_precedenceStack","buildParseTrees","_tracer","_parseListeners","_syntaxErrors","setInputStream","setTrace","getCurrentToken","reportMatch","recoverInline","addErrorNode","_buildParseTrees","listener","idx","indexOf","enterEveryRule","enterRule","reverse","exitRule","exitEveryRule","factory","serializedAtn","getSerializedATN","bypassAltsAtnCache","deserializationOptions","generateRuleBypassTransitions","deserialize","pattern","patternRuleIndex","getTokenStream","ParseTreePatternMatcher","compile","setTokenStream","offendingToken","err","o","getInputStream","hasListener","inErrorRecoveryMode","addTokenNode","invokingState","isErrorNode","visitErrorNode","visitTerminal","parentCtx","addChild","localctx","addContextToParseTree","triggerEnterRuleEvent","triggerExitRuleEvent","altNum","setAltNumber","removeLastChild","precedence","previous","retCtx","parseListeners","getParseListeners","following","nextTokens","rt","getExpectedTokens","ruleName","getRuleIndexMap","p","decisionToDFA","seenOne","dfa","printer","println","decision","print","trace","removeParseListener","addParseListener","RuleContext","Tree","INVALID_INTERVAL","TerminalNodeImpl","ErrorNodeImpl","ParserRuleContext","parent","invokingStateNumber","children","exception","child","badToken","ctxType","getChild","contexts","Hash","Map","equalArrays","cachedHashCode","EMPTY_RETURN_STATE","hash","update","globalNodeCount","id","PredictionContextCache","cache","get","put","hashCode","finish","equals","up","EmptyPredictionContext","ArrayPredictionContext","parents","returnStates","merge","a","b","rootIsWildcard","mergeCache","rootMerge","payloads","mergeRoot","spc","singleParent","apc","a_","mergeSingletons","mergedReturnStates","mergedParents","a_parent","b_parent","payload","M","uniqueParents","containsKey","q","combineCommonParents","mergeArrays","outerContext","getCachedPredictionContext","contextCache","visited","changed","updated","ConsoleErrorListener","ProxyErrorListener","_listeners","INSTANCE","_stateNumber","toolVersion","runtimeVersion","Object","getPrototypeOf","tokenNames","getLiteralNames","getSymbolicNames","getTokenNames","tokenTypeMapCache","ruleIndexMapCache","tokenName","getTokenTypeMap","getOffendingToken","actionIndex","RuleNode","Trees","getChildCount","altNumber","visitor","visitChildren","recog","toStringTree","ri","EMPTY_SOURCE","txt","size","valueToString","arrayToString","isArray","standardEqualsFunction","standardHashCodeFunction","prototype","seed","round","random","pow","h1b","k1","key","remainder","bytes","h1","c1","c2","hashFunction","equalsFunction","values","concat","bits","keys","apply","hashKey","entries","entry","oldValue","AltDict","DoubleDict","defaultMapCtor","cacheMap","arguments","updateHashCode","hashStuff","escapeWhitespace","escapeSpaces","titleCase","str","charAt","toUpperCase","substr","ATN","grammarType","decisionToState","ruleToStartState","ruleToStopState","modeNameToStartState","ruleToTokenType","lexerActions","modeToStartState","LOOK","nextTokenWithinRule","nextTokensInContext","nextTokensNoContext","expected","INVALID_ALT_NUMBER","DecisionState","SemanticContext","checkParams","params","isCfg","semanticContext","reachesIntoOuterContext","props","precedenceFilterSuppressed","config","checkContext","NONE","LexerATNConfig","lexerActionExecutor","passedThroughNonGreedyDecision","checkNonGreedyDecision","hashCodeForConfigSet","equalsForConfigSet","nonGreedy","Utils","hashATNConfig","equalATNConfigs","ATNConfigSet","fullCtx","configLookup","configs","uniqueAlt","conflictingAlts","hasSemanticContext","dipsIntoOuterContext","merged","preds","interpreter","getCachedContext","coll","containsFast","OrderedATNConfigSet","copyFrom","verifyATN","defaultOptions","ATNType","ATNState","BasicState","BlockStartState","BlockEndState","LoopEndState","RuleStartState","TokensStartState","PlusLoopbackState","StarLoopbackState","StarLoopEntryState","PlusBlockStartState","StarBlockStartState","BasicBlockStartState","Transition","AtomTransition","SetTransition","RangeTransition","ActionTransition","EpsilonTransition","PredicateTransition","PrecedencePredicateTransition","LexerActionType","LexerSkipAction","LexerChannelAction","LexerCustomAction","LexerMoreAction","LexerTypeAction","LexerPushModeAction","LexerPopModeAction","LexerModeAction","ADDED_UNICODE_SMP","SUPPORTED_UUIDS","SERIALIZED_UUID","initArray","tmp","options","stateFactories","actionFactories","feature","actualUuid","idx1","checkVersion","checkUUID","readATN","readStates","readRules","readModes","sets","readSets","readInt","bind","isFeatureSupported","uuid","readInt32","readEdges","readDecisions","readLexerActions","markPrecedenceDecisions","PARSER","temp","split","version","readUUID","pair","loopBackStateNumbers","endStateNumbers","nstates","stype","stateFactory","LOOP_END","loopBackStateNumber","endStateNumber","addState","loopBackState","endState","numNonGreedyStates","numPrecedenceStates","isPrecedenceRule","nrules","LEXER","tokenType","nmodes","readUnicode","iset","i1","i2","trans","nedges","src","trg","arg1","arg2","arg3","edgeFactory","addTransition","outermostPrecedenceReturn","startState","ndecisions","decState","actionType","data1","data2","lexerActionFactory","generateRuleBypassTransition","bypassStart","bypassStop","defineDecisionState","excludeTransition","stateIsEndStateFor","matchState","maybeLoopEndState","epsilonOnlyTransitions","isPrecedenceDecision","checkCondition","condition","message","bb","int","byteToHex","RANGE","RULE","PREDICATE","PRECEDENCE","ATOM","ACTION","SET","NOT_SET","WILDCARD","sf","BASIC","RULE_START","BLOCK_START","PLUS_BLOCK_START","STAR_BLOCK_START","TOKEN_START","RULE_STOP","BLOCK_END","STAR_LOOP_BACK","STAR_LOOP_ENTRY","PLUS_LOOP_BACK","af","CHANNEL","CUSTOM","MODE","POP_MODE","PUSH_MODE","TYPE","bth","createByteToHex","DFAState","ATNSimulator","sharedContextCache","ERROR","INVALID_STATE_NUMBER","stateType","serializationNames","LexerActionExecutor","resetSimState","sim","dfaState","SimState","LexerATNSimulator","startIndex","prevAccept","simulator","match_calls","s0","matchATN","execATN","old_mode","s0_closure","computeStartState","suppressEdge","addDFAState","predict","toLexerString","ds0","isAcceptState","captureSimState","getExistingTargetState","computeTargetState","failOrAccept","edges","MIN_DFA_EDGE","MAX_DFA_EDGE","reach","getReachableConfigSet","items","addDFAEdge","accept","prediction","closure","skipAlt","cfg","currentAltReachedAcceptState","getTokenName","getReachableTarget","fixOffsetBeforeMatch","treatEofAsEpsilon","charPos","execute","matches","initialContext","speculative","hasEmptyPath","getEpsilonTarget","serializationType","predIndex","evaluatePredicate","append","sempred","savedcolumn","savedLine","settings","tk","cfgs","proposed","firstConfigWithRuleStopState","newState","setReadonly","tt","dfa_debug","LexerAction","action","isPositionDependent","skip","pushMode","popMode","more","LexerIndexedCustomAction","lexerAction","updatedLexerActions","requiresSeek","stopIndex","numActions","PredPrediction","PredictionMode","NoViableAltException","ParserATNSimulator","predictionMode","LL","_startIndex","_outerContext","_dfa","debug_closure","debug_add","debug_list_atn_decisions","retry_debug","getLookaheadName","precedenceDfa","getPrecedenceStartState","getPrecedence","atnStartState","applyPrecedenceFilter","setPrecedenceStartState","previousD","D","noViableAlt","getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule","requiresFullContext","SLL","predicates","conflictIndex","evalSemanticContext","minValue","reportAttemptingFullContext","execATNWithFullContext","alts","reportAmbiguity","computeReachSet","predictedAlt","getUniqueAlt","altSubSets","getConflictingAltSubsets","allSubsetsConflict","getConflictingAlts","hasSLLConflictTerminatingPrediction","predicateDFAState","getDecisionState","decisionState","nalts","altsToCollectPredsFrom","getConflictingAltsOrUniqueAlt","altToPred","getPredsForAmbigAlts","getPredicatePredictions","foundExactAmbig","resolvesToJustOneViableAlt","LL_EXACT_AMBIG_DETECTION","allSubsetsEqual","getSingleViableAlt","reportContextSensitivity","intermediate","skippedStopStates","closureBusy","removeAllConfigsNotInRuleStopState","hasConfigInRuleStopState","lookToEndOfRule","allConfigsInRuleStopStates","endOfRuleState","statesFromAlt1","configSet","updatedContext","evalPrecedence","ambigAlts","orContext","nPredAlts","pred","pairs","containsPredicate","splitAccordingToSemanticValidity","semValidConfigs","semInvalidConfigs","getAltThatFinishedDecisionEntryRule","succeeded","failed","evaluate","predPredictions","complete","predictions","predicateEvaluationResult","collectPredicates","closureCheckingStopState","depth","parms","getRuleName","closure_","canDropLoopEntryEdgeInLeftRecursiveRule","continueCollecting","newDepth","numCtxs","blockEndStateNum","blockEndState","returnStateNumber","returnStateTarget","inContext","ruleTransition","precedenceTransition","predTransition","actionTransition","pt","getRuleInvocationStack","currentPosition","predSucceeds","getPredicate","newSemCtx","andContext","isCtxDependent","altsets","getAlts","getTokens","nvae","decs","getDeadEndConfigs","error","optimizeConfigs","exact","dup","hasConflictingAltSet","hasStateAssociatedWithOneAlt","hasNonConflictingAltSet","first","all","or","configToAlts","getValues","getStateToAltMap","minAlt","AND","opnds","OR","Predicate","PrecedencePredicate","precpred","operands","precedencePredicates","filterPrecedencePredicates","reduced","from","differs","evaluated","sort","compareTo","serializationTypes","label_","makeLabel","minVocabSymbol","maxVocabSymbol","ruleStart","DFASerializer","LexerDFASerializer","DFA","_states","precedenceState","buf","sortedStates","getStateString","getEdgeLabel","baseStateStr","ErrorListener","DiagnosticErrorListener","exactOnly","recognizer","getDecisionDescription","notifyErrorListeners","reportedAlts","offendingSymbol","delegates","InputMismatchException","FailedPredicateException","ParseCancellationException","errorRecoveryMode","lastErrorIndex","lastErrorStates","nextTokensContext","nextTokenState","endErrorCondition","beginErrorCondition","reportNoViableAlternative","reportInputMismatch","reportFailedPredicate","getMessage","followSet","getErrorRecoverySet","consumeUntil","la","nextTokensState","singleTokenDeletion","reportUnwantedToken","expecting","whatFollowsLoopIterationOrRule","startToken","escapeWSAndQuote","getTokenErrorDisplay","matchedSymbol","singleTokenInsertion","getMissingSymbol","currentSymbolType","reportMissingToken","nextTokenType","tokenText","currentSymbol","expectedTokenType","lookback","getTokenFactory","recoverSet","follow","ErrorStrategy","BailErrorStrategy","Error","captureStackTrace","offendingState","deadEndConfigs","formatMessage","predicate","predicateIndex","defineProperty","object","$defineProperty","position","TypeError","string","Number","second","stringFromCharCode","floor","_","highSurrogate","lowSurrogate","MAX_SIZE","codeUnits","isFinite","RangeError","ParseTree","SyntaxTree","ParseTreeVisitor","visit","ParseTreeWalker","walk","getRuleContext","tree","getNodeText","res","getAltNumber","getPayload","getChildren","list","getAncestors","ancestors","findAllTokenNodes","findAllNodes","findAllRuleNodes","findTokens","nodes","_findAllNodes","descendants","dirtyDate","date","Date","getTime","baseTimezoneOffset","getTimezoneOffset","setSeconds","parse","dirtyAmount","amount","setDate","getDate","addMilliseconds","timestamp","getDaysInMonth","desiredMonth","getMonth","dateWithDesiredMonth","setFullYear","getFullYear","setHours","daysInMonth","setMonth","addDays","addMonths","year","monthIndex","lastDayOfMonth","argument","getTimezoneOffsetInMilliseconds","isDate","MILLISECONDS_IN_HOUR","MILLISECONDS_IN_MINUTE","parseTokenDateTimeDelimeter","parseTokenPlainTime","parseTokenYY","parseTokensYYY","parseTokenYYYY","parseTokensYYYYY","parseTokenMM","parseTokenDDD","parseTokenMMDD","parseTokenWww","parseTokenWwwD","parseTokenHH","parseTokenHHMM","parseTokenHHMMSS","parseTokenTimezone","parseTokenTimezoneZ","parseTokenTimezoneHH","parseTokenTimezoneHHMM","dayOfISOYear","isoYear","week","day","setUTCFullYear","diff","getUTCDay","setUTCDate","getUTCDate","dirtyOptions","additionalDigits","dateStrings","dateString","timeString","array","test","exec","time","timezone","splitDateString","parseYearResult","parseTokenYYY","parseTokenYYYYY","yearString","parseInt","restDateString","centuryString","parseYear","month","dayOfYear","parseDate","hours","minutes","parseFloat","seconds","parseTime","timezoneString","absoluteOffset","parseTimezone","fullTime","fullTimeDate","fullTimeDateNextDay","offsetDiff","equal","RegExp","flags","valueOf","hasOwnProperty","call","choiceTypePaths","pathsDefinedElsewhere","engine","math","equality","util","aggregateMacro","expr","initialValue","total","$index","$total","countFn","sumFn","$this","plus","arraify","minFn","curr","lt","maxFn","gt","avgFn","div","deepEqual","containsImpl","JSON","stringify","in","combineFns","distinctFn","hashObject","union","coll1","coll2","combineFn","intersect","coll1Length","uncheckedLength","coll2hash","nowDate","today","now","timeOfDay","localTimezoneOffset","constants","FP_DateTime","FP_Time","isoStr","isoDateTime","isoDate","isoTime","FP_Type","numbers","pSlice","objectKeys","isArguments","isString","myVar","isNumber","isNaN","normalizeStr","actual","opts","valData","fuzzy","isEquivalent","isEqual","actualIsFPT","expectedIsFPT","equivalentTo","fpt","nonFPT","rtn","checkString","isUndefinedOrNull","ka","kb","objEquiv","y","equivalence","typecheck","assertAtMostOne","lClass","rClass","raiseError","unequal","eq","equival","unequival","a0","b0","compare","lte","gte","whereMacro","misc","subsetOf","c2Hash","some","emptyFn","notFn","singleton","existsMacro","vec","allMacro","len","isTrue","allTrueFn","assertType","anyTrueFn","allFalseFn","anyFalseFn","subsetOfFn","supersetOfFn","isDistinctFn","existence","filtering","aggregate","combining","collections","strings","navigation","datetime","logic","FP_Quantity","ResourceNode","TypeInfo","makeResNode","makeParam","parentData","param","doEval","dataRoot","TypeSpecifier","isNullable","infixInvoke","fnName","rawParams","invoc","invocationTable","fn","paramsNumber","argTypes","arity","tp","pr","nullable","path","applyParsedPath","resource","parsedPath","model","vars","ucum","assign","firstRtn","expression","fhirData","inObjPath","__path__","base","empty","not","exists","allTrue","anyTrue","allFalse","anyFalse","supersetOf","isDistinct","distinct","where","extension","select","selectMacro","sum","avg","single","singleFn","firstFn","last","lastFn","typeFn","ofType","ofTypeFn","is","isFn","tail","tailFn","take","takeFn","skipFn","combine","iif","iifMacro","traceFn","toInteger","toDecimal","toDateTime","toTime","toBoolean","toQuantity","convertsToBoolean","createConvertsToFn","convertsToInteger","convertsToDecimal","convertsToString","convertsToDateTime","convertsToTime","convertsToQuantity","substring","startsWith","endsWith","containsFn","upper","lower","replaceMatches","toChars","abs","ceiling","exp","ln","power","sqrt","truncate","repeat","repeatMacro","amp","minus","mul","mod","intdiv","orOp","andOp","xorOp","impliesOp","InvocationExpression","ch","TermExpression","resourceType","PolarityExpression","sign","terminalNodeText","namespace","identifiers","ExternalConstantTerm","identifier","varName","Identifier","LiteralTerm","term","StringLiteral","submatch","BooleanLiteral","QuantityLiteral","valueNode","unitNode","unit","DateTimeLiteral","dateStr","TimeLiteral","timeStr","NumberLiteral","InvocationTerm","MemberInvocation","isCapitalized","filter","_toAdd","childPath","defPath","actualTypes","field","_data","isSome","IndexerExpression","coll_node","idx_node","idxNum","Functn","realizeParams","args","FunctionInvocation","shift","unshift","doInvoke","ParamList","UnionExpression","ThisInvocation","TotalInvocation","IndexInvocation","OpExpression","AliasOpExpression","op","alias","NullLiteral","ParenthesizedTerm","evalTable","EqualityExpression","InequalityExpression","AdditiveExpression","MultiplicativeExpression","TypeExpression","MembershipExpression","EntireExpression","OrExpression","ImpliesExpression","AndExpression","XorExpression","evaluator","ucumUtils","flatten","url","extensions","unique","newItems","isUnique","$status","$error","num","typeInfo","fromValue","uniqueHash","xObj","xStr","roundToMaxPrecision","prepareObject","toISOString","magnitude","_yearMonthConversionFactor","ucumQuantity","toUcumQuantity","getSpecifiedUnit","property_","magnitude_","obj","FP_TimeBase","ensureNumberSingleton","xs","ys","ceil","num2","degree","trunc","cond","ok","fail","intRegex","isInteger","quantityRegex","quantityRegexMap","toUnit","mapTimeUnitsToUCUMCode","quantityRegexRes","convUnitTo","numRegex","defineTimeConverter","timeType","timeName","trueStrings","falseStrings","lowerCaseValue","toLowerCase","toFunction","singletonEvalByType","toSingleton","prop","numberFns","decimalPlaces","fraction","exponent","roundToDecimalPlaces","scale","prec","codepointat","fromcodepoint","pc","antlr4","serializedATN","decisionsToDFA","ds","FHIRPathLexer","T__0","T__1","T__2","T__3","T__4","T__5","T__6","T__7","T__8","T__9","T__10","T__11","T__12","T__13","T__14","T__15","T__16","T__17","T__18","T__19","T__20","T__21","T__22","T__23","T__24","T__25","T__26","T__27","T__28","T__29","T__30","T__31","T__32","T__33","T__34","T__35","T__36","T__37","T__38","T__39","T__40","T__41","T__42","T__43","T__44","T__45","T__46","T__47","T__48","T__49","T__50","T__51","T__52","T__53","DATETIME","TIME","IDENTIFIER","DELIMITEDIDENTIFIER","STRING","NUMBER","WS","COMMENT","LINE_COMMENT","FHIRPathListener","FHIRPathParser","expression_sempred","EntireExpressionContext","RULE_entireExpression","enterOuterAlt","reportError","_p","_parentctx","_parentState","ExpressionContext","enterRecursionRule","RULE_expression","_la","TermExpressionContext","PolarityExpressionContext","_alt","adaptivePredict","MultiplicativeExpressionContext","pushNewRecursionContext","AdditiveExpressionContext","UnionExpressionContext","InequalityExpressionContext","EqualityExpressionContext","MembershipExpressionContext","AndExpressionContext","OrExpressionContext","ImpliesExpressionContext","InvocationExpressionContext","invocation","IndexerExpressionContext","TypeExpressionContext","typeSpecifier","unrollRecursionContexts","TermContext","RULE_term","InvocationTermContext","LiteralTermContext","literal","ExternalConstantTermContext","externalConstant","ParenthesizedTermContext","LiteralContext","RULE_literal","NullLiteralContext","BooleanLiteralContext","StringLiteralContext","NumberLiteralContext","DateTimeLiteralContext","TimeLiteralContext","QuantityLiteralContext","quantity","ExternalConstantContext","RULE_externalConstant","InvocationContext","RULE_invocation","MemberInvocationContext","FunctionInvocationContext","functn","ThisInvocationContext","IndexInvocationContext","TotalInvocationContext","FunctnContext","RULE_functn","paramList","ParamListContext","RULE_paramList","QuantityContext","RULE_quantity","UnitContext","RULE_unit","dateTimePrecision","pluralDateTimePrecision","DateTimePrecisionContext","RULE_dateTimePrecision","PluralDateTimePrecisionContext","RULE_pluralDateTimePrecision","TypeSpecifierContext","RULE_typeSpecifier","qualifiedIdentifier","QualifiedIdentifierContext","RULE_qualifiedIdentifier","IdentifierContext","RULE_identifier","getTypedRuleContext","getToken","enterEntireExpression","exitEntireExpression","getTypedRuleContexts","enterIndexerExpression","exitIndexerExpression","enterPolarityExpression","exitPolarityExpression","enterAdditiveExpression","exitAdditiveExpression","enterMultiplicativeExpression","exitMultiplicativeExpression","enterUnionExpression","exitUnionExpression","enterOrExpression","exitOrExpression","enterAndExpression","exitAndExpression","enterMembershipExpression","exitMembershipExpression","enterInequalityExpression","exitInequalityExpression","enterInvocationExpression","exitInvocationExpression","enterEqualityExpression","exitEqualityExpression","enterImpliesExpression","exitImpliesExpression","enterTermExpression","exitTermExpression","enterTypeExpression","exitTypeExpression","enterExternalConstantTerm","exitExternalConstantTerm","enterLiteralTerm","exitLiteralTerm","enterParenthesizedTerm","exitParenthesizedTerm","enterInvocationTerm","exitInvocationTerm","enterTimeLiteral","exitTimeLiteral","enterNullLiteral","exitNullLiteral","enterDateTimeLiteral","exitDateTimeLiteral","enterStringLiteral","exitStringLiteral","enterBooleanLiteral","exitBooleanLiteral","enterNumberLiteral","exitNumberLiteral","enterQuantityLiteral","exitQuantityLiteral","enterExternalConstant","exitExternalConstant","enterTotalInvocation","exitTotalInvocation","enterThisInvocation","exitThisInvocation","enterIndexInvocation","exitIndexInvocation","enterFunctionInvocation","exitFunctionInvocation","enterMemberInvocation","exitMemberInvocation","enterFunctn","exitFunctn","enterParamList","exitParamList","enterQuantity","exitQuantity","enterUnit","exitUnit","enterDateTimePrecision","exitDateTimePrecision","enterPluralDateTimePrecision","exitPluralDateTimePrecision","enterTypeSpecifier","exitTypeSpecifier","enterQualifiedIdentifier","exitQualifiedIdentifier","enterIdentifier","exitIdentifier","Listener","errors","rec","sym","col","chars","removeErrorListeners","addErrorListener","entireExpression","PathListener","ast","parentStack","getOwnPropertyNames","parentNode","nodeType","errMsgs","Function","searchString","subjectString","lastIndex","includes","nextSource","nextKey","cachedRegExp","prefix","postfix","dotAllIsSupported","dotAll","regex","entirePattern","cleanPrecedingPart","escaped","lastIndexOfOpenBracket","lastIndexOf","lastIndexOfCloseBracket","repl","reg","escapeStringForRegExp","addMinutes","ucumSystemUrl","timeFormat","timeRE","dateTimeRE","asStr","otherQuantity","compareYearsAndMonths","_compareYearsAndMonths","thisQuantity","normalizedOtherQuantity","convResult","convertUnitTo","status","toVal","ucumUnitCode","getEquivalentUcumUnitCode","otherUcumUnitCode","magnitude1","magnitude2","surroundingApostrophesRegex","_calendarDuration2Seconds","fromUnit","fromYearMonthMagnitude","toYearMonthMagnitude","fromMagnitude","toMagnitude","arithmeticDurationUnits","mapUCUMCodeToTimeUnits","timeQuantity","timeUnit","cls","unitPrecision","_timeUnitToDatePrecision","qVal","isTime","_getPrecision","neededUnit","_datePrecisionToTimeUnit","newQuantity","newDate","timeUnitToAddFn","_getDateObj","precision","newDateStr","otherDateTime","thisPrec","otherPrec","commonPrec","thisUTCStr","otherUTCStr","thisAdj","_getTimeParts","otherAdj","otherTime","thisPrecision","otherPrecision","thisTimeInt","_dateAtPrecision","otherTimeInt","_getMatchData","regEx","maxPrecision","timeMatchData","timeParts","timeZone","sec","ms","dateObj","hour","timezoneOffset","localTimezoneMinutes","timezoneMinutes","timezoneParts","_createDate","getHours","getMinutes","setYear","formatNum","tzOffset","tzSign","tzMin","getSeconds","getMilliseconds","system","code","getResourceNodeData","FHIR","createByValueInNamespace","System","getTypeInfo","collection","errorMsgPrefix","typeList","isFalse","LForms","ucumPkg","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","_OBX_REF_PREFIX","_getFormattedDate","Util","dateToDTMString","_createDiagnosticReportContent","contained","content","resultObj","iLen","subItem","obx","_commonExport","_createObservation","related","ret","jLen","subObxRef","reference","lLen","_convertFromContainedToBundle","dr","bundleType","bundleDr","_convertContainedToTransactionBundle","_convertContainedToCollectionBundle","ref","request","method","kLen","targetObservation","createDiagnosticReport","formData","subject","inBundle","formAndUserData","getFormData","drContent","_getUniqueId","_addVersionTag","createLocalFHIRReference","pruneNulls","_findObxById","refId","_setupItemValueAndUnit","coding","questionCode","dataType","units","valueInteger","qty","valueQuantity","unitName","stringToDTDateISO","valueDate","stringToDate","valueDateTime","itemValue","valueCodeableConcept","display","valueString","answerCardinality","_findTotalRepeatingNum","refIdList","refIds","_checkRepeatingItems","parentObxInfo","parentRefId","diagnosticReport","obxInfoList","repeatingItemInfo","obxIdList","parentObx","itemCode","repeatingInfo","repeatingRefIds","obxInfo","_getReportStructure","reportStructure","_findTheMatchingItemByCodeAndIndex","parentItem","_addRepeatingItems","newItem","deepCopy","_processObxAndItem","_convertFromBundleToContained","containedDr","mergeDiagnosticReportToLForms","LFormsData","hasSavedData","_versionTagStr","setId","_createObsIntValue","valValue","_setFHIRQuantityUnit","itemValues","codeSystem","getCodeSystem","obxs","codeList","question","header","_idCtr","_resTags","meta","tag","_setVersionTag","tags","lformsVersion","self","commonExport","sdcVersion","SDCVersion","QProfile","QRProfile","stdQProfile","stdQRProfile","convertLFormsToQRAndExtracFHIRData","lfData","noExtensions","qr","convertLFormsToQuestionnaireResponse","objPerformers","itemList","_getExtractValue","_hasItemValue","obs","basedOn","authored","effectiveDateTime","issued","author","performer","_processQuestionCardinality","targetItem","questionCardinality","repeats","_handleSpecialConstraints","required","_handleRestrictions","restrictions","extValue","_getAssumedDataTypeForExport","valueKey","_getValueKeyByDataType","_exportMinMax","maxLength","_handleChoiceField","externallyDefined","_handleExternallyDefined","answers","answerValueSet","_fhirExt","fhirExtAnswerExp","option","_handleAnswers","optionArray","answer","ext","score","valueCoding","_handleInitialValues","defaultAnswer","_answerRepeats","answerCodeSystem","fhirQuantity","_makeQuantity","dateValue","dateToDTStringISO","_handleLFormsUnits","fhirExtUrlUnit","_createFhirUnitCoding","defUnit","_getDefaultUnit","default","initialQuantity","_setUnitAttributesToFhirQuantity","fhirUnitExt","fhirExtUrlUnitOption","_handleSkipLogic","skipLogic","enableWhen","conditions","sourceItem","_getSkipLogicSourceItem","enableWhenRule","linkId","trigger","hasAnswer","answerCoding","_copyTriggerCoding","ns","_processRepeatingItemValues","_setResponseFormLevelFields","_processResponseItem","convertLFormsToQuestionnaire","_removeRepeatingItems","_setFormLevelFields","_processItem","_getFhirDataType","_answerRequired","minOccurInt","_processQuestionAndAnswerCardinality","_handleItemControl","_isHiddenInDef","valueBoolean","extField","extFieldData","editable","_handleTerminologyServer","_handleDataControl","codingInstructions","helpItem","codingInstructionsPlain","codingInstructionsFormat","maxAttachmentSize","exts","fhirExtMaxSize","valueDecimal","allowedAttachmentTypes","fhirExtMimeType","valueCode","copyFields","itemLevelIgnoredFields","maxOccurs","qCard","aCard","qCardMax","aCardMax","intQCardMax","intACardMax","fhirExtUrlCardinalityMax","dataControl","_id","formLevelFields","shortName","title","obj_title","_title","profile","itemControlDisplay","answerChoiceOrientation","itemControlType","jQuery","isEmptyObject","displayControl","answerLayout","questionLayout","isSearchAutocomplete","columns","terminologyServer","fhirExtTerminologyServer","_lformsTypesToFHIRTypes","_makeValueQuantity","itemUnit","unitSystem","floatValue","itemUnits","defaultUnit","lformsUnits","_lformsTypesToFHIRFields","_MIN_MAX_TYPES","_MIN_MAX_KEYS","minMaxKey","isoDateStr","fhirValue","_skipLogicValueDataTypes","_createEnableWhenRulesForSkipLogicCondition","skipLogicCondition","sourceDataType","sourceValueKey","enableWhenRules","operator","_operatorMapping","triggerValue","rule","answerBoolean","lfUnit","_lfItemValueToFhirAnswer","_setIfHasValue","_lfHasSubItems","lfItem","isForm","fhirItems","lfSubItem","_isProcessed","_repeatingItems","fhirItem","rpt","rptItem","tmpFhirItem","_questionRepeats","currentItem","fhirExtObsExtract","_parentItem","_skipLogicStatus","isItemValueEmpty","fhirExtUrlOptionScore","fhirExtUrlValueSetScore","_extractContainedVS","questionnaire","answersVS","vs","expansion","answersFromVS","lfVS","_processQuestionnaireItem","qItem","containedVS","linkIdItemMap","_processDataType","_processTextAndPrefix","_processCodeAndLinkId","codes","_processDisplayItemCode","_processEditable","_processFHIRQuestionAndAnswerCardinality","_processDisplayControl","_processDataControl","_processRestrictions","_processHiddenItem","_processUnitList","findObjectInArray","fhirExtUrlOptionPrefix","argonautExtUrlExtensionScore","optionKey","_processAnswers","_processDefaultAnswer","fhirExtUrlExternallyDefined","valueUri","_processExternallyDefined","_processTerminologyServer","_getDataType","_getFHIRValueWithPrefixKey","_processSkipLogic","_processExtensions","_processChildItems","ci","fhirExtUrlHidden","initialCoding","_processFHIRValues","getFirstInitialQuantity","_mergeQR","_getQRStructure","qrInfo","qrItemsInfo","_checkQRItems","parentQRItemInfo","parentQRItem","repeatingItemProcessed","repeatingItems","qrItemInfo","_checkQRItemAnswerItems","_findTheMatchingItemByLinkIdAndIndex","_findTheMatchingItemByLinkId","requestLinkedObs","fhirContext","client","_fhir","_serverFHIRReleaseID","pendingPromises","validateFHIRVersion","serverFHIR","obsLinkURI","SDC","fhirExtObsLinkPeriod","obsExt","duration","valueDuration","fhirClient","queryParams","LOINC_URI","_sort","_count","UcumLhcUtils","getInstance","patient","_buildURL","then","successData","bundle","foundObs","focus","importObsValue","_setUnitDisplay","Promise","resolve","reject","getServerFHIRReleaseID","relID","_questionRepeatable","_multipleAnswers","fieldList","UCUM_URI","srcCoding","dstCoding","lforms2Fhir","srcTextField","dstTextField","hasResponsiveExpression","itemOrLFData","fhirExtCalculatedExp","fhirExtEnableWhenExp","hasListExpression","hasInitialExpression","fhirExtInitialExp","buildExtensionMap","isExpressionExtension","fhirExtVariable","exprExtensions","extArray","_exprExtensions","loadLaunchContext","contextItems","fhirExtLaunchContext","contextsFromServer","Patient","encounter","Encounter","user","Practitioner","PractitionerRole","RelatedPerson","addIfValid","resType","permittedTypes","warn","restype","_fhirVariables","contextItemExt","fieldExt","valueId","_checkFHIRVarName","fromMap","contextResource","read","reason","errorMessages","_internalUtil","fhirExtUrlCardinalityMin","fhirExtUrlItemControl","fhirExtUrlMinValue","fhirExtUrlMaxValue","fhirExtUrlMinLength","fhirExtUrlRegex","fhirExtUrlAnswerRepeats","fhirExtUrlDataControl","fhirExtChoiceOrientation","fhirExtUrlRestrictionArray","handledExtensionSet","extensionHandlers","convertQuestionnaireToLForms","baseFormDef","_processFormLevelFields","_createLinkIdItemMap","fhirVersion","codeAndSystemObj","_getCode","_significantDigits","wholeNum","lfDataType","fhirValType","unitOkay","matchingUnit","valSystem","ucumUnit","isUCUMUnit","originalSD","toPrecision","_convertFHIRValues","fhirVals","forDefault","messages","fhirVal","hasMessages","codings","itemAnswers","_modifiedAnswers","listAnswer","listAnswerSystem","_processCWECNEValueInQR","_notOnList","_displayText","comparator","addMsg","setDefault","_hasMultipleAnswers","setItemMessagesArray","assignValueToItem","keyRegex","matchData","questionCodeSystem","lformsDefaultUnit","unitOption","lUnit","initialQ","findItem","dataControlType","qrImport","mergeQuestionnaireResponseToLForms","_processQRItemAndLFormsItem","parentLFormsItem","qrItem","defItem","newQRItemInfo","qrAnswersItemsInfo","qrAnswer","qrValue","valueAttachment","qResource","traverse","itemArray","questionnaireItemOrResource","_toLfCodeSystem","valueSet","vsItem","ordExt","tServer","valueUrl","_getTerminologyServer","_getExpansionURL","loadAnswerValueSets","expURL","vsKey","_answerValueSetKey","_valueSetAnswerCache","_updateAutocompOptions","response","json","parsedJSON","errorOrFatal","issue","find","severity","diagnostics","catch","qrItemValue","retValue","sysetm","_processCodingInstructions","xhtmlFormat","help","extHandler","has","_arrayLen","entity","answerLen","numAnswersWithItems","answersItemsInfo","restriction","ExpressionProcessor","lfNode","fieldName","extNode","css","extProcessors","renderingStyle","_queryCache","_pendingQueries","_calculatedValues","_repetitionKeys","_pendingRun","_currentRunPromise","_lfData","_compiledExpressions","runCalculations","includeInitialExpr","_runStart","_regenerateQuestionnaireResp","_asyncRunCalculations","_firstExpressionRunComplete","failureReason","_handlePendingQueries","allSettled","results","varsChanged","fieldsChanged","changes","variables","fields","changesByVarsOnly","_evaluateExpressions","queryChanges","onlyVarsChanged","_updateItemVariable","newVal","oldVal","_varChanged","sdc","fieldChanged","isInitialExp","currentVals","isCalcExp","_lastRepeatingItem","calcVal","_getRepetitionKey","_userModifiedCalculatedValue","getItemValues","valueExpression","itemVars","_getItemVariables","updateValue","language","_evaluateFHIRPath","queryURL","undefinedExprVal","fpExp","_currentFhirQueryURLs","oldQueryURL","fetchPromise","_fetch","fChanged","_updateItemFromExp","vChanged","childChanges","childItems","questResp","_elemIDToQRItem","_createIDtoQRItemMap","_itemWithVars","itemWithVars","_setItemListFromFHIRPath","actualNewVal","showWarning","_enableWhenExpVal","_setItemValueFromFHIRPath","fhirPathVal","contextNode","fVars","_elementId","compiledExpr","fhirpath","fhirpathModel","_addToIDtoQRItemMap","added","lfItems","qrItems","numLFItems","qrI","qrIthItem","lfIthItem","numAnswers","newlyAdded","currentList","hasCurrentList","listHasData","newList","scoreURI","newEntry","scoreExt","_objectEqual","_resetItemValueWithModifiedAnswers","fhirPathRes","nonEmptyNewVal","msgSource","setRepeatingItems","setRepeatingItemMessages","found","fhir","drCopy","DiagnosticReport","fhir_sdc","addCommonSDCExportFns","addSDCImportFns","addCommonSDCFns","addCommonSDCImportFns","processExtensions","lfFieldName","fieldData","extData","extURL","processor","reservedVarNames"],"sourceRoot":""}