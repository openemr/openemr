{"version":3,"file":"lformsFHIR.min.js","mappings":"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CA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,gBACA,eACA,eACA,eACA,iBACA,gBACA,eACA,eACA,eACA,eACA,iBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,gBACA,gBACA,iBACA,eACA,eACA,eACA,eACA,eACA,iBACA,kBACA,iBACA,eACA,eACA,gBACA,eACA,gBACA,eACA,eACA,eACA,eACA,eACA,eACA,iBACA,gBACA,gBACA,gBACA,gBACA,eACA,iBACA,eACA,gBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,iBACA,eACA,iBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,eACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,iBACA,eACA,iBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,gBACA,gBACA,kBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,iBACA,eACA,iBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,gBACA,gBACA,iBACA,gBACA,gBACA,gBACA,oBACA,iBACA,kBACA,iBACA,iBACA,gBACA,eACA,eACA,eACA,eACA,gBACA,eACA,kBACA,iBACA,iBACA,kBACA,mBACA,iBACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,kBACA,kBACA,mBACA,eACA,eACA,gBACA,gBACA,eACA,eACA,eACA,eACA,iBACA,eACA,eACA,eACA,gBACA,gBACA,gBACA,eACA,eACA,eACA,gBACA,gBACA,eACA,eACA,iBACA,eACA,eACA,eACA,mBACA,eACA,eACA,iBACA,gBACA,eACA,gBACA,eACA,eACA,eACA,eACA,iBACA,gBACA,kBACA,eACA,eACA,iBACA,eACA,mBACA,eACA,eACA,gBACA,gBACA,iBACA,eACA,eACA,YAAoDz+C,KAAK,IAGvDmB,GAAM,IAAIq9C,EAAOr9C,IAAI0G,iBAAkBoC,YAAYw0C,GAEnDC,EAAiBv9C,EAAI6U,gBAAgB5V,KAAK,SAACu+C,EAAI/lD,GAAL,OAAe,IAAI4lD,EAAO9xC,IAAImlB,IAAI8sB,EAAI/lD,EAAtC,IAE1CgmD,EAAAA,SAAAA,I,4SAqCF,WAAY16C,GAAO,a,4FAAA,UACf,cAAMA,IACDI,QAAU,IAAIk6C,EAAOr9C,IAAIoiB,kBAAf,KAAuCpiB,EAAKu9C,EAAgB,IAAIF,EAAO9vC,wBAFvE,CAGlB,C,8BAED,WACI,OAAOvN,CACV,M,gFA5CCy9C,CAAsBJ,EAAOjmD,O,EAA7BqmD,EAAAA,kBAEuB,e,EAFvBA,EAAAA,eAGoB,CAAE,wBAAyB,W,EAH/CA,EAAAA,YAIc,CAAE,iB,EAJhBA,EAAAA,eAKiB,CAAE,KAAM,MAAO,MAAO,MAAO,MAAO,MAAO,MACzC,MAAO,QAAS,QAAS,MAAO,MAAO,OACvC,MAAO,MAAO,OAAQ,OAAQ,OAAQ,MAAO,MAC7C,OAAQ,OAAQ,OAAQ,aAAc,QACtC,OAAQ,QAAS,YAAa,MAAO,MAAO,MAC5C,MAAO,SAAU,UAAW,MAAO,UAAW,WAC9C,WAAY,MAAO,SAAU,UAAW,SACxC,QAAS,SAAU,WAAY,WAAY,gBAC3C,UAAW,WAAY,UAAW,SAAU,UAC5C,YAAa,YAAa,mB,EAd7CA,EAAAA,gBAekB,CAAE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,WAC1C,OAAQ,aAAc,sBAAuB,SAC7C,SAAU,KAAM,UAAW,iB,EAvB/CA,EAAAA,YAwBc,CAAE,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAChD,OAAQ,OAAQ,OAAQ,QAAS,QAAS,QAC1C,QAAS,QAAS,QAAS,QAAS,QAAS,QAC7C,QAAS,QAAS,QAAS,QAAS,QAAS,QAC7C,QAAS,QAAS,QAAS,QAAS,QAAS,QAC7C,QAAS,QAAS,QAAS,QAAS,QAAS,QAC7C,QAAS,QAAS,QAAS,QAAS,QAAS,QAC7C,QAAS,QAAS,QAAS,QAAS,QAAS,QAC7C,QAAS,QAAS,QAAS,QAAS,QAAS,WAC7C,OAAQ,aAAc,aAAc,sBACpC,SAAU,SAAU,KAAM,UAAW,eACrC,MAAO,UAAW,QAYxCA,EAAcvlD,IAAMmlD,EAAOnmD,MAAMgB,IACjCulD,EAAcC,KAAO,EACrBD,EAAcE,KAAO,EACrBF,EAAcG,KAAO,EACrBH,EAAcI,KAAO,EACrBJ,EAAcK,KAAO,EACrBL,EAAcM,KAAO,EACrBN,EAAcO,KAAO,EACrBP,EAAcQ,KAAO,EACrBR,EAAcS,KAAO,EACrBT,EAAcU,KAAO,GACrBV,EAAcW,MAAQ,GACtBX,EAAcY,MAAQ,GACtBZ,EAAca,MAAQ,GACtBb,EAAcc,MAAQ,GACtBd,EAAce,MAAQ,GACtBf,EAAcgB,MAAQ,GACtBhB,EAAciB,MAAQ,GACtBjB,EAAckB,MAAQ,GACtBlB,EAAcmB,MAAQ,GACtBnB,EAAcoB,MAAQ,GACtBpB,EAAcqB,MAAQ,GACtBrB,EAAcsB,MAAQ,GACtBtB,EAAcuB,MAAQ,GACtBvB,EAAcwB,MAAQ,GACtBxB,EAAcyB,MAAQ,GACtBzB,EAAc0B,MAAQ,GACtB1B,EAAc2B,MAAQ,GACtB3B,EAAc4B,MAAQ,GACtB5B,EAAc6B,MAAQ,GACtB7B,EAAc8B,MAAQ,GACtB9B,EAAc+B,MAAQ,GACtB/B,EAAcgC,MAAQ,GACtBhC,EAAciC,MAAQ,GACtBjC,EAAckC,MAAQ,GACtBlC,EAAcmC,MAAQ,GACtBnC,EAAcoC,MAAQ,GACtBpC,EAAcqC,MAAQ,GACtBrC,EAAcsC,MAAQ,GACtBtC,EAAcuC,MAAQ,GACtBvC,EAAcwC,MAAQ,GACtBxC,EAAcyC,MAAQ,GACtBzC,EAAc0C,MAAQ,GACtB1C,EAAc2C,MAAQ,GACtB3C,EAAc4C,MAAQ,GACtB5C,EAAc6C,MAAQ,GACtB7C,EAAc8C,MAAQ,GACtB9C,EAAc+C,MAAQ,GACtB/C,EAAcgD,MAAQ,GACtBhD,EAAciD,MAAQ,GACtBjD,EAAckD,MAAQ,GACtBlD,EAAcmD,MAAQ,GACtBnD,EAAcoD,MAAQ,GACtBpD,EAAcqD,MAAQ,GACtBrD,EAAcsD,MAAQ,GACtBtD,EAAcuD,SAAW,GACzBvD,EAAcwD,KAAO,GACrBxD,EAAcyD,WAAa,GAC3BzD,EAAc0D,oBAAsB,GACpC1D,EAAc2D,OAAS,GACvB3D,EAAc4D,OAAS,GACvB5D,EAAc6D,GAAK,GACnB7D,EAAc8D,QAAU,GACxB9D,EAAc+D,aAAe,GAK7B/mD,EAAOC,QAAU+iD,C,g7CC5bjB,IAGMgE,EAAAA,SAAAA,I,oZAGL,SAAsB7gD,GACrB,G,kCAGD,SAAqBA,GACpB,G,oCAID,SAAuBA,GACtB,G,mCAGD,SAAsBA,GACrB,G,qCAID,SAAwBA,GACvB,G,oCAGD,SAAuBA,GACtB,G,qCAID,SAAwBA,GACvB,G,oCAGD,SAAuBA,GACtB,G,2CAID,SAA8BA,GAC7B,G,0CAGD,SAA6BA,GAC5B,G,kCAID,SAAqBA,GACpB,G,iCAGD,SAAoBA,GACnB,G,+BAID,SAAkBA,GACjB,G,8BAGD,SAAiBA,GAChB,G,gCAID,SAAmBA,GAClB,G,+BAGD,SAAkBA,GACjB,G,uCAID,SAA0BA,GACzB,G,sCAGD,SAAyBA,GACxB,G,uCAID,SAA0BA,GACzB,G,sCAGD,SAAyBA,GACxB,G,uCAID,SAA0BA,GACzB,G,sCAGD,SAAyBA,GACxB,G,qCAID,SAAwBA,GACvB,G,oCAGD,SAAuBA,GACtB,G,oCAID,SAAuBA,GACtB,G,mCAGD,SAAsBA,GACrB,G,iCAID,SAAoBA,GACnB,G,gCAGD,SAAmBA,GAClB,G,iCAID,SAAoBA,GACnB,G,gCAGD,SAAmBA,GAClB,G,iCAID,SAAoBA,GACnB,G,gCAGD,SAAmBA,GAClB,G,8BAID,SAAiBA,GAChB,G,6BAGD,SAAgBA,GACf,G,uCAID,SAA0BA,GACzB,G,sCAGD,SAAyBA,GACxB,G,oCAID,SAAuBA,GACtB,G,mCAGD,SAAsBA,GACrB,G,8BAID,SAAiBA,GAChB,G,6BAGD,SAAgBA,GACf,G,iCAID,SAAoBA,GACnB,G,gCAGD,SAAmBA,GAClB,G,gCAID,SAAmBA,GAClB,G,+BAGD,SAAkBA,GACjB,G,gCAID,SAAmBA,GAClB,G,+BAGD,SAAkBA,GACjB,G,kCAID,SAAqBA,GACpB,G,iCAGD,SAAoBA,GACnB,G,8BAID,SAAiBA,GAChB,G,6BAGD,SAAgBA,GACf,G,kCAID,SAAqBA,GACpB,G,iCAGD,SAAoBA,GACnB,G,mCAID,SAAsBA,GACrB,G,kCAGD,SAAqBA,GACpB,G,mCAID,SAAsBA,GACrB,G,kCAGD,SAAqBA,GACpB,G,qCAID,SAAwBA,GACvB,G,oCAGD,SAAuBA,GACtB,G,iCAID,SAAoBA,GACnB,G,gCAGD,SAAmBA,GAClB,G,kCAID,SAAqBA,GACpB,G,iCAGD,SAAoBA,GACnB,G,kCAID,SAAqBA,GACpB,G,iCAGD,SAAoBA,GACnB,G,yBAID,SAAYA,GACX,G,wBAGD,SAAWA,GACV,G,4BAID,SAAeA,GACd,G,2BAGD,SAAcA,GACb,G,2BAID,SAAcA,GACb,G,0BAGD,SAAaA,GACZ,G,uBAID,SAAUA,GACT,G,sBAGD,SAASA,GACR,G,oCAID,SAAuBA,GACtB,G,mCAGD,SAAsBA,GACrB,G,0CAID,SAA6BA,GAC5B,G,yCAGD,SAA4BA,GAC3B,G,gCAID,SAAmBA,GAClB,G,+BAGD,SAAkBA,GACjB,G,sCAID,SAAyBA,GACxB,G,qCAGD,SAAwBA,GACvB,G,6BAID,SAAgBA,GACf,G,4BAGD,SAAeA,GACd,M,gFAhXI6gD,CAHStqD,EAAQ,MAGeg/B,KAAK7vB,mBAqX3C7L,EAAOC,QAAU+mD,C,qvECxXjB,IAAMpE,EAASlmD,EAAQ,MACjBsqD,EAAmBtqD,EAAQ,MAE3BmmD,EAAgB,CAAC,WACnB,mBACA,qBACA,sCACA,yBACA,eACA,iBACA,eACA,eACA,eACA,eACA,eACA,eACA,qBACA,gBACA,gBACA,iBACA,iBACA,mBACA,gCACA,oCACA,qBACA,qBACA,kBACA,gBACA,oBACA,iBACA,kBACA,eACA,mBACA,kBACA,kBACA,oBACA,eACA,eACA,eACA,eACA,kBACA,oBACA,uBACA,kBACA,+BACA,0BACA,0BACA,yBACA,yBACA,qBACA,qBACA,yBACA,qBACA,uBACA,oBACA,0BACA,oBACA,oBACA,kBACA,oBACA,oBACA,mBACA,oBACA,yBACA,oBACA,kBACA,oBACA,yBACA,wBACA,sBACA,kBACA,oBACA,qBACA,oBACA,kBACA,uBACA,oBACA,oBACA,oBACA,oBACA,oBACA,gBACA,oBACA,gBACA,eACA,eACA,gBACA,eACA,kBACA,eACA,eACA,iBACA,kBACA,eACA,eACA,eACA,eACA,eACA,eACA,wBACA,QAA4Bz+C,KAAK,IAG/BmB,GAAM,IAAIq9C,EAAOr9C,IAAI0G,iBAAkBoC,YAAYw0C,GAEnDC,EAAiBv9C,EAAI6U,gBAAgB5V,KAAK,SAACu+C,EAAI/lD,GAAL,OAAe,IAAI4lD,EAAO9xC,IAAImlB,IAAI8sB,EAAI/lD,EAAtC,IAE1CiqB,EAAqB,IAAI27B,EAAO9vC,uBAEhCm0C,EAAAA,SAAAA,G,kBA4BF,WAAY3+C,GAAO,wBACf,cAAMA,IACDI,QAAU,IAAIk6C,EAAOr9C,IAAIinB,mBAAf,KAAwCjnB,EAAKu9C,EAAgB77B,GAC5E,EAAK5a,UAAY46C,EAAe56C,UAChC,EAAKzI,aAAeqjD,EAAerjD,aACnC,EAAKC,cAAgBojD,EAAepjD,cALrB,CAMlB,C,2BAED,WACI,OAAO0B,CACV,G,qBAED,SAAQkK,EAAUzI,EAAWyjB,GAC5B,GACK,IADEzjB,EAED,OAAO7J,KAAK+pD,mBAAmBz3C,EAAUgb,GAExC,KAAM,2BAA6BzjB,CAE1C,G,gCAED,SAAmByI,EAAUgb,GAC5B,OAAOA,GACN,KAAK,EACJ,OAAOttB,KAAK43B,SAAS53B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","sources":["webpack://lforms/./node_modules/antlr4/src/antlr4/BufferedTokenStream.js","webpack://lforms/./node_modules/antlr4/src/antlr4/CommonTokenFactory.js","webpack://lforms/./node_modules/antlr4/src/antlr4/CommonTokenStream.js","webpack://lforms/./node_modules/antlr4/src/antlr4/InputStream.js","webpack://lforms/./node_modules/antlr4/src/antlr4/IntervalSet.js","webpack://lforms/./node_modules/antlr4/src/antlr4/LL1Analyzer.js","webpack://lforms/./node_modules/antlr4/src/antlr4/Lexer.js","webpack://lforms/./node_modules/antlr4/src/antlr4/Parser.js","webpack://lforms/./node_modules/antlr4/src/antlr4/ParserRuleContext.js","webpack://lforms/./node_modules/antlr4/src/antlr4/PredictionContext.js","webpack://lforms/./node_modules/antlr4/src/antlr4/Recognizer.js","webpack://lforms/./node_modules/antlr4/src/antlr4/RuleContext.js","webpack://lforms/./node_modules/antlr4/src/antlr4/Token.js","webpack://lforms/./node_modules/antlr4/src/antlr4/Utils.js","webpack://lforms/./node_modules/antlr4/src/antlr4/atn/ATN.js","webpack://lforms/./node_modules/antlr4/src/antlr4/atn/ATNConfig.js","webpack://lforms/./node_modules/antlr4/src/antlr4/atn/ATNConfigSet.js","webpack://lforms/./node_modules/antlr4/src/antlr4/atn/ATNDeserializationOptions.js","webpack://lforms/./node_modules/antlr4/src/antlr4/atn/ATNDeserializer.js","webpack://lforms/./node_modules/antlr4/src/antlr4/atn/ATNSimulator.js","webpack://lforms/./node_modules/antlr4/src/antlr4/atn/ATNState.js","webpack://lforms/./node_modules/antlr4/src/antlr4/atn/ATNType.js","webpack://lforms/./node_modules/antlr4/src/antlr4/atn/LexerATNSimulator.js","webpack://lforms/./node_modules/antlr4/src/antlr4/atn/LexerAction.js","webpack://lforms/./node_modules/antlr4/src/antlr4/atn/LexerActionExecutor.js","webpack://lforms/./node_modules/antlr4/src/antlr4/atn/ParserATNSimulator.js","webpack://lforms/./node_modules/antlr4/src/antlr4/atn/PredictionMode.js","webpack://lforms/./node_modules/antlr4/src/antlr4/atn/SemanticContext.js","webpack://lforms/./node_modules/antlr4/src/antlr4/atn/Transition.js","webpack://lforms/./node_modules/antlr4/src/antlr4/atn/index.js","webpack://lforms/./node_modules/antlr4/src/antlr4/dfa/DFA.js","webpack://lforms/./node_modules/antlr4/src/antlr4/dfa/DFASerializer.js","webpack://lforms/./node_modules/antlr4/src/antlr4/dfa/DFAState.js","webpack://lforms/./node_modules/antlr4/src/antlr4/dfa/index.js","webpack://lforms/./node_modules/antlr4/src/antlr4/error/DiagnosticErrorListener.js","webpack://lforms/./node_modules/antlr4/src/antlr4/error/ErrorListener.js","webpack://lforms/./node_modules/antlr4/src/antlr4/error/ErrorStrategy.js","webpack://lforms/./node_modules/antlr4/src/antlr4/error/Errors.js","webpack://lforms/./node_modules/antlr4/src/antlr4/error/index.js","webpack://lforms/./node_modules/antlr4/src/antlr4/polyfills/codepointat.js","webpack://lforms/./node_modules/antlr4/src/antlr4/polyfills/fromcodepoint.js","webpack://lforms/./node_modules/antlr4/src/antlr4/tree/Tree.js","webpack://lforms/./node_modules/antlr4/src/antlr4/tree/Trees.js","webpack://lforms/./node_modules/antlr4/src/antlr4/tree/index.js","webpack://lforms/./node_modules/call-bind/callBound.js","webpack://lforms/./node_modules/call-bind/index.js","webpack://lforms/./node_modules/date-fns/_lib/getTimezoneOffsetInMilliseconds/index.js","webpack://lforms/./node_modules/date-fns/add_days/index.js","webpack://lforms/./node_modules/date-fns/add_hours/index.js","webpack://lforms/./node_modules/date-fns/add_milliseconds/index.js","webpack://lforms/./node_modules/date-fns/add_minutes/index.js","webpack://lforms/./node_modules/date-fns/add_months/index.js","webpack://lforms/./node_modules/date-fns/add_seconds/index.js","webpack://lforms/./node_modules/date-fns/add_weeks/index.js","webpack://lforms/./node_modules/date-fns/add_years/index.js","webpack://lforms/./node_modules/date-fns/get_days_in_month/index.js","webpack://lforms/./node_modules/date-fns/is_date/index.js","webpack://lforms/./node_modules/date-fns/parse/index.js","webpack://lforms/./node_modules/deep-equal/index.js","webpack://lforms/./node_modules/deep-equal/node_modules/isarray/index.js","webpack://lforms/./node_modules/define-properties/index.js","webpack://lforms/./node_modules/es-get-iterator/node_modules/isarray/index.js","webpack://lforms/../../src/utils.ts","webpack://lforms/../../src/index.ts","webpack://lforms/./node_modules/fhirpath/fhir-context/r4/index.js","webpack://lforms/./node_modules/fhirpath/src/aggregate.js","webpack://lforms/./node_modules/fhirpath/src/collections.js","webpack://lforms/./node_modules/fhirpath/src/combining.js","webpack://lforms/./node_modules/fhirpath/src/constants.js","webpack://lforms/./node_modules/fhirpath/src/datetime.js","webpack://lforms/./node_modules/fhirpath/src/deep-equal.js","webpack://lforms/./node_modules/fhirpath/src/equality.js","webpack://lforms/./node_modules/fhirpath/src/existence.js","webpack://lforms/./node_modules/fhirpath/src/fhirpath.js","webpack://lforms/./node_modules/fhirpath/src/filtering.js","webpack://lforms/./node_modules/fhirpath/src/hash-object.js","webpack://lforms/./node_modules/fhirpath/src/logic.js","webpack://lforms/./node_modules/fhirpath/src/math.js","webpack://lforms/./node_modules/fhirpath/src/misc.js","webpack://lforms/./node_modules/fhirpath/src/navigation.js","webpack://lforms/./node_modules/fhirpath/src/numbers.js","webpack://lforms/./node_modules/fhirpath/src/parser/antlr4-index.js","webpack://lforms/./node_modules/fhirpath/src/parser/generated/FHIRPathLexer.js","webpack://lforms/./node_modules/fhirpath/src/parser/generated/FHIRPathListener.js","webpack://lforms/./node_modules/fhirpath/src/parser/generated/FHIRPathParser.js","webpack://lforms/./node_modules/fhirpath/src/parser/index.js","webpack://lforms/./node_modules/fhirpath/src/polyfill.js","webpack://lforms/./node_modules/fhirpath/src/strings.js","webpack://lforms/./node_modules/fhirpath/src/types.js","webpack://lforms/./node_modules/fhirpath/src/utilities.js","webpack://lforms/./node_modules/for-each/index.js","webpack://lforms/./node_modules/function-bind/implementation.js","webpack://lforms/./node_modules/function-bind/index.js","webpack://lforms/./node_modules/functions-have-names/index.js","webpack://lforms/./node_modules/get-intrinsic/index.js","webpack://lforms/./node_modules/has-bigints/index.js","webpack://lforms/./node_modules/has-property-descriptors/index.js","webpack://lforms/./node_modules/has-symbols/index.js","webpack://lforms/./node_modules/has-symbols/shams.js","webpack://lforms/./node_modules/has-tostringtag/shams.js","webpack://lforms/./node_modules/has/src/index.js","webpack://lforms/./node_modules/is-arguments/index.js","webpack://lforms/./node_modules/is-bigint/index.js","webpack://lforms/./node_modules/is-boolean-object/index.js","webpack://lforms/./node_modules/is-callable/index.js","webpack://lforms/./node_modules/is-date-object/index.js","webpack://lforms/./node_modules/is-map/index.js","webpack://lforms/./node_modules/is-number-object/index.js","webpack://lforms/./node_modules/is-regex/index.js","webpack://lforms/./node_modules/is-set/index.js","webpack://lforms/./node_modules/is-string/index.js","webpack://lforms/./node_modules/is-symbol/index.js","webpack://lforms/./node_modules/is-typed-array/index.js","webpack://lforms/./node_modules/is-weakmap/index.js","webpack://lforms/./node_modules/is-weakset/index.js","webpack://lforms/./node_modules/object-inspect/index.js","webpack://lforms/./node_modules/object-is/implementation.js","webpack://lforms/./node_modules/object-is/index.js","webpack://lforms/./node_modules/object-is/polyfill.js","webpack://lforms/./node_modules/object-is/shim.js","webpack://lforms/./node_modules/object-keys/implementation.js","webpack://lforms/./node_modules/object-keys/index.js","webpack://lforms/./node_modules/object-keys/isArguments.js","webpack://lforms/./node_modules/object.assign/implementation.js","webpack://lforms/./node_modules/object.assign/index.js","webpack://lforms/./node_modules/object.assign/polyfill.js","webpack://lforms/./node_modules/object.assign/shim.js","webpack://lforms/./node_modules/regexp.prototype.flags/implementation.js","webpack://lforms/./node_modules/regexp.prototype.flags/index.js","webpack://lforms/./node_modules/regexp.prototype.flags/polyfill.js","webpack://lforms/./node_modules/regexp.prototype.flags/shim.js","webpack://lforms/./node_modules/side-channel/index.js","webpack://lforms/./node_modules/which-boxed-primitive/index.js","webpack://lforms/./node_modules/which-typed-array/index.js","webpack://lforms/external \"LForms.ucumPkg\"","webpack://lforms/./node_modules/available-typed-arrays/index.js","webpack://lforms/./node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js","webpack://lforms/./node_modules/es-get-iterator/index.js","webpack://lforms/./node_modules/which-collection/index.js","webpack://lforms/webpack/bootstrap","webpack://lforms/webpack/runtime/compat get default export","webpack://lforms/webpack/runtime/define property getters","webpack://lforms/webpack/runtime/global","webpack://lforms/webpack/runtime/hasOwnProperty shorthand","webpack://lforms/./src/fhir/import-common.js","webpack://lforms/./src/fhir/diagnostic-report.js","webpack://lforms/./src/fhir/export-common.js","webpack://lforms/./src/fhir/R4/export.js","webpack://lforms/./src/fhir/R4/sdc-export.js","webpack://lforms/./src/fhir/sdc-export-common.js","webpack://lforms/./src/fhir/R4/sdc-import.js","webpack://lforms/./src/fhir/obs-prepop.mjs","webpack://lforms/./src/fhir/sdc-common.js","webpack://lforms/./src/fhir/sdc-import-common.js","webpack://lforms/./src/fhir/extensions/rendering-style.js","webpack://lforms/./src/fhir/runtime-common.js","webpack://lforms/./src/fhir/expression-processor.js","webpack://lforms/./src/fhir/R4/fhirRequire.js","webpack://lforms/./src/fhir/fhir-common.js"],"sourcesContent":["/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Token} = require('./Token');\nconst Lexer = require('./Lexer');\nconst {Interval} = require('./IntervalSet');\n\n// this is just to keep meaningful parameter types to Parser\nclass TokenStream {}\n\n/**\n * This implementation of {@link TokenStream} loads tokens from a\n * {@link TokenSource} on-demand, and places the tokens in a buffer to provide\n * access to any previous token by index.\n *\n * <p>\n * This token stream ignores the value of {@link Token//getChannel}. If your\n * parser requires the token stream filter tokens to only those on a particular\n * channel, such as {@link Token//DEFAULT_CHANNEL} or\n * {@link Token//HIDDEN_CHANNEL}, use a filtering token stream such a\n * {@link CommonTokenStream}.</p>\n */\nclass BufferedTokenStream extends TokenStream {\n\tconstructor(tokenSource) {\n\n\t\tsuper();\n\t\t// The {@link TokenSource} from which tokens for this stream are fetched.\n\t\tthis.tokenSource = tokenSource;\n\t\t/**\n\t\t * A collection of all tokens fetched from the token source. The list is\n\t\t * considered a complete view of the input once {@link //fetchedEOF} is set\n\t\t * to {@code true}.\n\t\t */\n\t\tthis.tokens = [];\n\n\t\t/**\n\t\t * The index into {@link //tokens} of the current token (next token to\n\t\t * {@link //consume}). {@link //tokens}{@code [}{@link //p}{@code ]} should\n\t\t * be\n\t\t * {@link //LT LT(1)}.\n\t\t *\n\t\t * <p>This field is set to -1 when the stream is first constructed or when\n\t\t * {@link //setTokenSource} is called, indicating that the first token has\n\t\t * not yet been fetched from the token source. For additional information,\n\t\t * see the documentation of {@link IntStream} for a description of\n\t\t * Initializing Methods.</p>\n\t\t */\n\t\tthis.index = -1;\n\n\t\t/**\n\t\t * Indicates whether the {@link Token//EOF} token has been fetched from\n\t\t * {@link //tokenSource} and added to {@link //tokens}. This field improves\n\t\t * performance for the following cases:\n\t\t *\n\t\t * <ul>\n\t\t * <li>{@link //consume}: The lookahead check in {@link //consume} to\n\t\t * prevent\n\t\t * consuming the EOF symbol is optimized by checking the values of\n\t\t * {@link //fetchedEOF} and {@link //p} instead of calling {@link\n\t\t * //LA}.</li>\n\t\t * <li>{@link //fetch}: The check to prevent adding multiple EOF symbols\n\t\t * into\n\t\t * {@link //tokens} is trivial with this field.</li>\n\t\t * <ul>\n\t\t */\n\t\tthis.fetchedEOF = false;\n\t}\n\n\tmark() {\n\t\treturn 0;\n\t}\n\n\trelease(marker) {\n\t\t// no resources to release\n\t}\n\n\treset() {\n\t\tthis.seek(0);\n\t}\n\n\tseek(index) {\n\t\tthis.lazyInit();\n\t\tthis.index = this.adjustSeekIndex(index);\n\t}\n\n\tget(index) {\n\t\tthis.lazyInit();\n\t\treturn this.tokens[index];\n\t}\n\n\tconsume() {\n\t\tlet skipEofCheck = false;\n\t\tif (this.index >= 0) {\n\t\t\tif (this.fetchedEOF) {\n\t\t\t\t// the last token in tokens is EOF. skip check if p indexes any\n\t\t\t\t// fetched token except the last.\n\t\t\t\tskipEofCheck = this.index < this.tokens.length - 1;\n\t\t\t} else {\n\t\t\t\t// no EOF token in tokens. skip check if p indexes a fetched token.\n\t\t\t\tskipEofCheck = this.index < this.tokens.length;\n\t\t\t}\n\t\t} else {\n\t\t\t// not yet initialized\n\t\t\tskipEofCheck = false;\n\t\t}\n\t\tif (!skipEofCheck && this.LA(1) === Token.EOF) {\n\t\t\tthrow \"cannot consume EOF\";\n\t\t}\n\t\tif (this.sync(this.index + 1)) {\n\t\t\tthis.index = this.adjustSeekIndex(this.index + 1);\n\t\t}\n\t}\n\n\t/**\n\t * Make sure index {@code i} in tokens has a token.\n\t *\n\t * @return {Boolean} {@code true} if a token is located at index {@code i}, otherwise\n\t * {@code false}.\n\t * @see //get(int i)\n\t */\n\tsync(i) {\n\t\tconst n = i - this.tokens.length + 1; // how many more elements we need?\n\t\tif (n > 0) {\n\t\t\tconst fetched = this.fetch(n);\n\t\t\treturn fetched >= n;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Add {@code n} elements to buffer.\n\t *\n\t * @return {Number} The actual number of elements added to the buffer.\n\t */\n\tfetch(n) {\n\t\tif (this.fetchedEOF) {\n\t\t\treturn 0;\n\t\t}\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tconst t = this.tokenSource.nextToken();\n\t\t\tt.tokenIndex = this.tokens.length;\n\t\t\tthis.tokens.push(t);\n\t\t\tif (t.type === Token.EOF) {\n\t\t\t\tthis.fetchedEOF = true;\n\t\t\t\treturn i + 1;\n\t\t\t}\n\t\t}\n\t\treturn n;\n\t}\n\n// Get all tokens from start..stop inclusively///\n\tgetTokens(start, stop, types) {\n\t\tif (types === undefined) {\n\t\t\ttypes = null;\n\t\t}\n\t\tif (start < 0 || stop < 0) {\n\t\t\treturn null;\n\t\t}\n\t\tthis.lazyInit();\n\t\tconst subset = [];\n\t\tif (stop >= this.tokens.length) {\n\t\t\tstop = this.tokens.length - 1;\n\t\t}\n\t\tfor (let i = start; i < stop; i++) {\n\t\t\tconst t = this.tokens[i];\n\t\t\tif (t.type === Token.EOF) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (types === null || types.contains(t.type)) {\n\t\t\t\tsubset.push(t);\n\t\t\t}\n\t\t}\n\t\treturn subset;\n\t}\n\n\tLA(i) {\n\t\treturn this.LT(i).type;\n\t}\n\n\tLB(k) {\n\t\tif (this.index - k < 0) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this.tokens[this.index - k];\n\t}\n\n\tLT(k) {\n\t\tthis.lazyInit();\n\t\tif (k === 0) {\n\t\t\treturn null;\n\t\t}\n\t\tif (k < 0) {\n\t\t\treturn this.LB(-k);\n\t\t}\n\t\tconst i = this.index + k - 1;\n\t\tthis.sync(i);\n\t\tif (i >= this.tokens.length) { // return EOF token\n\t\t\t// EOF must be last token\n\t\t\treturn this.tokens[this.tokens.length - 1];\n\t\t}\n\t\treturn this.tokens[i];\n\t}\n\n\t/**\n\t * Allowed derived classes to modify the behavior of operations which change\n\t * the current stream position by adjusting the target token index of a seek\n\t * operation. The default implementation simply returns {@code i}. If an\n\t * exception is thrown in this method, the current stream index should not be\n\t * changed.\n\t *\n\t * <p>For example, {@link CommonTokenStream} overrides this method to ensure\n\t * that\n\t * the seek target is always an on-channel token.</p>\n\t *\n\t * @param {Number} i The target token index.\n\t * @return {Number} The adjusted target token index.\n\t */\n\tadjustSeekIndex(i) {\n\t\treturn i;\n\t}\n\n\tlazyInit() {\n\t\tif (this.index === -1) {\n\t\t\tthis.setup();\n\t\t}\n\t}\n\n\tsetup() {\n\t\tthis.sync(0);\n\t\tthis.index = this.adjustSeekIndex(0);\n\t}\n\n// Reset this token stream by setting its token source.///\n\tsetTokenSource(tokenSource) {\n\t\tthis.tokenSource = tokenSource;\n\t\tthis.tokens = [];\n\t\tthis.index = -1;\n\t\tthis.fetchedEOF = false;\n\t}\n\n\t/**\n\t * Given a starting index, return the index of the next token on channel.\n\t * Return i if tokens[i] is on channel. Return -1 if there are no tokens\n\t * on channel between i and EOF.\n\t */\n\tnextTokenOnChannel(i, channel) {\n\t\tthis.sync(i);\n\t\tif (i >= this.tokens.length) {\n\t\t\treturn -1;\n\t\t}\n\t\tlet token = this.tokens[i];\n\t\twhile (token.channel !== this.channel) {\n\t\t\tif (token.type === Token.EOF) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\ti += 1;\n\t\t\tthis.sync(i);\n\t\t\ttoken = this.tokens[i];\n\t\t}\n\t\treturn i;\n\t}\n\n\t/**\n\t * Given a starting index, return the index of the previous token on channel.\n\t * Return i if tokens[i] is on channel. Return -1 if there are no tokens\n\t * on channel between i and 0.\n\t */\n\tpreviousTokenOnChannel(i, channel) {\n\t\twhile (i >= 0 && this.tokens[i].channel !== channel) {\n\t\t\ti -= 1;\n\t\t}\n\t\treturn i;\n\t}\n\n\t/**\n\t * Collect all tokens on specified channel to the right of\n\t * the current token up until we see a token on DEFAULT_TOKEN_CHANNEL or\n\t * EOF. If channel is -1, find any non default channel token.\n\t */\n\tgetHiddenTokensToRight(tokenIndex,\n\t\t\tchannel) {\n\t\tif (channel === undefined) {\n\t\t\tchannel = -1;\n\t\t}\n\t\tthis.lazyInit();\n\t\tif (tokenIndex < 0 || tokenIndex >= this.tokens.length) {\n\t\t\tthrow \"\" + tokenIndex + \" not in 0..\" + this.tokens.length - 1;\n\t\t}\n\t\tconst nextOnChannel = this.nextTokenOnChannel(tokenIndex + 1, Lexer.DEFAULT_TOKEN_CHANNEL);\n\t\tconst from_ = tokenIndex + 1;\n\t\t// if none onchannel to right, nextOnChannel=-1 so set to = last token\n\t\tconst to = nextOnChannel === -1 ? this.tokens.length - 1 : nextOnChannel;\n\t\treturn this.filterForChannel(from_, to, channel);\n\t}\n\n\t/**\n\t * Collect all tokens on specified channel to the left of\n\t * the current token up until we see a token on DEFAULT_TOKEN_CHANNEL.\n\t * If channel is -1, find any non default channel token.\n\t */\n\tgetHiddenTokensToLeft(tokenIndex,\n\t\t\tchannel) {\n\t\tif (channel === undefined) {\n\t\t\tchannel = -1;\n\t\t}\n\t\tthis.lazyInit();\n\t\tif (tokenIndex < 0 || tokenIndex >= this.tokens.length) {\n\t\t\tthrow \"\" + tokenIndex + \" not in 0..\" + this.tokens.length - 1;\n\t\t}\n\t\tconst prevOnChannel = this.previousTokenOnChannel(tokenIndex - 1, Lexer.DEFAULT_TOKEN_CHANNEL);\n\t\tif (prevOnChannel === tokenIndex - 1) {\n\t\t\treturn null;\n\t\t}\n\t\t// if none on channel to left, prevOnChannel=-1 then from=0\n\t\tconst from_ = prevOnChannel + 1;\n\t\tconst to = tokenIndex - 1;\n\t\treturn this.filterForChannel(from_, to, channel);\n\t}\n\n\tfilterForChannel(left, right, channel) {\n\t\tconst hidden = [];\n\t\tfor (let i = left; i < right + 1; i++) {\n\t\t\tconst t = this.tokens[i];\n\t\t\tif (channel === -1) {\n\t\t\t\tif (t.channel !== Lexer.DEFAULT_TOKEN_CHANNEL) {\n\t\t\t\t\thidden.push(t);\n\t\t\t\t}\n\t\t\t} else if (t.channel === channel) {\n\t\t\t\thidden.push(t);\n\t\t\t}\n\t\t}\n\t\tif (hidden.length === 0) {\n\t\t\treturn null;\n\t\t}\n\t\treturn hidden;\n\t}\n\n\tgetSourceName() {\n\t\treturn this.tokenSource.getSourceName();\n\t}\n\n// Get the text of all tokens in this buffer.///\n\tgetText(interval) {\n\t\tthis.lazyInit();\n\t\tthis.fill();\n\t\tif (interval === undefined || interval === null) {\n\t\t\tinterval = new Interval(0, this.tokens.length - 1);\n\t\t}\n\t\tlet start = interval.start;\n\t\tif (start instanceof Token) {\n\t\t\tstart = start.tokenIndex;\n\t\t}\n\t\tlet stop = interval.stop;\n\t\tif (stop instanceof Token) {\n\t\t\tstop = stop.tokenIndex;\n\t\t}\n\t\tif (start === null || stop === null || start < 0 || stop < 0) {\n\t\t\treturn \"\";\n\t\t}\n\t\tif (stop >= this.tokens.length) {\n\t\t\tstop = this.tokens.length - 1;\n\t\t}\n\t\tlet s = \"\";\n\t\tfor (let i = start; i < stop + 1; i++) {\n\t\t\tconst t = this.tokens[i];\n\t\t\tif (t.type === Token.EOF) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ts = s + t.text;\n\t\t}\n\t\treturn s;\n\t}\n\n// Get all tokens from lexer until EOF///\n\tfill() {\n\t\tthis.lazyInit();\n\t\twhile (this.fetch(1000) === 1000) {\n\t\t\tcontinue;\n\t\t}\n\t}\n}\n\n\nmodule.exports = BufferedTokenStream;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst CommonToken = require('./Token').CommonToken;\n\nclass TokenFactory {}\n\n/**\n * This default implementation of {@link TokenFactory} creates\n * {@link CommonToken} objects.\n */\nclass CommonTokenFactory extends TokenFactory {\n    constructor(copyText) {\n        super();\n        /**\n         * Indicates whether {@link CommonToken//setText} should be called after\n         * constructing tokens to explicitly set the text. This is useful for cases\n         * where the input stream might not be able to provide arbitrary substrings\n         * of text from the input after the lexer creates a token (e.g. the\n         * implementation of {@link CharStream//getText} in\n         * {@link UnbufferedCharStream} throws an\n         * {@link UnsupportedOperationException}). Explicitly setting the token text\n         * allows {@link Token//getText} to be called at any time regardless of the\n         * input stream implementation.\n         *\n         * <p>\n         * The default value is {@code false} to avoid the performance and memory\n         * overhead of copying text for every token unless explicitly requested.</p>\n         */\n        this.copyText = copyText===undefined ? false : copyText;\n    }\n\n    create(source, type, text, channel, start, stop, line, column) {\n        const t = new CommonToken(source, type, channel, start, stop);\n        t.line = line;\n        t.column = column;\n        if (text !==null) {\n            t.text = text;\n        } else if (this.copyText && source[1] !==null) {\n            t.text = source[1].getText(start,stop);\n        }\n        return t;\n    }\n\n    createThin(type, text) {\n        const t = new CommonToken(null, type);\n        t.text = text;\n        return t;\n    }\n}\n\n/**\n * The default {@link CommonTokenFactory} instance.\n *\n * <p>\n * This token factory does not explicitly copy token text when constructing\n * tokens.</p>\n */\nCommonTokenFactory.DEFAULT = new CommonTokenFactory();\n\nmodule.exports = CommonTokenFactory;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\n\nconst Token = require('./Token').Token;\nconst BufferedTokenStream = require('./BufferedTokenStream');\n\n/**\n * This class extends {@link BufferedTokenStream} with functionality to filter\n * token streams to tokens on a particular channel (tokens where\n * {@link Token//getChannel} returns a particular value).\n *\n * <p>\n * This token stream provides access to all tokens by index or when calling\n * methods like {@link //getText}. The channel filtering is only used for code\n * accessing tokens via the lookahead methods {@link //LA}, {@link //LT}, and\n * {@link //LB}.</p>\n *\n * <p>\n * By default, tokens are placed on the default channel\n * ({@link Token//DEFAULT_CHANNEL}), but may be reassigned by using the\n * {@code ->channel(HIDDEN)} lexer command, or by using an embedded action to\n * call {@link Lexer//setChannel}.\n * </p>\n *\n * <p>\n * Note: lexer rules which use the {@code ->skip} lexer command or call\n * {@link Lexer//skip} do not produce tokens at all, so input text matched by\n * such a rule will not be available as part of the token stream, regardless of\n * channel.</p>\n */\nclass CommonTokenStream extends BufferedTokenStream {\n    constructor(lexer, channel) {\n        super(lexer);\n        this.channel = channel===undefined ? Token.DEFAULT_CHANNEL : channel;\n    }\n\n    adjustSeekIndex(i) {\n        return this.nextTokenOnChannel(i, this.channel);\n    }\n\n    LB(k) {\n        if (k===0 || this.index-k<0) {\n            return null;\n        }\n        let i = this.index;\n        let n = 1;\n        // find k good tokens looking backwards\n        while (n <= k) {\n            // skip off-channel tokens\n            i = this.previousTokenOnChannel(i - 1, this.channel);\n            n += 1;\n        }\n        if (i < 0) {\n            return null;\n        }\n        return this.tokens[i];\n    }\n\n    LT(k) {\n        this.lazyInit();\n        if (k === 0) {\n            return null;\n        }\n        if (k < 0) {\n            return this.LB(-k);\n        }\n        let i = this.index;\n        let n = 1; // we know tokens[pos] is a good one\n        // find k good tokens\n        while (n < k) {\n            // skip off-channel tokens, but make sure to not look past EOF\n            if (this.sync(i + 1)) {\n                i = this.nextTokenOnChannel(i + 1, this.channel);\n            }\n            n += 1;\n        }\n        return this.tokens[i];\n    }\n\n    // Count EOF just once.\n    getNumberOfOnChannelTokens() {\n        let n = 0;\n        this.fill();\n        for (let i =0; i< this.tokens.length;i++) {\n            const t = this.tokens[i];\n            if( t.channel===this.channel) {\n                n += 1;\n            }\n            if( t.type===Token.EOF) {\n                break;\n            }\n        }\n        return n;\n    }\n}\n\nmodule.exports = CommonTokenStream;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Token} = require('./Token');\nrequire('./polyfills/codepointat');\nrequire('./polyfills/fromcodepoint');\n\n/**\n * If decodeToUnicodeCodePoints is true, the input is treated\n * as a series of Unicode code points.\n *\n * Otherwise, the input is treated as a series of 16-bit UTF-16 code\n * units.\n */\nclass InputStream {\n\tconstructor(data, decodeToUnicodeCodePoints) {\n\t\tthis.name = \"<empty>\";\n\t\tthis.strdata = data;\n\t\tthis.decodeToUnicodeCodePoints = decodeToUnicodeCodePoints || false;\n\t\t// _loadString - Vacuum all input from a string and then treat it like a buffer.\n\t\tthis._index = 0;\n\t\tthis.data = [];\n\t\tif (this.decodeToUnicodeCodePoints) {\n\t\t\tfor (let i = 0; i < this.strdata.length; ) {\n\t\t\t\tconst codePoint = this.strdata.codePointAt(i);\n\t\t\t\tthis.data.push(codePoint);\n\t\t\t\ti += codePoint <= 0xFFFF ? 1 : 2;\n\t\t\t}\n\t\t} else {\n\t\t\tthis.data = new Array(this.strdata.length);\n\t\t\tfor (let i = 0; i < this.strdata.length; i++) {\n\t\t\t\tconst codeUnit = this.strdata.charCodeAt(i);\n\t\t\t\tthis.data[i] = codeUnit;\n\t\t\t}\n\t\t}\n\t\tthis._size = this.data.length;\n\t}\n\n\t/**\n\t * Reset the stream so that it's in the same state it was\n\t * when the object was created *except* the data array is not\n\t * touched.\n\t */\n\treset() {\n\t\tthis._index = 0;\n\t}\n\n\tconsume() {\n\t\tif (this._index >= this._size) {\n\t\t\t// assert this.LA(1) == Token.EOF\n\t\t\tthrow (\"cannot consume EOF\");\n\t\t}\n\t\tthis._index += 1;\n\t}\n\n\tLA(offset) {\n\t\tif (offset === 0) {\n\t\t\treturn 0; // undefined\n\t\t}\n\t\tif (offset < 0) {\n\t\t\toffset += 1; // e.g., translate LA(-1) to use offset=0\n\t\t}\n\t\tconst pos = this._index + offset - 1;\n\t\tif (pos < 0 || pos >= this._size) { // invalid\n\t\t\treturn Token.EOF;\n\t\t}\n\t\treturn this.data[pos];\n\t}\n\n\tLT(offset) {\n\t\treturn this.LA(offset);\n\t}\n\n// mark/release do nothing; we have entire buffer\n\tmark() {\n\t\treturn -1;\n\t}\n\n\trelease(marker) {\n\t}\n\n\t/**\n\t * consume() ahead until p==_index; can't just set p=_index as we must\n\t * update line and column. If we seek backwards, just set p\n\t */\n\tseek(_index) {\n\t\tif (_index <= this._index) {\n\t\t\tthis._index = _index; // just jump; don't update stream state (line,\n\t\t\t\t\t\t\t\t\t// ...)\n\t\t\treturn;\n\t\t}\n\t\t// seek forward\n\t\tthis._index = Math.min(_index, this._size);\n\t}\n\n\tgetText(start, stop) {\n\t\tif (stop >= this._size) {\n\t\t\tstop = this._size - 1;\n\t\t}\n\t\tif (start >= this._size) {\n\t\t\treturn \"\";\n\t\t} else {\n\t\t\tif (this.decodeToUnicodeCodePoints) {\n\t\t\t\tlet result = \"\";\n\t\t\t\tfor (let i = start; i <= stop; i++) {\n\t\t\t\t\tresult += String.fromCodePoint(this.data[i]);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this.strdata.slice(start, stop + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn this.strdata;\n\t}\n\n\tget index(){\n\t\treturn this._index;\n\t}\n\n\tget size(){\n\t\treturn this._size;\n\t}\n}\n\n\nmodule.exports = InputStream;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Token} = require('./Token');\n\n/* stop is not included! */\nclass Interval {\n\n\tconstructor(start, stop) {\n\t\tthis.start = start;\n\t\tthis.stop = stop;\n\t}\n\n\tclone() {\n\t\treturn new Interval(this.start, this.stop);\n\t}\n\n\tcontains(item) {\n\t\treturn item >= this.start && item < this.stop;\n\t}\n\n\ttoString() {\n\t\tif(this.start===this.stop-1) {\n\t\t\treturn this.start.toString();\n\t\t} else {\n\t\t\treturn this.start.toString() + \"..\" + (this.stop-1).toString();\n\t\t}\n\t}\n\n\tget length(){\n\t\treturn this.stop - this.start;\n\t}\n}\n\n\nclass IntervalSet {\n\tconstructor() {\n\t\tthis.intervals = null;\n\t\tthis.readOnly = false;\n\t}\n\n\tfirst(v) {\n\t\tif (this.intervals === null || this.intervals.length===0) {\n\t\t\treturn Token.INVALID_TYPE;\n\t\t} else {\n\t\t\treturn this.intervals[0].start;\n\t\t}\n\t}\n\n\taddOne(v) {\n\t\tthis.addInterval(new Interval(v, v + 1));\n\t}\n\n\taddRange(l, h) {\n\t\tthis.addInterval(new Interval(l, h + 1));\n\t}\n\n\taddInterval(toAdd) {\n\t\tif (this.intervals === null) {\n\t\t\tthis.intervals = [];\n\t\t\tthis.intervals.push(toAdd.clone());\n\t\t} else {\n\t\t\t// find insert pos\n\t\t\tfor (let pos = 0; pos < this.intervals.length; pos++) {\n\t\t\t\tconst existing = this.intervals[pos];\n\t\t\t\t// distinct range -> insert\n\t\t\t\tif (toAdd.stop < existing.start) {\n\t\t\t\t\tthis.intervals.splice(pos, 0, toAdd);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// contiguous range -> adjust\n\t\t\t\telse if (toAdd.stop === existing.start) {\n\t\t\t\t\tthis.intervals[pos] = new Interval(toAdd.start, existing.stop)\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// overlapping range -> adjust and reduce\n\t\t\t\telse if (toAdd.start <= existing.stop) {\n\t\t\t\t\tthis.intervals[pos] = new Interval(Math.min(existing.start, toAdd.start), Math.max(existing.stop, toAdd.stop));\n\t\t\t\t\tthis.reduce(pos);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// greater than any existing\n\t\t\tthis.intervals.push(toAdd.clone());\n\t\t}\n\t}\n\n\taddSet(other) {\n\t\tif (other.intervals !== null) {\n\t\t\tother.intervals.forEach( toAdd => this.addInterval(toAdd), this);\n\t\t}\n\t\treturn this;\n\t}\n\n\treduce(pos) {\n\t\t// only need to reduce if pos is not the last\n\t\tif (pos < this.intervals.length - 1) {\n\t\t\tconst current = this.intervals[pos];\n\t\t\tconst next = this.intervals[pos + 1];\n\t\t\t// if next contained in current\n\t\t\tif (current.stop >= next.stop) {\n\t\t\t\tthis.intervals.splice(pos + 1, 1);\n\t\t\t\tthis.reduce(pos);\n\t\t\t} else if (current.stop >= next.start) {\n\t\t\t\tthis.intervals[pos] = new Interval(current.start, next.stop);\n\t\t\t\tthis.intervals.splice(pos + 1, 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tcomplement(start, stop) {\n\t\tconst result = new IntervalSet();\n\t\tresult.addInterval(new Interval(start, stop + 1));\n\t\tif(this.intervals !== null)\n\t\t\tthis.intervals.forEach(toRemove => result.removeRange(toRemove));\n\t\treturn result;\n\t}\n\n\tcontains(item) {\n\t\tif (this.intervals === null) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\tfor (let k = 0; k < this.intervals.length; k++) {\n\t\t\t\tif(this.intervals[k].contains(item)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tremoveRange(toRemove) {\n\t\tif(toRemove.start===toRemove.stop-1) {\n\t\t\tthis.removeOne(toRemove.start);\n\t\t} else if (this.intervals !== null) {\n\t\t\tlet pos = 0;\n\t\t\tfor(let n=0; n<this.intervals.length; n++) {\n\t\t\t\tconst existing = this.intervals[pos];\n\t\t\t\t// intervals are ordered\n\t\t\t\tif (toRemove.stop<=existing.start) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// check for including range, split it\n\t\t\t\telse if(toRemove.start>existing.start && toRemove.stop<existing.stop) {\n\t\t\t\t\tthis.intervals[pos] = new Interval(existing.start, toRemove.start);\n\t\t\t\t\tconst x = new Interval(toRemove.stop, existing.stop);\n\t\t\t\t\tthis.intervals.splice(pos, 0, x);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// check for included range, remove it\n\t\t\t\telse if(toRemove.start<=existing.start && toRemove.stop>=existing.stop) {\n\t\t\t\t\tthis.intervals.splice(pos, 1);\n\t\t\t\t\tpos = pos - 1; // need another pass\n\t\t\t\t}\n\t\t\t\t// check for lower boundary\n\t\t\t\telse if(toRemove.start<existing.stop) {\n\t\t\t\t\tthis.intervals[pos] = new Interval(existing.start, toRemove.start);\n\t\t\t\t}\n\t\t\t\t// check for upper boundary\n\t\t\t\telse if(toRemove.stop<existing.stop) {\n\t\t\t\t\tthis.intervals[pos] = new Interval(toRemove.stop, existing.stop);\n\t\t\t\t}\n\t\t\t\tpos += 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tremoveOne(value) {\n\t\tif (this.intervals !== null) {\n\t\t\tfor (let i = 0; i < this.intervals.length; i++) {\n\t\t\t\tconst existing = this.intervals[i];\n\t\t\t\t// intervals are ordered\n\t\t\t\tif (value < existing.start) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// check for single value range\n\t\t\t\telse if (value === existing.start && value === existing.stop - 1) {\n\t\t\t\t\tthis.intervals.splice(i, 1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// check for lower boundary\n\t\t\t\telse if (value === existing.start) {\n\t\t\t\t\tthis.intervals[i] = new Interval(existing.start + 1, existing.stop);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// check for upper boundary\n\t\t\t\telse if (value === existing.stop - 1) {\n\t\t\t\t\tthis.intervals[i] = new Interval(existing.start, existing.stop - 1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// split existing range\n\t\t\t\telse if (value < existing.stop - 1) {\n\t\t\t\t\tconst replace = new Interval(existing.start, value);\n\t\t\t\t\texisting.start = value + 1;\n\t\t\t\t\tthis.intervals.splice(i, 0, replace);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\ttoString(literalNames, symbolicNames, elemsAreChar) {\n\t\tliteralNames = literalNames || null;\n\t\tsymbolicNames = symbolicNames || null;\n\t\telemsAreChar = elemsAreChar || false;\n\t\tif (this.intervals === null) {\n\t\t\treturn \"{}\";\n\t\t} else if(literalNames!==null || symbolicNames!==null) {\n\t\t\treturn this.toTokenString(literalNames, symbolicNames);\n\t\t} else if(elemsAreChar) {\n\t\t\treturn this.toCharString();\n\t\t} else {\n\t\t\treturn this.toIndexString();\n\t\t}\n\t}\n\n\ttoCharString() {\n\t\tconst names = [];\n\t\tfor (let i = 0; i < this.intervals.length; i++) {\n\t\t\tconst existing = this.intervals[i];\n\t\t\tif(existing.stop===existing.start+1) {\n\t\t\t\tif ( existing.start===Token.EOF ) {\n\t\t\t\t\tnames.push(\"<EOF>\");\n\t\t\t\t} else {\n\t\t\t\t\tnames.push(\"'\" + String.fromCharCode(existing.start) + \"'\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnames.push(\"'\" + String.fromCharCode(existing.start) + \"'..'\" + String.fromCharCode(existing.stop-1) + \"'\");\n\t\t\t}\n\t\t}\n\t\tif (names.length > 1) {\n\t\t\treturn \"{\" + names.join(\", \") + \"}\";\n\t\t} else {\n\t\t\treturn names[0];\n\t\t}\n\t}\n\n\ttoIndexString() {\n\t\tconst names = [];\n\t\tfor (let i = 0; i < this.intervals.length; i++) {\n\t\t\tconst existing = this.intervals[i];\n\t\t\tif(existing.stop===existing.start+1) {\n\t\t\t\tif ( existing.start===Token.EOF ) {\n\t\t\t\t\tnames.push(\"<EOF>\");\n\t\t\t\t} else {\n\t\t\t\t\tnames.push(existing.start.toString());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnames.push(existing.start.toString() + \"..\" + (existing.stop-1).toString());\n\t\t\t}\n\t\t}\n\t\tif (names.length > 1) {\n\t\t\treturn \"{\" + names.join(\", \") + \"}\";\n\t\t} else {\n\t\t\treturn names[0];\n\t\t}\n\t}\n\n\ttoTokenString(literalNames, symbolicNames) {\n\t\tconst names = [];\n\t\tfor (let i = 0; i < this.intervals.length; i++) {\n\t\t\tconst existing = this.intervals[i];\n\t\t\tfor (let j = existing.start; j < existing.stop; j++) {\n\t\t\t\tnames.push(this.elementName(literalNames, symbolicNames, j));\n\t\t\t}\n\t\t}\n\t\tif (names.length > 1) {\n\t\t\treturn \"{\" + names.join(\", \") + \"}\";\n\t\t} else {\n\t\t\treturn names[0];\n\t\t}\n\t}\n\n\telementName(literalNames, symbolicNames, token) {\n\t\tif (token === Token.EOF) {\n\t\t\treturn \"<EOF>\";\n\t\t} else if (token === Token.EPSILON) {\n\t\t\treturn \"<EPSILON>\";\n\t\t} else {\n\t\t\treturn literalNames[token] || symbolicNames[token];\n\t\t}\n\t}\n\n\tget length(){\n\t\treturn this.intervals.map( interval => interval.length ).reduce((acc, val) => acc + val);\n\t}\n}\n\nmodule.exports = {\n\tInterval,\n\tIntervalSet\n};\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Set, BitSet} = require('./Utils');\nconst {Token} = require('./Token');\nconst {ATNConfig} = require('./atn/ATNConfig');\nconst {IntervalSet} = require('./IntervalSet');\nconst {RuleStopState} = require('./atn/ATNState');\nconst {RuleTransition, NotSetTransition, WildcardTransition, AbstractPredicateTransition} = require('./atn/Transition');\nconst {predictionContextFromRuleContext, PredictionContext, SingletonPredictionContext} = require('./PredictionContext');\n\nclass LL1Analyzer {\n    constructor(atn) {\n        this.atn = atn;\n    }\n\n    /**\n     * Calculates the SLL(1) expected lookahead set for each outgoing transition\n     * of an {@link ATNState}. The returned array has one element for each\n     * outgoing transition in {@code s}. If the closure from transition\n     * <em>i</em> leads to a semantic predicate before matching a symbol, the\n     * element at index <em>i</em> of the result will be {@code null}.\n     *\n     * @param s the ATN state\n     * @return the expected symbols for each outgoing transition of {@code s}.\n     */\n    getDecisionLookahead(s) {\n        if (s === null) {\n            return null;\n        }\n        const count = s.transitions.length;\n        const look = [];\n        for(let alt=0; alt< count; alt++) {\n            look[alt] = new IntervalSet();\n            const lookBusy = new Set();\n            const seeThruPreds = false; // fail to get lookahead upon pred\n            this._LOOK(s.transition(alt).target, null, PredictionContext.EMPTY,\n                  look[alt], lookBusy, new BitSet(), seeThruPreds, false);\n            // Wipe out lookahead for this alternative if we found nothing\n            // or we had a predicate when we !seeThruPreds\n            if (look[alt].length===0 || look[alt].contains(LL1Analyzer.HIT_PRED)) {\n                look[alt] = null;\n            }\n        }\n        return look;\n    }\n\n    /**\n     * Compute set of tokens that can follow {@code s} in the ATN in the\n     * specified {@code ctx}.\n     *\n     * <p>If {@code ctx} is {@code null} and the end of the rule containing\n     * {@code s} is reached, {@link Token//EPSILON} is added to the result set.\n     * If {@code ctx} is not {@code null} and the end of the outermost rule is\n     * reached, {@link Token//EOF} is added to the result set.</p>\n     *\n     * @param s the ATN state\n     * @param stopState the ATN state to stop at. This can be a\n     * {@link BlockEndState} to detect epsilon paths through a closure.\n     * @param ctx the complete parser context, or {@code null} if the context\n     * should be ignored\n     *\n     * @return The set of tokens that can follow {@code s} in the ATN in the\n     * specified {@code ctx}.\n     */\n    LOOK(s, stopState, ctx) {\n        const r = new IntervalSet();\n        const seeThruPreds = true; // ignore preds; get all lookahead\n        ctx = ctx || null;\n        const lookContext = ctx!==null ? predictionContextFromRuleContext(s.atn, ctx) : null;\n        this._LOOK(s, stopState, lookContext, r, new Set(), new BitSet(), seeThruPreds, true);\n        return r;\n    }\n\n    /**\n     * Compute set of tokens that can follow {@code s} in the ATN in the\n     * specified {@code ctx}.\n     *\n     * <p>If {@code ctx} is {@code null} and {@code stopState} or the end of the\n     * rule containing {@code s} is reached, {@link Token//EPSILON} is added to\n     * the result set. If {@code ctx} is not {@code null} and {@code addEOF} is\n     * {@code true} and {@code stopState} or the end of the outermost rule is\n     * reached, {@link Token//EOF} is added to the result set.</p>\n     *\n     * @param s the ATN state.\n     * @param stopState the ATN state to stop at. This can be a\n     * {@link BlockEndState} to detect epsilon paths through a closure.\n     * @param ctx The outer context, or {@code null} if the outer context should\n     * not be used.\n     * @param look The result lookahead set.\n     * @param lookBusy A set used for preventing epsilon closures in the ATN\n     * from causing a stack overflow. Outside code should pass\n     * {@code new Set<ATNConfig>} for this argument.\n     * @param calledRuleStack A set used for preventing left recursion in the\n     * ATN from causing a stack overflow. Outside code should pass\n     * {@code new BitSet()} for this argument.\n     * @param seeThruPreds {@code true} to true semantic predicates as\n     * implicitly {@code true} and \"see through them\", otherwise {@code false}\n     * to treat semantic predicates as opaque and add {@link //HIT_PRED} to the\n     * result if one is encountered.\n     * @param addEOF Add {@link Token//EOF} to the result if the end of the\n     * outermost context is reached. This parameter has no effect if {@code ctx}\n     * is {@code null}.\n     */\n    _LOOK(s, stopState , ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF) {\n        const c = new ATNConfig({state:s, alt:0, context: ctx}, null);\n        if (lookBusy.contains(c)) {\n            return;\n        }\n        lookBusy.add(c);\n        if (s === stopState) {\n            if (ctx ===null) {\n                look.addOne(Token.EPSILON);\n                return;\n            } else if (ctx.isEmpty() && addEOF) {\n                look.addOne(Token.EOF);\n                return;\n            }\n        }\n        if (s instanceof RuleStopState ) {\n            if (ctx ===null) {\n                look.addOne(Token.EPSILON);\n                return;\n            } else if (ctx.isEmpty() && addEOF) {\n                look.addOne(Token.EOF);\n                return;\n            }\n            if (ctx !== PredictionContext.EMPTY) {\n                const removed = calledRuleStack.contains(s.ruleIndex);\n                try {\n                    calledRuleStack.remove(s.ruleIndex);\n                    // run thru all possible stack tops in ctx\n                    for (let i = 0; i < ctx.length; i++) {\n                        const returnState = this.atn.states[ctx.getReturnState(i)];\n                        this._LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n                    }\n                }finally {\n                    if (removed) {\n                        calledRuleStack.add(s.ruleIndex);\n                    }\n                }\n                return;\n            }\n        }\n        for(let j=0; j<s.transitions.length; j++) {\n            const t = s.transitions[j];\n            if (t.constructor === RuleTransition) {\n                if (calledRuleStack.contains(t.target.ruleIndex)) {\n                    continue;\n                }\n                const newContext = SingletonPredictionContext.create(ctx, t.followState.stateNumber);\n                try {\n                    calledRuleStack.add(t.target.ruleIndex);\n                    this._LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n                } finally {\n                    calledRuleStack.remove(t.target.ruleIndex);\n                }\n            } else if (t instanceof AbstractPredicateTransition ) {\n                if (seeThruPreds) {\n                    this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n                } else {\n                    look.addOne(LL1Analyzer.HIT_PRED);\n                }\n            } else if( t.isEpsilon) {\n                this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n            } else if (t.constructor === WildcardTransition) {\n                look.addRange( Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType );\n            } else {\n                let set = t.label;\n                if (set !== null) {\n                    if (t instanceof NotSetTransition) {\n                        set = set.complement(Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType);\n                    }\n                    look.addSet(set);\n                }\n            }\n        }\n    }\n}\n\n/**\n * Special value added to the lookahead sets to indicate that we hit\n * a predicate during analysis if {@code seeThruPreds==false}.\n */\nLL1Analyzer.HIT_PRED = Token.INVALID_TYPE;\n\nmodule.exports = LL1Analyzer;\n\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Token} = require('./Token');\nconst Recognizer = require('./Recognizer');\nconst CommonTokenFactory = require('./CommonTokenFactory');\nconst {RecognitionException} = require('./error/Errors');\nconst {LexerNoViableAltException} = require('./error/Errors');\n\nclass TokenSource {}\n\n/**\n * A lexer is recognizer that draws input symbols from a character stream.\n * lexer grammars result in a subclass of this object. A Lexer object\n * uses simplified match() and error recovery mechanisms in the interest of speed.\n */\nclass Lexer extends Recognizer {\n\tconstructor(input) {\n\t\tsuper();\n\t\tthis._input = input;\n\t\tthis._factory = CommonTokenFactory.DEFAULT;\n\t\tthis._tokenFactorySourcePair = [ this, input ];\n\n\t\tthis._interp = null; // child classes must populate this\n\n\t\t/**\n\t\t * The goal of all lexer rules/methods is to create a token object.\n\t\t * this is an instance variable as multiple rules may collaborate to\n\t\t * create a single token. nextToken will return this object after\n\t\t * matching lexer rule(s). If you subclass to allow multiple token\n\t\t * emissions, then set this to the last token to be matched or\n\t\t * something nonnull so that the auto token emit mechanism will not\n\t\t * emit another token.\n\t\t */\n\t\tthis._token = null;\n\n\t\t/**\n\t\t * What character index in the stream did the current token start at?\n\t\t * Needed, for example, to get the text for current token. Set at\n\t\t * the start of nextToken.\n\t\t */\n\t\tthis._tokenStartCharIndex = -1;\n\n\t\t// The line on which the first character of the token resides///\n\t\tthis._tokenStartLine = -1;\n\n\t\t// The character position of first character within the line///\n\t\tthis._tokenStartColumn = -1;\n\n\t\t// Once we see EOF on char stream, next token will be EOF.\n\t\t// If you have DONE : EOF ; then you see DONE EOF.\n\t\tthis._hitEOF = false;\n\n\t\t// The channel number for the current token///\n\t\tthis._channel = Token.DEFAULT_CHANNEL;\n\n\t\t// The token type for the current token///\n\t\tthis._type = Token.INVALID_TYPE;\n\n\t\tthis._modeStack = [];\n\t\tthis._mode = Lexer.DEFAULT_MODE;\n\n\t\t/**\n\t\t * You can set the text for the current token to override what is in\n\t\t * the input char buffer. Use setText() or can set this instance var.\n\t\t */\n\t\tthis._text = null;\n\t}\n\n\treset() {\n\t\t// wack Lexer state variables\n\t\tif (this._input !== null) {\n\t\t\tthis._input.seek(0); // rewind the input\n\t\t}\n\t\tthis._token = null;\n\t\tthis._type = Token.INVALID_TYPE;\n\t\tthis._channel = Token.DEFAULT_CHANNEL;\n\t\tthis._tokenStartCharIndex = -1;\n\t\tthis._tokenStartColumn = -1;\n\t\tthis._tokenStartLine = -1;\n\t\tthis._text = null;\n\n\t\tthis._hitEOF = false;\n\t\tthis._mode = Lexer.DEFAULT_MODE;\n\t\tthis._modeStack = [];\n\n\t\tthis._interp.reset();\n\t}\n\n// Return a token from this source; i.e., match a token on the char stream.\n\tnextToken() {\n\t\tif (this._input === null) {\n\t\t\tthrow \"nextToken requires a non-null input stream.\";\n\t\t}\n\n\t\t/**\n\t\t * Mark start location in char stream so unbuffered streams are\n\t\t * guaranteed at least have text of current token\n\t\t */\n\t\tconst tokenStartMarker = this._input.mark();\n\t\ttry {\n\t\t\twhile (true) {\n\t\t\t\tif (this._hitEOF) {\n\t\t\t\t\tthis.emitEOF();\n\t\t\t\t\treturn this._token;\n\t\t\t\t}\n\t\t\t\tthis._token = null;\n\t\t\t\tthis._channel = Token.DEFAULT_CHANNEL;\n\t\t\t\tthis._tokenStartCharIndex = this._input.index;\n\t\t\t\tthis._tokenStartColumn = this._interp.column;\n\t\t\t\tthis._tokenStartLine = this._interp.line;\n\t\t\t\tthis._text = null;\n\t\t\t\tlet continueOuter = false;\n\t\t\t\twhile (true) {\n\t\t\t\t\tthis._type = Token.INVALID_TYPE;\n\t\t\t\t\tlet ttype = Lexer.SKIP;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tttype = this._interp.match(this._input, this._mode);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tif(e instanceof RecognitionException) {\n\t\t\t\t\t\t\tthis.notifyListeners(e); // report error\n\t\t\t\t\t\t\tthis.recover(e);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconsole.log(e.stack);\n\t\t\t\t\t\t\tthrow e;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (this._input.LA(1) === Token.EOF) {\n\t\t\t\t\t\tthis._hitEOF = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (this._type === Token.INVALID_TYPE) {\n\t\t\t\t\t\tthis._type = ttype;\n\t\t\t\t\t}\n\t\t\t\t\tif (this._type === Lexer.SKIP) {\n\t\t\t\t\t\tcontinueOuter = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (this._type !== Lexer.MORE) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (continueOuter) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (this._token === null) {\n\t\t\t\t\tthis.emit();\n\t\t\t\t}\n\t\t\t\treturn this._token;\n\t\t\t}\n\t\t} finally {\n\t\t\t// make sure we release marker after match or\n\t\t\t// unbuffered char stream will keep buffering\n\t\t\tthis._input.release(tokenStartMarker);\n\t\t}\n\t}\n\n\t/**\n\t * Instruct the lexer to skip creating a token for current lexer rule\n\t * and look for another token. nextToken() knows to keep looking when\n\t * a lexer rule finishes with token set to SKIP_TOKEN. Recall that\n\t * if token==null at end of any token rule, it creates one for you\n\t * and emits it.\n\t */\n\tskip() {\n\t\tthis._type = Lexer.SKIP;\n\t}\n\n\tmore() {\n\t\tthis._type = Lexer.MORE;\n\t}\n\n\tmode(m) {\n\t\tthis._mode = m;\n\t}\n\n\tpushMode(m) {\n\t\tif (this._interp.debug) {\n\t\t\tconsole.log(\"pushMode \" + m);\n\t\t}\n\t\tthis._modeStack.push(this._mode);\n\t\tthis.mode(m);\n\t}\n\n\tpopMode() {\n\t\tif (this._modeStack.length === 0) {\n\t\t\tthrow \"Empty Stack\";\n\t\t}\n\t\tif (this._interp.debug) {\n\t\t\tconsole.log(\"popMode back to \" + this._modeStack.slice(0, -1));\n\t\t}\n\t\tthis.mode(this._modeStack.pop());\n\t\treturn this._mode;\n\t}\n\n\t/**\n\t * By default does not support multiple emits per nextToken invocation\n\t * for efficiency reasons. Subclass and override this method, nextToken,\n\t * and getToken (to push tokens into a list and pull from that list\n\t * rather than a single variable as this implementation does).\n\t */\n\temitToken(token) {\n\t\tthis._token = token;\n\t}\n\n\t/**\n\t * The standard method called to automatically emit a token at the\n\t * outermost lexical rule. The token object should point into the\n\t * char buffer start..stop. If there is a text override in 'text',\n\t * use that to set the token's text. Override this method to emit\n\t * custom Token objects or provide a new factory.\n\t */\n\temit() {\n\t\tconst t = this._factory.create(this._tokenFactorySourcePair, this._type,\n\t\t\t\tthis._text, this._channel, this._tokenStartCharIndex, this\n\t\t\t\t\t\t.getCharIndex() - 1, this._tokenStartLine,\n\t\t\t\tthis._tokenStartColumn);\n\t\tthis.emitToken(t);\n\t\treturn t;\n\t}\n\n\temitEOF() {\n\t\tconst cpos = this.column;\n\t\tconst lpos = this.line;\n\t\tconst eof = this._factory.create(this._tokenFactorySourcePair, Token.EOF,\n\t\t\t\tnull, Token.DEFAULT_CHANNEL, this._input.index,\n\t\t\t\tthis._input.index - 1, lpos, cpos);\n\t\tthis.emitToken(eof);\n\t\treturn eof;\n\t}\n\n// What is the index of the current character of lookahead?///\n\tgetCharIndex() {\n\t\treturn this._input.index;\n\t}\n\n\t/**\n\t * Return a list of all Token objects in input char stream.\n\t * Forces load of all tokens. Does not include EOF token.\n\t */\n\tgetAllTokens() {\n\t\tconst tokens = [];\n\t\tlet t = this.nextToken();\n\t\twhile (t.type !== Token.EOF) {\n\t\t\ttokens.push(t);\n\t\t\tt = this.nextToken();\n\t\t}\n\t\treturn tokens;\n\t}\n\n\tnotifyListeners(e) {\n\t\tconst start = this._tokenStartCharIndex;\n\t\tconst stop = this._input.index;\n\t\tconst text = this._input.getText(start, stop);\n\t\tconst msg = \"token recognition error at: '\" + this.getErrorDisplay(text) + \"'\";\n\t\tconst listener = this.getErrorListenerDispatch();\n\t\tlistener.syntaxError(this, null, this._tokenStartLine,\n\t\t\t\tthis._tokenStartColumn, msg, e);\n\t}\n\n\tgetErrorDisplay(s) {\n\t\tconst d = [];\n\t\tfor (let i = 0; i < s.length; i++) {\n\t\t\td.push(s[i]);\n\t\t}\n\t\treturn d.join('');\n\t}\n\n\tgetErrorDisplayForChar(c) {\n\t\tif (c.charCodeAt(0) === Token.EOF) {\n\t\t\treturn \"<EOF>\";\n\t\t} else if (c === '\\n') {\n\t\t\treturn \"\\\\n\";\n\t\t} else if (c === '\\t') {\n\t\t\treturn \"\\\\t\";\n\t\t} else if (c === '\\r') {\n\t\t\treturn \"\\\\r\";\n\t\t} else {\n\t\t\treturn c;\n\t\t}\n\t}\n\n\tgetCharErrorDisplay(c) {\n\t\treturn \"'\" + this.getErrorDisplayForChar(c) + \"'\";\n\t}\n\n\t/**\n\t * Lexers can normally match any char in it's vocabulary after matching\n\t * a token, so do the easy thing and just kill a character and hope\n\t * it all works out. You can instead use the rule invocation stack\n\t * to do sophisticated error recovery if you are in a fragment rule.\n\t */\n\trecover(re) {\n\t\tif (this._input.LA(1) !== Token.EOF) {\n\t\t\tif (re instanceof LexerNoViableAltException) {\n\t\t\t\t// skip a char and try again\n\t\t\t\tthis._interp.consume(this._input);\n\t\t\t} else {\n\t\t\t\t// TODO: Do we lose character or line position information?\n\t\t\t\tthis._input.consume();\n\t\t\t}\n\t\t}\n\t}\n\n\tget inputStream(){\n\t\treturn this._input;\n\t}\n\n\tset inputStream(input) {\n\t\tthis._input = null;\n\t\tthis._tokenFactorySourcePair = [ this, this._input ];\n\t\tthis.reset();\n\t\tthis._input = input;\n\t\tthis._tokenFactorySourcePair = [ this, this._input ];\n\t}\n\n\tget sourceName(){\n\t\treturn this._input.sourceName;\n\t}\n\n\tget type(){\n\t\treturn this._type;\n\t}\n\n\tset type(type) {\n\t\tthis._type = type;\n\t}\n\n\tget line(){\n\t\treturn this._interp.line;\n\t}\n\n\tset line(line) {\n\t\tthis._interp.line = line;\n\t}\n\n\tget column(){\n\t\treturn this._interp.column;\n\t}\n\n\tset column(column) {\n\t\tthis._interp.column = column;\n\t}\n\n\tget text(){\n\t\tif (this._text !== null) {\n\t\t\treturn this._text;\n\t\t} else {\n\t\t\treturn this._interp.getText(this._input);\n\t\t}\n\t}\n\n\tset text(text) {\n\t\tthis._text = text;\n\t}\n}\n\n\n\n\nLexer.DEFAULT_MODE = 0;\nLexer.MORE = -2;\nLexer.SKIP = -3;\n\nLexer.DEFAULT_TOKEN_CHANNEL = Token.DEFAULT_CHANNEL;\nLexer.HIDDEN = Token.HIDDEN_CHANNEL;\nLexer.MIN_CHAR_VALUE = 0x0000;\nLexer.MAX_CHAR_VALUE = 0x10FFFF;\n\n// Set the char stream and reset the lexer\n\n\nmodule.exports = Lexer;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Token} = require('./Token');\nconst {ParseTreeListener, TerminalNode, ErrorNode} = require('./tree/Tree');\nconst Recognizer = require('./Recognizer');\nconst {DefaultErrorStrategy} = require('./error/ErrorStrategy');\nconst ATNDeserializer = require('./atn/ATNDeserializer');\nconst ATNDeserializationOptions = require('./atn/ATNDeserializationOptions');\nconst Lexer = require('./Lexer');\n\nclass TraceListener extends ParseTreeListener {\n\tconstructor(parser) {\n\t\tsuper();\n\t\tthis.parser = parser;\n\t}\n\n\tenterEveryRule(ctx) {\n\t\tconsole.log(\"enter   \" + this.parser.ruleNames[ctx.ruleIndex] + \", LT(1)=\" + this.parser._input.LT(1).text);\n\t}\n\n\tvisitTerminal(node) {\n\t\tconsole.log(\"consume \" + node.symbol + \" rule \" + this.parser.ruleNames[this.parser._ctx.ruleIndex]);\n\t}\n\n\texitEveryRule(ctx) {\n\t\tconsole.log(\"exit    \" + this.parser.ruleNames[ctx.ruleIndex] + \", LT(1)=\" + this.parser._input.LT(1).text);\n\t}\n}\n\nclass Parser extends Recognizer {\n\t/**\n\t * this is all the parsing support code essentially; most of it is error\n\t * recovery stuff.\n\t */\n\tconstructor(input) {\n\t\tsuper();\n\t\t// The input stream.\n\t\tthis._input = null;\n\t\t/**\n\t\t * The error handling strategy for the parser. The default value is a new\n\t\t * instance of {@link DefaultErrorStrategy}.\n\t\t */\n\t\tthis._errHandler = new DefaultErrorStrategy();\n\t\tthis._precedenceStack = [];\n\t\tthis._precedenceStack.push(0);\n\t\t/**\n\t\t * The {@link ParserRuleContext} object for the currently executing rule.\n\t\t * this is always non-null during the parsing process.\n\t\t */\n\t\tthis._ctx = null;\n\t\t/**\n\t\t * Specifies whether or not the parser should construct a parse tree during\n\t\t * the parsing process. The default value is {@code true}.\n\t\t */\n\t\tthis.buildParseTrees = true;\n\t\t/**\n\t\t * When {@link //setTrace}{@code (true)} is called, a reference to the\n\t\t * {@link TraceListener} is stored here so it can be easily removed in a\n\t\t * later call to {@link //setTrace}{@code (false)}. The listener itself is\n\t\t * implemented as a parser listener so this field is not directly used by\n\t\t * other parser methods.\n\t\t */\n\t\tthis._tracer = null;\n\t\t/**\n\t\t * The list of {@link ParseTreeListener} listeners registered to receive\n\t\t * events during the parse.\n\t\t */\n\t\tthis._parseListeners = null;\n\t\t/**\n\t\t * The number of syntax errors reported during parsing. this value is\n\t\t * incremented each time {@link //notifyErrorListeners} is called.\n\t\t */\n\t\tthis._syntaxErrors = 0;\n\t\tthis.setInputStream(input);\n\t}\n\n\t// reset the parser's state\n\treset() {\n\t\tif (this._input !== null) {\n\t\t\tthis._input.seek(0);\n\t\t}\n\t\tthis._errHandler.reset(this);\n\t\tthis._ctx = null;\n\t\tthis._syntaxErrors = 0;\n\t\tthis.setTrace(false);\n\t\tthis._precedenceStack = [];\n\t\tthis._precedenceStack.push(0);\n\t\tif (this._interp !== null) {\n\t\t\tthis._interp.reset();\n\t\t}\n\t}\n\n\t/**\n\t * Match current input symbol against {@code ttype}. If the symbol type\n\t * matches, {@link ANTLRErrorStrategy//reportMatch} and {@link //consume} are\n\t * called to complete the match process.\n\t *\n\t * <p>If the symbol type does not match,\n\t * {@link ANTLRErrorStrategy//recoverInline} is called on the current error\n\t * strategy to attempt recovery. If {@link //getBuildParseTree} is\n\t * {@code true} and the token index of the symbol returned by\n\t * {@link ANTLRErrorStrategy//recoverInline} is -1, the symbol is added to\n\t * the parse tree by calling {@link ParserRuleContext//addErrorNode}.</p>\n\t *\n\t * @param ttype the token type to match\n\t * @return the matched symbol\n\t * @throws RecognitionException if the current input symbol did not match\n\t * {@code ttype} and the error strategy could not recover from the\n\t * mismatched symbol\n\t */\n\tmatch(ttype) {\n\t\tlet t = this.getCurrentToken();\n\t\tif (t.type === ttype) {\n\t\t\tthis._errHandler.reportMatch(this);\n\t\t\tthis.consume();\n\t\t} else {\n\t\t\tt = this._errHandler.recoverInline(this);\n\t\t\tif (this.buildParseTrees && t.tokenIndex === -1) {\n\t\t\t\t// we must have conjured up a new token during single token\n\t\t\t\t// insertion\n\t\t\t\t// if it's not the current symbol\n\t\t\t\tthis._ctx.addErrorNode(t);\n\t\t\t}\n\t\t}\n\t\treturn t;\n\t}\n\n\t/**\n\t * Match current input symbol as a wildcard. If the symbol type matches\n\t * (i.e. has a value greater than 0), {@link ANTLRErrorStrategy//reportMatch}\n\t * and {@link //consume} are called to complete the match process.\n\t *\n\t * <p>If the symbol type does not match,\n\t * {@link ANTLRErrorStrategy//recoverInline} is called on the current error\n\t * strategy to attempt recovery. If {@link //getBuildParseTree} is\n\t * {@code true} and the token index of the symbol returned by\n\t * {@link ANTLRErrorStrategy//recoverInline} is -1, the symbol is added to\n\t * the parse tree by calling {@link ParserRuleContext//addErrorNode}.</p>\n\t *\n\t * @return the matched symbol\n\t * @throws RecognitionException if the current input symbol did not match\n\t * a wildcard and the error strategy could not recover from the mismatched\n\t * symbol\n\t */\n\tmatchWildcard() {\n\t\tlet t = this.getCurrentToken();\n\t\tif (t.type > 0) {\n\t\t\tthis._errHandler.reportMatch(this);\n\t\t\tthis.consume();\n\t\t} else {\n\t\t\tt = this._errHandler.recoverInline(this);\n\t\t\tif (this._buildParseTrees && t.tokenIndex === -1) {\n\t\t\t\t// we must have conjured up a new token during single token\n\t\t\t\t// insertion\n\t\t\t\t// if it's not the current symbol\n\t\t\t\tthis._ctx.addErrorNode(t);\n\t\t\t}\n\t\t}\n\t\treturn t;\n\t}\n\n\tgetParseListeners() {\n\t\treturn this._parseListeners || [];\n\t}\n\n\t/**\n\t * Registers {@code listener} to receive events during the parsing process.\n\t *\n\t * <p>To support output-preserving grammar transformations (including but not\n\t * limited to left-recursion removal, automated left-factoring, and\n\t * optimized code generation), calls to listener methods during the parse\n\t * may differ substantially from calls made by\n\t * {@link ParseTreeWalker//DEFAULT} used after the parse is complete. In\n\t * particular, rule entry and exit events may occur in a different order\n\t * during the parse than after the parser. In addition, calls to certain\n\t * rule entry methods may be omitted.</p>\n\t *\n\t * <p>With the following specific exceptions, calls to listener events are\n\t * <em>deterministic</em>, i.e. for identical input the calls to listener\n\t * methods will be the same.</p>\n\t *\n\t * <ul>\n\t * <li>Alterations to the grammar used to generate code may change the\n\t * behavior of the listener calls.</li>\n\t * <li>Alterations to the command line options passed to ANTLR 4 when\n\t * generating the parser may change the behavior of the listener calls.</li>\n\t * <li>Changing the version of the ANTLR Tool used to generate the parser\n\t * may change the behavior of the listener calls.</li>\n\t * </ul>\n\t *\n\t * @param listener the listener to add\n\t *\n\t * @throws NullPointerException if {@code} listener is {@code null}\n\t */\n\taddParseListener(listener) {\n\t\tif (listener === null) {\n\t\t\tthrow \"listener\";\n\t\t}\n\t\tif (this._parseListeners === null) {\n\t\t\tthis._parseListeners = [];\n\t\t}\n\t\tthis._parseListeners.push(listener);\n\t}\n\n\t/**\n\t * Remove {@code listener} from the list of parse listeners.\n\t *\n\t * <p>If {@code listener} is {@code null} or has not been added as a parse\n\t * listener, this method does nothing.</p>\n\t * @param listener the listener to remove\n\t */\n\tremoveParseListener(listener) {\n\t\tif (this._parseListeners !== null) {\n\t\t\tconst idx = this._parseListeners.indexOf(listener);\n\t\t\tif (idx >= 0) {\n\t\t\t\tthis._parseListeners.splice(idx, 1);\n\t\t\t}\n\t\t\tif (this._parseListeners.length === 0) {\n\t\t\t\tthis._parseListeners = null;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove all parse listeners.\n\tremoveParseListeners() {\n\t\tthis._parseListeners = null;\n\t}\n\n\t// Notify any parse listeners of an enter rule event.\n\ttriggerEnterRuleEvent() {\n\t\tif (this._parseListeners !== null) {\n\t\t\tconst ctx = this._ctx;\n\t\t\tthis._parseListeners.forEach(function(listener) {\n\t\t\t\tlistener.enterEveryRule(ctx);\n\t\t\t\tctx.enterRule(listener);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Notify any parse listeners of an exit rule event.\n\t * @see //addParseListener\n\t */\n\ttriggerExitRuleEvent() {\n\t\tif (this._parseListeners !== null) {\n\t\t\t// reverse order walk of listeners\n\t\t\tconst ctx = this._ctx;\n\t\t\tthis._parseListeners.slice(0).reverse().forEach(function(listener) {\n\t\t\t\tctx.exitRule(listener);\n\t\t\t\tlistener.exitEveryRule(ctx);\n\t\t\t});\n\t\t}\n\t}\n\n\tgetTokenFactory() {\n\t\treturn this._input.tokenSource._factory;\n\t}\n\n\t// Tell our token source and error strategy about a new way to create tokens.\n\tsetTokenFactory(factory) {\n\t\tthis._input.tokenSource._factory = factory;\n\t}\n\n\t/**\n\t * The ATN with bypass alternatives is expensive to create so we create it\n\t * lazily.\n\t *\n\t * @throws UnsupportedOperationException if the current parser does not\n\t * implement the {@link //getSerializedATN()} method.\n\t */\n\tgetATNWithBypassAlts() {\n\t\tconst serializedAtn = this.getSerializedATN();\n\t\tif (serializedAtn === null) {\n\t\t\tthrow \"The current parser does not support an ATN with bypass alternatives.\";\n\t\t}\n\t\tlet result = this.bypassAltsAtnCache[serializedAtn];\n\t\tif (result === null) {\n\t\t\tconst deserializationOptions = new ATNDeserializationOptions();\n\t\t\tdeserializationOptions.generateRuleBypassTransitions = true;\n\t\t\tresult = new ATNDeserializer(deserializationOptions)\n\t\t\t\t\t.deserialize(serializedAtn);\n\t\t\tthis.bypassAltsAtnCache[serializedAtn] = result;\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * The preferred method of getting a tree pattern. For example, here's a\n\t * sample use:\n\t *\n\t * <pre>\n\t * ParseTree t = parser.expr();\n\t * ParseTreePattern p = parser.compileParseTreePattern(\"&lt;ID&gt;+0\",\n\t * MyParser.RULE_expr);\n\t * ParseTreeMatch m = p.match(t);\n\t * String id = m.get(\"ID\");\n\t * </pre>\n\t */\n\tcompileParseTreePattern(pattern, patternRuleIndex, lexer) {\n\t\tlexer = lexer || null;\n\t\tif (lexer === null) {\n\t\t\tif (this.getTokenStream() !== null) {\n\t\t\t\tconst tokenSource = this.getTokenStream().tokenSource;\n\t\t\t\tif (tokenSource instanceof Lexer) {\n\t\t\t\t\tlexer = tokenSource;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (lexer === null) {\n\t\t\tthrow \"Parser can't discover a lexer to use\";\n\t\t}\n\t\tconst m = new ParseTreePatternMatcher(lexer, this);\n\t\treturn m.compile(pattern, patternRuleIndex);\n\t}\n\n\tgetInputStream() {\n\t\treturn this.getTokenStream();\n\t}\n\n\tsetInputStream(input) {\n\t\tthis.setTokenStream(input);\n\t}\n\n\tgetTokenStream() {\n\t\treturn this._input;\n\t}\n\n\t// Set the token stream and reset the parser.\n\tsetTokenStream(input) {\n\t\tthis._input = null;\n\t\tthis.reset();\n\t\tthis._input = input;\n\t}\n\n\t/**\n\t * Match needs to return the current input symbol, which gets put\n\t * into the label for the associated token ref; e.g., x=ID.\n\t */\n\tgetCurrentToken() {\n\t\treturn this._input.LT(1);\n\t}\n\n\tnotifyErrorListeners(msg, offendingToken, err) {\n\t\toffendingToken = offendingToken || null;\n\t\terr = err || null;\n\t\tif (offendingToken === null) {\n\t\t\toffendingToken = this.getCurrentToken();\n\t\t}\n\t\tthis._syntaxErrors += 1;\n\t\tconst line = offendingToken.line;\n\t\tconst column = offendingToken.column;\n\t\tconst listener = this.getErrorListenerDispatch();\n\t\tlistener.syntaxError(this, offendingToken, line, column, msg, err);\n\t}\n\n\t/**\n\t * Consume and return the {@linkplain //getCurrentToken current symbol}.\n\t *\n\t * <p>E.g., given the following input with {@code A} being the current\n\t * lookahead symbol, this function moves the cursor to {@code B} and returns\n\t * {@code A}.</p>\n\t *\n\t * <pre>\n\t * A B\n\t * ^\n\t * </pre>\n\t *\n\t * If the parser is not in error recovery mode, the consumed symbol is added\n\t * to the parse tree using {@link ParserRuleContext//addChild(Token)}, and\n\t * {@link ParseTreeListener//visitTerminal} is called on any parse listeners.\n\t * If the parser <em>is</em> in error recovery mode, the consumed symbol is\n\t * added to the parse tree using\n\t * {@link ParserRuleContext//addErrorNode(Token)}, and\n\t * {@link ParseTreeListener//visitErrorNode} is called on any parse\n\t * listeners.\n\t */\n\tconsume() {\n\t\tconst o = this.getCurrentToken();\n\t\tif (o.type !== Token.EOF) {\n\t\t\tthis.getInputStream().consume();\n\t\t}\n\t\tconst hasListener = this._parseListeners !== null && this._parseListeners.length > 0;\n\t\tif (this.buildParseTrees || hasListener) {\n\t\t\tlet node;\n\t\t\tif (this._errHandler.inErrorRecoveryMode(this)) {\n\t\t\t\tnode = this._ctx.addErrorNode(o);\n\t\t\t} else {\n\t\t\t\tnode = this._ctx.addTokenNode(o);\n\t\t\t}\n\t\t\tnode.invokingState = this.state;\n\t\t\tif (hasListener) {\n\t\t\t\tthis._parseListeners.forEach(function(listener) {\n\t\t\t\t\tif (node instanceof ErrorNode || (node.isErrorNode !== undefined && node.isErrorNode())) {\n\t\t\t\t\t\tlistener.visitErrorNode(node);\n\t\t\t\t\t} else if (node instanceof TerminalNode) {\n\t\t\t\t\t\tlistener.visitTerminal(node);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn o;\n\t}\n\n\taddContextToParseTree() {\n\t\t// add current context to parent if we have a parent\n\t\tif (this._ctx.parentCtx !== null) {\n\t\t\tthis._ctx.parentCtx.addChild(this._ctx);\n\t\t}\n\t}\n\n\t/**\n\t * Always called by generated parsers upon entry to a rule. Access field\n\t * {@link //_ctx} get the current context.\n\t */\n\tenterRule(localctx, state, ruleIndex) {\n\t\tthis.state = state;\n\t\tthis._ctx = localctx;\n\t\tthis._ctx.start = this._input.LT(1);\n\t\tif (this.buildParseTrees) {\n\t\t\tthis.addContextToParseTree();\n\t\t}\n\t\tthis.triggerEnterRuleEvent();\n\t}\n\n\texitRule() {\n\t\tthis._ctx.stop = this._input.LT(-1);\n\t\t// trigger event on _ctx, before it reverts to parent\n\t\tthis.triggerExitRuleEvent();\n\t\tthis.state = this._ctx.invokingState;\n\t\tthis._ctx = this._ctx.parentCtx;\n\t}\n\n\tenterOuterAlt(localctx, altNum) {\n\t\tlocalctx.setAltNumber(altNum);\n\t\t// if we have new localctx, make sure we replace existing ctx\n\t\t// that is previous child of parse tree\n\t\tif (this.buildParseTrees && this._ctx !== localctx) {\n\t\t\tif (this._ctx.parentCtx !== null) {\n\t\t\t\tthis._ctx.parentCtx.removeLastChild();\n\t\t\t\tthis._ctx.parentCtx.addChild(localctx);\n\t\t\t}\n\t\t}\n\t\tthis._ctx = localctx;\n\t}\n\n\t/**\n\t * Get the precedence level for the top-most precedence rule.\n\t *\n\t * @return The precedence level for the top-most precedence rule, or -1 if\n\t * the parser context is not nested within a precedence rule.\n\t */\n\tgetPrecedence() {\n\t\tif (this._precedenceStack.length === 0) {\n\t\t\treturn -1;\n\t\t} else {\n\t\t\treturn this._precedenceStack[this._precedenceStack.length-1];\n\t\t}\n\t}\n\n\tenterRecursionRule(localctx, state, ruleIndex, precedence) {\n\t   this.state = state;\n\t   this._precedenceStack.push(precedence);\n\t   this._ctx = localctx;\n\t   this._ctx.start = this._input.LT(1);\n\t   this.triggerEnterRuleEvent(); // simulates rule entry for left-recursive rules\n   }\n\n\t// Like {@link //enterRule} but for recursive rules.\n\tpushNewRecursionContext(localctx, state, ruleIndex) {\n\t\tconst previous = this._ctx;\n\t\tprevious.parentCtx = localctx;\n\t\tprevious.invokingState = state;\n\t\tprevious.stop = this._input.LT(-1);\n\n\t\tthis._ctx = localctx;\n\t\tthis._ctx.start = previous.start;\n\t\tif (this.buildParseTrees) {\n\t\t\tthis._ctx.addChild(previous);\n\t\t}\n\t\tthis.triggerEnterRuleEvent(); // simulates rule entry for left-recursive rules\n\t}\n\n\tunrollRecursionContexts(parentCtx) {\n\t\tthis._precedenceStack.pop();\n\t\tthis._ctx.stop = this._input.LT(-1);\n\t\tconst retCtx = this._ctx; // save current ctx (return value)\n\t\t// unroll so _ctx is as it was before call to recursive method\n\t\tconst parseListeners = this.getParseListeners();\n\t\tif (parseListeners !== null && parseListeners.length > 0) {\n\t\t\twhile (this._ctx !== parentCtx) {\n\t\t\t\tthis.triggerExitRuleEvent();\n\t\t\t\tthis._ctx = this._ctx.parentCtx;\n\t\t\t}\n\t\t} else {\n\t\t\tthis._ctx = parentCtx;\n\t\t}\n\t\t// hook into tree\n\t\tretCtx.parentCtx = parentCtx;\n\t\tif (this.buildParseTrees && parentCtx !== null) {\n\t\t\t// add return ctx into invoking rule's tree\n\t\t\tparentCtx.addChild(retCtx);\n\t\t}\n\t}\n\n\tgetInvokingContext(ruleIndex) {\n\t\tlet ctx = this._ctx;\n\t\twhile (ctx !== null) {\n\t\t\tif (ctx.ruleIndex === ruleIndex) {\n\t\t\t\treturn ctx;\n\t\t\t}\n\t\t\tctx = ctx.parentCtx;\n\t\t}\n\t\treturn null;\n\t}\n\n\tprecpred(localctx, precedence) {\n\t\treturn precedence >= this._precedenceStack[this._precedenceStack.length-1];\n\t}\n\n\tinContext(context) {\n\t\t// TODO: useful in parser?\n\t\treturn false;\n\t}\n\n\t/**\n\t * Checks whether or not {@code symbol} can follow the current state in the\n\t * ATN. The behavior of this method is equivalent to the following, but is\n\t * implemented such that the complete context-sensitive follow set does not\n\t * need to be explicitly constructed.\n\t *\n\t * <pre>\n\t * return getExpectedTokens().contains(symbol);\n\t * </pre>\n\t *\n\t * @param symbol the symbol type to check\n\t * @return {@code true} if {@code symbol} can follow the current state in\n\t * the ATN, otherwise {@code false}.\n\t */\n\tisExpectedToken(symbol) {\n\t\tconst atn = this._interp.atn;\n\t\tlet ctx = this._ctx;\n\t\tconst s = atn.states[this.state];\n\t\tlet following = atn.nextTokens(s);\n\t\tif (following.contains(symbol)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!following.contains(Token.EPSILON)) {\n\t\t\treturn false;\n\t\t}\n\t\twhile (ctx !== null && ctx.invokingState >= 0 && following.contains(Token.EPSILON)) {\n\t\t\tconst invokingState = atn.states[ctx.invokingState];\n\t\t\tconst rt = invokingState.transitions[0];\n\t\t\tfollowing = atn.nextTokens(rt.followState);\n\t\t\tif (following.contains(symbol)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tctx = ctx.parentCtx;\n\t\t}\n\t\tif (following.contains(Token.EPSILON) && symbol === Token.EOF) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Computes the set of input symbols which could follow the current parser\n\t * state and context, as given by {@link //getState} and {@link //getContext},\n\t * respectively.\n\t *\n\t * @see ATN//getExpectedTokens(int, RuleContext)\n\t */\n\tgetExpectedTokens() {\n\t\treturn this._interp.atn.getExpectedTokens(this.state, this._ctx);\n\t}\n\n\tgetExpectedTokensWithinCurrentRule() {\n\t\tconst atn = this._interp.atn;\n\t\tconst s = atn.states[this.state];\n\t\treturn atn.nextTokens(s);\n\t}\n\n\t// Get a rule's index (i.e., {@code RULE_ruleName} field) or -1 if not found.\n\tgetRuleIndex(ruleName) {\n\t\tconst ruleIndex = this.getRuleIndexMap()[ruleName];\n\t\tif (ruleIndex !== null) {\n\t\t\treturn ruleIndex;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/**\n\t * Return List&lt;String&gt; of the rule names in your parser instance\n\t * leading up to a call to the current rule. You could override if\n\t * you want more details such as the file/line info of where\n\t * in the ATN a rule is invoked.\n\t *\n\t * this is very useful for error messages.\n\t */\n\tgetRuleInvocationStack(p) {\n\t\tp = p || null;\n\t\tif (p === null) {\n\t\t\tp = this._ctx;\n\t\t}\n\t\tconst stack = [];\n\t\twhile (p !== null) {\n\t\t\t// compute what follows who invoked us\n\t\t\tconst ruleIndex = p.ruleIndex;\n\t\t\tif (ruleIndex < 0) {\n\t\t\t\tstack.push(\"n/a\");\n\t\t\t} else {\n\t\t\t\tstack.push(this.ruleNames[ruleIndex]);\n\t\t\t}\n\t\t\tp = p.parentCtx;\n\t\t}\n\t\treturn stack;\n\t}\n\n\t// For debugging and other purposes.\n\tgetDFAStrings() {\n\t\treturn this._interp.decisionToDFA.toString();\n\t}\n\n\t// For debugging and other purposes.\n\tdumpDFA() {\n\t\tlet seenOne = false;\n\t\tfor (let i = 0; i < this._interp.decisionToDFA.length; i++) {\n\t\t\tconst dfa = this._interp.decisionToDFA[i];\n\t\t\tif (dfa.states.length > 0) {\n\t\t\t\tif (seenOne) {\n\t\t\t\t\tconsole.log();\n\t\t\t\t}\n\t\t\t\tthis.printer.println(\"Decision \" + dfa.decision + \":\");\n\t\t\t\tthis.printer.print(dfa.toString(this.literalNames, this.symbolicNames));\n\t\t\t\tseenOne = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t\t\"\t\t\tprinter = function() {\\r\\n\" +\n\t\t\"\t\t\t\tthis.println = function(s) { document.getElementById('output') += s + '\\\\n'; }\\r\\n\" +\n\t\t\"\t\t\t\tthis.print = function(s) { document.getElementById('output') += s; }\\r\\n\" +\n\t\t\"\t\t\t};\\r\\n\" +\n\t\t*/\n\tgetSourceName() {\n\t\treturn this._input.sourceName;\n\t}\n\n\t/**\n\t * During a parse is sometimes useful to listen in on the rule entry and exit\n\t * events as well as token matches. this is for quick and dirty debugging.\n\t */\n\tsetTrace(trace) {\n\t\tif (!trace) {\n\t\t\tthis.removeParseListener(this._tracer);\n\t\t\tthis._tracer = null;\n\t\t} else {\n\t\t\tif (this._tracer !== null) {\n\t\t\t\tthis.removeParseListener(this._tracer);\n\t\t\t}\n\t\t\tthis._tracer = new TraceListener(this);\n\t\t\tthis.addParseListener(this._tracer);\n\t\t}\n\t}\n}\n\n/**\n * this field maps from the serialized ATN string to the deserialized {@link\n * ATN} with\n * bypass alternatives.\n *\n * @see ATNDeserializationOptions//isGenerateRuleBypassTransitions()\n */\nParser.bypassAltsAtnCache = {};\n\nmodule.exports = Parser;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst RuleContext = require('./RuleContext');\nconst Tree = require('./tree/Tree');\nconst INVALID_INTERVAL = Tree.INVALID_INTERVAL;\nconst TerminalNode = Tree.TerminalNode;\nconst TerminalNodeImpl = Tree.TerminalNodeImpl;\nconst ErrorNodeImpl = Tree.ErrorNodeImpl;\nconst Interval = require(\"./IntervalSet\").Interval;\n\n/**\n * A rule invocation record for parsing.\n *\n *  Contains all of the information about the current rule not stored in the\n *  RuleContext. It handles parse tree children list, Any ATN state\n *  tracing, and the default values available for rule indications:\n *  start, stop, rule index, current alt number, current\n *  ATN state.\n *\n *  Subclasses made for each rule and grammar track the parameters,\n *  return values, locals, and labels specific to that rule. These\n *  are the objects that are returned from rules.\n *\n *  Note text is not an actual field of a rule return value; it is computed\n *  from start and stop using the input stream's toString() method.  I\n *  could add a ctor to this so that we can pass in and store the input\n *  stream, but I'm not sure we want to do that.  It would seem to be undefined\n *  to get the .text property anyway if the rule matches tokens from multiple\n *  input streams.\n *\n *  I do not use getters for fields of objects that are used simply to\n *  group values such as this aggregate.  The getters/setters are there to\n *  satisfy the superclass interface.\n */\nclass ParserRuleContext extends RuleContext {\n\tconstructor(parent, invokingStateNumber) {\n\t\tparent = parent || null;\n\t\tinvokingStateNumber = invokingStateNumber || null;\n\t\tsuper(parent, invokingStateNumber);\n\t\tthis.ruleIndex = -1;\n\t\t/**\n\t\t * If we are debugging or building a parse tree for a visitor,\n\t\t * we need to track all of the tokens and rule invocations associated\n\t\t * with this rule's context. This is empty for parsing w/o tree constr.\n\t\t * operation because we don't the need to track the details about\n\t\t * how we parse this rule.\n\t\t */\n\t\tthis.children = null;\n\t\tthis.start = null;\n\t\tthis.stop = null;\n\t\t/**\n\t\t * The exception that forced this rule to return. If the rule successfully\n\t\t * completed, this is {@code null}.\n\t\t */\n\t\tthis.exception = null;\n\t}\n\n\t// COPY a ctx (I'm deliberately not using copy constructor)\n\tcopyFrom(ctx) {\n\t\t// from RuleContext\n\t\tthis.parentCtx = ctx.parentCtx;\n\t\tthis.invokingState = ctx.invokingState;\n\t\tthis.children = null;\n\t\tthis.start = ctx.start;\n\t\tthis.stop = ctx.stop;\n\t\t// copy any error nodes to alt label node\n\t\tif(ctx.children) {\n\t\t\tthis.children = [];\n\t\t\t// reset parent pointer for any error nodes\n\t\t\tctx.children.map(function(child) {\n\t\t\t\tif (child instanceof ErrorNodeImpl) {\n\t\t\t\t\tthis.children.push(child);\n\t\t\t\t\tchild.parentCtx = this;\n\t\t\t\t}\n\t\t\t}, this);\n\t\t}\n\t}\n\n\t// Double dispatch methods for listeners\n\tenterRule(listener) {\n\t}\n\n\texitRule(listener) {\n\t}\n\n\t// Does not set parent link; other add methods do that\n\taddChild(child) {\n\t\tif (this.children === null) {\n\t\t\tthis.children = [];\n\t\t}\n\t\tthis.children.push(child);\n\t\treturn child;\n\t}\n\n\t/** Used by enterOuterAlt to toss out a RuleContext previously added as\n\t * we entered a rule. If we have // label, we will need to remove\n\t * generic ruleContext object.\n\t */\n\tremoveLastChild() {\n\t\tif (this.children !== null) {\n\t\t\tthis.children.pop();\n\t\t}\n\t}\n\n\taddTokenNode(token) {\n\t\tconst node = new TerminalNodeImpl(token);\n\t\tthis.addChild(node);\n\t\tnode.parentCtx = this;\n\t\treturn node;\n\t}\n\n\taddErrorNode(badToken) {\n\t\tconst node = new ErrorNodeImpl(badToken);\n\t\tthis.addChild(node);\n\t\tnode.parentCtx = this;\n\t\treturn node;\n\t}\n\n\tgetChild(i, type) {\n\t\ttype = type || null;\n\t\tif (this.children === null || i < 0 || i >= this.children.length) {\n\t\t\treturn null;\n\t\t}\n\t\tif (type === null) {\n\t\t\treturn this.children[i];\n\t\t} else {\n\t\t\tfor(let j=0; j<this.children.length; j++) {\n\t\t\t\tconst child = this.children[j];\n\t\t\t\tif(child instanceof type) {\n\t\t\t\t\tif(i===0) {\n\t\t\t\t\t\treturn child;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ti -= 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tgetToken(ttype, i) {\n\t\tif (this.children === null || i < 0 || i >= this.children.length) {\n\t\t\treturn null;\n\t\t}\n\t\tfor(let j=0; j<this.children.length; j++) {\n\t\t\tconst child = this.children[j];\n\t\t\tif (child instanceof TerminalNode) {\n\t\t\t\tif (child.symbol.type === ttype) {\n\t\t\t\t\tif(i===0) {\n\t\t\t\t\t\treturn child;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ti -= 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tgetTokens(ttype ) {\n\t\tif (this.children=== null) {\n\t\t\treturn [];\n\t\t} else {\n\t\t\tconst tokens = [];\n\t\t\tfor(let j=0; j<this.children.length; j++) {\n\t\t\t\tconst child = this.children[j];\n\t\t\t\tif (child instanceof TerminalNode) {\n\t\t\t\t\tif (child.symbol.type === ttype) {\n\t\t\t\t\t\ttokens.push(child);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokens;\n\t\t}\n\t}\n\n\tgetTypedRuleContext(ctxType, i) {\n\t\treturn this.getChild(i, ctxType);\n\t}\n\n\tgetTypedRuleContexts(ctxType) {\n\t\tif (this.children=== null) {\n\t\t\treturn [];\n\t\t} else {\n\t\t\tconst contexts = [];\n\t\t\tfor(let j=0; j<this.children.length; j++) {\n\t\t\t\tconst child = this.children[j];\n\t\t\t\tif (child instanceof ctxType) {\n\t\t\t\t\tcontexts.push(child);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn contexts;\n\t\t}\n\t}\n\n\tgetChildCount() {\n\t\tif (this.children=== null) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn this.children.length;\n\t\t}\n\t}\n\n\tgetSourceInterval() {\n\t\tif( this.start === null || this.stop === null) {\n\t\t\treturn INVALID_INTERVAL;\n\t\t} else {\n\t\t\treturn new Interval(this.start.tokenIndex, this.stop.tokenIndex);\n\t\t}\n\t}\n}\n\nRuleContext.EMPTY = new ParserRuleContext();\n\nclass InterpreterRuleContext extends ParserRuleContext {\n\tconstructor(parent, invokingStateNumber, ruleIndex) {\n\t\tsuper(parent, invokingStateNumber);\n\t\tthis.ruleIndex = ruleIndex;\n\t}\n}\n\nmodule.exports = ParserRuleContext;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst RuleContext = require('./RuleContext');\nconst {Hash, Map, equalArrays} = require('./Utils');\n\nclass PredictionContext {\n\n\tconstructor(cachedHashCode) {\n\t\tthis.cachedHashCode = cachedHashCode;\n\t}\n\n\t/**\n\t * Stores the computed hash code of this {@link PredictionContext}. The hash\n\t * code is computed in parts to match the following reference algorithm.\n\t *\n\t * <pre>\n\t * private int referenceHashCode() {\n\t * int hash = {@link MurmurHash//initialize MurmurHash.initialize}({@link\n\t * //INITIAL_HASH});\n\t *\n\t * for (int i = 0; i &lt; {@link //size()}; i++) {\n\t * hash = {@link MurmurHash//update MurmurHash.update}(hash, {@link //getParent\n\t * getParent}(i));\n\t * }\n\t *\n\t * for (int i = 0; i &lt; {@link //size()}; i++) {\n\t * hash = {@link MurmurHash//update MurmurHash.update}(hash, {@link\n\t * //getReturnState getReturnState}(i));\n\t * }\n\t *\n\t * hash = {@link MurmurHash//finish MurmurHash.finish}(hash, 2// {@link\n\t * //size()});\n\t * return hash;\n\t * }\n\t * </pre>\n\t * This means only the {@link //EMPTY} context is in set.\n\t */\n\tisEmpty() {\n\t\treturn this === PredictionContext.EMPTY;\n\t}\n\n\thasEmptyPath() {\n\t\treturn this.getReturnState(this.length - 1) === PredictionContext.EMPTY_RETURN_STATE;\n\t}\n\n\thashCode() {\n\t\treturn this.cachedHashCode;\n\t}\n\n\tupdateHashCode(hash) {\n\t\thash.update(this.cachedHashCode);\n\t}\n}\n\n/**\n * Represents {@code $} in local context prediction, which means wildcard.\n * {@code//+x =//}.\n */\nPredictionContext.EMPTY = null;\n\n/**\n * Represents {@code $} in an array in full context mode, when {@code $}\n * doesn't mean wildcard: {@code $ + x = [$,x]}. Here,\n * {@code $} = {@link //EMPTY_RETURN_STATE}.\n */\nPredictionContext.EMPTY_RETURN_STATE = 0x7FFFFFFF;\n\nPredictionContext.globalNodeCount = 1;\nPredictionContext.id = PredictionContext.globalNodeCount;\n\n\n/*\nfunction calculateHashString(parent, returnState) {\n\treturn \"\" + parent + returnState;\n}\n*/\n\n/**\n * Used to cache {@link PredictionContext} objects. Its used for the shared\n * context cash associated with contexts in DFA states. This cache\n * can be used for both lexers and parsers.\n */\nclass PredictionContextCache {\n\n\tconstructor() {\n\t\tthis.cache = new Map();\n\t}\n\n\t/**\n\t * Add a context to the cache and return it. If the context already exists,\n\t * return that one instead and do not add a new context to the cache.\n\t * Protect shared cache from unsafe thread access.\n\t */\n\tadd(ctx) {\n\t\tif (ctx === PredictionContext.EMPTY) {\n\t\t\treturn PredictionContext.EMPTY;\n\t\t}\n\t\tconst existing = this.cache.get(ctx) || null;\n\t\tif (existing !== null) {\n\t\t\treturn existing;\n\t\t}\n\t\tthis.cache.put(ctx, ctx);\n\t\treturn ctx;\n\t}\n\n\tget(ctx) {\n\t\treturn this.cache.get(ctx) || null;\n\t}\n\n\tget length(){\n\t\treturn this.cache.length;\n\t}\n}\n\n\nclass SingletonPredictionContext extends PredictionContext {\n\n\tconstructor(parent, returnState) {\n\t\tlet hashCode = 0;\n\t\tconst hash = new Hash();\n\t\tif(parent !== null) {\n\t\t\thash.update(parent, returnState);\n\t\t} else {\n\t\t\thash.update(1);\n\t\t}\n\t\thashCode = hash.finish();\n\t\tsuper(hashCode);\n\t\tthis.parentCtx = parent;\n\t\tthis.returnState = returnState;\n\t}\n\n\tgetParent(index) {\n\t\treturn this.parentCtx;\n\t}\n\n\tgetReturnState(index) {\n\t\treturn this.returnState;\n\t}\n\n\tequals(other) {\n\t\tif (this === other) {\n\t\t\treturn true;\n\t\t} else if (!(other instanceof SingletonPredictionContext)) {\n\t\t\treturn false;\n\t\t} else if (this.hashCode() !== other.hashCode()) {\n\t\t\treturn false; // can't be same if hash is different\n\t\t} else {\n\t\t\tif(this.returnState !== other.returnState)\n\t\t\t\treturn false;\n\t\t\telse if(this.parentCtx==null)\n\t\t\t\treturn other.parentCtx==null\n\t\t\telse\n\t\t\t\treturn this.parentCtx.equals(other.parentCtx);\n\t\t}\n\t}\n\n\ttoString() {\n\t\tconst up = this.parentCtx === null ? \"\" : this.parentCtx.toString();\n\t\tif (up.length === 0) {\n\t\t\tif (this.returnState === PredictionContext.EMPTY_RETURN_STATE) {\n\t\t\t\treturn \"$\";\n\t\t\t} else {\n\t\t\t\treturn \"\" + this.returnState;\n\t\t\t}\n\t\t} else {\n\t\t\treturn \"\" + this.returnState + \" \" + up;\n\t\t}\n\t}\n\n\tget length(){\n\t\treturn 1;\n\t}\n\n\tstatic create(parent, returnState) {\n\t\tif (returnState === PredictionContext.EMPTY_RETURN_STATE && parent === null) {\n\t\t\t// someone can pass in the bits of an array ctx that mean $\n\t\t\treturn PredictionContext.EMPTY;\n\t\t} else {\n\t\t\treturn new SingletonPredictionContext(parent, returnState);\n\t\t}\n\t}\n}\n\nclass EmptyPredictionContext extends SingletonPredictionContext {\n\n\tconstructor() {\n\t\tsuper(null, PredictionContext.EMPTY_RETURN_STATE);\n\t}\n\n\tisEmpty() {\n\t\treturn true;\n\t}\n\n\tgetParent(index) {\n\t\treturn null;\n\t}\n\n\tgetReturnState(index) {\n\t\treturn this.returnState;\n\t}\n\n\tequals(other) {\n\t\treturn this === other;\n\t}\n\n\ttoString() {\n\t\treturn \"$\";\n\t}\n}\n\n\nPredictionContext.EMPTY = new EmptyPredictionContext();\n\nclass ArrayPredictionContext extends PredictionContext {\n\n\tconstructor(parents, returnStates) {\n\t\t/**\n\t\t * Parent can be null only if full ctx mode and we make an array\n\t\t * from {@link //EMPTY} and non-empty. We merge {@link //EMPTY} by using\n\t\t * null parent and\n\t\t * returnState == {@link //EMPTY_RETURN_STATE}.\n\t\t */\n\t\tconst h = new Hash();\n\t\th.update(parents, returnStates);\n\t\tconst hashCode = h.finish();\n\t\tsuper(hashCode);\n\t\tthis.parents = parents;\n\t\tthis.returnStates = returnStates;\n\t\treturn this;\n\t}\n\n\tisEmpty() {\n\t\t// since EMPTY_RETURN_STATE can only appear in the last position, we\n\t\t// don't need to verify that size==1\n\t\treturn this.returnStates[0] === PredictionContext.EMPTY_RETURN_STATE;\n\t}\n\n\tgetParent(index) {\n\t\treturn this.parents[index];\n\t}\n\n\tgetReturnState(index) {\n\t\treturn this.returnStates[index];\n\t}\n\n\tequals(other) {\n\t\tif (this === other) {\n\t\t\treturn true;\n\t\t} else if (!(other instanceof ArrayPredictionContext)) {\n\t\t\treturn false;\n\t\t} else if (this.hashCode() !== other.hashCode()) {\n\t\t\treturn false; // can't be same if hash is different\n\t\t} else {\n\t\t\treturn equalArrays(this.returnStates, other.returnStates) &&\n\t\t\t\tequalArrays(this.parents, other.parents);\n\t\t}\n\t}\n\n\ttoString() {\n\t\tif (this.isEmpty()) {\n\t\t\treturn \"[]\";\n\t\t} else {\n\t\t\tlet s = \"[\";\n\t\t\tfor (let i = 0; i < this.returnStates.length; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\ts = s + \", \";\n\t\t\t\t}\n\t\t\t\tif (this.returnStates[i] === PredictionContext.EMPTY_RETURN_STATE) {\n\t\t\t\t\ts = s + \"$\";\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ts = s + this.returnStates[i];\n\t\t\t\tif (this.parents[i] !== null) {\n\t\t\t\t\ts = s + \" \" + this.parents[i];\n\t\t\t\t} else {\n\t\t\t\t\ts = s + \"null\";\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn s + \"]\";\n\t\t}\n\t}\n\n\tget length(){\n\t\treturn this.returnStates.length;\n\t}\n}\n\n\n/**\n * Convert a {@link RuleContext} tree to a {@link PredictionContext} graph.\n * Return {@link //EMPTY} if {@code outerContext} is empty or null.\n */\nfunction predictionContextFromRuleContext(atn, outerContext) {\n\tif (outerContext === undefined || outerContext === null) {\n\t\touterContext = RuleContext.EMPTY;\n\t}\n\t// if we are in RuleContext of start rule, s, then PredictionContext\n\t// is EMPTY. Nobody called us. (if we are empty, return empty)\n\tif (outerContext.parentCtx === null || outerContext === RuleContext.EMPTY) {\n\t\treturn PredictionContext.EMPTY;\n\t}\n\t// If we have a parent, convert it to a PredictionContext graph\n\tconst parent = predictionContextFromRuleContext(atn, outerContext.parentCtx);\n\tconst state = atn.states[outerContext.invokingState];\n\tconst transition = state.transitions[0];\n\treturn SingletonPredictionContext.create(parent, transition.followState.stateNumber);\n}\n/*\nfunction calculateListsHashString(parents, returnStates) {\n\tconst s = \"\";\n\tparents.map(function(p) {\n\t\ts = s + p;\n\t});\n\treturnStates.map(function(r) {\n\t\ts = s + r;\n\t});\n\treturn s;\n}\n*/\nfunction merge(a, b, rootIsWildcard, mergeCache) {\n\t// share same graph if both same\n\tif (a === b) {\n\t\treturn a;\n\t}\n\tif (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {\n\t\treturn mergeSingletons(a, b, rootIsWildcard, mergeCache);\n\t}\n\t// At least one of a or b is array\n\t// If one is $ and rootIsWildcard, return $ as// wildcard\n\tif (rootIsWildcard) {\n\t\tif (a instanceof EmptyPredictionContext) {\n\t\t\treturn a;\n\t\t}\n\t\tif (b instanceof EmptyPredictionContext) {\n\t\t\treturn b;\n\t\t}\n\t}\n\t// convert singleton so both are arrays to normalize\n\tif (a instanceof SingletonPredictionContext) {\n\t\ta = new ArrayPredictionContext([a.getParent()], [a.returnState]);\n\t}\n\tif (b instanceof SingletonPredictionContext) {\n\t\tb = new ArrayPredictionContext([b.getParent()], [b.returnState]);\n\t}\n\treturn mergeArrays(a, b, rootIsWildcard, mergeCache);\n}\n\n/**\n * Merge two {@link SingletonPredictionContext} instances.\n *\n * <p>Stack tops equal, parents merge is same; return left graph.<br>\n * <embed src=\"images/SingletonMerge_SameRootSamePar.svg\"\n * type=\"image/svg+xml\"/></p>\n *\n * <p>Same stack top, parents differ; merge parents giving array node, then\n * remainders of those graphs. A new root node is created to point to the\n * merged parents.<br>\n * <embed src=\"images/SingletonMerge_SameRootDiffPar.svg\"\n * type=\"image/svg+xml\"/></p>\n *\n * <p>Different stack tops pointing to same parent. Make array node for the\n * root where both element in the root point to the same (original)\n * parent.<br>\n * <embed src=\"images/SingletonMerge_DiffRootSamePar.svg\"\n * type=\"image/svg+xml\"/></p>\n *\n * <p>Different stack tops pointing to different parents. Make array node for\n * the root where each element points to the corresponding original\n * parent.<br>\n * <embed src=\"images/SingletonMerge_DiffRootDiffPar.svg\"\n * type=\"image/svg+xml\"/></p>\n *\n * @param a the first {@link SingletonPredictionContext}\n * @param b the second {@link SingletonPredictionContext}\n * @param rootIsWildcard {@code true} if this is a local-context merge,\n * otherwise false to indicate a full-context merge\n * @param mergeCache\n */\nfunction mergeSingletons(a, b, rootIsWildcard, mergeCache) {\n\tif (mergeCache !== null) {\n\t\tlet previous = mergeCache.get(a, b);\n\t\tif (previous !== null) {\n\t\t\treturn previous;\n\t\t}\n\t\tprevious = mergeCache.get(b, a);\n\t\tif (previous !== null) {\n\t\t\treturn previous;\n\t\t}\n\t}\n\n\tconst rootMerge = mergeRoot(a, b, rootIsWildcard);\n\tif (rootMerge !== null) {\n\t\tif (mergeCache !== null) {\n\t\t\tmergeCache.set(a, b, rootMerge);\n\t\t}\n\t\treturn rootMerge;\n\t}\n\tif (a.returnState === b.returnState) {\n\t\tconst parent = merge(a.parentCtx, b.parentCtx, rootIsWildcard, mergeCache);\n\t\t// if parent is same as existing a or b parent or reduced to a parent,\n\t\t// return it\n\t\tif (parent === a.parentCtx) {\n\t\t\treturn a; // ax + bx = ax, if a=b\n\t\t}\n\t\tif (parent === b.parentCtx) {\n\t\t\treturn b; // ax + bx = bx, if a=b\n\t\t}\n\t\t// else: ax + ay = a'[x,y]\n\t\t// merge parents x and y, giving array node with x,y then remainders\n\t\t// of those graphs. dup a, a' points at merged array\n\t\t// new joined parent so create new singleton pointing to it, a'\n\t\tconst spc = SingletonPredictionContext.create(parent, a.returnState);\n\t\tif (mergeCache !== null) {\n\t\t\tmergeCache.set(a, b, spc);\n\t\t}\n\t\treturn spc;\n\t} else { // a != b payloads differ\n\t\t// see if we can collapse parents due to $+x parents if local ctx\n\t\tlet singleParent = null;\n\t\tif (a === b || (a.parentCtx !== null && a.parentCtx === b.parentCtx)) { // ax +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// bx =\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// [a,b]x\n\t\t\tsingleParent = a.parentCtx;\n\t\t}\n\t\tif (singleParent !== null) { // parents are same\n\t\t\t// sort payloads and use same parent\n\t\t\tconst payloads = [ a.returnState, b.returnState ];\n\t\t\tif (a.returnState > b.returnState) {\n\t\t\t\tpayloads[0] = b.returnState;\n\t\t\t\tpayloads[1] = a.returnState;\n\t\t\t}\n\t\t\tconst parents = [ singleParent, singleParent ];\n\t\t\tconst apc = new ArrayPredictionContext(parents, payloads);\n\t\t\tif (mergeCache !== null) {\n\t\t\t\tmergeCache.set(a, b, apc);\n\t\t\t}\n\t\t\treturn apc;\n\t\t}\n\t\t// parents differ and can't merge them. Just pack together\n\t\t// into array; can't merge.\n\t\t// ax + by = [ax,by]\n\t\tconst payloads = [ a.returnState, b.returnState ];\n\t\tlet parents = [ a.parentCtx, b.parentCtx ];\n\t\tif (a.returnState > b.returnState) { // sort by payload\n\t\t\tpayloads[0] = b.returnState;\n\t\t\tpayloads[1] = a.returnState;\n\t\t\tparents = [ b.parentCtx, a.parentCtx ];\n\t\t}\n\t\tconst a_ = new ArrayPredictionContext(parents, payloads);\n\t\tif (mergeCache !== null) {\n\t\t\tmergeCache.set(a, b, a_);\n\t\t}\n\t\treturn a_;\n\t}\n}\n\n/**\n * Handle case where at least one of {@code a} or {@code b} is\n * {@link //EMPTY}. In the following diagrams, the symbol {@code $} is used\n * to represent {@link //EMPTY}.\n *\n * <h2>Local-Context Merges</h2>\n *\n * <p>These local-context merge operations are used when {@code rootIsWildcard}\n * is true.</p>\n *\n * <p>{@link //EMPTY} is superset of any graph; return {@link //EMPTY}.<br>\n * <embed src=\"images/LocalMerge_EmptyRoot.svg\" type=\"image/svg+xml\"/></p>\n *\n * <p>{@link //EMPTY} and anything is {@code //EMPTY}, so merged parent is\n * {@code //EMPTY}; return left graph.<br>\n * <embed src=\"images/LocalMerge_EmptyParent.svg\" type=\"image/svg+xml\"/></p>\n *\n * <p>Special case of last merge if local context.<br>\n * <embed src=\"images/LocalMerge_DiffRoots.svg\" type=\"image/svg+xml\"/></p>\n *\n * <h2>Full-Context Merges</h2>\n *\n * <p>These full-context merge operations are used when {@code rootIsWildcard}\n * is false.</p>\n *\n * <p><embed src=\"images/FullMerge_EmptyRoots.svg\" type=\"image/svg+xml\"/></p>\n *\n * <p>Must keep all contexts; {@link //EMPTY} in array is a special value (and\n * null parent).<br>\n * <embed src=\"images/FullMerge_EmptyRoot.svg\" type=\"image/svg+xml\"/></p>\n *\n * <p><embed src=\"images/FullMerge_SameRoot.svg\" type=\"image/svg+xml\"/></p>\n *\n * @param a the first {@link SingletonPredictionContext}\n * @param b the second {@link SingletonPredictionContext}\n * @param rootIsWildcard {@code true} if this is a local-context merge,\n * otherwise false to indicate a full-context merge\n */\nfunction mergeRoot(a, b, rootIsWildcard) {\n\tif (rootIsWildcard) {\n\t\tif (a === PredictionContext.EMPTY) {\n\t\t\treturn PredictionContext.EMPTY; // // + b =//\n\t\t}\n\t\tif (b === PredictionContext.EMPTY) {\n\t\t\treturn PredictionContext.EMPTY; // a +// =//\n\t\t}\n\t} else {\n\t\tif (a === PredictionContext.EMPTY && b === PredictionContext.EMPTY) {\n\t\t\treturn PredictionContext.EMPTY; // $ + $ = $\n\t\t} else if (a === PredictionContext.EMPTY) { // $ + x = [$,x]\n\t\t\tconst payloads = [ b.returnState,\n\t\t\t\t\tPredictionContext.EMPTY_RETURN_STATE ];\n\t\t\tconst parents = [ b.parentCtx, null ];\n\t\t\treturn new ArrayPredictionContext(parents, payloads);\n\t\t} else if (b === PredictionContext.EMPTY) { // x + $ = [$,x] ($ is always first if present)\n\t\t\tconst payloads = [ a.returnState, PredictionContext.EMPTY_RETURN_STATE ];\n\t\t\tconst parents = [ a.parentCtx, null ];\n\t\t\treturn new ArrayPredictionContext(parents, payloads);\n\t\t}\n\t}\n\treturn null;\n}\n\n/**\n * Merge two {@link ArrayPredictionContext} instances.\n *\n * <p>Different tops, different parents.<br>\n * <embed src=\"images/ArrayMerge_DiffTopDiffPar.svg\" type=\"image/svg+xml\"/></p>\n *\n * <p>Shared top, same parents.<br>\n * <embed src=\"images/ArrayMerge_ShareTopSamePar.svg\" type=\"image/svg+xml\"/></p>\n *\n * <p>Shared top, different parents.<br>\n * <embed src=\"images/ArrayMerge_ShareTopDiffPar.svg\" type=\"image/svg+xml\"/></p>\n *\n * <p>Shared top, all shared parents.<br>\n * <embed src=\"images/ArrayMerge_ShareTopSharePar.svg\"\n * type=\"image/svg+xml\"/></p>\n *\n * <p>Equal tops, merge parents and reduce top to\n * {@link SingletonPredictionContext}.<br>\n * <embed src=\"images/ArrayMerge_EqualTop.svg\" type=\"image/svg+xml\"/></p>\n */\nfunction mergeArrays(a, b, rootIsWildcard, mergeCache) {\n\tif (mergeCache !== null) {\n\t\tlet previous = mergeCache.get(a, b);\n\t\tif (previous !== null) {\n\t\t\treturn previous;\n\t\t}\n\t\tprevious = mergeCache.get(b, a);\n\t\tif (previous !== null) {\n\t\t\treturn previous;\n\t\t}\n\t}\n\t// merge sorted payloads a + b => M\n\tlet i = 0; // walks a\n\tlet j = 0; // walks b\n\tlet k = 0; // walks target M array\n\n\tlet mergedReturnStates = [];\n\tlet mergedParents = [];\n\t// walk and merge to yield mergedParents, mergedReturnStates\n\twhile (i < a.returnStates.length && j < b.returnStates.length) {\n\t\tconst a_parent = a.parents[i];\n\t\tconst b_parent = b.parents[j];\n\t\tif (a.returnStates[i] === b.returnStates[j]) {\n\t\t\t// same payload (stack tops are equal), must yield merged singleton\n\t\t\tconst payload = a.returnStates[i];\n\t\t\t// $+$ = $\n\t\t\tconst bothDollars = payload === PredictionContext.EMPTY_RETURN_STATE &&\n\t\t\t\t\ta_parent === null && b_parent === null;\n\t\t\tconst ax_ax = (a_parent !== null && b_parent !== null && a_parent === b_parent); // ax+ax\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// ->\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// ax\n\t\t\tif (bothDollars || ax_ax) {\n\t\t\t\tmergedParents[k] = a_parent; // choose left\n\t\t\t\tmergedReturnStates[k] = payload;\n\t\t\t} else { // ax+ay -> a'[x,y]\n\t\t\t\tmergedParents[k] = merge(a_parent, b_parent, rootIsWildcard, mergeCache);\n\t\t\t\tmergedReturnStates[k] = payload;\n\t\t\t}\n\t\t\ti += 1; // hop over left one as usual\n\t\t\tj += 1; // but also skip one in right side since we merge\n\t\t} else if (a.returnStates[i] < b.returnStates[j]) { // copy a[i] to M\n\t\t\tmergedParents[k] = a_parent;\n\t\t\tmergedReturnStates[k] = a.returnStates[i];\n\t\t\ti += 1;\n\t\t} else { // b > a, copy b[j] to M\n\t\t\tmergedParents[k] = b_parent;\n\t\t\tmergedReturnStates[k] = b.returnStates[j];\n\t\t\tj += 1;\n\t\t}\n\t\tk += 1;\n\t}\n\t// copy over any payloads remaining in either array\n\tif (i < a.returnStates.length) {\n\t\tfor (let p = i; p < a.returnStates.length; p++) {\n\t\t\tmergedParents[k] = a.parents[p];\n\t\t\tmergedReturnStates[k] = a.returnStates[p];\n\t\t\tk += 1;\n\t\t}\n\t} else {\n\t\tfor (let p = j; p < b.returnStates.length; p++) {\n\t\t\tmergedParents[k] = b.parents[p];\n\t\t\tmergedReturnStates[k] = b.returnStates[p];\n\t\t\tk += 1;\n\t\t}\n\t}\n\t// trim merged if we combined a few that had same stack tops\n\tif (k < mergedParents.length) { // write index < last position; trim\n\t\tif (k === 1) { // for just one merged element, return singleton top\n\t\t\tconst a_ = SingletonPredictionContext.create(mergedParents[0],\n\t\t\t\t\tmergedReturnStates[0]);\n\t\t\tif (mergeCache !== null) {\n\t\t\t\tmergeCache.set(a, b, a_);\n\t\t\t}\n\t\t\treturn a_;\n\t\t}\n\t\tmergedParents = mergedParents.slice(0, k);\n\t\tmergedReturnStates = mergedReturnStates.slice(0, k);\n\t}\n\n\tconst M = new ArrayPredictionContext(mergedParents, mergedReturnStates);\n\n\t// if we created same array as a or b, return that instead\n\t// TODO: track whether this is possible above during merge sort for speed\n\tif (M === a) {\n\t\tif (mergeCache !== null) {\n\t\t\tmergeCache.set(a, b, a);\n\t\t}\n\t\treturn a;\n\t}\n\tif (M === b) {\n\t\tif (mergeCache !== null) {\n\t\t\tmergeCache.set(a, b, b);\n\t\t}\n\t\treturn b;\n\t}\n\tcombineCommonParents(mergedParents);\n\n\tif (mergeCache !== null) {\n\t\tmergeCache.set(a, b, M);\n\t}\n\treturn M;\n}\n\n/**\n * Make pass over all <em>M</em> {@code parents}; merge any {@code equals()}\n * ones.\n */\nfunction combineCommonParents(parents) {\n\tconst uniqueParents = new Map();\n\n\tfor (let p = 0; p < parents.length; p++) {\n\t\tconst parent = parents[p];\n\t\tif (!(uniqueParents.containsKey(parent))) {\n\t\t\tuniqueParents.put(parent, parent);\n\t\t}\n\t}\n\tfor (let q = 0; q < parents.length; q++) {\n\t\tparents[q] = uniqueParents.get(parents[q]);\n\t}\n}\n\nfunction getCachedPredictionContext(context, contextCache, visited) {\n\tif (context.isEmpty()) {\n\t\treturn context;\n\t}\n\tlet existing = visited.get(context) || null;\n\tif (existing !== null) {\n\t\treturn existing;\n\t}\n\texisting = contextCache.get(context);\n\tif (existing !== null) {\n\t\tvisited.put(context, existing);\n\t\treturn existing;\n\t}\n\tlet changed = false;\n\tlet parents = [];\n\tfor (let i = 0; i < parents.length; i++) {\n\t\tconst parent = getCachedPredictionContext(context.getParent(i), contextCache, visited);\n\t\tif (changed || parent !== context.getParent(i)) {\n\t\t\tif (!changed) {\n\t\t\t\tparents = [];\n\t\t\t\tfor (let j = 0; j < context.length; j++) {\n\t\t\t\t\tparents[j] = context.getParent(j);\n\t\t\t\t}\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t\tparents[i] = parent;\n\t\t}\n\t}\n\tif (!changed) {\n\t\tcontextCache.add(context);\n\t\tvisited.put(context, context);\n\t\treturn context;\n\t}\n\tlet updated = null;\n\tif (parents.length === 0) {\n\t\tupdated = PredictionContext.EMPTY;\n\t} else if (parents.length === 1) {\n\t\tupdated = SingletonPredictionContext.create(parents[0], context\n\t\t\t\t.getReturnState(0));\n\t} else {\n\t\tupdated = new ArrayPredictionContext(parents, context.returnStates);\n\t}\n\tcontextCache.add(updated);\n\tvisited.put(updated, updated);\n\tvisited.put(context, updated);\n\n\treturn updated;\n}\n\n// ter's recursive version of Sam's getAllNodes()\nfunction getAllContextNodes(context, nodes, visited) {\n\tif (nodes === null) {\n\t\tnodes = [];\n\t\treturn getAllContextNodes(context, nodes, visited);\n\t} else if (visited === null) {\n\t\tvisited = new Map();\n\t\treturn getAllContextNodes(context, nodes, visited);\n\t} else {\n\t\tif (context === null || visited.containsKey(context)) {\n\t\t\treturn nodes;\n\t\t}\n\t\tvisited.put(context, context);\n\t\tnodes.push(context);\n\t\tfor (let i = 0; i < context.length; i++) {\n\t\t\tgetAllContextNodes(context.getParent(i), nodes, visited);\n\t\t}\n\t\treturn nodes;\n\t}\n}\n\nmodule.exports = {\n\tmerge,\n\tPredictionContext,\n\tPredictionContextCache,\n\tSingletonPredictionContext,\n\tpredictionContextFromRuleContext,\n\tgetCachedPredictionContext\n}\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Token} = require('./Token');\nconst {ConsoleErrorListener} = require('./error/ErrorListener');\nconst {ProxyErrorListener} = require('./error/ErrorListener');\n\nclass Recognizer {\n    constructor() {\n        this._listeners = [ ConsoleErrorListener.INSTANCE ];\n        this._interp = null;\n        this._stateNumber = -1;\n    }\n\n    checkVersion(toolVersion) {\n        const runtimeVersion = \"4.9.3\";\n        if (runtimeVersion!==toolVersion) {\n            console.log(\"ANTLR runtime and generated code versions disagree: \"+runtimeVersion+\"!=\"+toolVersion);\n        }\n    }\n\n    addErrorListener(listener) {\n        this._listeners.push(listener);\n    }\n\n    removeErrorListeners() {\n        this._listeners = [];\n    }\n\n    getLiteralNames() {\n        return Object.getPrototypeOf(this).constructor.literalNames || [];\n    }\n\n    getSymbolicNames() {\n        return Object.getPrototypeOf(this).constructor.symbolicNames || [];\n    }\n\n    getTokenNames() {\n        if(!this.tokenNames) {\n            const literalNames = this.getLiteralNames();\n            const symbolicNames = this.getSymbolicNames();\n            const length = literalNames.length > symbolicNames.length ? literalNames.length : symbolicNames.length;\n            this.tokenNames = [];\n            for(let i=0; i<length; i++) {\n                this.tokenNames[i] = literalNames[i] || symbolicNames[i] || \"<INVALID\";\n            }\n        }\n        return this.tokenNames;\n    }\n\n    getTokenTypeMap() {\n        const tokenNames = this.getTokenNames();\n        if (tokenNames===null) {\n            throw(\"The current recognizer does not provide a list of token names.\");\n        }\n        let result = this.tokenTypeMapCache[tokenNames];\n        if(result===undefined) {\n            result = tokenNames.reduce(function(o, k, i) { o[k] = i; });\n            result.EOF = Token.EOF;\n            this.tokenTypeMapCache[tokenNames] = result;\n        }\n        return result;\n    }\n\n    /**\n     * Get a map from rule names to rule indexes.\n     * <p>Used for XPath and tree pattern compilation.</p>\n     */\n    getRuleIndexMap() {\n        const ruleNames = this.ruleNames;\n        if (ruleNames===null) {\n            throw(\"The current recognizer does not provide a list of rule names.\");\n        }\n        let result = this.ruleIndexMapCache[ruleNames]; // todo: should it be Recognizer.ruleIndexMapCache ?\n        if(result===undefined) {\n            result = ruleNames.reduce(function(o, k, i) { o[k] = i; });\n            this.ruleIndexMapCache[ruleNames] = result;\n        }\n        return result;\n    }\n\n    getTokenType(tokenName) {\n        const ttype = this.getTokenTypeMap()[tokenName];\n        if (ttype !==undefined) {\n            return ttype;\n        } else {\n            return Token.INVALID_TYPE;\n        }\n    }\n\n    // What is the error header, normally line/character position information?\n    getErrorHeader(e) {\n        const line = e.getOffendingToken().line;\n        const column = e.getOffendingToken().column;\n        return \"line \" + line + \":\" + column;\n    }\n\n    /**\n     * How should a token be displayed in an error message? The default\n     * is to display just the text, but during development you might\n     * want to have a lot of information spit out.  Override in that case\n     * to use t.toString() (which, for CommonToken, dumps everything about\n     * the token). This is better than forcing you to override a method in\n     * your token objects because you don't have to go modify your lexer\n     * so that it creates a new Java type.\n     *\n     * @deprecated This method is not called by the ANTLR 4 Runtime. Specific\n     * implementations of {@link ANTLRErrorStrategy} may provide a similar\n     * feature when necessary. For example, see\n     * {@link DefaultErrorStrategy//getTokenErrorDisplay}.*/\n    getTokenErrorDisplay(t) {\n        if (t===null) {\n            return \"<no token>\";\n        }\n        let s = t.text;\n        if (s===null) {\n            if (t.type===Token.EOF) {\n                s = \"<EOF>\";\n            } else {\n                s = \"<\" + t.type + \">\";\n            }\n        }\n        s = s.replace(\"\\n\",\"\\\\n\").replace(\"\\r\",\"\\\\r\").replace(\"\\t\",\"\\\\t\");\n        return \"'\" + s + \"'\";\n    }\n\n    getErrorListenerDispatch() {\n        return new ProxyErrorListener(this._listeners);\n    }\n\n    /**\n     * subclass needs to override these if there are sempreds or actions\n     * that the ATN interp needs to execute\n     */\n    sempred(localctx, ruleIndex, actionIndex) {\n        return true;\n    }\n\n    precpred(localctx , precedence) {\n        return true;\n    }\n\n    get state(){\n        return this._stateNumber;\n    }\n\n    set state(state) {\n        this._stateNumber = state;\n    }\n}\n\nRecognizer.tokenTypeMapCache = {};\nRecognizer.ruleIndexMapCache = {};\n\nmodule.exports = Recognizer;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {RuleNode} = require('./tree/Tree');\nconst {INVALID_INTERVAL} = require('./tree/Tree');\nconst Trees = require('./tree/Trees');\n\nclass RuleContext extends RuleNode {\n\t/** A rule context is a record of a single rule invocation. It knows\n\t * which context invoked it, if any. If there is no parent context, then\n\t * naturally the invoking state is not valid.  The parent link\n\t * provides a chain upwards from the current rule invocation to the root\n\t * of the invocation tree, forming a stack. We actually carry no\n\t * information about the rule associated with this context (except\n\t * when parsing). We keep only the state number of the invoking state from\n\t * the ATN submachine that invoked this. Contrast this with the s\n\t * pointer inside ParserRuleContext that tracks the current state\n\t * being \"executed\" for the current rule.\n\t *\n\t * The parent contexts are useful for computing lookahead sets and\n\t * getting error information.\n\t *\n\t * These objects are used during parsing and prediction.\n\t * For the special case of parsers, we use the subclass\n\t * ParserRuleContext.\n\t *\n\t * @see ParserRuleContext\n\t */\n\tconstructor(parent, invokingState) {\n\t\t// What context invoked this rule?\n\t\tsuper();\n\t\tthis.parentCtx = parent || null;\n\t\t/**\n\t\t * What state invoked the rule associated with this context?\n\t\t * The \"return address\" is the followState of invokingState\n\t\t * If parent is null, this should be -1.\n\t\t */\n\t\tthis.invokingState = invokingState || -1;\n\t}\n\n\tdepth() {\n\t\tlet n = 0;\n\t\tlet p = this;\n\t\twhile (p !== null) {\n\t\t\tp = p.parentCtx;\n\t\t\tn += 1;\n\t\t}\n\t\treturn n;\n\t}\n\n\t/**\n\t * A context is empty if there is no invoking state; meaning nobody call\n\t * current context.\n\t */\n\tisEmpty() {\n\t\treturn this.invokingState === -1;\n\t}\n\n// satisfy the ParseTree / SyntaxTree interface\n\tgetSourceInterval() {\n\t\treturn INVALID_INTERVAL;\n\t}\n\n\tgetRuleContext() {\n\t\treturn this;\n\t}\n\n\tgetPayload() {\n\t\treturn this;\n\t}\n\n\t/**\n\t * Return the combined text of all child nodes. This method only considers\n\t * tokens which have been added to the parse tree.\n\t * <p>\n\t * Since tokens on hidden channels (e.g. whitespace or comments) are not\n\t * added to the parse trees, they will not appear in the output of this\n\t * method.\n\t */\n\tgetText() {\n\t\tif (this.getChildCount() === 0) {\n\t\t\treturn \"\";\n\t\t} else {\n\t\t\treturn this.children.map(function(child) {\n\t\t\t\treturn child.getText();\n\t\t\t}).join(\"\");\n\t\t}\n\t}\n\n\t/**\n\t * For rule associated with this parse tree internal node, return\n\t * the outer alternative number used to match the input. Default\n\t * implementation does not compute nor store this alt num. Create\n\t * a subclass of ParserRuleContext with backing field and set\n\t * option contextSuperClass.\n\t * to set it.\n\t */\n\tgetAltNumber() {\n\t    // use constant value of ATN.INVALID_ALT_NUMBER to avoid circular dependency\n\t    return 0;\n    }\n\n\t/**\n\t * Set the outer alternative number for this context node. Default\n\t * implementation does nothing to avoid backing field overhead for\n\t * trees that don't need it.  Create\n\t * a subclass of ParserRuleContext with backing field and set\n\t * option contextSuperClass.\n\t */\n\tsetAltNumber(altNumber) { }\n\n\tgetChild(i) {\n\t\treturn null;\n\t}\n\n\tgetChildCount() {\n\t\treturn 0;\n\t}\n\n\taccept(visitor) {\n\t\treturn visitor.visitChildren(this);\n\t}\n\n\t/**\n\t * Print out a whole tree, not just a node, in LISP format\n\t * (root child1 .. childN). Print just a node if this is a leaf.\n\t */\n\ttoStringTree(ruleNames, recog) {\n\t\treturn Trees.toStringTree(this, ruleNames, recog);\n\t}\n\n\ttoString(ruleNames, stop) {\n\t\truleNames = ruleNames || null;\n\t\tstop = stop || null;\n\t\tlet p = this;\n\t\tlet s = \"[\";\n\t\twhile (p !== null && p !== stop) {\n\t\t\tif (ruleNames === null) {\n\t\t\t\tif (!p.isEmpty()) {\n\t\t\t\t\ts += p.invokingState;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst ri = p.ruleIndex;\n\t\t\t\tconst ruleName = (ri >= 0 && ri < ruleNames.length) ? ruleNames[ri]\n\t\t\t\t\t\t: \"\" + ri;\n\t\t\t\ts += ruleName;\n\t\t\t}\n\t\t\tif (p.parentCtx !== null && (ruleNames !== null || !p.parentCtx.isEmpty())) {\n\t\t\t\ts += \" \";\n\t\t\t}\n\t\t\tp = p.parentCtx;\n\t\t}\n\t\ts += \"]\";\n\t\treturn s;\n\t}\n}\n\nmodule.exports = RuleContext;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\n/**\n * A token has properties: text, type, line, character position in the line\n * (so we can ignore tabs), token channel, index, and source from which\n * we obtained this token.\n */\nclass Token {\n\tconstructor() {\n\t\tthis.source = null;\n\t\tthis.type = null; // token type of the token\n\t\tthis.channel = null; // The parser ignores everything not on DEFAULT_CHANNEL\n\t\tthis.start = null; // optional; return -1 if not implemented.\n\t\tthis.stop = null; // optional; return -1 if not implemented.\n\t\tthis.tokenIndex = null; // from 0..n-1 of the token object in the input stream\n\t\tthis.line = null; // line=1..n of the 1st character\n\t\tthis.column = null; // beginning of the line at which it occurs, 0..n-1\n\t\tthis._text = null; // text of the token.\n\t}\n\n\tgetTokenSource() {\n\t\treturn this.source[0];\n\t}\n\n\tgetInputStream() {\n\t\treturn this.source[1];\n\t}\n\n\tget text(){\n\t\treturn this._text;\n\t}\n\n\tset text(text) {\n\t\tthis._text = text;\n\t}\n}\n\nToken.INVALID_TYPE = 0;\n\n/**\n * During lookahead operations, this \"token\" signifies we hit rule end ATN state\n * and did not follow it despite needing to.\n */\nToken.EPSILON = -2;\n\nToken.MIN_USER_TOKEN_TYPE = 1;\n\nToken.EOF = -1;\n\n/**\n * All tokens go to the parser (unless skip() is called in that rule)\n * on a particular \"channel\". The parser tunes to a particular channel\n * so that whitespace etc... can go to the parser on a \"hidden\" channel.\n */\nToken.DEFAULT_CHANNEL = 0;\n\n/**\n * Anything on different channel than DEFAULT_CHANNEL is not parsed\n * by parser.\n */\nToken.HIDDEN_CHANNEL = 1;\n\n\nclass CommonToken extends Token {\n\tconstructor(source, type, channel, start, stop) {\n\t\tsuper();\n\t\tthis.source = source !== undefined ? source : CommonToken.EMPTY_SOURCE;\n\t\tthis.type = type !== undefined ? type : null;\n\t\tthis.channel = channel !== undefined ? channel : Token.DEFAULT_CHANNEL;\n\t\tthis.start = start !== undefined ? start : -1;\n\t\tthis.stop = stop !== undefined ? stop : -1;\n\t\tthis.tokenIndex = -1;\n\t\tif (this.source[0] !== null) {\n\t\t\tthis.line = source[0].line;\n\t\t\tthis.column = source[0].column;\n\t\t} else {\n\t\t\tthis.column = -1;\n\t\t}\n\t}\n\n\t/**\n\t * Constructs a new {@link CommonToken} as a copy of another {@link Token}.\n\t *\n\t * <p>\n\t * If {@code oldToken} is also a {@link CommonToken} instance, the newly\n\t * constructed token will share a reference to the {@link //text} field and\n\t * the {@link Pair} stored in {@link //source}. Otherwise, {@link //text} will\n\t * be assigned the result of calling {@link //getText}, and {@link //source}\n\t * will be constructed from the result of {@link Token//getTokenSource} and\n\t * {@link Token//getInputStream}.</p>\n\t *\n\t * @param oldToken The token to copy.\n\t */\n\tclone() {\n\t\tconst t = new CommonToken(this.source, this.type, this.channel, this.start, this.stop);\n\t\tt.tokenIndex = this.tokenIndex;\n\t\tt.line = this.line;\n\t\tt.column = this.column;\n\t\tt.text = this.text;\n\t\treturn t;\n\t}\n\n\ttoString() {\n\t\tlet txt = this.text;\n\t\tif (txt !== null) {\n\t\t\ttxt = txt.replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/\\t/g, \"\\\\t\");\n\t\t} else {\n\t\t\ttxt = \"<no text>\";\n\t\t}\n\t\treturn \"[@\" + this.tokenIndex + \",\" + this.start + \":\" + this.stop + \"='\" +\n\t\t\t\ttxt + \"',<\" + this.type + \">\" +\n\t\t\t\t(this.channel > 0 ? \",channel=\" + this.channel : \"\") + \",\" +\n\t\t\t\tthis.line + \":\" + this.column + \"]\";\n\t}\n\n\tget text(){\n\t\tif (this._text !== null) {\n\t\t\treturn this._text;\n\t\t}\n\t\tconst input = this.getInputStream();\n\t\tif (input === null) {\n\t\t\treturn null;\n\t\t}\n\t\tconst n = input.size;\n\t\tif (this.start < n && this.stop < n) {\n\t\t\treturn input.getText(this.start, this.stop);\n\t\t} else {\n\t\t\treturn \"<EOF>\";\n\t\t}\n\t}\n\n\tset text(text) {\n\t\tthis._text = text;\n\t}\n}\n\n/**\n * An empty {@link Pair} which is used as the default value of\n * {@link //source} for tokens that do not have a source.\n */\nCommonToken.EMPTY_SOURCE = [ null, null ];\n\nmodule.exports = {\n\tToken,\n\tCommonToken\n}\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nfunction valueToString(v) {\n    return v === null ? \"null\" : v;\n}\n\nfunction arrayToString(a) {\n    return Array.isArray(a) ? (\"[\" + a.map(valueToString).join(\", \") + \"]\") : \"null\";\n}\n\nString.prototype.seed = String.prototype.seed || Math.round(Math.random() * Math.pow(2, 32));\n\nString.prototype.hashCode = function () {\n    const key = this.toString();\n    let h1b, k1;\n\n    const remainder = key.length & 3; // key.length % 4\n    const bytes = key.length - remainder;\n    let h1 = String.prototype.seed;\n    const c1 = 0xcc9e2d51;\n    const c2 = 0x1b873593;\n    let i = 0;\n\n    while (i < bytes) {\n        k1 =\n            ((key.charCodeAt(i) & 0xff)) |\n            ((key.charCodeAt(++i) & 0xff) << 8) |\n            ((key.charCodeAt(++i) & 0xff) << 16) |\n            ((key.charCodeAt(++i) & 0xff) << 24);\n        ++i;\n\n        k1 = ((((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16))) & 0xffffffff;\n        k1 = (k1 << 15) | (k1 >>> 17);\n        k1 = ((((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16))) & 0xffffffff;\n\n        h1 ^= k1;\n        h1 = (h1 << 13) | (h1 >>> 19);\n        h1b = ((((h1 & 0xffff) * 5) + ((((h1 >>> 16) * 5) & 0xffff) << 16))) & 0xffffffff;\n        h1 = (((h1b & 0xffff) + 0x6b64) + ((((h1b >>> 16) + 0xe654) & 0xffff) << 16));\n    }\n\n    k1 = 0;\n\n    switch (remainder) {\n        case 3:\n            k1 ^= (key.charCodeAt(i + 2) & 0xff) << 16;\n        case 2:\n            k1 ^= (key.charCodeAt(i + 1) & 0xff) << 8;\n        case 1:\n            k1 ^= (key.charCodeAt(i) & 0xff);\n\n            k1 = (((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16)) & 0xffffffff;\n            k1 = (k1 << 15) | (k1 >>> 17);\n            k1 = (((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16)) & 0xffffffff;\n            h1 ^= k1;\n    }\n\n    h1 ^= key.length;\n\n    h1 ^= h1 >>> 16;\n    h1 = (((h1 & 0xffff) * 0x85ebca6b) + ((((h1 >>> 16) * 0x85ebca6b) & 0xffff) << 16)) & 0xffffffff;\n    h1 ^= h1 >>> 13;\n    h1 = ((((h1 & 0xffff) * 0xc2b2ae35) + ((((h1 >>> 16) * 0xc2b2ae35) & 0xffff) << 16))) & 0xffffffff;\n    h1 ^= h1 >>> 16;\n\n    return h1 >>> 0;\n};\n\nfunction standardEqualsFunction(a, b) {\n    return a ? a.equals(b) : a==b;\n}\n\nfunction standardHashCodeFunction(a) {\n    return a ? a.hashCode() : -1;\n}\n\nclass Set {\n    constructor(hashFunction, equalsFunction) {\n        this.data = {};\n        this.hashFunction = hashFunction || standardHashCodeFunction;\n        this.equalsFunction = equalsFunction || standardEqualsFunction;\n    }\n\n    add(value) {\n        const hash = this.hashFunction(value);\n        const key = \"hash_\" + hash;\n        if (key in this.data) {\n            const values = this.data[key];\n            for (let i = 0; i < values.length; i++) {\n                if (this.equalsFunction(value, values[i])) {\n                    return values[i];\n                }\n            }\n            values.push(value);\n            return value;\n        } else {\n            this.data[key] = [value];\n            return value;\n        }\n    }\n\n    contains(value) {\n        return this.get(value) != null;\n    }\n\n    get(value) {\n        const hash = this.hashFunction(value);\n        const key = \"hash_\" + hash;\n        if (key in this.data) {\n            const values = this.data[key];\n            for (let i = 0; i < values.length; i++) {\n                if (this.equalsFunction(value, values[i])) {\n                    return values[i];\n                }\n            }\n        }\n        return null;\n    }\n\n    values() {\n        let l = [];\n        for (const key in this.data) {\n            if (key.indexOf(\"hash_\") === 0) {\n                l = l.concat(this.data[key]);\n            }\n        }\n        return l;\n    }\n\n    toString() {\n        return arrayToString(this.values());\n    }\n\n    get length(){\n        let l = 0;\n        for (const key in this.data) {\n            if (key.indexOf(\"hash_\") === 0) {\n                l = l + this.data[key].length;\n            }\n        }\n        return l;\n    }\n}\n\n\nclass BitSet {\n    constructor() {\n        this.data = [];\n    }\n\n    add(value) {\n        this.data[value] = true;\n    }\n\n    or(set) {\n        const bits = this;\n        Object.keys(set.data).map(function (alt) {\n            bits.add(alt);\n        });\n    }\n\n    remove(value) {\n        delete this.data[value];\n    }\n\n    contains(value) {\n        return this.data[value] === true;\n    }\n\n    values() {\n        return Object.keys(this.data);\n    }\n\n    minValue() {\n        return Math.min.apply(null, this.values());\n    }\n\n    hashCode() {\n        const hash = new Hash();\n        hash.update(this.values());\n        return hash.finish();\n    }\n\n    equals(other) {\n        if (!(other instanceof BitSet)) {\n            return false;\n        }\n        return this.hashCode() === other.hashCode();\n    }\n\n    toString() {\n        return \"{\" + this.values().join(\", \") + \"}\";\n    }\n\n    get length(){\n        return this.values().length;\n    }\n}\n\n\nclass Map {\n    constructor(hashFunction, equalsFunction) {\n        this.data = {};\n        this.hashFunction = hashFunction || standardHashCodeFunction;\n        this.equalsFunction = equalsFunction || standardEqualsFunction;\n    }\n\n    put(key, value) {\n        const hashKey = \"hash_\" + this.hashFunction(key);\n        if (hashKey in this.data) {\n            const entries = this.data[hashKey];\n            for (let i = 0; i < entries.length; i++) {\n                const entry = entries[i];\n                if (this.equalsFunction(key, entry.key)) {\n                    const oldValue = entry.value;\n                    entry.value = value;\n                    return oldValue;\n                }\n            }\n            entries.push({key:key, value:value});\n            return value;\n        } else {\n            this.data[hashKey] = [{key:key, value:value}];\n            return value;\n        }\n    }\n\n    containsKey(key) {\n        const hashKey = \"hash_\" + this.hashFunction(key);\n        if(hashKey in this.data) {\n            const entries = this.data[hashKey];\n            for (let i = 0; i < entries.length; i++) {\n                const entry = entries[i];\n                if (this.equalsFunction(key, entry.key))\n                    return true;\n            }\n        }\n        return false;\n    }\n\n    get(key) {\n        const hashKey = \"hash_\" + this.hashFunction(key);\n        if(hashKey in this.data) {\n            const entries = this.data[hashKey];\n            for (let i = 0; i < entries.length; i++) {\n                const entry = entries[i];\n                if (this.equalsFunction(key, entry.key))\n                    return entry.value;\n            }\n        }\n        return null;\n    }\n\n    entries() {\n        let l = [];\n        for (const key in this.data) {\n            if (key.indexOf(\"hash_\") === 0) {\n                l = l.concat(this.data[key]);\n            }\n        }\n        return l;\n    }\n\n    getKeys() {\n        return this.entries().map(function(e) {\n            return e.key;\n        });\n    }\n\n    getValues() {\n        return this.entries().map(function(e) {\n                return e.value;\n        });\n    }\n\n    toString() {\n        const ss = this.entries().map(function(entry) {\n            return '{' + entry.key + ':' + entry.value + '}';\n        });\n        return '[' + ss.join(\", \") + ']';\n    }\n\n    get length(){\n        let l = 0;\n        for (const hashKey in this.data) {\n            if (hashKey.indexOf(\"hash_\") === 0) {\n                l = l + this.data[hashKey].length;\n            }\n        }\n        return l;\n    }\n}\n\n\nclass AltDict {\n    constructor() {\n        this.data = {};\n    }\n\n    get(key) {\n        key = \"k-\" + key;\n        if (key in this.data) {\n            return this.data[key];\n        } else {\n            return null;\n        }\n    }\n\n    put(key, value) {\n        key = \"k-\" + key;\n        this.data[key] = value;\n    }\n\n    values() {\n        const data = this.data;\n        const keys = Object.keys(this.data);\n        return keys.map(function (key) {\n            return data[key];\n        });\n    }\n}\n\n\nclass DoubleDict {\n    constructor(defaultMapCtor) {\n        this.defaultMapCtor = defaultMapCtor || Map;\n        this.cacheMap = new this.defaultMapCtor();\n    }\n\n    get(a, b) {\n        const d = this.cacheMap.get(a) || null;\n        return d === null ? null : (d.get(b) || null);\n    }\n\n    set(a, b, o) {\n        let d = this.cacheMap.get(a) || null;\n        if (d === null) {\n            d = new this.defaultMapCtor();\n            this.cacheMap.put(a, d);\n        }\n        d.put(b, o);\n    }\n}\n\nclass Hash {\n    constructor() {\n        this.count = 0;\n        this.hash = 0;\n    }\n\n    update() {\n        for(let i=0;i<arguments.length;i++) {\n            const value = arguments[i];\n            if (value == null)\n                continue;\n            if(Array.isArray(value))\n                this.update.apply(this, value);\n            else {\n                let k = 0;\n                switch (typeof(value)) {\n                    case 'undefined':\n                    case 'function':\n                        continue;\n                    case 'number':\n                    case 'boolean':\n                        k = value;\n                        break;\n                    case 'string':\n                        k = value.hashCode();\n                        break;\n                    default:\n                        if(value.updateHashCode)\n                            value.updateHashCode(this);\n                        else\n                            console.log(\"No updateHashCode for \" + value.toString())\n                        continue;\n                }\n                k = k * 0xCC9E2D51;\n                k = (k << 15) | (k >>> (32 - 15));\n                k = k * 0x1B873593;\n                this.count = this.count + 1;\n                let hash = this.hash ^ k;\n                hash = (hash << 13) | (hash >>> (32 - 13));\n                hash = hash * 5 + 0xE6546B64;\n                this.hash = hash;\n            }\n        }\n    }\n\n    finish() {\n        let hash = this.hash ^ (this.count * 4);\n        hash = hash ^ (hash >>> 16);\n        hash = hash * 0x85EBCA6B;\n        hash = hash ^ (hash >>> 13);\n        hash = hash * 0xC2B2AE35;\n        hash = hash ^ (hash >>> 16);\n        return hash;\n    }\n}\n\nfunction hashStuff() {\n    const hash = new Hash();\n    hash.update.apply(hash, arguments);\n    return hash.finish();\n}\n\n\nfunction escapeWhitespace(s, escapeSpaces) {\n    s = s.replace(/\\t/g, \"\\\\t\")\n         .replace(/\\n/g, \"\\\\n\")\n         .replace(/\\r/g, \"\\\\r\");\n    if (escapeSpaces) {\n        s = s.replace(/ /g, \"\\u00B7\");\n    }\n    return s;\n}\n\nfunction titleCase(str) {\n    return str.replace(/\\w\\S*/g, function (txt) {\n        return txt.charAt(0).toUpperCase() + txt.substr(1);\n    });\n}\n\nfunction equalArrays(a, b) {\n    if (!Array.isArray(a) || !Array.isArray(b))\n        return false;\n    if (a === b)\n        return true;\n    if (a.length !== b.length)\n        return false;\n    for (let i = 0; i < a.length; i++) {\n        if (a[i] === b[i])\n            continue;\n        if (!a[i].equals || !a[i].equals(b[i]))\n            return false;\n    }\n    return true;\n}\n\nmodule.exports = {\n    Hash,\n    Set,\n    Map,\n    BitSet,\n    AltDict,\n    DoubleDict,\n    hashStuff,\n    escapeWhitespace,\n    arrayToString,\n    titleCase,\n    equalArrays\n}\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst LL1Analyzer = require('./../LL1Analyzer');\nconst {IntervalSet} = require('./../IntervalSet');\nconst {Token} = require('./../Token');\n\nclass ATN {\n\n    constructor(grammarType , maxTokenType) {\n        /**\n         * Used for runtime deserialization of ATNs from strings\n         * The type of the ATN.\n        */\n        this.grammarType = grammarType;\n        // The maximum value for any symbol recognized by a transition in the ATN.\n        this.maxTokenType = maxTokenType;\n        this.states = [];\n        /**\n         * Each subrule/rule is a decision point and we must track them so we\n         * can go back later and build DFA predictors for them.  This includes\n         * all the rules, subrules, optional blocks, ()+, ()* etc...\n         */\n        this.decisionToState = [];\n        // Maps from rule index to starting state number.\n        this.ruleToStartState = [];\n        // Maps from rule index to stop state number.\n        this.ruleToStopState = null;\n        this.modeNameToStartState = {};\n        /**\n         * For lexer ATNs, this maps the rule index to the resulting token type.\n         * For parser ATNs, this maps the rule index to the generated bypass token\n         * type if the {@link ATNDeserializationOptions//isGenerateRuleBypassTransitions}\n         * deserialization option was specified; otherwise, this is {@code null}\n         */\n        this.ruleToTokenType = null;\n        /**\n         * For lexer ATNs, this is an array of {@link LexerAction} objects which may\n         * be referenced by action transitions in the ATN\n         */\n        this.lexerActions = null;\n        this.modeToStartState = [];\n    }\n\n    /**\n     * Compute the set of valid tokens that can occur starting in state {@code s}.\n     * If {@code ctx} is null, the set of tokens will not include what can follow\n     * the rule surrounding {@code s}. In other words, the set will be\n     * restricted to tokens reachable staying within {@code s}'s rule\n     */\n    nextTokensInContext(s, ctx) {\n        const anal = new LL1Analyzer(this);\n        return anal.LOOK(s, null, ctx);\n    }\n\n    /**\n     * Compute the set of valid tokens that can occur starting in {@code s} and\n     * staying in same rule. {@link Token//EPSILON} is in set if we reach end of\n     * rule\n     */\n    nextTokensNoContext(s) {\n        if (s.nextTokenWithinRule !== null ) {\n            return s.nextTokenWithinRule;\n        }\n        s.nextTokenWithinRule = this.nextTokensInContext(s, null);\n        s.nextTokenWithinRule.readOnly = true;\n        return s.nextTokenWithinRule;\n    }\n\n    nextTokens(s, ctx) {\n        if ( ctx===undefined ) {\n            return this.nextTokensNoContext(s);\n        } else {\n            return this.nextTokensInContext(s, ctx);\n        }\n    }\n\n    addState(state) {\n        if ( state !== null ) {\n            state.atn = this;\n            state.stateNumber = this.states.length;\n        }\n        this.states.push(state);\n    }\n\n    removeState(state) {\n        this.states[state.stateNumber] = null; // just free mem, don't shift states in list\n    }\n\n    defineDecisionState(s) {\n        this.decisionToState.push(s);\n        s.decision = this.decisionToState.length-1;\n        return s.decision;\n    }\n\n    getDecisionState(decision) {\n        if (this.decisionToState.length===0) {\n            return null;\n        } else {\n            return this.decisionToState[decision];\n        }\n    }\n\n    /**\n     * Computes the set of input symbols which could follow ATN state number\n     * {@code stateNumber} in the specified full {@code context}. This method\n     * considers the complete parser context, but does not evaluate semantic\n     * predicates (i.e. all predicates encountered during the calculation are\n     * assumed true). If a path in the ATN exists from the starting state to the\n     * {@link RuleStopState} of the outermost context without matching any\n     * symbols, {@link Token//EOF} is added to the returned set.\n     *\n     * <p>If {@code context} is {@code null}, it is treated as\n     * {@link ParserRuleContext//EMPTY}.</p>\n     *\n     * @param stateNumber the ATN state number\n     * @param ctx the full parse context\n     *\n     * @return {IntervalSet} The set of potentially valid input symbols which could follow the\n     * specified state in the specified context.\n     *\n     * @throws IllegalArgumentException if the ATN does not contain a state with\n     * number {@code stateNumber}\n     */\n    getExpectedTokens(stateNumber, ctx ) {\n        if ( stateNumber < 0 || stateNumber >= this.states.length ) {\n            throw(\"Invalid state number.\");\n        }\n        const s = this.states[stateNumber];\n        let following = this.nextTokens(s);\n        if (!following.contains(Token.EPSILON)) {\n            return following;\n        }\n        const expected = new IntervalSet();\n        expected.addSet(following);\n        expected.removeOne(Token.EPSILON);\n        while (ctx !== null && ctx.invokingState >= 0 && following.contains(Token.EPSILON)) {\n            const invokingState = this.states[ctx.invokingState];\n            const rt = invokingState.transitions[0];\n            following = this.nextTokens(rt.followState);\n            expected.addSet(following);\n            expected.removeOne(Token.EPSILON);\n            ctx = ctx.parentCtx;\n        }\n        if (following.contains(Token.EPSILON)) {\n            expected.addOne(Token.EOF);\n        }\n        return expected;\n    }\n}\n\nATN.INVALID_ALT_NUMBER = 0;\n\nmodule.exports = ATN;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {DecisionState} = require('./ATNState');\nconst {SemanticContext} = require('./SemanticContext');\nconst {Hash} = require(\"../Utils\");\n\n\nfunction checkParams(params, isCfg) {\n\tif(params===null) {\n\t\tconst result = { state:null, alt:null, context:null, semanticContext:null };\n\t\tif(isCfg) {\n\t\t\tresult.reachesIntoOuterContext = 0;\n\t\t}\n\t\treturn result;\n\t} else {\n\t\tconst props = {};\n\t\tprops.state = params.state || null;\n\t\tprops.alt = (params.alt === undefined) ? null : params.alt;\n\t\tprops.context = params.context || null;\n\t\tprops.semanticContext = params.semanticContext || null;\n\t\tif(isCfg) {\n\t\t\tprops.reachesIntoOuterContext = params.reachesIntoOuterContext || 0;\n\t\t\tprops.precedenceFilterSuppressed = params.precedenceFilterSuppressed || false;\n\t\t}\n\t\treturn props;\n\t}\n}\n\nclass ATNConfig {\n    /**\n     * @param {Object} params A tuple: (ATN state, predicted alt, syntactic, semantic context).\n     * The syntactic context is a graph-structured stack node whose\n     * path(s) to the root is the rule invocation(s)\n     * chain used to arrive at the state.  The semantic context is\n     * the tree of semantic predicates encountered before reaching\n     * an ATN state\n     */\n    constructor(params, config) {\n        this.checkContext(params, config);\n        params = checkParams(params);\n        config = checkParams(config, true);\n        // The ATN state associated with this configuration///\n        this.state = params.state!==null ? params.state : config.state;\n        // What alt (or lexer rule) is predicted by this configuration///\n        this.alt = params.alt!==null ? params.alt : config.alt;\n        /**\n         * The stack of invoking states leading to the rule/states associated\n         * with this config.  We track only those contexts pushed during\n         * execution of the ATN simulator\n         */\n        this.context = params.context!==null ? params.context : config.context;\n        this.semanticContext = params.semanticContext!==null ? params.semanticContext :\n            (config.semanticContext!==null ? config.semanticContext : SemanticContext.NONE);\n        // TODO: make it a boolean then\n        /**\n         * We cannot execute predicates dependent upon local context unless\n         * we know for sure we are in the correct context. Because there is\n         * no way to do this efficiently, we simply cannot evaluate\n         * dependent predicates unless we are in the rule that initially\n         * invokes the ATN simulator.\n         * closure() tracks the depth of how far we dip into the\n         * outer context: depth &gt; 0.  Note that it may not be totally\n         * accurate depth since I don't ever decrement\n         */\n        this.reachesIntoOuterContext = config.reachesIntoOuterContext;\n        this.precedenceFilterSuppressed = config.precedenceFilterSuppressed;\n    }\n\n    checkContext(params, config) {\n        if((params.context===null || params.context===undefined) &&\n                (config===null || config.context===null || config.context===undefined)) {\n            this.context = null;\n        }\n    }\n\n    hashCode() {\n        const hash = new Hash();\n        this.updateHashCode(hash);\n        return hash.finish();\n    }\n\n    updateHashCode(hash) {\n        hash.update(this.state.stateNumber, this.alt, this.context, this.semanticContext);\n    }\n\n    /**\n     * An ATN configuration is equal to another if both have\n     * the same state, they predict the same alternative, and\n     * syntactic/semantic contexts are the same\n     */\n    equals(other) {\n        if (this === other) {\n            return true;\n        } else if (! (other instanceof ATNConfig)) {\n            return false;\n        } else {\n            return this.state.stateNumber===other.state.stateNumber &&\n                this.alt===other.alt &&\n                (this.context===null ? other.context===null : this.context.equals(other.context)) &&\n                this.semanticContext.equals(other.semanticContext) &&\n                this.precedenceFilterSuppressed===other.precedenceFilterSuppressed;\n        }\n    }\n\n    hashCodeForConfigSet() {\n        const hash = new Hash();\n        hash.update(this.state.stateNumber, this.alt, this.semanticContext);\n        return hash.finish();\n    }\n\n    equalsForConfigSet(other) {\n        if (this === other) {\n            return true;\n        } else if (! (other instanceof ATNConfig)) {\n            return false;\n        } else {\n            return this.state.stateNumber===other.state.stateNumber &&\n                this.alt===other.alt &&\n                this.semanticContext.equals(other.semanticContext);\n        }\n    }\n\n    toString() {\n        return \"(\" + this.state + \",\" + this.alt +\n            (this.context!==null ? \",[\" + this.context.toString() + \"]\" : \"\") +\n            (this.semanticContext !== SemanticContext.NONE ?\n                    (\",\" + this.semanticContext.toString())\n                    : \"\") +\n            (this.reachesIntoOuterContext>0 ?\n                    (\",up=\" + this.reachesIntoOuterContext)\n                    : \"\") + \")\";\n    }\n}\n\n\nclass LexerATNConfig extends ATNConfig {\n    constructor(params, config) {\n        super(params, config);\n\n        // This is the backing field for {@link //getLexerActionExecutor}.\n        const lexerActionExecutor = params.lexerActionExecutor || null;\n        this.lexerActionExecutor = lexerActionExecutor || (config!==null ? config.lexerActionExecutor : null);\n        this.passedThroughNonGreedyDecision = config!==null ? this.checkNonGreedyDecision(config, this.state) : false;\n        this.hashCodeForConfigSet = LexerATNConfig.prototype.hashCode;\n        this.equalsForConfigSet = LexerATNConfig.prototype.equals;\n        return this;\n    }\n\n    updateHashCode(hash) {\n        hash.update(this.state.stateNumber, this.alt, this.context, this.semanticContext, this.passedThroughNonGreedyDecision, this.lexerActionExecutor);\n    }\n\n    equals(other) {\n        return this === other ||\n                (other instanceof LexerATNConfig &&\n                this.passedThroughNonGreedyDecision === other.passedThroughNonGreedyDecision &&\n                (this.lexerActionExecutor ? this.lexerActionExecutor.equals(other.lexerActionExecutor) : !other.lexerActionExecutor) &&\n                super.equals(other));\n    }\n\n    checkNonGreedyDecision(source, target) {\n        return source.passedThroughNonGreedyDecision ||\n            (target instanceof DecisionState) && target.nonGreedy;\n    }\n}\n\n\nmodule.exports.ATNConfig = ATNConfig;\nmodule.exports.LexerATNConfig = LexerATNConfig;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst ATN = require('./ATN');\nconst Utils = require('./../Utils');\nconst {SemanticContext} = require('./SemanticContext');\nconst {merge} = require('./../PredictionContext');\n\nfunction hashATNConfig(c) {\n\treturn c.hashCodeForConfigSet();\n}\n\nfunction equalATNConfigs(a, b) {\n\tif ( a===b ) {\n\t\treturn true;\n\t} else if ( a===null || b===null ) {\n\t\treturn false;\n\t} else\n       return a.equalsForConfigSet(b);\n }\n\n/**\n * Specialized {@link Set}{@code <}{@link ATNConfig}{@code >} that can track\n * info about the set, with support for combining similar configurations using a\n * graph-structured stack\n */\nclass ATNConfigSet {\n\tconstructor(fullCtx) {\n\t\t/**\n\t\t * The reason that we need this is because we don't want the hash map to use\n\t\t * the standard hash code and equals. We need all configurations with the\n\t\t * same\n\t\t * {@code (s,i,_,semctx)} to be equal. Unfortunately, this key effectively\n\t\t * doubles\n\t\t * the number of objects associated with ATNConfigs. The other solution is\n\t\t * to\n\t\t * use a hash table that lets us specify the equals/hashcode operation.\n\t\t * All configs but hashed by (s, i, _, pi) not including context. Wiped out\n\t\t * when we go readonly as this set becomes a DFA state\n\t\t */\n\t\tthis.configLookup = new Utils.Set(hashATNConfig, equalATNConfigs);\n\t\t/**\n\t\t * Indicates that this configuration set is part of a full context\n\t\t * LL prediction. It will be used to determine how to merge $. With SLL\n\t\t * it's a wildcard whereas it is not for LL context merge\n\t\t */\n\t\tthis.fullCtx = fullCtx === undefined ? true : fullCtx;\n\t\t/**\n\t\t * Indicates that the set of configurations is read-only. Do not\n\t\t * allow any code to manipulate the set; DFA states will point at\n\t\t * the sets and they must not change. This does not protect the other\n\t\t * fields; in particular, conflictingAlts is set after\n\t\t * we've made this readonly\n\t\t */\n\t\tthis.readOnly = false;\n\t\t// Track the elements as they are added to the set; supports get(i)///\n\t\tthis.configs = [];\n\n\t\t// TODO: these fields make me pretty uncomfortable but nice to pack up info\n\t\t// together, saves recomputation\n\t\t// TODO: can we track conflicts as they are added to save scanning configs\n\t\t// later?\n\t\tthis.uniqueAlt = 0;\n\t\tthis.conflictingAlts = null;\n\n\t\t/**\n\t\t * Used in parser and lexer. In lexer, it indicates we hit a pred\n\t\t * while computing a closure operation. Don't make a DFA state from this\n\t\t */\n\t\tthis.hasSemanticContext = false;\n\t\tthis.dipsIntoOuterContext = false;\n\n\t\tthis.cachedHashCode = -1;\n\t}\n\n\t/**\n\t * Adding a new config means merging contexts with existing configs for\n\t * {@code (s, i, pi, _)}, where {@code s} is the\n\t * {@link ATNConfig//state}, {@code i} is the {@link ATNConfig//alt}, and\n\t * {@code pi} is the {@link ATNConfig//semanticContext}. We use\n\t * {@code (s,i,pi)} as key.\n\t *\n\t * <p>This method updates {@link //dipsIntoOuterContext} and\n\t * {@link //hasSemanticContext} when necessary.</p>\n\t */\n\tadd(config, mergeCache) {\n\t\tif (mergeCache === undefined) {\n\t\t\tmergeCache = null;\n\t\t}\n\t\tif (this.readOnly) {\n\t\t\tthrow \"This set is readonly\";\n\t\t}\n\t\tif (config.semanticContext !== SemanticContext.NONE) {\n\t\t\tthis.hasSemanticContext = true;\n\t\t}\n\t\tif (config.reachesIntoOuterContext > 0) {\n\t\t\tthis.dipsIntoOuterContext = true;\n\t\t}\n\t\tconst existing = this.configLookup.add(config);\n\t\tif (existing === config) {\n\t\t\tthis.cachedHashCode = -1;\n\t\t\tthis.configs.push(config); // track order here\n\t\t\treturn true;\n\t\t}\n\t\t// a previous (s,i,pi,_), merge with it and save result\n\t\tconst rootIsWildcard = !this.fullCtx;\n\t\tconst merged = merge(existing.context, config.context, rootIsWildcard, mergeCache);\n\t\t/**\n\t\t * no need to check for existing.context, config.context in cache\n\t\t * since only way to create new graphs is \"call rule\" and here. We\n\t\t * cache at both places\n\t\t */\n\t\texisting.reachesIntoOuterContext = Math.max( existing.reachesIntoOuterContext, config.reachesIntoOuterContext);\n\t\t// make sure to preserve the precedence filter suppression during the merge\n\t\tif (config.precedenceFilterSuppressed) {\n\t\t\texisting.precedenceFilterSuppressed = true;\n\t\t}\n\t\texisting.context = merged; // replace context; no need to alt mapping\n\t\treturn true;\n\t}\n\n\tgetStates() {\n\t\tconst states = new Utils.Set();\n\t\tfor (let i = 0; i < this.configs.length; i++) {\n\t\t\tstates.add(this.configs[i].state);\n\t\t}\n\t\treturn states;\n\t}\n\n\tgetPredicates() {\n\t\tconst preds = [];\n\t\tfor (let i = 0; i < this.configs.length; i++) {\n\t\t\tconst c = this.configs[i].semanticContext;\n\t\t\tif (c !== SemanticContext.NONE) {\n\t\t\t\tpreds.push(c.semanticContext);\n\t\t\t}\n\t\t}\n\t\treturn preds;\n\t}\n\n\toptimizeConfigs(interpreter) {\n\t\tif (this.readOnly) {\n\t\t\tthrow \"This set is readonly\";\n\t\t}\n\t\tif (this.configLookup.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tfor (let i = 0; i < this.configs.length; i++) {\n\t\t\tconst config = this.configs[i];\n\t\t\tconfig.context = interpreter.getCachedContext(config.context);\n\t\t}\n\t}\n\n\taddAll(coll) {\n\t\tfor (let i = 0; i < coll.length; i++) {\n\t\t\tthis.add(coll[i]);\n\t\t}\n\t\treturn false;\n\t}\n\n\tequals(other) {\n\t\treturn this === other ||\n\t\t\t(other instanceof ATNConfigSet &&\n\t\t\tUtils.equalArrays(this.configs, other.configs) &&\n\t\t\tthis.fullCtx === other.fullCtx &&\n\t\t\tthis.uniqueAlt === other.uniqueAlt &&\n\t\t\tthis.conflictingAlts === other.conflictingAlts &&\n\t\t\tthis.hasSemanticContext === other.hasSemanticContext &&\n\t\t\tthis.dipsIntoOuterContext === other.dipsIntoOuterContext);\n\t}\n\n\thashCode() {\n\t\tconst hash = new Utils.Hash();\n\t\thash.update(this.configs);\n\t\treturn hash.finish();\n\t}\n\n\tupdateHashCode(hash) {\n\t\tif (this.readOnly) {\n\t\t\tif (this.cachedHashCode === -1) {\n\t\t\t\tthis.cachedHashCode = this.hashCode();\n\t\t\t}\n\t\t\thash.update(this.cachedHashCode);\n\t\t} else {\n\t\t\thash.update(this.hashCode());\n\t\t}\n\t}\n\n\tisEmpty() {\n\t\treturn this.configs.length === 0;\n\t}\n\n\tcontains(item) {\n\t\tif (this.configLookup === null) {\n\t\t\tthrow \"This method is not implemented for readonly sets.\";\n\t\t}\n\t\treturn this.configLookup.contains(item);\n\t}\n\n\tcontainsFast(item) {\n\t\tif (this.configLookup === null) {\n\t\t\tthrow \"This method is not implemented for readonly sets.\";\n\t\t}\n\t\treturn this.configLookup.containsFast(item);\n\t}\n\n\tclear() {\n\t\tif (this.readOnly) {\n\t\t\tthrow \"This set is readonly\";\n\t\t}\n\t\tthis.configs = [];\n\t\tthis.cachedHashCode = -1;\n\t\tthis.configLookup = new Utils.Set();\n\t}\n\n\tsetReadonly(readOnly) {\n\t\tthis.readOnly = readOnly;\n\t\tif (readOnly) {\n\t\t\tthis.configLookup = null; // can't mod, no need for lookup cache\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn Utils.arrayToString(this.configs) +\n\t\t\t(this.hasSemanticContext ? \",hasSemanticContext=\" + this.hasSemanticContext : \"\") +\n\t\t\t(this.uniqueAlt !== ATN.INVALID_ALT_NUMBER ? \",uniqueAlt=\" + this.uniqueAlt : \"\") +\n\t\t\t(this.conflictingAlts !== null ? \",conflictingAlts=\" + this.conflictingAlts : \"\") +\n\t\t\t(this.dipsIntoOuterContext ? \",dipsIntoOuterContext\" : \"\");\n\t}\n\n\tget items(){\n\t\treturn this.configs;\n\t}\n\n\tget length(){\n\t\treturn this.configs.length;\n\t}\n}\n\n\nclass OrderedATNConfigSet extends ATNConfigSet {\n\tconstructor() {\n\t\tsuper();\n\t\tthis.configLookup = new Utils.Set();\n\t}\n}\n\nmodule.exports = {\n\tATNConfigSet,\n\tOrderedATNConfigSet\n}\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nclass ATNDeserializationOptions {\n\tconstructor(copyFrom) {\n\t\tif(copyFrom===undefined) {\n\t\t\tcopyFrom = null;\n\t\t}\n\t\tthis.readOnly = false;\n\t\tthis.verifyATN = copyFrom===null ? true : copyFrom.verifyATN;\n\t\tthis.generateRuleBypassTransitions = copyFrom===null ? false : copyFrom.generateRuleBypassTransitions;\n\t}\n}\n\nATNDeserializationOptions.defaultOptions = new ATNDeserializationOptions();\nATNDeserializationOptions.defaultOptions.readOnly = true;\n\n//    def __setattr__(self, key, value):\n//        if key!=\"readOnly\" and self.readOnly:\n//            raise Exception(\"The object is read only.\")\n//        super(type(self), self).__setattr__(key,value)\n\nmodule.exports = ATNDeserializationOptions\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Token} = require('./../Token');\nconst ATN = require('./ATN');\nconst ATNType = require('./ATNType');\n\nconst {\n    ATNState,\n    BasicState,\n    DecisionState,\n    BlockStartState,\n    BlockEndState,\n    LoopEndState,\n    RuleStartState,\n    RuleStopState,\n    TokensStartState,\n    PlusLoopbackState,\n    StarLoopbackState,\n    StarLoopEntryState,\n    PlusBlockStartState,\n    StarBlockStartState,\n    BasicBlockStartState\n} = require('./ATNState');\n\nconst {\n    Transition,\n    AtomTransition,\n    SetTransition,\n    NotSetTransition,\n    RuleTransition,\n    RangeTransition,\n    ActionTransition,\n    EpsilonTransition,\n    WildcardTransition,\n    PredicateTransition,\n    PrecedencePredicateTransition\n} = require('./Transition')\n\nconst {IntervalSet} = require('./../IntervalSet');\nconst ATNDeserializationOptions = require('./ATNDeserializationOptions');\n\nconst {\n    LexerActionType,\n    LexerSkipAction,\n    LexerChannelAction,\n    LexerCustomAction,\n    LexerMoreAction,\n    LexerTypeAction,\n    LexerPushModeAction,\n    LexerPopModeAction,\n    LexerModeAction,\n} = require('./LexerAction');\n\n// This is the earliest supported serialized UUID.\n// stick to serialized version for now, we don't need a UUID instance\nconst BASE_SERIALIZED_UUID = \"AADB8D7E-AEEF-4415-AD2B-8204D6CF042E\";\n\n//\n// This UUID indicates the serialized ATN contains two sets of\n// IntervalSets, where the second set's values are encoded as\n// 32-bit integers to support the full Unicode SMP range up to U+10FFFF.\n//\nconst ADDED_UNICODE_SMP = \"59627784-3BE5-417A-B9EB-8131A7286089\";\n\n// This list contains all of the currently supported UUIDs, ordered by when\n// the feature first appeared in this branch.\nconst SUPPORTED_UUIDS = [ BASE_SERIALIZED_UUID, ADDED_UNICODE_SMP ];\n\nconst SERIALIZED_VERSION = 3;\n\n// This is the current serialized UUID.\nconst SERIALIZED_UUID = ADDED_UNICODE_SMP;\n\nfunction initArray( length, value) {\n\tconst tmp = [];\n\ttmp[length-1] = value;\n\treturn tmp.map(function(i) {return value;});\n}\n\nclass ATNDeserializer {\n    constructor(options) {\n\n        if ( options=== undefined || options === null ) {\n            options = ATNDeserializationOptions.defaultOptions;\n        }\n        this.deserializationOptions = options;\n        this.stateFactories = null;\n        this.actionFactories = null;\n    }\n\n    /**\n     * Determines if a particular serialized representation of an ATN supports\n     * a particular feature, identified by the {@link UUID} used for serializing\n     * the ATN at the time the feature was first introduced.\n     *\n     * @param feature The {@link UUID} marking the first time the feature was\n     * supported in the serialized ATN.\n     * @param actualUuid The {@link UUID} of the actual serialized ATN which is\n     * currently being deserialized.\n     * @return {@code true} if the {@code actualUuid} value represents a\n     * serialized ATN at or after the feature identified by {@code feature} was\n     * introduced; otherwise, {@code false}.\n    */\n    isFeatureSupported(feature, actualUuid) {\n        const idx1 = SUPPORTED_UUIDS.indexOf(feature);\n        if (idx1<0) {\n            return false;\n        }\n        const idx2 = SUPPORTED_UUIDS.indexOf(actualUuid);\n        return idx2 >= idx1;\n    }\n\n    deserialize(data) {\n        this.reset(data);\n        this.checkVersion();\n        this.checkUUID();\n        const atn = this.readATN();\n        this.readStates(atn);\n        this.readRules(atn);\n        this.readModes(atn);\n        const sets = [];\n        // First, deserialize sets with 16-bit arguments <= U+FFFF.\n        this.readSets(atn, sets, this.readInt.bind(this));\n        // Next, if the ATN was serialized with the Unicode SMP feature,\n        // deserialize sets with 32-bit arguments <= U+10FFFF.\n        if (this.isFeatureSupported(ADDED_UNICODE_SMP, this.uuid)) {\n            this.readSets(atn, sets, this.readInt32.bind(this));\n        }\n        this.readEdges(atn, sets);\n        this.readDecisions(atn);\n        this.readLexerActions(atn);\n        this.markPrecedenceDecisions(atn);\n        this.verifyATN(atn);\n        if (this.deserializationOptions.generateRuleBypassTransitions && atn.grammarType === ATNType.PARSER ) {\n            this.generateRuleBypassTransitions(atn);\n            // re-verify after modification\n            this.verifyATN(atn);\n        }\n        return atn;\n    }\n\n    reset(data) {\n        const adjust = function(c) {\n            const v = c.charCodeAt(0);\n            return v>1  ? v-2 : v + 65534;\n        };\n        const temp = data.split(\"\").map(adjust);\n        // don't adjust the first value since that's the version number\n        temp[0] = data.charCodeAt(0);\n        this.data = temp;\n        this.pos = 0;\n    }\n\n    checkVersion() {\n        const version = this.readInt();\n        if ( version !== SERIALIZED_VERSION ) {\n            throw (\"Could not deserialize ATN with version \" + version + \" (expected \" + SERIALIZED_VERSION + \").\");\n        }\n    }\n\n    checkUUID() {\n        const uuid = this.readUUID();\n        if (SUPPORTED_UUIDS.indexOf(uuid)<0) {\n            throw (\"Could not deserialize ATN with UUID: \" + uuid +\n                            \" (expected \" + SERIALIZED_UUID + \" or a legacy UUID).\", uuid, SERIALIZED_UUID);\n        }\n        this.uuid = uuid;\n    }\n\n    readATN() {\n        const grammarType = this.readInt();\n        const maxTokenType = this.readInt();\n        return new ATN(grammarType, maxTokenType);\n    }\n\n    readStates(atn) {\n        let j, pair, stateNumber;\n        const  loopBackStateNumbers = [];\n        const  endStateNumbers = [];\n        const  nstates = this.readInt();\n        for(let i=0; i<nstates; i++) {\n            const  stype = this.readInt();\n            // ignore bad type of states\n            if (stype===ATNState.INVALID_TYPE) {\n                atn.addState(null);\n                continue;\n            }\n            let ruleIndex = this.readInt();\n            if (ruleIndex === 0xFFFF) {\n                ruleIndex = -1;\n            }\n            const  s = this.stateFactory(stype, ruleIndex);\n            if (stype === ATNState.LOOP_END) { // special case\n                const  loopBackStateNumber = this.readInt();\n                loopBackStateNumbers.push([s, loopBackStateNumber]);\n            } else if(s instanceof BlockStartState) {\n                const  endStateNumber = this.readInt();\n                endStateNumbers.push([s, endStateNumber]);\n            }\n            atn.addState(s);\n        }\n        // delay the assignment of loop back and end states until we know all the\n        // state instances have been initialized\n        for (j=0; j<loopBackStateNumbers.length; j++) {\n            pair = loopBackStateNumbers[j];\n            pair[0].loopBackState = atn.states[pair[1]];\n        }\n\n        for (j=0; j<endStateNumbers.length; j++) {\n            pair = endStateNumbers[j];\n            pair[0].endState = atn.states[pair[1]];\n        }\n\n        let numNonGreedyStates = this.readInt();\n        for (j=0; j<numNonGreedyStates; j++) {\n            stateNumber = this.readInt();\n            atn.states[stateNumber].nonGreedy = true;\n        }\n\n        let numPrecedenceStates = this.readInt();\n        for (j=0; j<numPrecedenceStates; j++) {\n            stateNumber = this.readInt();\n            atn.states[stateNumber].isPrecedenceRule = true;\n        }\n    }\n\n    readRules(atn) {\n        let i;\n        const nrules = this.readInt();\n        if (atn.grammarType === ATNType.LEXER ) {\n            atn.ruleToTokenType = initArray(nrules, 0);\n        }\n        atn.ruleToStartState = initArray(nrules, 0);\n        for (i=0; i<nrules; i++) {\n            const s = this.readInt();\n            atn.ruleToStartState[i] = atn.states[s];\n            if ( atn.grammarType === ATNType.LEXER ) {\n                let tokenType = this.readInt();\n                if (tokenType === 0xFFFF) {\n                    tokenType = Token.EOF;\n                }\n                atn.ruleToTokenType[i] = tokenType;\n            }\n        }\n        atn.ruleToStopState = initArray(nrules, 0);\n        for (i=0; i<atn.states.length; i++) {\n            const state = atn.states[i];\n            if (!(state instanceof RuleStopState)) {\n                continue;\n            }\n            atn.ruleToStopState[state.ruleIndex] = state;\n            atn.ruleToStartState[state.ruleIndex].stopState = state;\n        }\n    }\n\n    readModes(atn) {\n        const nmodes = this.readInt();\n        for (let i=0; i<nmodes; i++) {\n            let s = this.readInt();\n            atn.modeToStartState.push(atn.states[s]);\n        }\n    }\n\n    readSets(atn, sets, readUnicode) {\n        const m = this.readInt();\n        for (let i=0; i<m; i++) {\n            const iset = new IntervalSet();\n            sets.push(iset);\n            const n = this.readInt();\n            const containsEof = this.readInt();\n            if (containsEof!==0) {\n                iset.addOne(-1);\n            }\n            for (let j=0; j<n; j++) {\n                const i1 = readUnicode();\n                const i2 = readUnicode();\n                iset.addRange(i1, i2);\n            }\n        }\n    }\n\n    readEdges(atn, sets) {\n        let i, j, state, trans, target;\n        const nedges = this.readInt();\n        for (i=0; i<nedges; i++) {\n            const src = this.readInt();\n            const trg = this.readInt();\n            const ttype = this.readInt();\n            const arg1 = this.readInt();\n            const arg2 = this.readInt();\n            const arg3 = this.readInt();\n            trans = this.edgeFactory(atn, ttype, src, trg, arg1, arg2, arg3, sets);\n            const srcState = atn.states[src];\n            srcState.addTransition(trans);\n        }\n        // edges for rule stop states can be derived, so they aren't serialized\n        for (i=0; i<atn.states.length; i++) {\n            state = atn.states[i];\n            for (j=0; j<state.transitions.length; j++) {\n                const t = state.transitions[j];\n                if (!(t instanceof RuleTransition)) {\n                    continue;\n                }\n                let outermostPrecedenceReturn = -1;\n                if (atn.ruleToStartState[t.target.ruleIndex].isPrecedenceRule) {\n                    if (t.precedence === 0) {\n                        outermostPrecedenceReturn = t.target.ruleIndex;\n                    }\n                }\n\n                trans = new EpsilonTransition(t.followState, outermostPrecedenceReturn);\n                atn.ruleToStopState[t.target.ruleIndex].addTransition(trans);\n            }\n        }\n\n        for (i=0; i<atn.states.length; i++) {\n            state = atn.states[i];\n            if (state instanceof BlockStartState) {\n                // we need to know the end state to set its start state\n                if (state.endState === null) {\n                    throw (\"IllegalState\");\n                }\n                // block end states can only be associated to a single block start\n                // state\n                if ( state.endState.startState !== null) {\n                    throw (\"IllegalState\");\n                }\n                state.endState.startState = state;\n            }\n            if (state instanceof PlusLoopbackState) {\n                for (j=0; j<state.transitions.length; j++) {\n                    target = state.transitions[j].target;\n                    if (target instanceof PlusBlockStartState) {\n                        target.loopBackState = state;\n                    }\n                }\n            } else if (state instanceof StarLoopbackState) {\n                for (j=0; j<state.transitions.length; j++) {\n                    target = state.transitions[j].target;\n                    if (target instanceof StarLoopEntryState) {\n                        target.loopBackState = state;\n                    }\n                }\n            }\n        }\n    }\n\n    readDecisions(atn) {\n        const ndecisions = this.readInt();\n        for (let i=0; i<ndecisions; i++) {\n            const s = this.readInt();\n            const decState = atn.states[s];\n            atn.decisionToState.push(decState);\n            decState.decision = i;\n        }\n    }\n\n    readLexerActions(atn) {\n        if (atn.grammarType === ATNType.LEXER) {\n            const count = this.readInt();\n            atn.lexerActions = initArray(count, null);\n            for (let i=0; i<count; i++) {\n                const actionType = this.readInt();\n                let data1 = this.readInt();\n                if (data1 === 0xFFFF) {\n                    data1 = -1;\n                }\n                let data2 = this.readInt();\n                if (data2 === 0xFFFF) {\n                    data2 = -1;\n                }\n\n                atn.lexerActions[i] = this.lexerActionFactory(actionType, data1, data2);\n            }\n        }\n    }\n\n    generateRuleBypassTransitions(atn) {\n        let i;\n        const count = atn.ruleToStartState.length;\n        for(i=0; i<count; i++) {\n            atn.ruleToTokenType[i] = atn.maxTokenType + i + 1;\n        }\n        for(i=0; i<count; i++) {\n            this.generateRuleBypassTransition(atn, i);\n        }\n    }\n\n    generateRuleBypassTransition(atn, idx) {\n        let i, state;\n        const bypassStart = new BasicBlockStartState();\n        bypassStart.ruleIndex = idx;\n        atn.addState(bypassStart);\n\n        const bypassStop = new BlockEndState();\n        bypassStop.ruleIndex = idx;\n        atn.addState(bypassStop);\n\n        bypassStart.endState = bypassStop;\n        atn.defineDecisionState(bypassStart);\n\n        bypassStop.startState = bypassStart;\n\n        let excludeTransition = null;\n        let endState = null;\n\n        if (atn.ruleToStartState[idx].isPrecedenceRule) {\n            // wrap from the beginning of the rule to the StarLoopEntryState\n            endState = null;\n            for(i=0; i<atn.states.length; i++) {\n                state = atn.states[i];\n                if (this.stateIsEndStateFor(state, idx)) {\n                    endState = state;\n                    excludeTransition = state.loopBackState.transitions[0];\n                    break;\n                }\n            }\n            if (excludeTransition === null) {\n                throw (\"Couldn't identify final state of the precedence rule prefix section.\");\n            }\n        } else {\n            endState = atn.ruleToStopState[idx];\n        }\n\n        // all non-excluded transitions that currently target end state need to\n        // target blockEnd instead\n        for(i=0; i<atn.states.length; i++) {\n            state = atn.states[i];\n            for(let j=0; j<state.transitions.length; j++) {\n                const transition = state.transitions[j];\n                if (transition === excludeTransition) {\n                    continue;\n                }\n                if (transition.target === endState) {\n                    transition.target = bypassStop;\n                }\n            }\n        }\n\n        // all transitions leaving the rule start state need to leave blockStart\n        // instead\n        const ruleToStartState = atn.ruleToStartState[idx];\n        const count = ruleToStartState.transitions.length;\n        while ( count > 0) {\n            bypassStart.addTransition(ruleToStartState.transitions[count-1]);\n            ruleToStartState.transitions = ruleToStartState.transitions.slice(-1);\n        }\n        // link the new states\n        atn.ruleToStartState[idx].addTransition(new EpsilonTransition(bypassStart));\n        bypassStop.addTransition(new EpsilonTransition(endState));\n\n        const matchState = new BasicState();\n        atn.addState(matchState);\n        matchState.addTransition(new AtomTransition(bypassStop, atn.ruleToTokenType[idx]));\n        bypassStart.addTransition(new EpsilonTransition(matchState));\n    }\n\n    stateIsEndStateFor(state, idx) {\n        if ( state.ruleIndex !== idx) {\n            return null;\n        }\n        if (!( state instanceof StarLoopEntryState)) {\n            return null;\n        }\n        const maybeLoopEndState = state.transitions[state.transitions.length - 1].target;\n        if (!( maybeLoopEndState instanceof LoopEndState)) {\n            return null;\n        }\n        if (maybeLoopEndState.epsilonOnlyTransitions &&\n            (maybeLoopEndState.transitions[0].target instanceof RuleStopState)) {\n            return state;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Analyze the {@link StarLoopEntryState} states in the specified ATN to set\n     * the {@link StarLoopEntryState//isPrecedenceDecision} field to the\n     * correct value.\n     * @param atn The ATN.\n     */\n    markPrecedenceDecisions(atn) {\n        for(let i=0; i<atn.states.length; i++) {\n            const state = atn.states[i];\n            if (!( state instanceof StarLoopEntryState)) {\n                continue;\n            }\n            // We analyze the ATN to determine if this ATN decision state is the\n            // decision for the closure block that determines whether a\n            // precedence rule should continue or complete.\n            if ( atn.ruleToStartState[state.ruleIndex].isPrecedenceRule) {\n                const maybeLoopEndState = state.transitions[state.transitions.length - 1].target;\n                if (maybeLoopEndState instanceof LoopEndState) {\n                    if ( maybeLoopEndState.epsilonOnlyTransitions &&\n                            (maybeLoopEndState.transitions[0].target instanceof RuleStopState)) {\n                        state.isPrecedenceDecision = true;\n                    }\n                }\n            }\n        }\n    }\n\n    verifyATN(atn) {\n        if (!this.deserializationOptions.verifyATN) {\n            return;\n        }\n        // verify assumptions\n        for(let i=0; i<atn.states.length; i++) {\n            const state = atn.states[i];\n            if (state === null) {\n                continue;\n            }\n            this.checkCondition(state.epsilonOnlyTransitions || state.transitions.length <= 1);\n            if (state instanceof PlusBlockStartState) {\n                this.checkCondition(state.loopBackState !== null);\n            } else  if (state instanceof StarLoopEntryState) {\n                this.checkCondition(state.loopBackState !== null);\n                this.checkCondition(state.transitions.length === 2);\n                if (state.transitions[0].target instanceof StarBlockStartState) {\n                    this.checkCondition(state.transitions[1].target instanceof LoopEndState);\n                    this.checkCondition(!state.nonGreedy);\n                } else if (state.transitions[0].target instanceof LoopEndState) {\n                    this.checkCondition(state.transitions[1].target instanceof StarBlockStartState);\n                    this.checkCondition(state.nonGreedy);\n                } else {\n                    throw(\"IllegalState\");\n                }\n            } else if (state instanceof StarLoopbackState) {\n                this.checkCondition(state.transitions.length === 1);\n                this.checkCondition(state.transitions[0].target instanceof StarLoopEntryState);\n            } else if (state instanceof LoopEndState) {\n                this.checkCondition(state.loopBackState !== null);\n            } else if (state instanceof RuleStartState) {\n                this.checkCondition(state.stopState !== null);\n            } else if (state instanceof BlockStartState) {\n                this.checkCondition(state.endState !== null);\n            } else if (state instanceof BlockEndState) {\n                this.checkCondition(state.startState !== null);\n            } else if (state instanceof DecisionState) {\n                this.checkCondition(state.transitions.length <= 1 || state.decision >= 0);\n            } else {\n                this.checkCondition(state.transitions.length <= 1 || (state instanceof RuleStopState));\n            }\n        }\n    }\n\n    checkCondition(condition, message) {\n        if (!condition) {\n            if (message === undefined || message===null) {\n                message = \"IllegalState\";\n            }\n            throw (message);\n        }\n    }\n\n    readInt() {\n        return this.data[this.pos++];\n    }\n\n    readInt32() {\n        const low = this.readInt();\n        const high = this.readInt();\n        return low | (high << 16);\n    }\n\n    readLong() {\n        const low = this.readInt32();\n        const high = this.readInt32();\n        return (low & 0x00000000FFFFFFFF) | (high << 32);\n    }\n\n    readUUID() {\n        const bb = [];\n        for(let i=7;i>=0;i--) {\n            const int = this.readInt();\n            /* jshint bitwise: false */\n            bb[(2*i)+1] = int & 0xFF;\n            bb[2*i] = (int >> 8) & 0xFF;\n        }\n        return byteToHex[bb[0]] + byteToHex[bb[1]] +\n        byteToHex[bb[2]] + byteToHex[bb[3]] + '-' +\n        byteToHex[bb[4]] + byteToHex[bb[5]] + '-' +\n        byteToHex[bb[6]] + byteToHex[bb[7]] + '-' +\n        byteToHex[bb[8]] + byteToHex[bb[9]] + '-' +\n        byteToHex[bb[10]] + byteToHex[bb[11]] +\n        byteToHex[bb[12]] + byteToHex[bb[13]] +\n        byteToHex[bb[14]] + byteToHex[bb[15]];\n    }\n\n    edgeFactory(atn, type, src, trg, arg1, arg2, arg3, sets) {\n        const target = atn.states[trg];\n        switch(type) {\n        case Transition.EPSILON:\n            return new EpsilonTransition(target);\n        case Transition.RANGE:\n            return arg3 !== 0 ? new RangeTransition(target, Token.EOF, arg2) : new RangeTransition(target, arg1, arg2);\n        case Transition.RULE:\n            return new RuleTransition(atn.states[arg1], arg2, arg3, target);\n        case Transition.PREDICATE:\n            return new PredicateTransition(target, arg1, arg2, arg3 !== 0);\n        case Transition.PRECEDENCE:\n            return new PrecedencePredicateTransition(target, arg1);\n        case Transition.ATOM:\n            return arg3 !== 0 ? new AtomTransition(target, Token.EOF) : new AtomTransition(target, arg1);\n        case Transition.ACTION:\n            return new ActionTransition(target, arg1, arg2, arg3 !== 0);\n        case Transition.SET:\n            return new SetTransition(target, sets[arg1]);\n        case Transition.NOT_SET:\n            return new NotSetTransition(target, sets[arg1]);\n        case Transition.WILDCARD:\n            return new WildcardTransition(target);\n        default:\n            throw \"The specified transition type: \" + type + \" is not valid.\";\n        }\n    }\n\n    stateFactory(type, ruleIndex) {\n        if (this.stateFactories === null) {\n            const sf = [];\n            sf[ATNState.INVALID_TYPE] = null;\n            sf[ATNState.BASIC] = () => new BasicState();\n            sf[ATNState.RULE_START] = () => new RuleStartState();\n            sf[ATNState.BLOCK_START] = () => new BasicBlockStartState();\n            sf[ATNState.PLUS_BLOCK_START] = () => new PlusBlockStartState();\n            sf[ATNState.STAR_BLOCK_START] = () => new StarBlockStartState();\n            sf[ATNState.TOKEN_START] = () => new TokensStartState();\n            sf[ATNState.RULE_STOP] = () => new RuleStopState();\n            sf[ATNState.BLOCK_END] = () => new BlockEndState();\n            sf[ATNState.STAR_LOOP_BACK] = () => new StarLoopbackState();\n            sf[ATNState.STAR_LOOP_ENTRY] = () => new StarLoopEntryState();\n            sf[ATNState.PLUS_LOOP_BACK] = () => new PlusLoopbackState();\n            sf[ATNState.LOOP_END] = () => new LoopEndState();\n            this.stateFactories = sf;\n        }\n        if (type>this.stateFactories.length || this.stateFactories[type] === null) {\n            throw(\"The specified state type \" + type + \" is not valid.\");\n        } else {\n            const s = this.stateFactories[type]();\n            if (s!==null) {\n                s.ruleIndex = ruleIndex;\n                return s;\n            }\n        }\n    }\n\n    lexerActionFactory(type, data1, data2) {\n        if (this.actionFactories === null) {\n            const af = [];\n            af[LexerActionType.CHANNEL] = (data1, data2) => new LexerChannelAction(data1);\n            af[LexerActionType.CUSTOM] = (data1, data2) => new LexerCustomAction(data1, data2);\n            af[LexerActionType.MODE] = (data1, data2) => new LexerModeAction(data1);\n            af[LexerActionType.MORE] = (data1, data2) => LexerMoreAction.INSTANCE;\n            af[LexerActionType.POP_MODE] = (data1, data2) => LexerPopModeAction.INSTANCE;\n            af[LexerActionType.PUSH_MODE] = (data1, data2) => new LexerPushModeAction(data1);\n            af[LexerActionType.SKIP] = (data1, data2) => LexerSkipAction.INSTANCE;\n            af[LexerActionType.TYPE] = (data1, data2) => new LexerTypeAction(data1);\n            this.actionFactories = af;\n        }\n        if (type>this.actionFactories.length || this.actionFactories[type] === null) {\n            throw(\"The specified lexer action type \" + type + \" is not valid.\");\n        } else {\n            return this.actionFactories[type](data1, data2);\n        }\n    }\n}\n\nfunction createByteToHex() {\n\tconst bth = [];\n\tfor (let i = 0; i < 256; i++) {\n\t\tbth[i] = (i + 0x100).toString(16).substr(1).toUpperCase();\n\t}\n\treturn bth;\n}\n\nconst byteToHex = createByteToHex();\n\n\nmodule.exports = ATNDeserializer;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {DFAState} = require('./../dfa/DFAState');\nconst {ATNConfigSet} = require('./ATNConfigSet');\nconst {getCachedPredictionContext} = require('./../PredictionContext');\nconst {Map} = require('./../Utils');\n\nclass ATNSimulator {\n    constructor(atn, sharedContextCache) {\n        /**\n         * The context cache maps all PredictionContext objects that are ==\n         * to a single cached copy. This cache is shared across all contexts\n         * in all ATNConfigs in all DFA states.  We rebuild each ATNConfigSet\n         * to use only cached nodes/graphs in addDFAState(). We don't want to\n         * fill this during closure() since there are lots of contexts that\n         * pop up but are not used ever again. It also greatly slows down closure().\n         *\n         * <p>This cache makes a huge difference in memory and a little bit in speed.\n         * For the Java grammar on java.*, it dropped the memory requirements\n         * at the end from 25M to 16M. We don't store any of the full context\n         * graphs in the DFA because they are limited to local context only,\n         * but apparently there's a lot of repetition there as well. We optimize\n         * the config contexts before storing the config set in the DFA states\n         * by literally rebuilding them with cached subgraphs only.</p>\n         *\n         * <p>I tried a cache for use during closure operations, that was\n         * whacked after each adaptivePredict(). It cost a little bit\n         * more time I think and doesn't save on the overall footprint\n         * so it's not worth the complexity.</p>\n         */\n        this.atn = atn;\n        this.sharedContextCache = sharedContextCache;\n        return this;\n    }\n\n    getCachedContext(context) {\n        if (this.sharedContextCache ===null) {\n            return context;\n        }\n        const visited = new Map();\n        return getCachedPredictionContext(context, this.sharedContextCache, visited);\n    }\n}\n\n// Must distinguish between missing edge and edge we know leads nowhere///\nATNSimulator.ERROR = new DFAState(0x7FFFFFFF, new ATNConfigSet());\n\n\nmodule.exports = ATNSimulator;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst INITIAL_NUM_TRANSITIONS = 4;\n\n/**\n * The following images show the relation of states and\n * {@link ATNState//transitions} for various grammar constructs.\n *\n * <ul>\n *\n * <li>Solid edges marked with an &//0949; indicate a required\n * {@link EpsilonTransition}.</li>\n *\n * <li>Dashed edges indicate locations where any transition derived from\n * {@link Transition} might appear.</li>\n *\n * <li>Dashed nodes are place holders for either a sequence of linked\n * {@link BasicState} states or the inclusion of a block representing a nested\n * construct in one of the forms below.</li>\n *\n * <li>Nodes showing multiple outgoing alternatives with a {@code ...} support\n * any number of alternatives (one or more). Nodes without the {@code ...} only\n * support the exact number of alternatives shown in the diagram.</li>\n *\n * </ul>\n *\n * <h2>Basic Blocks</h2>\n *\n * <h3>Rule</h3>\n *\n * <embed src=\"images/Rule.svg\" type=\"image/svg+xml\"/>\n *\n * <h3>Block of 1 or more alternatives</h3>\n *\n * <embed src=\"images/Block.svg\" type=\"image/svg+xml\"/>\n *\n * <h2>Greedy Loops</h2>\n *\n * <h3>Greedy Closure: {@code (...)*}</h3>\n *\n * <embed src=\"images/ClosureGreedy.svg\" type=\"image/svg+xml\"/>\n *\n * <h3>Greedy Positive Closure: {@code (...)+}</h3>\n *\n * <embed src=\"images/PositiveClosureGreedy.svg\" type=\"image/svg+xml\"/>\n *\n * <h3>Greedy Optional: {@code (...)?}</h3>\n *\n * <embed src=\"images/OptionalGreedy.svg\" type=\"image/svg+xml\"/>\n *\n * <h2>Non-Greedy Loops</h2>\n *\n * <h3>Non-Greedy Closure: {@code (...)*?}</h3>\n *\n * <embed src=\"images/ClosureNonGreedy.svg\" type=\"image/svg+xml\"/>\n *\n * <h3>Non-Greedy Positive Closure: {@code (...)+?}</h3>\n *\n * <embed src=\"images/PositiveClosureNonGreedy.svg\" type=\"image/svg+xml\"/>\n *\n * <h3>Non-Greedy Optional: {@code (...)??}</h3>\n *\n * <embed src=\"images/OptionalNonGreedy.svg\" type=\"image/svg+xml\"/>\n */\nclass ATNState {\n    constructor() {\n        // Which ATN are we in?\n        this.atn = null;\n        this.stateNumber = ATNState.INVALID_STATE_NUMBER;\n        this.stateType = null;\n        this.ruleIndex = 0; // at runtime, we don't have Rule objects\n        this.epsilonOnlyTransitions = false;\n        // Track the transitions emanating from this ATN state.\n        this.transitions = [];\n        // Used to cache lookahead during parsing, not used during construction\n        this.nextTokenWithinRule = null;\n    }\n\n    toString() {\n        return this.stateNumber;\n    }\n\n    equals(other) {\n        if (other instanceof ATNState) {\n            return this.stateNumber===other.stateNumber;\n        } else {\n            return false;\n        }\n    }\n\n    isNonGreedyExitState() {\n        return false;\n    }\n\n    addTransition(trans, index) {\n        if(index===undefined) {\n            index = -1;\n        }\n        if (this.transitions.length===0) {\n            this.epsilonOnlyTransitions = trans.isEpsilon;\n        } else if(this.epsilonOnlyTransitions !== trans.isEpsilon) {\n            this.epsilonOnlyTransitions = false;\n        }\n        if (index===-1) {\n            this.transitions.push(trans);\n        } else {\n            this.transitions.splice(index, 1, trans);\n        }\n    }\n}\n\n// constants for serialization\nATNState.INVALID_TYPE = 0;\nATNState.BASIC = 1;\nATNState.RULE_START = 2;\nATNState.BLOCK_START = 3;\nATNState.PLUS_BLOCK_START = 4;\nATNState.STAR_BLOCK_START = 5;\nATNState.TOKEN_START = 6;\nATNState.RULE_STOP = 7;\nATNState.BLOCK_END = 8;\nATNState.STAR_LOOP_BACK = 9;\nATNState.STAR_LOOP_ENTRY = 10;\nATNState.PLUS_LOOP_BACK = 11;\nATNState.LOOP_END = 12;\n\nATNState.serializationNames = [\n            \"INVALID\",\n            \"BASIC\",\n            \"RULE_START\",\n            \"BLOCK_START\",\n            \"PLUS_BLOCK_START\",\n            \"STAR_BLOCK_START\",\n            \"TOKEN_START\",\n            \"RULE_STOP\",\n            \"BLOCK_END\",\n            \"STAR_LOOP_BACK\",\n            \"STAR_LOOP_ENTRY\",\n            \"PLUS_LOOP_BACK\",\n            \"LOOP_END\" ];\n\nATNState.INVALID_STATE_NUMBER = -1;\n\n\nclass BasicState extends ATNState {\n    constructor() {\n        super();\n        this.stateType = ATNState.BASIC;\n    }\n}\n\nclass DecisionState extends ATNState {\n    constructor() {\n        super();\n        this.decision = -1;\n        this.nonGreedy = false;\n        return this;\n    }\n}\n\n/**\n *  The start of a regular {@code (...)} block\n */\nclass BlockStartState extends DecisionState {\n    constructor() {\n        super();\n        this.endState = null;\n        return this;\n    }\n}\n\nclass BasicBlockStartState extends BlockStartState {\n    constructor() {\n        super();\n        this.stateType = ATNState.BLOCK_START;\n        return this;\n    }\n}\n\n/**\n * Terminal node of a simple {@code (a|b|c)} block\n */\nclass BlockEndState extends ATNState {\n    constructor() {\n        super();\n        this.stateType = ATNState.BLOCK_END;\n        this.startState = null;\n        return this;\n    }\n}\n\n/**\n * The last node in the ATN for a rule, unless that rule is the start symbol.\n * In that case, there is one transition to EOF. Later, we might encode\n * references to all calls to this rule to compute FOLLOW sets for\n * error handling\n */\nclass RuleStopState extends ATNState {\n    constructor() {\n        super();\n        this.stateType = ATNState.RULE_STOP;\n        return this;\n    }\n}\n\nclass RuleStartState extends ATNState {\n    constructor() {\n        super();\n        this.stateType = ATNState.RULE_START;\n        this.stopState = null;\n        this.isPrecedenceRule = false;\n        return this;\n    }\n}\n\n/**\n * Decision state for {@code A+} and {@code (A|B)+}.  It has two transitions:\n * one to the loop back to start of the block and one to exit.\n */\nclass PlusLoopbackState extends DecisionState {\n    constructor() {\n        super();\n        this.stateType = ATNState.PLUS_LOOP_BACK;\n        return this;\n    }\n}\n\n/**\n * Start of {@code (A|B|...)+} loop. Technically a decision state, but\n * we don't use for code generation; somebody might need it, so I'm defining\n * it for completeness. In reality, the {@link PlusLoopbackState} node is the\n * real decision-making note for {@code A+}\n */\nclass PlusBlockStartState extends BlockStartState {\n    constructor() {\n        super();\n        this.stateType = ATNState.PLUS_BLOCK_START;\n        this.loopBackState = null;\n        return this;\n    }\n}\n\n/**\n * The block that begins a closure loop\n */\nclass StarBlockStartState extends BlockStartState {\n    constructor() {\n        super();\n        this.stateType = ATNState.STAR_BLOCK_START;\n        return this;\n    }\n}\n\nclass StarLoopbackState extends ATNState {\n    constructor() {\n        super();\n        this.stateType = ATNState.STAR_LOOP_BACK;\n        return this;\n    }\n}\n\nclass StarLoopEntryState extends DecisionState {\n    constructor() {\n        super();\n        this.stateType = ATNState.STAR_LOOP_ENTRY;\n        this.loopBackState = null;\n        // Indicates whether this state can benefit from a precedence DFA during SLL decision making.\n        this.isPrecedenceDecision = null;\n        return this;\n    }\n}\n\n/**\n * Mark the end of a * or + loop\n */\nclass LoopEndState extends ATNState {\n    constructor() {\n        super();\n        this.stateType = ATNState.LOOP_END;\n        this.loopBackState = null;\n        return this;\n    }\n}\n\n/**\n * The Tokens rule start state linking to each lexer rule start state\n */\nclass TokensStartState extends DecisionState {\n    constructor() {\n        super();\n        this.stateType = ATNState.TOKEN_START;\n        return this;\n    }\n}\n\nmodule.exports = {\n    ATNState,\n    BasicState,\n    DecisionState,\n    BlockStartState,\n    BlockEndState,\n    LoopEndState,\n    RuleStartState,\n    RuleStopState,\n    TokensStartState,\n    PlusLoopbackState,\n    StarLoopbackState,\n    StarLoopEntryState,\n    PlusBlockStartState,\n    StarBlockStartState,\n    BasicBlockStartState\n}\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\n/**\n * Represents the type of recognizer an ATN applies to\n */\nmodule.exports = {\n    LEXER: 0,\n    PARSER: 1\n};\n\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Token} = require('./../Token');\nconst Lexer = require('./../Lexer');\nconst ATN = require('./ATN');\nconst ATNSimulator = require('./ATNSimulator');\nconst {DFAState} = require('./../dfa/DFAState');\nconst {OrderedATNConfigSet} = require('./ATNConfigSet');\nconst {PredictionContext} = require('./../PredictionContext');\nconst {SingletonPredictionContext} = require('./../PredictionContext');\nconst {RuleStopState} = require('./ATNState');\nconst {LexerATNConfig} = require('./ATNConfig');\nconst {Transition} = require('./Transition');\nconst LexerActionExecutor = require('./LexerActionExecutor');\nconst {LexerNoViableAltException} = require('./../error/Errors');\n\nfunction resetSimState(sim) {\n\tsim.index = -1;\n\tsim.line = 0;\n\tsim.column = -1;\n\tsim.dfaState = null;\n}\n\nclass SimState {\n\tconstructor() {\n\t\tresetSimState(this);\n\t}\n\n\treset() {\n\t\tresetSimState(this);\n\t}\n}\n\nclass LexerATNSimulator extends ATNSimulator {\n\t/**\n\t * When we hit an accept state in either the DFA or the ATN, we\n\t * have to notify the character stream to start buffering characters\n\t * via {@link IntStream//mark} and record the current state. The current sim state\n\t * includes the current index into the input, the current line,\n\t * and current character position in that line. Note that the Lexer is\n\t * tracking the starting line and characterization of the token. These\n\t * variables track the \"state\" of the simulator when it hits an accept state.\n\t *\n\t * <p>We track these variables separately for the DFA and ATN simulation\n\t * because the DFA simulation often has to fail over to the ATN\n\t * simulation. If the ATN simulation fails, we need the DFA to fall\n\t * back to its previously accepted state, if any. If the ATN succeeds,\n\t * then the ATN does the accept and the DFA simulator that invoked it\n\t * can simply return the predicted token type.</p>\n\t */\n\tconstructor(recog, atn, decisionToDFA, sharedContextCache) {\n\t\tsuper(atn, sharedContextCache);\n\t\tthis.decisionToDFA = decisionToDFA;\n\t\tthis.recog = recog;\n\t\t/**\n\t\t * The current token's starting index into the character stream.\n\t\t * Shared across DFA to ATN simulation in case the ATN fails and the\n\t\t * DFA did not have a previous accept state. In this case, we use the\n\t\t * ATN-generated exception object\n\t\t */\n\t\tthis.startIndex = -1;\n\t\t// line number 1..n within the input///\n\t\tthis.line = 1;\n\t\t/**\n\t\t * The index of the character relative to the beginning of the line\n\t\t * 0..n-1\n\t\t */\n\t\tthis.column = 0;\n\t\tthis.mode = Lexer.DEFAULT_MODE;\n\t\t/**\n\t\t * Used during DFA/ATN exec to record the most recent accept configuration\n\t\t * info\n\t\t */\n\t\tthis.prevAccept = new SimState();\n\t}\n\n\tcopyState(simulator) {\n\t\tthis.column = simulator.column;\n\t\tthis.line = simulator.line;\n\t\tthis.mode = simulator.mode;\n\t\tthis.startIndex = simulator.startIndex;\n\t}\n\n\tmatch(input, mode) {\n\t\tthis.match_calls += 1;\n\t\tthis.mode = mode;\n\t\tconst mark = input.mark();\n\t\ttry {\n\t\t\tthis.startIndex = input.index;\n\t\t\tthis.prevAccept.reset();\n\t\t\tconst dfa = this.decisionToDFA[mode];\n\t\t\tif (dfa.s0 === null) {\n\t\t\t\treturn this.matchATN(input);\n\t\t\t} else {\n\t\t\t\treturn this.execATN(input, dfa.s0);\n\t\t\t}\n\t\t} finally {\n\t\t\tinput.release(mark);\n\t\t}\n\t}\n\n\treset() {\n\t\tthis.prevAccept.reset();\n\t\tthis.startIndex = -1;\n\t\tthis.line = 1;\n\t\tthis.column = 0;\n\t\tthis.mode = Lexer.DEFAULT_MODE;\n\t}\n\n\tmatchATN(input) {\n\t\tconst startState = this.atn.modeToStartState[this.mode];\n\n\t\tif (LexerATNSimulator.debug) {\n\t\t\tconsole.log(\"matchATN mode \" + this.mode + \" start: \" + startState);\n\t\t}\n\t\tconst old_mode = this.mode;\n\t\tconst s0_closure = this.computeStartState(input, startState);\n\t\tconst suppressEdge = s0_closure.hasSemanticContext;\n\t\ts0_closure.hasSemanticContext = false;\n\n\t\tconst next = this.addDFAState(s0_closure);\n\t\tif (!suppressEdge) {\n\t\t\tthis.decisionToDFA[this.mode].s0 = next;\n\t\t}\n\n\t\tconst predict = this.execATN(input, next);\n\n\t\tif (LexerATNSimulator.debug) {\n\t\t\tconsole.log(\"DFA after matchATN: \" + this.decisionToDFA[old_mode].toLexerString());\n\t\t}\n\t\treturn predict;\n\t}\n\n\texecATN(input, ds0) {\n\t\tif (LexerATNSimulator.debug) {\n\t\t\tconsole.log(\"start state closure=\" + ds0.configs);\n\t\t}\n\t\tif (ds0.isAcceptState) {\n\t\t\t// allow zero-length tokens\n\t\t\tthis.captureSimState(this.prevAccept, input, ds0);\n\t\t}\n\t\tlet t = input.LA(1);\n\t\tlet s = ds0; // s is current/from DFA state\n\n\t\twhile (true) { // while more work\n\t\t\tif (LexerATNSimulator.debug) {\n\t\t\t\tconsole.log(\"execATN loop starting closure: \" + s.configs);\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * As we move src->trg, src->trg, we keep track of the previous trg to\n\t\t\t * avoid looking up the DFA state again, which is expensive.\n\t\t\t * If the previous target was already part of the DFA, we might\n\t\t\t * be able to avoid doing a reach operation upon t. If s!=null,\n\t\t\t * it means that semantic predicates didn't prevent us from\n\t\t\t * creating a DFA state. Once we know s!=null, we check to see if\n\t\t\t * the DFA state has an edge already for t. If so, we can just reuse\n\t\t\t * it's configuration set; there's no point in re-computing it.\n\t\t\t * This is kind of like doing DFA simulation within the ATN\n\t\t\t * simulation because DFA simulation is really just a way to avoid\n\t\t\t * computing reach/closure sets. Technically, once we know that\n\t\t\t * we have a previously added DFA state, we could jump over to\n\t\t\t * the DFA simulator. But, that would mean popping back and forth\n\t\t\t * a lot and making things more complicated algorithmically.\n\t\t\t * This optimization makes a lot of sense for loops within DFA.\n\t\t\t * A character will take us back to an existing DFA state\n\t\t\t * that already has lots of edges out of it. e.g., .* in comments.\n\t\t\t * print(\"Target for:\" + str(s) + \" and:\" + str(t))\n\t\t\t */\n\t\t\tlet target = this.getExistingTargetState(s, t);\n\t\t\t// print(\"Existing:\" + str(target))\n\t\t\tif (target === null) {\n\t\t\t\ttarget = this.computeTargetState(input, s, t);\n\t\t\t\t// print(\"Computed:\" + str(target))\n\t\t\t}\n\t\t\tif (target === ATNSimulator.ERROR) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// If this is a consumable input element, make sure to consume before\n\t\t\t// capturing the accept state so the input index, line, and char\n\t\t\t// position accurately reflect the state of the interpreter at the\n\t\t\t// end of the token.\n\t\t\tif (t !== Token.EOF) {\n\t\t\t\tthis.consume(input);\n\t\t\t}\n\t\t\tif (target.isAcceptState) {\n\t\t\t\tthis.captureSimState(this.prevAccept, input, target);\n\t\t\t\tif (t === Token.EOF) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tt = input.LA(1);\n\t\t\ts = target; // flip; current DFA target becomes new src/from state\n\t\t}\n\t\treturn this.failOrAccept(this.prevAccept, input, s.configs, t);\n\t}\n\n\t/**\n\t * Get an existing target state for an edge in the DFA. If the target state\n\t * for the edge has not yet been computed or is otherwise not available,\n\t * this method returns {@code null}.\n\t *\n\t * @param s The current DFA state\n\t * @param t The next input symbol\n\t * @return The existing target DFA state for the given input symbol\n\t * {@code t}, or {@code null} if the target state for this edge is not\n\t * already cached\n\t */\n\tgetExistingTargetState(s, t) {\n\t\tif (s.edges === null || t < LexerATNSimulator.MIN_DFA_EDGE || t > LexerATNSimulator.MAX_DFA_EDGE) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet target = s.edges[t - LexerATNSimulator.MIN_DFA_EDGE];\n\t\tif(target===undefined) {\n\t\t\ttarget = null;\n\t\t}\n\t\tif (LexerATNSimulator.debug && target !== null) {\n\t\t\tconsole.log(\"reuse state \" + s.stateNumber + \" edge to \" + target.stateNumber);\n\t\t}\n\t\treturn target;\n\t}\n\n\t/**\n\t * Compute a target state for an edge in the DFA, and attempt to add the\n\t * computed state and corresponding edge to the DFA.\n\t *\n\t * @param input The input stream\n\t * @param s The current DFA state\n\t * @param t The next input symbol\n\t *\n\t * @return The computed target DFA state for the given input symbol\n\t * {@code t}. If {@code t} does not lead to a valid DFA state, this method\n\t * returns {@link //ERROR}.\n\t */\n\tcomputeTargetState(input, s, t) {\n\t\tconst reach = new OrderedATNConfigSet();\n\t\t// if we don't find an existing DFA state\n\t\t// Fill reach starting from closure, following t transitions\n\t\tthis.getReachableConfigSet(input, s.configs, reach, t);\n\n\t\tif (reach.items.length === 0) { // we got nowhere on t from s\n\t\t\tif (!reach.hasSemanticContext) {\n\t\t\t\t// we got nowhere on t, don't throw out this knowledge; it'd\n\t\t\t\t// cause a failover from DFA later.\n\t\t\t\tthis.addDFAEdge(s, t, ATNSimulator.ERROR);\n\t\t\t}\n\t\t\t// stop when we can't match any more char\n\t\t\treturn ATNSimulator.ERROR;\n\t\t}\n\t\t// Add an edge from s to target DFA found/created for reach\n\t\treturn this.addDFAEdge(s, t, null, reach);\n\t}\n\n\tfailOrAccept(prevAccept, input, reach, t) {\n\t\tif (this.prevAccept.dfaState !== null) {\n\t\t\tconst lexerActionExecutor = prevAccept.dfaState.lexerActionExecutor;\n\t\t\tthis.accept(input, lexerActionExecutor, this.startIndex,\n\t\t\t\t\tprevAccept.index, prevAccept.line, prevAccept.column);\n\t\t\treturn prevAccept.dfaState.prediction;\n\t\t} else {\n\t\t\t// if no accept and EOF is first char, return EOF\n\t\t\tif (t === Token.EOF && input.index === this.startIndex) {\n\t\t\t\treturn Token.EOF;\n\t\t\t}\n\t\t\tthrow new LexerNoViableAltException(this.recog, input, this.startIndex, reach);\n\t\t}\n\t}\n\n\t/**\n\t * Given a starting configuration set, figure out all ATN configurations\n\t * we can reach upon input {@code t}. Parameter {@code reach} is a return\n\t * parameter.\n\t */\n\tgetReachableConfigSet(input, closure,\n\t\t\treach, t) {\n\t\t// this is used to skip processing for configs which have a lower priority\n\t\t// than a config that already reached an accept state for the same rule\n\t\tlet skipAlt = ATN.INVALID_ALT_NUMBER;\n\t\tfor (let i = 0; i < closure.items.length; i++) {\n\t\t\tconst cfg = closure.items[i];\n\t\t\tconst currentAltReachedAcceptState = (cfg.alt === skipAlt);\n\t\t\tif (currentAltReachedAcceptState && cfg.passedThroughNonGreedyDecision) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (LexerATNSimulator.debug) {\n\t\t\t\tconsole.log(\"testing %s at %s\\n\", this.getTokenName(t), cfg\n\t\t\t\t\t\t.toString(this.recog, true));\n\t\t\t}\n\t\t\tfor (let j = 0; j < cfg.state.transitions.length; j++) {\n\t\t\t\tconst trans = cfg.state.transitions[j]; // for each transition\n\t\t\t\tconst target = this.getReachableTarget(trans, t);\n\t\t\t\tif (target !== null) {\n\t\t\t\t\tlet lexerActionExecutor = cfg.lexerActionExecutor;\n\t\t\t\t\tif (lexerActionExecutor !== null) {\n\t\t\t\t\t\tlexerActionExecutor = lexerActionExecutor.fixOffsetBeforeMatch(input.index - this.startIndex);\n\t\t\t\t\t}\n\t\t\t\t\tconst treatEofAsEpsilon = (t === Token.EOF);\n\t\t\t\t\tconst config = new LexerATNConfig({state:target, lexerActionExecutor:lexerActionExecutor}, cfg);\n\t\t\t\t\tif (this.closure(input, config, reach,\n\t\t\t\t\t\t\tcurrentAltReachedAcceptState, true, treatEofAsEpsilon)) {\n\t\t\t\t\t\t// any remaining configs for this alt have a lower priority\n\t\t\t\t\t\t// than the one that just reached an accept state.\n\t\t\t\t\t\tskipAlt = cfg.alt;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\taccept(input, lexerActionExecutor,\n\t\t\t   startIndex, index, line, charPos) {\n\t\t   if (LexerATNSimulator.debug) {\n\t\t\t   console.log(\"ACTION %s\\n\", lexerActionExecutor);\n\t\t   }\n\t\t   // seek to after last char in token\n\t\t   input.seek(index);\n\t\t   this.line = line;\n\t\t   this.column = charPos;\n\t\t   if (lexerActionExecutor !== null && this.recog !== null) {\n\t\t\t   lexerActionExecutor.execute(this.recog, input, startIndex);\n\t\t   }\n\t   }\n\n\tgetReachableTarget(trans, t) {\n\t\tif (trans.matches(t, 0, Lexer.MAX_CHAR_VALUE)) {\n\t\t\treturn trans.target;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tcomputeStartState(input, p) {\n\t\tconst initialContext = PredictionContext.EMPTY;\n\t\tconst configs = new OrderedATNConfigSet();\n\t\tfor (let i = 0; i < p.transitions.length; i++) {\n\t\t\tconst target = p.transitions[i].target;\n\t\t\tconst cfg = new LexerATNConfig({state:target, alt:i+1, context:initialContext}, null);\n\t\t\tthis.closure(input, cfg, configs, false, false, false);\n\t\t}\n\t\treturn configs;\n\t}\n\n\t/**\n\t * Since the alternatives within any lexer decision are ordered by\n\t * preference, this method stops pursuing the closure as soon as an accept\n\t * state is reached. After the first accept state is reached by depth-first\n\t * search from {@code config}, all other (potentially reachable) states for\n\t * this rule would have a lower priority.\n\t *\n\t * @return {Boolean} {@code true} if an accept state is reached, otherwise\n\t * {@code false}.\n\t */\n\tclosure(input, config, configs,\n\t\t\tcurrentAltReachedAcceptState, speculative, treatEofAsEpsilon) {\n\t\tlet cfg = null;\n\t\tif (LexerATNSimulator.debug) {\n\t\t\tconsole.log(\"closure(\" + config.toString(this.recog, true) + \")\");\n\t\t}\n\t\tif (config.state instanceof RuleStopState) {\n\t\t\tif (LexerATNSimulator.debug) {\n\t\t\t\tif (this.recog !== null) {\n\t\t\t\t\tconsole.log(\"closure at %s rule stop %s\\n\", this.recog.ruleNames[config.state.ruleIndex], config);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.log(\"closure at rule stop %s\\n\", config);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (config.context === null || config.context.hasEmptyPath()) {\n\t\t\t\tif (config.context === null || config.context.isEmpty()) {\n\t\t\t\t\tconfigs.add(config);\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\tconfigs.add(new LexerATNConfig({ state:config.state, context:PredictionContext.EMPTY}, config));\n\t\t\t\t\tcurrentAltReachedAcceptState = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (config.context !== null && !config.context.isEmpty()) {\n\t\t\t\tfor (let i = 0; i < config.context.length; i++) {\n\t\t\t\t\tif (config.context.getReturnState(i) !== PredictionContext.EMPTY_RETURN_STATE) {\n\t\t\t\t\t\tconst newContext = config.context.getParent(i); // \"pop\" return state\n\t\t\t\t\t\tconst returnState = this.atn.states[config.context.getReturnState(i)];\n\t\t\t\t\t\tcfg = new LexerATNConfig({ state:returnState, context:newContext }, config);\n\t\t\t\t\t\tcurrentAltReachedAcceptState = this.closure(input, cfg,\n\t\t\t\t\t\t\t\tconfigs, currentAltReachedAcceptState, speculative,\n\t\t\t\t\t\t\t\ttreatEofAsEpsilon);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn currentAltReachedAcceptState;\n\t\t}\n\t\t// optimization\n\t\tif (!config.state.epsilonOnlyTransitions) {\n\t\t\tif (!currentAltReachedAcceptState || !config.passedThroughNonGreedyDecision) {\n\t\t\t\tconfigs.add(config);\n\t\t\t}\n\t\t}\n\t\tfor (let j = 0; j < config.state.transitions.length; j++) {\n\t\t\tconst trans = config.state.transitions[j];\n\t\t\tcfg = this.getEpsilonTarget(input, config, trans, configs, speculative, treatEofAsEpsilon);\n\t\t\tif (cfg !== null) {\n\t\t\t\tcurrentAltReachedAcceptState = this.closure(input, cfg, configs,\n\t\t\t\t\t\tcurrentAltReachedAcceptState, speculative, treatEofAsEpsilon);\n\t\t\t}\n\t\t}\n\t\treturn currentAltReachedAcceptState;\n\t}\n\n\t// side-effect: can alter configs.hasSemanticContext\n\tgetEpsilonTarget(input, config, trans,\n\t\t\tconfigs, speculative, treatEofAsEpsilon) {\n\t\tlet cfg = null;\n\t\tif (trans.serializationType === Transition.RULE) {\n\t\t\tconst newContext = SingletonPredictionContext.create(config.context, trans.followState.stateNumber);\n\t\t\tcfg = new LexerATNConfig( { state:trans.target, context:newContext}, config);\n\t\t} else if (trans.serializationType === Transition.PRECEDENCE) {\n\t\t\tthrow \"Precedence predicates are not supported in lexers.\";\n\t\t} else if (trans.serializationType === Transition.PREDICATE) {\n\t\t\t// Track traversing semantic predicates. If we traverse,\n\t\t\t// we cannot add a DFA state for this \"reach\" computation\n\t\t\t// because the DFA would not test the predicate again in the\n\t\t\t// future. Rather than creating collections of semantic predicates\n\t\t\t// like v3 and testing them on prediction, v4 will test them on the\n\t\t\t// fly all the time using the ATN not the DFA. This is slower but\n\t\t\t// semantically it's not used that often. One of the key elements to\n\t\t\t// this predicate mechanism is not adding DFA states that see\n\t\t\t// predicates immediately afterwards in the ATN. For example,\n\n\t\t\t// a : ID {p1}? | ID {p2}? ;\n\n\t\t\t// should create the start state for rule 'a' (to save start state\n\t\t\t// competition), but should not create target of ID state. The\n\t\t\t// collection of ATN states the following ID references includes\n\t\t\t// states reached by traversing predicates. Since this is when we\n\t\t\t// test them, we cannot cash the DFA state target of ID.\n\n\t\t\tif (LexerATNSimulator.debug) {\n\t\t\t\tconsole.log(\"EVAL rule \" + trans.ruleIndex + \":\" + trans.predIndex);\n\t\t\t}\n\t\t\tconfigs.hasSemanticContext = true;\n\t\t\tif (this.evaluatePredicate(input, trans.ruleIndex, trans.predIndex, speculative)) {\n\t\t\t\tcfg = new LexerATNConfig({ state:trans.target}, config);\n\t\t\t}\n\t\t} else if (trans.serializationType === Transition.ACTION) {\n\t\t\tif (config.context === null || config.context.hasEmptyPath()) {\n\t\t\t\t// execute actions anywhere in the start rule for a token.\n\t\t\t\t//\n\t\t\t\t// TODO: if the entry rule is invoked recursively, some\n\t\t\t\t// actions may be executed during the recursive call. The\n\t\t\t\t// problem can appear when hasEmptyPath() is true but\n\t\t\t\t// isEmpty() is false. In this case, the config needs to be\n\t\t\t\t// split into two contexts - one with just the empty path\n\t\t\t\t// and another with everything but the empty path.\n\t\t\t\t// Unfortunately, the current algorithm does not allow\n\t\t\t\t// getEpsilonTarget to return two configurations, so\n\t\t\t\t// additional modifications are needed before we can support\n\t\t\t\t// the split operation.\n\t\t\t\tconst lexerActionExecutor = LexerActionExecutor.append(config.lexerActionExecutor,\n\t\t\t\t\t\tthis.atn.lexerActions[trans.actionIndex]);\n\t\t\t\tcfg = new LexerATNConfig({ state:trans.target, lexerActionExecutor:lexerActionExecutor }, config);\n\t\t\t} else {\n\t\t\t\t// ignore actions in referenced rules\n\t\t\t\tcfg = new LexerATNConfig( { state:trans.target}, config);\n\t\t\t}\n\t\t} else if (trans.serializationType === Transition.EPSILON) {\n\t\t\tcfg = new LexerATNConfig({ state:trans.target}, config);\n\t\t} else if (trans.serializationType === Transition.ATOM ||\n\t\t\t\t\ttrans.serializationType === Transition.RANGE ||\n\t\t\t\t\ttrans.serializationType === Transition.SET) {\n\t\t\tif (treatEofAsEpsilon) {\n\t\t\t\tif (trans.matches(Token.EOF, 0, Lexer.MAX_CHAR_VALUE)) {\n\t\t\t\t\tcfg = new LexerATNConfig( { state:trans.target }, config);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cfg;\n\t}\n\n\t/**\n\t * Evaluate a predicate specified in the lexer.\n\t *\n\t * <p>If {@code speculative} is {@code true}, this method was called before\n\t * {@link //consume} for the matched character. This method should call\n\t * {@link //consume} before evaluating the predicate to ensure position\n\t * sensitive values, including {@link Lexer//getText}, {@link Lexer//getLine},\n\t * and {@link Lexer//getcolumn}, properly reflect the current\n\t * lexer state. This method should restore {@code input} and the simulator\n\t * to the original state before returning (i.e. undo the actions made by the\n\t * call to {@link //consume}.</p>\n\t *\n\t * @param input The input stream.\n\t * @param ruleIndex The rule containing the predicate.\n\t * @param predIndex The index of the predicate within the rule.\n\t * @param speculative {@code true} if the current index in {@code input} is\n\t * one character before the predicate's location.\n\t *\n\t * @return {@code true} if the specified predicate evaluates to\n\t * {@code true}.\n\t */\n\tevaluatePredicate(input, ruleIndex,\n\t\t\tpredIndex, speculative) {\n\t\t// assume true if no recognizer was provided\n\t\tif (this.recog === null) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!speculative) {\n\t\t\treturn this.recog.sempred(null, ruleIndex, predIndex);\n\t\t}\n\t\tconst savedcolumn = this.column;\n\t\tconst savedLine = this.line;\n\t\tconst index = input.index;\n\t\tconst marker = input.mark();\n\t\ttry {\n\t\t\tthis.consume(input);\n\t\t\treturn this.recog.sempred(null, ruleIndex, predIndex);\n\t\t} finally {\n\t\t\tthis.column = savedcolumn;\n\t\t\tthis.line = savedLine;\n\t\t\tinput.seek(index);\n\t\t\tinput.release(marker);\n\t\t}\n\t}\n\n\tcaptureSimState(settings, input, dfaState) {\n\t\tsettings.index = input.index;\n\t\tsettings.line = this.line;\n\t\tsettings.column = this.column;\n\t\tsettings.dfaState = dfaState;\n\t}\n\n\taddDFAEdge(from_, tk, to, cfgs) {\n\t\tif (to === undefined) {\n\t\t\tto = null;\n\t\t}\n\t\tif (cfgs === undefined) {\n\t\t\tcfgs = null;\n\t\t}\n\t\tif (to === null && cfgs !== null) {\n\t\t\t// leading to this call, ATNConfigSet.hasSemanticContext is used as a\n\t\t\t// marker indicating dynamic predicate evaluation makes this edge\n\t\t\t// dependent on the specific input sequence, so the static edge in the\n\t\t\t// DFA should be omitted. The target DFAState is still created since\n\t\t\t// execATN has the ability to resynchronize with the DFA state cache\n\t\t\t// following the predicate evaluation step.\n\t\t\t//\n\t\t\t// TJP notes: next time through the DFA, we see a pred again and eval.\n\t\t\t// If that gets us to a previously created (but dangling) DFA\n\t\t\t// state, we can continue in pure DFA mode from there.\n\t\t\t// /\n\t\t\tconst suppressEdge = cfgs.hasSemanticContext;\n\t\t\tcfgs.hasSemanticContext = false;\n\n\t\t\tto = this.addDFAState(cfgs);\n\n\t\t\tif (suppressEdge) {\n\t\t\t\treturn to;\n\t\t\t}\n\t\t}\n\t\t// add the edge\n\t\tif (tk < LexerATNSimulator.MIN_DFA_EDGE || tk > LexerATNSimulator.MAX_DFA_EDGE) {\n\t\t\t// Only track edges within the DFA bounds\n\t\t\treturn to;\n\t\t}\n\t\tif (LexerATNSimulator.debug) {\n\t\t\tconsole.log(\"EDGE \" + from_ + \" -> \" + to + \" upon \" + tk);\n\t\t}\n\t\tif (from_.edges === null) {\n\t\t\t// make room for tokens 1..n and -1 masquerading as index 0\n\t\t\tfrom_.edges = [];\n\t\t}\n\t\tfrom_.edges[tk - LexerATNSimulator.MIN_DFA_EDGE] = to; // connect\n\n\t\treturn to;\n\t}\n\n\t/**\n\t * Add a new DFA state if there isn't one with this set of\n\t * configurations already. This method also detects the first\n\t * configuration containing an ATN rule stop state. Later, when\n\t * traversing the DFA, we will know which rule to accept.\n\t */\n\taddDFAState(configs) {\n\t\tconst proposed = new DFAState(null, configs);\n\t\tlet firstConfigWithRuleStopState = null;\n\t\tfor (let i = 0; i < configs.items.length; i++) {\n\t\t\tconst cfg = configs.items[i];\n\t\t\tif (cfg.state instanceof RuleStopState) {\n\t\t\t\tfirstConfigWithRuleStopState = cfg;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (firstConfigWithRuleStopState !== null) {\n\t\t\tproposed.isAcceptState = true;\n\t\t\tproposed.lexerActionExecutor = firstConfigWithRuleStopState.lexerActionExecutor;\n\t\t\tproposed.prediction = this.atn.ruleToTokenType[firstConfigWithRuleStopState.state.ruleIndex];\n\t\t}\n\t\tconst dfa = this.decisionToDFA[this.mode];\n\t\tconst existing = dfa.states.get(proposed);\n\t\tif (existing!==null) {\n\t\t\treturn existing;\n\t\t}\n\t\tconst newState = proposed;\n\t\tnewState.stateNumber = dfa.states.length;\n\t\tconfigs.setReadonly(true);\n\t\tnewState.configs = configs;\n\t\tdfa.states.add(newState);\n\t\treturn newState;\n\t}\n\n\tgetDFA(mode) {\n\t\treturn this.decisionToDFA[mode];\n\t}\n\n// Get the text matched so far for the current token.\n\tgetText(input) {\n\t\t// index is first lookahead char, don't include.\n\t\treturn input.getText(this.startIndex, input.index - 1);\n\t}\n\n\tconsume(input) {\n\t\tconst curChar = input.LA(1);\n\t\tif (curChar === \"\\n\".charCodeAt(0)) {\n\t\t\tthis.line += 1;\n\t\t\tthis.column = 0;\n\t\t} else {\n\t\t\tthis.column += 1;\n\t\t}\n\t\tinput.consume();\n\t}\n\n\tgetTokenName(tt) {\n\t\tif (tt === -1) {\n\t\t\treturn \"EOF\";\n\t\t} else {\n\t\t\treturn \"'\" + String.fromCharCode(tt) + \"'\";\n\t\t}\n\t}\n}\n\nLexerATNSimulator.debug = false;\nLexerATNSimulator.dfa_debug = false;\n\nLexerATNSimulator.MIN_DFA_EDGE = 0;\nLexerATNSimulator.MAX_DFA_EDGE = 127; // forces unicode to stay in ATN\n\nLexerATNSimulator.match_calls = 0;\n\nmodule.exports = LexerATNSimulator;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst LexerActionType = {\n    // The type of a {@link LexerChannelAction} action.\n    CHANNEL: 0,\n    // The type of a {@link LexerCustomAction} action\n    CUSTOM: 1,\n    // The type of a {@link LexerModeAction} action.\n    MODE: 2,\n    //The type of a {@link LexerMoreAction} action.\n    MORE: 3,\n    //The type of a {@link LexerPopModeAction} action.\n    POP_MODE: 4,\n    //The type of a {@link LexerPushModeAction} action.\n    PUSH_MODE: 5,\n    //The type of a {@link LexerSkipAction} action.\n    SKIP: 6,\n    //The type of a {@link LexerTypeAction} action.\n    TYPE: 7\n}\n\nclass LexerAction {\n    constructor(action) {\n        this.actionType = action;\n        this.isPositionDependent = false;\n    }\n\n    hashCode() {\n        const hash = new Hash();\n        this.updateHashCode(hash);\n        return hash.finish()\n    }\n\n    updateHashCode(hash) {\n        hash.update(this.actionType);\n    }\n\n    equals(other) {\n        return this === other;\n    }\n}\n\n\n/**\n * Implements the {@code skip} lexer action by calling {@link Lexer//skip}.\n *\n * <p>The {@code skip} command does not have any parameters, so this action is\n * implemented as a singleton instance exposed by {@link //INSTANCE}.</p>\n */\nclass LexerSkipAction extends LexerAction {\n    constructor() {\n        super(LexerActionType.SKIP);\n    }\n\n    execute(lexer) {\n        lexer.skip();\n    }\n\n    toString() {\n        return \"skip\";\n    }\n}\n\n// Provides a singleton instance of this parameterless lexer action.\nLexerSkipAction.INSTANCE = new LexerSkipAction();\n\n/**\n * Implements the {@code type} lexer action by calling {@link Lexer//setType}\n * with the assigned type\n */\nclass LexerTypeAction extends LexerAction {\n    constructor(type) {\n        super(LexerActionType.TYPE);\n        this.type = type;\n    }\n\n    execute(lexer) {\n        lexer.type = this.type;\n    }\n\n    updateHashCode(hash) {\n        hash.update(this.actionType, this.type);\n    }\n\n    equals(other) {\n        if(this === other) {\n            return true;\n        } else if (! (other instanceof LexerTypeAction)) {\n            return false;\n        } else {\n            return this.type === other.type;\n        }\n    }\n\n    toString() {\n        return \"type(\" + this.type + \")\";\n    }\n}\n\n\n/**\n * Implements the {@code pushMode} lexer action by calling\n * {@link Lexer//pushMode} with the assigned mode\n */\nclass LexerPushModeAction extends LexerAction {\n    constructor(mode) {\n        super(LexerActionType.PUSH_MODE);\n        this.mode = mode;\n    }\n\n    /**\n     * <p>This action is implemented by calling {@link Lexer//pushMode} with the\n     * value provided by {@link //getMode}.</p>\n     */\n    execute(lexer) {\n        lexer.pushMode(this.mode);\n    }\n\n    updateHashCode(hash) {\n        hash.update(this.actionType, this.mode);\n    }\n\n    equals(other) {\n        if (this === other) {\n            return true;\n        } else if (! (other instanceof LexerPushModeAction)) {\n            return false;\n        } else {\n            return this.mode === other.mode;\n        }\n    }\n\n    toString() {\n        return \"pushMode(\" + this.mode + \")\";\n    }\n}\n\n/**\n * Implements the {@code popMode} lexer action by calling {@link Lexer//popMode}.\n *\n * <p>The {@code popMode} command does not have any parameters, so this action is\n * implemented as a singleton instance exposed by {@link //INSTANCE}.</p>\n */\nclass LexerPopModeAction extends LexerAction {\n    constructor() {\n        super(LexerActionType.POP_MODE);\n    }\n\n    /**\n     * <p>This action is implemented by calling {@link Lexer//popMode}.</p>\n     */\n    execute(lexer) {\n        lexer.popMode();\n    }\n\n    toString() {\n        return \"popMode\";\n    }\n}\n\nLexerPopModeAction.INSTANCE = new LexerPopModeAction();\n\n/**\n * Implements the {@code more} lexer action by calling {@link Lexer//more}.\n *\n * <p>The {@code more} command does not have any parameters, so this action is\n * implemented as a singleton instance exposed by {@link //INSTANCE}.</p>\n */\nclass LexerMoreAction extends LexerAction {\n    constructor() {\n        super(LexerActionType.MORE);\n    }\n\n    /**\n     * <p>This action is implemented by calling {@link Lexer//popMode}.</p>\n     */\n    execute(lexer) {\n        lexer.more();\n    }\n\n    toString() {\n        return \"more\";\n    }\n}\n\nLexerMoreAction.INSTANCE = new LexerMoreAction();\n\n\n/**\n * Implements the {@code mode} lexer action by calling {@link Lexer//mode} with\n * the assigned mode\n */\nclass LexerModeAction extends LexerAction {\n    constructor(mode) {\n        super(LexerActionType.MODE);\n        this.mode = mode;\n    }\n\n    /**\n     * <p>This action is implemented by calling {@link Lexer//mode} with the\n     * value provided by {@link //getMode}.</p>\n     */\n    execute(lexer) {\n        lexer.mode(this.mode);\n    }\n\n    updateHashCode(hash) {\n        hash.update(this.actionType, this.mode);\n    }\n\n    equals(other) {\n        if (this === other) {\n            return true;\n        } else if (! (other instanceof LexerModeAction)) {\n            return false;\n        } else {\n            return this.mode === other.mode;\n        }\n    }\n\n    toString() {\n        return \"mode(\" + this.mode + \")\";\n    }\n}\n\n/**\n * Executes a custom lexer action by calling {@link Recognizer//action} with the\n * rule and action indexes assigned to the custom action. The implementation of\n * a custom action is added to the generated code for the lexer in an override\n * of {@link Recognizer//action} when the grammar is compiled.\n *\n * <p>This class may represent embedded actions created with the <code>{...}</code>\n * syntax in ANTLR 4, as well as actions created for lexer commands where the\n * command argument could not be evaluated when the grammar was compiled.</p>\n */\nclass LexerCustomAction extends LexerAction {\n    /**\n     * Constructs a custom lexer action with the specified rule and action\n     * indexes.\n     *\n     * @param ruleIndex The rule index to use for calls to\n     * {@link Recognizer//action}.\n     * @param actionIndex The action index to use for calls to\n     * {@link Recognizer//action}.\n     */\n    constructor(ruleIndex, actionIndex) {\n        super(LexerActionType.CUSTOM);\n        this.ruleIndex = ruleIndex;\n        this.actionIndex = actionIndex;\n        this.isPositionDependent = true;\n    }\n\n    /**\n     * <p>Custom actions are implemented by calling {@link Lexer//action} with the\n     * appropriate rule and action indexes.</p>\n     */\n    execute(lexer) {\n        lexer.action(null, this.ruleIndex, this.actionIndex);\n    }\n\n    updateHashCode(hash) {\n        hash.update(this.actionType, this.ruleIndex, this.actionIndex);\n    }\n\n    equals(other) {\n        if (this === other) {\n            return true;\n        } else if (! (other instanceof LexerCustomAction)) {\n            return false;\n        } else {\n            return this.ruleIndex === other.ruleIndex && this.actionIndex === other.actionIndex;\n        }\n    }\n}\n\n/**\n * Implements the {@code channel} lexer action by calling\n * {@link Lexer//setChannel} with the assigned channel.\n * Constructs a new {@code channel} action with the specified channel value.\n * @param channel The channel value to pass to {@link Lexer//setChannel}\n */\nclass LexerChannelAction extends LexerAction {\n    constructor(channel) {\n        super(LexerActionType.CHANNEL);\n        this.channel = channel;\n    }\n\n    /**\n     * <p>This action is implemented by calling {@link Lexer//setChannel} with the\n     * value provided by {@link //getChannel}.</p>\n     */\n    execute(lexer) {\n        lexer._channel = this.channel;\n    }\n\n    updateHashCode(hash) {\n        hash.update(this.actionType, this.channel);\n    }\n\n    equals(other) {\n        if (this === other) {\n            return true;\n        } else if (! (other instanceof LexerChannelAction)) {\n            return false;\n        } else {\n            return this.channel === other.channel;\n        }\n    }\n\n    toString() {\n        return \"channel(\" + this.channel + \")\";\n    }\n}\n\n\n/**\n * This implementation of {@link LexerAction} is used for tracking input offsets\n * for position-dependent actions within a {@link LexerActionExecutor}.\n *\n * <p>This action is not serialized as part of the ATN, and is only required for\n * position-dependent lexer actions which appear at a location other than the\n * end of a rule. For more information about DFA optimizations employed for\n * lexer actions, see {@link LexerActionExecutor//append} and\n * {@link LexerActionExecutor//fixOffsetBeforeMatch}.</p>\n *\n * Constructs a new indexed custom action by associating a character offset\n * with a {@link LexerAction}.\n *\n * <p>Note: This class is only required for lexer actions for which\n * {@link LexerAction//isPositionDependent} returns {@code true}.</p>\n *\n * @param offset The offset into the input {@link CharStream}, relative to\n * the token start index, at which the specified lexer action should be\n * executed.\n * @param action The lexer action to execute at a particular offset in the\n * input {@link CharStream}.\n */\nclass LexerIndexedCustomAction extends LexerAction {\n    constructor(offset, action) {\n        super(action.actionType);\n        this.offset = offset;\n        this.action = action;\n        this.isPositionDependent = true;\n    }\n\n    /**\n     * <p>This method calls {@link //execute} on the result of {@link //getAction}\n     * using the provided {@code lexer}.</p>\n     */\n    execute(lexer) {\n        // assume the input stream position was properly set by the calling code\n        this.action.execute(lexer);\n    }\n\n    updateHashCode(hash) {\n        hash.update(this.actionType, this.offset, this.action);\n    }\n\n    equals(other) {\n        if (this === other) {\n            return true;\n        } else if (! (other instanceof LexerIndexedCustomAction)) {\n            return false;\n        } else {\n            return this.offset === other.offset && this.action === other.action;\n        }\n    }\n}\n\nmodule.exports = {\n    LexerActionType,\n    LexerSkipAction,\n    LexerChannelAction,\n    LexerCustomAction,\n    LexerIndexedCustomAction,\n    LexerMoreAction,\n    LexerTypeAction,\n    LexerPushModeAction,\n    LexerPopModeAction,\n    LexerModeAction\n}\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {hashStuff} = require(\"../Utils\");\nconst {LexerIndexedCustomAction} = require('./LexerAction');\n\nclass LexerActionExecutor {\n\t/**\n\t * Represents an executor for a sequence of lexer actions which traversed during\n\t * the matching operation of a lexer rule (token).\n\t *\n\t * <p>The executor tracks position information for position-dependent lexer actions\n\t * efficiently, ensuring that actions appearing only at the end of the rule do\n\t * not cause bloating of the {@link DFA} created for the lexer.</p>\n\t */\n\tconstructor(lexerActions) {\n\t\tthis.lexerActions = lexerActions === null ? [] : lexerActions;\n\t\t/**\n\t\t * Caches the result of {@link //hashCode} since the hash code is an element\n\t\t * of the performance-critical {@link LexerATNConfig//hashCode} operation\n\t\t */\n\t\tthis.cachedHashCode = hashStuff(lexerActions); // \"\".join([str(la) for la in\n\t\t// lexerActions]))\n\t\treturn this;\n\t}\n\n\t/**\n\t * Creates a {@link LexerActionExecutor} which encodes the current offset\n\t * for position-dependent lexer actions.\n\t *\n\t * <p>Normally, when the executor encounters lexer actions where\n\t * {@link LexerAction//isPositionDependent} returns {@code true}, it calls\n\t * {@link IntStream//seek} on the input {@link CharStream} to set the input\n\t * position to the <em>end</em> of the current token. This behavior provides\n\t * for efficient DFA representation of lexer actions which appear at the end\n\t * of a lexer rule, even when the lexer rule matches a variable number of\n\t * characters.</p>\n\t *\n\t * <p>Prior to traversing a match transition in the ATN, the current offset\n\t * from the token start index is assigned to all position-dependent lexer\n\t * actions which have not already been assigned a fixed offset. By storing\n\t * the offsets relative to the token start index, the DFA representation of\n\t * lexer actions which appear in the middle of tokens remains efficient due\n\t * to sharing among tokens of the same length, regardless of their absolute\n\t * position in the input stream.</p>\n\t *\n\t * <p>If the current executor already has offsets assigned to all\n\t * position-dependent lexer actions, the method returns {@code this}.</p>\n\t *\n\t * @param offset The current offset to assign to all position-dependent\n\t * lexer actions which do not already have offsets assigned.\n\t *\n\t * @return {LexerActionExecutor} A {@link LexerActionExecutor} which stores input stream offsets\n\t * for all position-dependent lexer actions.\n\t */\n\tfixOffsetBeforeMatch(offset) {\n\t\tlet updatedLexerActions = null;\n\t\tfor (let i = 0; i < this.lexerActions.length; i++) {\n\t\t\tif (this.lexerActions[i].isPositionDependent &&\n\t\t\t\t\t!(this.lexerActions[i] instanceof LexerIndexedCustomAction)) {\n\t\t\t\tif (updatedLexerActions === null) {\n\t\t\t\t\tupdatedLexerActions = this.lexerActions.concat([]);\n\t\t\t\t}\n\t\t\t\tupdatedLexerActions[i] = new LexerIndexedCustomAction(offset,\n\t\t\t\t\t\tthis.lexerActions[i]);\n\t\t\t}\n\t\t}\n\t\tif (updatedLexerActions === null) {\n\t\t\treturn this;\n\t\t} else {\n\t\t\treturn new LexerActionExecutor(updatedLexerActions);\n\t\t}\n\t}\n\n\t/**\n\t * Execute the actions encapsulated by this executor within the context of a\n\t * particular {@link Lexer}.\n\t *\n\t * <p>This method calls {@link IntStream//seek} to set the position of the\n\t * {@code input} {@link CharStream} prior to calling\n\t * {@link LexerAction//execute} on a position-dependent action. Before the\n\t * method returns, the input position will be restored to the same position\n\t * it was in when the method was invoked.</p>\n\t *\n\t * @param lexer The lexer instance.\n\t * @param input The input stream which is the source for the current token.\n\t * When this method is called, the current {@link IntStream//index} for\n\t * {@code input} should be the start of the following token, i.e. 1\n\t * character past the end of the current token.\n\t * @param startIndex The token start index. This value may be passed to\n\t * {@link IntStream//seek} to set the {@code input} position to the beginning\n\t * of the token.\n\t */\n\texecute(lexer, input, startIndex) {\n\t\tlet requiresSeek = false;\n\t\tconst stopIndex = input.index;\n\t\ttry {\n\t\t\tfor (let i = 0; i < this.lexerActions.length; i++) {\n\t\t\t\tlet lexerAction = this.lexerActions[i];\n\t\t\t\tif (lexerAction instanceof LexerIndexedCustomAction) {\n\t\t\t\t\tconst offset = lexerAction.offset;\n\t\t\t\t\tinput.seek(startIndex + offset);\n\t\t\t\t\tlexerAction = lexerAction.action;\n\t\t\t\t\trequiresSeek = (startIndex + offset) !== stopIndex;\n\t\t\t\t} else if (lexerAction.isPositionDependent) {\n\t\t\t\t\tinput.seek(stopIndex);\n\t\t\t\t\trequiresSeek = false;\n\t\t\t\t}\n\t\t\t\tlexerAction.execute(lexer);\n\t\t\t}\n\t\t} finally {\n\t\t\tif (requiresSeek) {\n\t\t\t\tinput.seek(stopIndex);\n\t\t\t}\n\t\t}\n\t}\n\n\thashCode() {\n\t\treturn this.cachedHashCode;\n\t}\n\n\tupdateHashCode(hash) {\n\t\thash.update(this.cachedHashCode);\n\t}\n\n\tequals(other) {\n\t\tif (this === other) {\n\t\t\treturn true;\n\t\t} else if (!(other instanceof LexerActionExecutor)) {\n\t\t\treturn false;\n\t\t} else if (this.cachedHashCode != other.cachedHashCode) {\n\t\t\treturn false;\n\t\t} else if (this.lexerActions.length != other.lexerActions.length) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\tconst numActions = this.lexerActions.length\n\t\t\tfor (let idx = 0; idx < numActions; ++idx) {\n\t\t\t\tif (!this.lexerActions[idx].equals(other.lexerActions[idx])) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/**\n\t * Creates a {@link LexerActionExecutor} which executes the actions for\n\t * the input {@code lexerActionExecutor} followed by a specified\n\t * {@code lexerAction}.\n\t *\n\t * @param lexerActionExecutor The executor for actions already traversed by\n\t * the lexer while matching a token within a particular\n\t * {@link LexerATNConfig}. If this is {@code null}, the method behaves as\n\t * though it were an empty executor.\n\t * @param lexerAction The lexer action to execute after the actions\n\t * specified in {@code lexerActionExecutor}.\n\t *\n\t * @return {LexerActionExecutor} A {@link LexerActionExecutor} for executing the combine actions\n\t * of {@code lexerActionExecutor} and {@code lexerAction}.\n\t */\n\tstatic append(lexerActionExecutor, lexerAction) {\n\t\tif (lexerActionExecutor === null) {\n\t\t\treturn new LexerActionExecutor([ lexerAction ]);\n\t\t}\n\t\tconst lexerActions = lexerActionExecutor.lexerActions.concat([ lexerAction ]);\n\t\treturn new LexerActionExecutor(lexerActions);\n\t}\n}\n\n\nmodule.exports = LexerActionExecutor;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst Utils = require('./../Utils');\nconst {Set, BitSet, DoubleDict} = Utils;\n\nconst ATN = require('./ATN');\nconst {ATNState, RuleStopState} = require('./ATNState');\n\nconst {ATNConfig} = require('./ATNConfig');\nconst {ATNConfigSet} = require('./ATNConfigSet');\nconst {Token} = require('./../Token');\nconst {DFAState, PredPrediction} = require('./../dfa/DFAState');\nconst ATNSimulator = require('./ATNSimulator');\nconst PredictionMode = require('./PredictionMode');\nconst RuleContext = require('./../RuleContext');\nconst ParserRuleContext = require('./../ParserRuleContext');\nconst {SemanticContext} = require('./SemanticContext');\nconst {PredictionContext} = require('./../PredictionContext');\nconst {Interval} = require('./../IntervalSet');\nconst {Transition, SetTransition, NotSetTransition, RuleTransition, ActionTransition} = require('./Transition');\nconst {NoViableAltException} = require('./../error/Errors');\nconst {SingletonPredictionContext, predictionContextFromRuleContext} = require('./../PredictionContext');\n\n\n/**\n * The embodiment of the adaptive LL(*), ALL(*), parsing strategy.\n *\n * <p>\n * The basic complexity of the adaptive strategy makes it harder to understand.\n * We begin with ATN simulation to build paths in a DFA. Subsequent prediction\n * requests go through the DFA first. If they reach a state without an edge for\n * the current symbol, the algorithm fails over to the ATN simulation to\n * complete the DFA path for the current input (until it finds a conflict state\n * or uniquely predicting state).</p>\n *\n * <p>\n * All of that is done without using the outer context because we want to create\n * a DFA that is not dependent upon the rule invocation stack when we do a\n * prediction. One DFA works in all contexts. We avoid using context not\n * necessarily because it's slower, although it can be, but because of the DFA\n * caching problem. The closure routine only considers the rule invocation stack\n * created during prediction beginning in the decision rule. For example, if\n * prediction occurs without invoking another rule's ATN, there are no context\n * stacks in the configurations. When lack of context leads to a conflict, we\n * don't know if it's an ambiguity or a weakness in the strong LL(*) parsing\n * strategy (versus full LL(*)).</p>\n *\n * <p>\n * When SLL yields a configuration set with conflict, we rewind the input and\n * retry the ATN simulation, this time using full outer context without adding\n * to the DFA. Configuration context stacks will be the full invocation stacks\n * from the start rule. If we get a conflict using full context, then we can\n * definitively say we have a true ambiguity for that input sequence. If we\n * don't get a conflict, it implies that the decision is sensitive to the outer\n * context. (It is not context-sensitive in the sense of context-sensitive\n * grammars.)</p>\n *\n * <p>\n * The next time we reach this DFA state with an SLL conflict, through DFA\n * simulation, we will again retry the ATN simulation using full context mode.\n * This is slow because we can't save the results and have to \"interpret\" the\n * ATN each time we get that input.</p>\n *\n * <p>\n * <strong>CACHING FULL CONTEXT PREDICTIONS</strong></p>\n *\n * <p>\n * We could cache results from full context to predicted alternative easily and\n * that saves a lot of time but doesn't work in presence of predicates. The set\n * of visible predicates from the ATN start state changes depending on the\n * context, because closure can fall off the end of a rule. I tried to cache\n * tuples (stack context, semantic context, predicted alt) but it was slower\n * than interpreting and much more complicated. Also required a huge amount of\n * memory. The goal is not to create the world's fastest parser anyway. I'd like\n * to keep this algorithm simple. By launching multiple threads, we can improve\n * the speed of parsing across a large number of files.</p>\n *\n * <p>\n * There is no strict ordering between the amount of input used by SLL vs LL,\n * which makes it really hard to build a cache for full context. Let's say that\n * we have input A B C that leads to an SLL conflict with full context X. That\n * implies that using X we might only use A B but we could also use A B C D to\n * resolve conflict. Input A B C D could predict alternative 1 in one position\n * in the input and A B C E could predict alternative 2 in another position in\n * input. The conflicting SLL configurations could still be non-unique in the\n * full context prediction, which would lead us to requiring more input than the\n * original A B C.\tTo make a\tprediction cache work, we have to track\tthe exact\n * input\tused during the previous prediction. That amounts to a cache that maps\n * X to a specific DFA for that context.</p>\n *\n * <p>\n * Something should be done for left-recursive expression predictions. They are\n * likely LL(1) + pred eval. Easier to do the whole SLL unless error and retry\n * with full LL thing Sam does.</p>\n *\n * <p>\n * <strong>AVOIDING FULL CONTEXT PREDICTION</strong></p>\n *\n * <p>\n * We avoid doing full context retry when the outer context is empty, we did not\n * dip into the outer context by falling off the end of the decision state rule,\n * or when we force SLL mode.</p>\n *\n * <p>\n * As an example of the not dip into outer context case, consider as super\n * constructor calls versus function calls. One grammar might look like\n * this:</p>\n *\n * <pre>\n * ctorBody\n *   : '{' superCall? stat* '}'\n *   ;\n * </pre>\n *\n * <p>\n * Or, you might see something like</p>\n *\n * <pre>\n * stat\n *   : superCall ';'\n *   | expression ';'\n *   | ...\n *   ;\n * </pre>\n *\n * <p>\n * In both cases I believe that no closure operations will dip into the outer\n * context. In the first case ctorBody in the worst case will stop at the '}'.\n * In the 2nd case it should stop at the ';'. Both cases should stay within the\n * entry rule and not dip into the outer context.</p>\n *\n * <p>\n * <strong>PREDICATES</strong></p>\n *\n * <p>\n * Predicates are always evaluated if present in either SLL or LL both. SLL and\n * LL simulation deals with predicates differently. SLL collects predicates as\n * it performs closure operations like ANTLR v3 did. It delays predicate\n * evaluation until it reaches and accept state. This allows us to cache the SLL\n * ATN simulation whereas, if we had evaluated predicates on-the-fly during\n * closure, the DFA state configuration sets would be different and we couldn't\n * build up a suitable DFA.</p>\n *\n * <p>\n * When building a DFA accept state during ATN simulation, we evaluate any\n * predicates and return the sole semantically valid alternative. If there is\n * more than 1 alternative, we report an ambiguity. If there are 0 alternatives,\n * we throw an exception. Alternatives without predicates act like they have\n * true predicates. The simple way to think about it is to strip away all\n * alternatives with false predicates and choose the minimum alternative that\n * remains.</p>\n *\n * <p>\n * When we start in the DFA and reach an accept state that's predicated, we test\n * those and return the minimum semantically viable alternative. If no\n * alternatives are viable, we throw an exception.</p>\n *\n * <p>\n * During full LL ATN simulation, closure always evaluates predicates and\n * on-the-fly. This is crucial to reducing the configuration set size during\n * closure. It hits a landmine when parsing with the Java grammar, for example,\n * without this on-the-fly evaluation.</p>\n *\n * <p>\n * <strong>SHARING DFA</strong></p>\n *\n * <p>\n * All instances of the same parser share the same decision DFAs through a\n * static field. Each instance gets its own ATN simulator but they share the\n * same {@link //decisionToDFA} field. They also share a\n * {@link PredictionContextCache} object that makes sure that all\n * {@link PredictionContext} objects are shared among the DFA states. This makes\n * a big size difference.</p>\n *\n * <p>\n * <strong>THREAD SAFETY</strong></p>\n *\n * <p>\n * The {@link ParserATNSimulator} locks on the {@link //decisionToDFA} field when\n * it adds a new DFA object to that array. {@link //addDFAEdge}\n * locks on the DFA for the current decision when setting the\n * {@link DFAState//edges} field. {@link //addDFAState} locks on\n * the DFA for the current decision when looking up a DFA state to see if it\n * already exists. We must make sure that all requests to add DFA states that\n * are equivalent result in the same shared DFA object. This is because lots of\n * threads will be trying to update the DFA at once. The\n * {@link //addDFAState} method also locks inside the DFA lock\n * but this time on the shared context cache when it rebuilds the\n * configurations' {@link PredictionContext} objects using cached\n * subgraphs/nodes. No other locking occurs, even during DFA simulation. This is\n * safe as long as we can guarantee that all threads referencing\n * {@code s.edge[t]} get the same physical target {@link DFAState}, or\n * {@code null}. Once into the DFA, the DFA simulation does not reference the\n * {@link DFA//states} map. It follows the {@link DFAState//edges} field to new\n * targets. The DFA simulator will either find {@link DFAState//edges} to be\n * {@code null}, to be non-{@code null} and {@code dfa.edges[t]} null, or\n * {@code dfa.edges[t]} to be non-null. The\n * {@link //addDFAEdge} method could be racing to set the field\n * but in either case the DFA simulator works; if {@code null}, and requests ATN\n * simulation. It could also race trying to get {@code dfa.edges[t]}, but either\n * way it will work because it's not doing a test and set operation.</p>\n *\n * <p>\n * <strong>Starting with SLL then failing to combined SLL/LL (Two-Stage\n * Parsing)</strong></p>\n *\n * <p>\n * Sam pointed out that if SLL does not give a syntax error, then there is no\n * point in doing full LL, which is slower. We only have to try LL if we get a\n * syntax error. For maximum speed, Sam starts the parser set to pure SLL\n * mode with the {@link BailErrorStrategy}:</p>\n *\n * <pre>\n * parser.{@link Parser//getInterpreter() getInterpreter()}.{@link //setPredictionMode setPredictionMode}{@code (}{@link PredictionMode//SLL}{@code )};\n * parser.{@link Parser//setErrorHandler setErrorHandler}(new {@link BailErrorStrategy}());\n * </pre>\n *\n * <p>\n * If it does not get a syntax error, then we're done. If it does get a syntax\n * error, we need to retry with the combined SLL/LL strategy.</p>\n *\n * <p>\n * The reason this works is as follows. If there are no SLL conflicts, then the\n * grammar is SLL (at least for that input set). If there is an SLL conflict,\n * the full LL analysis must yield a set of viable alternatives which is a\n * subset of the alternatives reported by SLL. If the LL set is a singleton,\n * then the grammar is LL but not SLL. If the LL set is the same size as the SLL\n * set, the decision is SLL. If the LL set has size &gt; 1, then that decision\n * is truly ambiguous on the current input. If the LL set is smaller, then the\n * SLL conflict resolution might choose an alternative that the full LL would\n * rule out as a possibility based upon better context information. If that's\n * the case, then the SLL parse will definitely get an error because the full LL\n * analysis says it's not viable. If SLL conflict resolution chooses an\n * alternative within the LL set, them both SLL and LL would choose the same\n * alternative because they both choose the minimum of multiple conflicting\n * alternatives.</p>\n *\n * <p>\n * Let's say we have a set of SLL conflicting alternatives {@code {1, 2, 3}} and\n * a smaller LL set called <em>s</em>. If <em>s</em> is {@code {2, 3}}, then SLL\n * parsing will get an error because SLL will pursue alternative 1. If\n * <em>s</em> is {@code {1, 2}} or {@code {1, 3}} then both SLL and LL will\n * choose the same alternative because alternative one is the minimum of either\n * set. If <em>s</em> is {@code {2}} or {@code {3}} then SLL will get a syntax\n * error. If <em>s</em> is {@code {1}} then SLL will succeed.</p>\n *\n * <p>\n * Of course, if the input is invalid, then we will get an error for sure in\n * both SLL and LL parsing. Erroneous input will therefore require 2 passes over\n * the input.</p>\n */\nclass ParserATNSimulator extends ATNSimulator {\n    constructor(parser, atn, decisionToDFA, sharedContextCache) {\n        super(atn, sharedContextCache);\n        this.parser = parser;\n        this.decisionToDFA = decisionToDFA;\n        // SLL, LL, or LL + exact ambig detection?//\n        this.predictionMode = PredictionMode.LL;\n        // LAME globals to avoid parameters!!!!! I need these down deep in predTransition\n        this._input = null;\n        this._startIndex = 0;\n        this._outerContext = null;\n        this._dfa = null;\n        /**\n         * Each prediction operation uses a cache for merge of prediction contexts.\n         *  Don't keep around as it wastes huge amounts of memory. DoubleKeyMap\n         *  isn't synchronized but we're ok since two threads shouldn't reuse same\n         *  parser/atnsim object because it can only handle one input at a time.\n         *  This maps graphs a and b to merged result c. (a,b)&rarr;c. We can avoid\n         *  the merge if we ever see a and b again.  Note that (b,a)&rarr;c should\n         *  also be examined during cache lookup.\n         */\n        this.mergeCache = null;\n        this.debug = false;\n        this.debug_closure = false;\n        this.debug_add = false;\n        this.debug_list_atn_decisions = false;\n        this.dfa_debug = false;\n        this.retry_debug = false;\n    }\n\n    reset() {}\n\n    adaptivePredict(input, decision, outerContext) {\n        if (this.debug || this.debug_list_atn_decisions) {\n            console.log(\"adaptivePredict decision \" + decision +\n                                   \" exec LA(1)==\" + this.getLookaheadName(input) +\n                                   \" line \" + input.LT(1).line + \":\" +\n                                   input.LT(1).column);\n        }\n        this._input = input;\n        this._startIndex = input.index;\n        this._outerContext = outerContext;\n\n        const dfa = this.decisionToDFA[decision];\n        this._dfa = dfa;\n        const m = input.mark();\n        const index = input.index;\n\n        // Now we are certain to have a specific decision's DFA\n        // But, do we still need an initial state?\n        try {\n            let s0;\n            if (dfa.precedenceDfa) {\n                // the start state for a precedence DFA depends on the current\n                // parser precedence, and is provided by a DFA method.\n                s0 = dfa.getPrecedenceStartState(this.parser.getPrecedence());\n            } else {\n                // the start state for a \"regular\" DFA is just s0\n                s0 = dfa.s0;\n            }\n            if (s0===null) {\n                if (outerContext===null) {\n                    outerContext = RuleContext.EMPTY;\n                }\n                if (this.debug || this.debug_list_atn_decisions) {\n                    console.log(\"predictATN decision \" + dfa.decision +\n                                       \" exec LA(1)==\" + this.getLookaheadName(input) +\n                                       \", outerContext=\" + outerContext.toString(this.parser.ruleNames));\n                }\n\n                const fullCtx = false;\n                let s0_closure = this.computeStartState(dfa.atnStartState, RuleContext.EMPTY, fullCtx);\n\n                if( dfa.precedenceDfa) {\n                    // If this is a precedence DFA, we use applyPrecedenceFilter\n                    // to convert the computed start state to a precedence start\n                    // state. We then use DFA.setPrecedenceStartState to set the\n                    // appropriate start state for the precedence level rather\n                    // than simply setting DFA.s0.\n                    //\n                    dfa.s0.configs = s0_closure; // not used for prediction but useful to know start configs anyway\n                    s0_closure = this.applyPrecedenceFilter(s0_closure);\n                    s0 = this.addDFAState(dfa, new DFAState(null, s0_closure));\n                    dfa.setPrecedenceStartState(this.parser.getPrecedence(), s0);\n                } else {\n                    s0 = this.addDFAState(dfa, new DFAState(null, s0_closure));\n                    dfa.s0 = s0;\n                }\n            }\n            const alt = this.execATN(dfa, s0, input, index, outerContext);\n            if (this.debug) {\n                console.log(\"DFA after predictATN: \" + dfa.toString(this.parser.literalNames, this.parser.symbolicNames));\n            }\n            return alt;\n        } finally {\n            this._dfa = null;\n            this.mergeCache = null; // wack cache after each prediction\n            input.seek(index);\n            input.release(m);\n        }\n    }\n\n    /**\n     * Performs ATN simulation to compute a predicted alternative based\n     *  upon the remaining input, but also updates the DFA cache to avoid\n     *  having to traverse the ATN again for the same input sequence.\n     *\n     * There are some key conditions we're looking for after computing a new\n     * set of ATN configs (proposed DFA state):\n     *       if the set is empty, there is no viable alternative for current symbol\n     *       does the state uniquely predict an alternative?\n     *       does the state have a conflict that would prevent us from\n     *         putting it on the work list?\n     *\n     * We also have some key operations to do:\n     *       add an edge from previous DFA state to potentially new DFA state, D,\n     *         upon current symbol but only if adding to work list, which means in all\n     *         cases except no viable alternative (and possibly non-greedy decisions?)\n     *       collecting predicates and adding semantic context to DFA accept states\n     *       adding rule context to context-sensitive DFA accept states\n     *       consuming an input symbol\n     *       reporting a conflict\n     *       reporting an ambiguity\n     *       reporting a context sensitivity\n     *       reporting insufficient predicates\n     *\n     * cover these cases:\n     *    dead end\n     *    single alt\n     *    single alt + preds\n     *    conflict\n     *    conflict + preds\n     *\n     */\n    execATN(dfa, s0, input, startIndex, outerContext ) {\n        if (this.debug || this.debug_list_atn_decisions) {\n            console.log(\"execATN decision \" + dfa.decision +\n                    \" exec LA(1)==\" + this.getLookaheadName(input) +\n                    \" line \" + input.LT(1).line + \":\" + input.LT(1).column);\n        }\n        let alt;\n        let previousD = s0;\n\n        if (this.debug) {\n            console.log(\"s0 = \" + s0);\n        }\n        let t = input.LA(1);\n        while(true) { // while more work\n            let D = this.getExistingTargetState(previousD, t);\n            if(D===null) {\n                D = this.computeTargetState(dfa, previousD, t);\n            }\n            if(D===ATNSimulator.ERROR) {\n                // if any configs in previous dipped into outer context, that\n                // means that input up to t actually finished entry rule\n                // at least for SLL decision. Full LL doesn't dip into outer\n                // so don't need special case.\n                // We will get an error no matter what so delay until after\n                // decision; better error message. Also, no reachable target\n                // ATN states in SLL implies LL will also get nowhere.\n                // If conflict in states that dip out, choose min since we\n                // will get error no matter what.\n                const e = this.noViableAlt(input, outerContext, previousD.configs, startIndex);\n                input.seek(startIndex);\n                alt = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(previousD.configs, outerContext);\n                if(alt!==ATN.INVALID_ALT_NUMBER) {\n                    return alt;\n                } else {\n                    throw e;\n                }\n            }\n            if(D.requiresFullContext && this.predictionMode !== PredictionMode.SLL) {\n                // IF PREDS, MIGHT RESOLVE TO SINGLE ALT => SLL (or syntax error)\n                let conflictingAlts = null;\n                if (D.predicates!==null) {\n                    if (this.debug) {\n                        console.log(\"DFA state has preds in DFA sim LL failover\");\n                    }\n                    const conflictIndex = input.index;\n                    if(conflictIndex !== startIndex) {\n                        input.seek(startIndex);\n                    }\n                    conflictingAlts = this.evalSemanticContext(D.predicates, outerContext, true);\n                    if (conflictingAlts.length===1) {\n                        if(this.debug) {\n                            console.log(\"Full LL avoided\");\n                        }\n                        return conflictingAlts.minValue();\n                    }\n                    if (conflictIndex !== startIndex) {\n                        // restore the index so reporting the fallback to full\n                        // context occurs with the index at the correct spot\n                        input.seek(conflictIndex);\n                    }\n                }\n                if (this.dfa_debug) {\n                    console.log(\"ctx sensitive state \" + outerContext +\" in \" + D);\n                }\n                const fullCtx = true;\n                const s0_closure = this.computeStartState(dfa.atnStartState, outerContext, fullCtx);\n                this.reportAttemptingFullContext(dfa, conflictingAlts, D.configs, startIndex, input.index);\n                alt = this.execATNWithFullContext(dfa, D, s0_closure, input, startIndex, outerContext);\n                return alt;\n            }\n            if (D.isAcceptState) {\n                if (D.predicates===null) {\n                    return D.prediction;\n                }\n                const stopIndex = input.index;\n                input.seek(startIndex);\n                const alts = this.evalSemanticContext(D.predicates, outerContext, true);\n                if (alts.length===0) {\n                    throw this.noViableAlt(input, outerContext, D.configs, startIndex);\n                } else if (alts.length===1) {\n                    return alts.minValue();\n                } else {\n                    // report ambiguity after predicate evaluation to make sure the correct set of ambig alts is reported.\n                    this.reportAmbiguity(dfa, D, startIndex, stopIndex, false, alts, D.configs);\n                    return alts.minValue();\n                }\n            }\n            previousD = D;\n\n            if (t !== Token.EOF) {\n                input.consume();\n                t = input.LA(1);\n            }\n        }\n    }\n\n    /**\n     * Get an existing target state for an edge in the DFA. If the target state\n     * for the edge has not yet been computed or is otherwise not available,\n     * this method returns {@code null}.\n     *\n     * @param previousD The current DFA state\n     * @param t The next input symbol\n     * @return The existing target DFA state for the given input symbol\n     * {@code t}, or {@code null} if the target state for this edge is not\n     * already cached\n     */\n    getExistingTargetState(previousD, t) {\n        const edges = previousD.edges;\n        if (edges===null) {\n            return null;\n        } else {\n            return edges[t + 1] || null;\n        }\n    }\n\n    /**\n     * Compute a target state for an edge in the DFA, and attempt to add the\n     * computed state and corresponding edge to the DFA.\n     *\n     * @param dfa The DFA\n     * @param previousD The current DFA state\n     * @param t The next input symbol\n     *\n     * @return The computed target DFA state for the given input symbol\n     * {@code t}. If {@code t} does not lead to a valid DFA state, this method\n     * returns {@link //ERROR\n     */\n    computeTargetState(dfa, previousD, t) {\n       const reach = this.computeReachSet(previousD.configs, t, false);\n        if(reach===null) {\n            this.addDFAEdge(dfa, previousD, t, ATNSimulator.ERROR);\n            return ATNSimulator.ERROR;\n        }\n        // create new target state; we'll add to DFA after it's complete\n        let D = new DFAState(null, reach);\n\n        const predictedAlt = this.getUniqueAlt(reach);\n\n        if (this.debug) {\n            const altSubSets = PredictionMode.getConflictingAltSubsets(reach);\n            console.log(\"SLL altSubSets=\" + Utils.arrayToString(altSubSets) +\n                        /*\", previous=\" + previousD.configs + */\n                        \", configs=\" + reach +\n                        \", predict=\" + predictedAlt +\n                        \", allSubsetsConflict=\" +\n                        PredictionMode.allSubsetsConflict(altSubSets) + \", conflictingAlts=\" +\n                        this.getConflictingAlts(reach));\n        }\n        if (predictedAlt!==ATN.INVALID_ALT_NUMBER) {\n            // NO CONFLICT, UNIQUELY PREDICTED ALT\n            D.isAcceptState = true;\n            D.configs.uniqueAlt = predictedAlt;\n            D.prediction = predictedAlt;\n        } else if (PredictionMode.hasSLLConflictTerminatingPrediction(this.predictionMode, reach)) {\n            // MORE THAN ONE VIABLE ALTERNATIVE\n            D.configs.conflictingAlts = this.getConflictingAlts(reach);\n            D.requiresFullContext = true;\n            // in SLL-only mode, we will stop at this state and return the minimum alt\n            D.isAcceptState = true;\n            D.prediction = D.configs.conflictingAlts.minValue();\n        }\n        if (D.isAcceptState && D.configs.hasSemanticContext) {\n            this.predicateDFAState(D, this.atn.getDecisionState(dfa.decision));\n            if( D.predicates!==null) {\n                D.prediction = ATN.INVALID_ALT_NUMBER;\n            }\n        }\n        // all adds to dfa are done after we've created full D state\n        D = this.addDFAEdge(dfa, previousD, t, D);\n        return D;\n    }\n\n    predicateDFAState(dfaState, decisionState) {\n        // We need to test all predicates, even in DFA states that\n        // uniquely predict alternative.\n        const nalts = decisionState.transitions.length;\n        // Update DFA so reach becomes accept state with (predicate,alt)\n        // pairs if preds found for conflicting alts\n        const altsToCollectPredsFrom = this.getConflictingAltsOrUniqueAlt(dfaState.configs);\n        const altToPred = this.getPredsForAmbigAlts(altsToCollectPredsFrom, dfaState.configs, nalts);\n        if (altToPred!==null) {\n            dfaState.predicates = this.getPredicatePredictions(altsToCollectPredsFrom, altToPred);\n            dfaState.prediction = ATN.INVALID_ALT_NUMBER; // make sure we use preds\n        } else {\n            // There are preds in configs but they might go away\n            // when OR'd together like {p}? || NONE == NONE. If neither\n            // alt has preds, resolve to min alt\n            dfaState.prediction = altsToCollectPredsFrom.minValue();\n        }\n    }\n\n// comes back with reach.uniqueAlt set to a valid alt\n    execATNWithFullContext(dfa, D, // how far we got before failing over\n                                         s0,\n                                         input,\n                                         startIndex,\n                                         outerContext) {\n        if (this.debug || this.debug_list_atn_decisions) {\n            console.log(\"execATNWithFullContext \"+s0);\n        }\n        const fullCtx = true;\n        let foundExactAmbig = false;\n        let reach;\n        let previous = s0;\n        input.seek(startIndex);\n        let t = input.LA(1);\n        let predictedAlt = -1;\n        while (true) { // while more work\n            reach = this.computeReachSet(previous, t, fullCtx);\n            if (reach===null) {\n                // if any configs in previous dipped into outer context, that\n                // means that input up to t actually finished entry rule\n                // at least for LL decision. Full LL doesn't dip into outer\n                // so don't need special case.\n                // We will get an error no matter what so delay until after\n                // decision; better error message. Also, no reachable target\n                // ATN states in SLL implies LL will also get nowhere.\n                // If conflict in states that dip out, choose min since we\n                // will get error no matter what.\n                const e = this.noViableAlt(input, outerContext, previous, startIndex);\n                input.seek(startIndex);\n                const alt = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(previous, outerContext);\n                if(alt!==ATN.INVALID_ALT_NUMBER) {\n                    return alt;\n                } else {\n                    throw e;\n                }\n            }\n            const altSubSets = PredictionMode.getConflictingAltSubsets(reach);\n            if(this.debug) {\n                console.log(\"LL altSubSets=\" + altSubSets + \", predict=\" +\n                      PredictionMode.getUniqueAlt(altSubSets) + \", resolvesToJustOneViableAlt=\" +\n                      PredictionMode.resolvesToJustOneViableAlt(altSubSets));\n            }\n            reach.uniqueAlt = this.getUniqueAlt(reach);\n            // unique prediction?\n            if(reach.uniqueAlt!==ATN.INVALID_ALT_NUMBER) {\n                predictedAlt = reach.uniqueAlt;\n                break;\n            } else if (this.predictionMode !== PredictionMode.LL_EXACT_AMBIG_DETECTION) {\n                predictedAlt = PredictionMode.resolvesToJustOneViableAlt(altSubSets);\n                if(predictedAlt !== ATN.INVALID_ALT_NUMBER) {\n                    break;\n                }\n            } else {\n                // In exact ambiguity mode, we never try to terminate early.\n                // Just keeps scarfing until we know what the conflict is\n                if (PredictionMode.allSubsetsConflict(altSubSets) && PredictionMode.allSubsetsEqual(altSubSets)) {\n                    foundExactAmbig = true;\n                    predictedAlt = PredictionMode.getSingleViableAlt(altSubSets);\n                    break;\n                }\n                // else there are multiple non-conflicting subsets or\n                // we're not sure what the ambiguity is yet.\n                // So, keep going.\n            }\n            previous = reach;\n            if( t !== Token.EOF) {\n                input.consume();\n                t = input.LA(1);\n            }\n        }\n        // If the configuration set uniquely predicts an alternative,\n        // without conflict, then we know that it's a full LL decision\n        // not SLL.\n        if (reach.uniqueAlt !== ATN.INVALID_ALT_NUMBER ) {\n            this.reportContextSensitivity(dfa, predictedAlt, reach, startIndex, input.index);\n            return predictedAlt;\n        }\n        // We do not check predicates here because we have checked them\n        // on-the-fly when doing full context prediction.\n\n        //\n        // In non-exact ambiguity detection mode, we might\tactually be able to\n        // detect an exact ambiguity, but I'm not going to spend the cycles\n        // needed to check. We only emit ambiguity warnings in exact ambiguity\n        // mode.\n        //\n        // For example, we might know that we have conflicting configurations.\n        // But, that does not mean that there is no way forward without a\n        // conflict. It's possible to have nonconflicting alt subsets as in:\n\n        // altSubSets=[{1, 2}, {1, 2}, {1}, {1, 2}]\n\n        // from\n        //\n        //    [(17,1,[5 $]), (13,1,[5 10 $]), (21,1,[5 10 $]), (11,1,[$]),\n        //     (13,2,[5 10 $]), (21,2,[5 10 $]), (11,2,[$])]\n        //\n        // In this case, (17,1,[5 $]) indicates there is some next sequence that\n        // would resolve this without conflict to alternative 1. Any other viable\n        // next sequence, however, is associated with a conflict.  We stop\n        // looking for input because no amount of further lookahead will alter\n        // the fact that we should predict alternative 1.  We just can't say for\n        // sure that there is an ambiguity without looking further.\n\n        this.reportAmbiguity(dfa, D, startIndex, input.index, foundExactAmbig, null, reach);\n\n        return predictedAlt;\n    }\n\n    computeReachSet(closure, t, fullCtx) {\n        if (this.debug) {\n            console.log(\"in computeReachSet, starting closure: \" + closure);\n        }\n        if( this.mergeCache===null) {\n            this.mergeCache = new DoubleDict();\n        }\n        const intermediate = new ATNConfigSet(fullCtx);\n\n        // Configurations already in a rule stop state indicate reaching the end\n        // of the decision rule (local context) or end of the start rule (full\n        // context). Once reached, these configurations are never updated by a\n        // closure operation, so they are handled separately for the performance\n        // advantage of having a smaller intermediate set when calling closure.\n        //\n        // For full-context reach operations, separate handling is required to\n        // ensure that the alternative matching the longest overall sequence is\n        // chosen when multiple such configurations can match the input.\n\n        let skippedStopStates = null;\n\n        // First figure out where we can reach on input t\n        for (let i=0; i<closure.items.length;i++) {\n            const c = closure.items[i];\n            if(this.debug) {\n                console.log(\"testing \" + this.getTokenName(t) + \" at \" + c);\n            }\n            if (c.state instanceof RuleStopState) {\n                if (fullCtx || t === Token.EOF) {\n                    if (skippedStopStates===null) {\n                        skippedStopStates = [];\n                    }\n                    skippedStopStates.push(c);\n                    if(this.debug_add) {\n                        console.log(\"added \" + c + \" to skippedStopStates\");\n                    }\n                }\n                continue;\n            }\n            for(let j=0;j<c.state.transitions.length;j++) {\n                const trans = c.state.transitions[j];\n                const target = this.getReachableTarget(trans, t);\n                if (target!==null) {\n                    const cfg = new ATNConfig({state:target}, c);\n                    intermediate.add(cfg, this.mergeCache);\n                    if(this.debug_add) {\n                        console.log(\"added \" + cfg + \" to intermediate\");\n                    }\n                }\n            }\n        }\n        // Now figure out where the reach operation can take us...\n        let reach = null;\n\n        // This block optimizes the reach operation for intermediate sets which\n        // trivially indicate a termination state for the overall\n        // adaptivePredict operation.\n        //\n        // The conditions assume that intermediate\n        // contains all configurations relevant to the reach set, but this\n        // condition is not true when one or more configurations have been\n        // withheld in skippedStopStates, or when the current symbol is EOF.\n        //\n        if (skippedStopStates===null && t!==Token.EOF) {\n            if (intermediate.items.length===1) {\n                // Don't pursue the closure if there is just one state.\n                // It can only have one alternative; just add to result\n                // Also don't pursue the closure if there is unique alternative\n                // among the configurations.\n                reach = intermediate;\n            } else if (this.getUniqueAlt(intermediate)!==ATN.INVALID_ALT_NUMBER) {\n                // Also don't pursue the closure if there is unique alternative\n                // among the configurations.\n                reach = intermediate;\n            }\n        }\n        // If the reach set could not be trivially determined, perform a closure\n        // operation on the intermediate set to compute its initial value.\n        //\n        if (reach===null) {\n            reach = new ATNConfigSet(fullCtx);\n            const closureBusy = new Set();\n            const treatEofAsEpsilon = t === Token.EOF;\n            for (let k=0; k<intermediate.items.length;k++) {\n                this.closure(intermediate.items[k], reach, closureBusy, false, fullCtx, treatEofAsEpsilon);\n            }\n        }\n        if (t === Token.EOF) {\n            // After consuming EOF no additional input is possible, so we are\n            // only interested in configurations which reached the end of the\n            // decision rule (local context) or end of the start rule (full\n            // context). Update reach to contain only these configurations. This\n            // handles both explicit EOF transitions in the grammar and implicit\n            // EOF transitions following the end of the decision or start rule.\n            //\n            // When reach==intermediate, no closure operation was performed. In\n            // this case, removeAllConfigsNotInRuleStopState needs to check for\n            // reachable rule stop states as well as configurations already in\n            // a rule stop state.\n            //\n            // This is handled before the configurations in skippedStopStates,\n            // because any configurations potentially added from that list are\n            // already guaranteed to meet this condition whether or not it's\n            // required.\n            //\n            reach = this.removeAllConfigsNotInRuleStopState(reach, reach === intermediate);\n        }\n        // If skippedStopStates!==null, then it contains at least one\n        // configuration. For full-context reach operations, these\n        // configurations reached the end of the start rule, in which case we\n        // only add them back to reach if no configuration during the current\n        // closure operation reached such a state. This ensures adaptivePredict\n        // chooses an alternative matching the longest overall sequence when\n        // multiple alternatives are viable.\n        //\n        if (skippedStopStates!==null && ( (! fullCtx) || (! PredictionMode.hasConfigInRuleStopState(reach)))) {\n            for (let l=0; l<skippedStopStates.length;l++) {\n                reach.add(skippedStopStates[l], this.mergeCache);\n            }\n        }\n        if (reach.items.length===0) {\n            return null;\n        } else {\n            return reach;\n        }\n    }\n\n    /**\n     * Return a configuration set containing only the configurations from\n     * {@code configs} which are in a {@link RuleStopState}. If all\n     * configurations in {@code configs} are already in a rule stop state, this\n     * method simply returns {@code configs}.\n     *\n     * <p>When {@code lookToEndOfRule} is true, this method uses\n     * {@link ATN//nextTokens} for each configuration in {@code configs} which is\n     * not already in a rule stop state to see if a rule stop state is reachable\n     * from the configuration via epsilon-only transitions.</p>\n     *\n     * @param configs the configuration set to update\n     * @param lookToEndOfRule when true, this method checks for rule stop states\n     * reachable by epsilon-only transitions from each configuration in\n     * {@code configs}.\n     *\n     * @return {@code configs} if all configurations in {@code configs} are in a\n     * rule stop state, otherwise return a new configuration set containing only\n     * the configurations from {@code configs} which are in a rule stop state\n     */\n    removeAllConfigsNotInRuleStopState(configs, lookToEndOfRule) {\n        if (PredictionMode.allConfigsInRuleStopStates(configs)) {\n            return configs;\n        }\n        const result = new ATNConfigSet(configs.fullCtx);\n        for(let i=0; i<configs.items.length;i++) {\n            const config = configs.items[i];\n            if (config.state instanceof RuleStopState) {\n                result.add(config, this.mergeCache);\n                continue;\n            }\n            if (lookToEndOfRule && config.state.epsilonOnlyTransitions) {\n                const nextTokens = this.atn.nextTokens(config.state);\n                if (nextTokens.contains(Token.EPSILON)) {\n                    const endOfRuleState = this.atn.ruleToStopState[config.state.ruleIndex];\n                    result.add(new ATNConfig({state:endOfRuleState}, config), this.mergeCache);\n                }\n            }\n        }\n        return result;\n    }\n\n    computeStartState(p, ctx, fullCtx) {\n        // always at least the implicit call to start rule\n        const initialContext = predictionContextFromRuleContext(this.atn, ctx);\n        const configs = new ATNConfigSet(fullCtx);\n        for(let i=0;i<p.transitions.length;i++) {\n            const target = p.transitions[i].target;\n            const c = new ATNConfig({ state:target, alt:i+1, context:initialContext }, null);\n            const closureBusy = new Set();\n            this.closure(c, configs, closureBusy, true, fullCtx, false);\n        }\n        return configs;\n    }\n\n    /**\n     * This method transforms the start state computed by\n     * {@link //computeStartState} to the special start state used by a\n     * precedence DFA for a particular precedence value. The transformation\n     * process applies the following changes to the start state's configuration\n     * set.\n     *\n     * <ol>\n     * <li>Evaluate the precedence predicates for each configuration using\n     * {@link SemanticContext//evalPrecedence}.</li>\n     * <li>Remove all configurations which predict an alternative greater than\n     * 1, for which another configuration that predicts alternative 1 is in the\n     * same ATN state with the same prediction context. This transformation is\n     * valid for the following reasons:\n     * <ul>\n     * <li>The closure block cannot contain any epsilon transitions which bypass\n     * the body of the closure, so all states reachable via alternative 1 are\n     * part of the precedence alternatives of the transformed left-recursive\n     * rule.</li>\n     * <li>The \"primary\" portion of a left recursive rule cannot contain an\n     * epsilon transition, so the only way an alternative other than 1 can exist\n     * in a state that is also reachable via alternative 1 is by nesting calls\n     * to the left-recursive rule, with the outer calls not being at the\n     * preferred precedence level.</li>\n     * </ul>\n     * </li>\n     * </ol>\n     *\n     * <p>\n     * The prediction context must be considered by this filter to address\n     * situations like the following.\n     * </p>\n     * <code>\n     * <pre>\n     * grammar TA;\n     * prog: statement* EOF;\n     * statement: letterA | statement letterA 'b' ;\n     * letterA: 'a';\n     * </pre>\n     * </code>\n     * <p>\n     * If the above grammar, the ATN state immediately before the token\n     * reference {@code 'a'} in {@code letterA} is reachable from the left edge\n     * of both the primary and closure blocks of the left-recursive rule\n     * {@code statement}. The prediction context associated with each of these\n     * configurations distinguishes between them, and prevents the alternative\n     * which stepped out to {@code prog} (and then back in to {@code statement}\n     * from being eliminated by the filter.\n     * </p>\n     *\n     * @param configs The configuration set computed by\n     * {@link //computeStartState} as the start state for the DFA.\n     * @return The transformed configuration set representing the start state\n     * for a precedence DFA at a particular precedence level (determined by\n     * calling {@link Parser//getPrecedence})\n     */\n    applyPrecedenceFilter(configs) {\n        let config;\n        const statesFromAlt1 = [];\n        const configSet = new ATNConfigSet(configs.fullCtx);\n        for(let i=0; i<configs.items.length; i++) {\n            config = configs.items[i];\n            // handle alt 1 first\n            if (config.alt !== 1) {\n                continue;\n            }\n            const updatedContext = config.semanticContext.evalPrecedence(this.parser, this._outerContext);\n            if (updatedContext===null) {\n                // the configuration was eliminated\n                continue;\n            }\n            statesFromAlt1[config.state.stateNumber] = config.context;\n            if (updatedContext !== config.semanticContext) {\n                configSet.add(new ATNConfig({semanticContext:updatedContext}, config), this.mergeCache);\n            } else {\n                configSet.add(config, this.mergeCache);\n            }\n        }\n        for(let i=0; i<configs.items.length; i++) {\n            config = configs.items[i];\n            if (config.alt === 1) {\n                // already handled\n                continue;\n            }\n            // In the future, this elimination step could be updated to also\n            // filter the prediction context for alternatives predicting alt>1\n            // (basically a graph subtraction algorithm).\n            if (!config.precedenceFilterSuppressed) {\n                const context = statesFromAlt1[config.state.stateNumber] || null;\n                if (context!==null && context.equals(config.context)) {\n                    // eliminated\n                    continue;\n                }\n            }\n            configSet.add(config, this.mergeCache);\n        }\n        return configSet;\n    }\n\n    getReachableTarget(trans, ttype) {\n        if (trans.matches(ttype, 0, this.atn.maxTokenType)) {\n            return trans.target;\n        } else {\n            return null;\n        }\n    }\n\n    getPredsForAmbigAlts(ambigAlts, configs, nalts) {\n        // REACH=[1|1|[]|0:0, 1|2|[]|0:1]\n        // altToPred starts as an array of all null contexts. The entry at index i\n        // corresponds to alternative i. altToPred[i] may have one of three values:\n        //   1. null: no ATNConfig c is found such that c.alt==i\n        //   2. SemanticContext.NONE: At least one ATNConfig c exists such that\n        //      c.alt==i and c.semanticContext==SemanticContext.NONE. In other words,\n        //      alt i has at least one unpredicated config.\n        //   3. Non-NONE Semantic Context: There exists at least one, and for all\n        //      ATNConfig c such that c.alt==i, c.semanticContext!=SemanticContext.NONE.\n        //\n        // From this, it is clear that NONE||anything==NONE.\n        //\n        let altToPred = [];\n        for(let i=0;i<configs.items.length;i++) {\n            const c = configs.items[i];\n            if(ambigAlts.contains( c.alt )) {\n                altToPred[c.alt] = SemanticContext.orContext(altToPred[c.alt] || null, c.semanticContext);\n            }\n        }\n        let nPredAlts = 0;\n        for (let i =1;i< nalts+1;i++) {\n            const pred = altToPred[i] || null;\n            if (pred===null) {\n                altToPred[i] = SemanticContext.NONE;\n            } else if (pred !== SemanticContext.NONE) {\n                nPredAlts += 1;\n            }\n        }\n        // nonambig alts are null in altToPred\n        if (nPredAlts===0) {\n            altToPred = null;\n        }\n        if (this.debug) {\n            console.log(\"getPredsForAmbigAlts result \" + Utils.arrayToString(altToPred));\n        }\n        return altToPred;\n    }\n\n    getPredicatePredictions(ambigAlts, altToPred) {\n        const pairs = [];\n        let containsPredicate = false;\n        for (let i=1; i<altToPred.length;i++) {\n            const pred = altToPred[i];\n            // unpredicated is indicated by SemanticContext.NONE\n            if( ambigAlts!==null && ambigAlts.contains( i )) {\n                pairs.push(new PredPrediction(pred, i));\n            }\n            if (pred !== SemanticContext.NONE) {\n                containsPredicate = true;\n            }\n        }\n        if (! containsPredicate) {\n            return null;\n        }\n        return pairs;\n    }\n\n    /**\n     * This method is used to improve the localization of error messages by\n     * choosing an alternative rather than throwing a\n     * {@link NoViableAltException} in particular prediction scenarios where the\n     * {@link //ERROR} state was reached during ATN simulation.\n     *\n     * <p>\n     * The default implementation of this method uses the following\n     * algorithm to identify an ATN configuration which successfully parsed the\n     * decision entry rule. Choosing such an alternative ensures that the\n     * {@link ParserRuleContext} returned by the calling rule will be complete\n     * and valid, and the syntax error will be reported later at a more\n     * localized location.</p>\n     *\n     * <ul>\n     * <li>If a syntactically valid path or paths reach the end of the decision rule and\n     * they are semantically valid if predicated, return the min associated alt.</li>\n     * <li>Else, if a semantically invalid but syntactically valid path exist\n     * or paths exist, return the minimum associated alt.\n     * </li>\n     * <li>Otherwise, return {@link ATN//INVALID_ALT_NUMBER}.</li>\n     * </ul>\n     *\n     * <p>\n     * In some scenarios, the algorithm described above could predict an\n     * alternative which will result in a {@link FailedPredicateException} in\n     * the parser. Specifically, this could occur if the <em>only</em> configuration\n     * capable of successfully parsing to the end of the decision rule is\n     * blocked by a semantic predicate. By choosing this alternative within\n     * {@link //adaptivePredict} instead of throwing a\n     * {@link NoViableAltException}, the resulting\n     * {@link FailedPredicateException} in the parser will identify the specific\n     * predicate which is preventing the parser from successfully parsing the\n     * decision rule, which helps developers identify and correct logic errors\n     * in semantic predicates.\n     * </p>\n     *\n     * @param configs The ATN configurations which were valid immediately before\n     * the {@link //ERROR} state was reached\n     * @param outerContext The is the \\gamma_0 initial parser context from the paper\n     * or the parser stack at the instant before prediction commences.\n     *\n     * @return The value to return from {@link //adaptivePredict}, or\n     * {@link ATN//INVALID_ALT_NUMBER} if a suitable alternative was not\n     * identified and {@link //adaptivePredict} should report an error instead\n     */\n    getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(configs, outerContext) {\n        const cfgs = this.splitAccordingToSemanticValidity(configs, outerContext);\n        const semValidConfigs = cfgs[0];\n        const semInvalidConfigs = cfgs[1];\n        let alt = this.getAltThatFinishedDecisionEntryRule(semValidConfigs);\n        if (alt!==ATN.INVALID_ALT_NUMBER) { // semantically/syntactically viable path exists\n            return alt;\n        }\n        // Is there a syntactically valid path with a failed pred?\n        if (semInvalidConfigs.items.length>0) {\n            alt = this.getAltThatFinishedDecisionEntryRule(semInvalidConfigs);\n            if (alt!==ATN.INVALID_ALT_NUMBER) { // syntactically viable path exists\n                return alt;\n            }\n        }\n        return ATN.INVALID_ALT_NUMBER;\n    }\n\n    getAltThatFinishedDecisionEntryRule(configs) {\n        const alts = [];\n        for(let i=0;i<configs.items.length; i++) {\n            const c = configs.items[i];\n            if (c.reachesIntoOuterContext>0 || ((c.state instanceof RuleStopState) && c.context.hasEmptyPath())) {\n                if(alts.indexOf(c.alt)<0) {\n                    alts.push(c.alt);\n                }\n            }\n        }\n        if (alts.length===0) {\n            return ATN.INVALID_ALT_NUMBER;\n        } else {\n            return Math.min.apply(null, alts);\n        }\n    }\n\n    /**\n     * Walk the list of configurations and split them according to\n     * those that have preds evaluating to true/false.  If no pred, assume\n     * true pred and include in succeeded set.  Returns Pair of sets.\n     *\n     * Create a new set so as not to alter the incoming parameter.\n     *\n     * Assumption: the input stream has been restored to the starting point\n     * prediction, which is where predicates need to evaluate.*/\n    splitAccordingToSemanticValidity( configs, outerContext) {\n        const succeeded = new ATNConfigSet(configs.fullCtx);\n        const failed = new ATNConfigSet(configs.fullCtx);\n        for(let i=0;i<configs.items.length; i++) {\n            const c = configs.items[i];\n            if (c.semanticContext !== SemanticContext.NONE) {\n                const predicateEvaluationResult = c.semanticContext.evaluate(this.parser, outerContext);\n                if (predicateEvaluationResult) {\n                    succeeded.add(c);\n                } else {\n                    failed.add(c);\n                }\n            } else {\n                succeeded.add(c);\n            }\n        }\n        return [succeeded, failed];\n    }\n\n    /**\n     * Look through a list of predicate/alt pairs, returning alts for the\n     * pairs that win. A {@code NONE} predicate indicates an alt containing an\n     * unpredicated config which behaves as \"always true.\" If !complete\n     * then we stop at the first predicate that evaluates to true. This\n     * includes pairs with null predicates.\n     */\n    evalSemanticContext(predPredictions, outerContext, complete) {\n        const predictions = new BitSet();\n        for(let i=0;i<predPredictions.length;i++) {\n            const pair = predPredictions[i];\n            if (pair.pred === SemanticContext.NONE) {\n                predictions.add(pair.alt);\n                if (! complete) {\n                    break;\n                }\n                continue;\n            }\n            const predicateEvaluationResult = pair.pred.evaluate(this.parser, outerContext);\n            if (this.debug || this.dfa_debug) {\n                console.log(\"eval pred \" + pair + \"=\" + predicateEvaluationResult);\n            }\n            if (predicateEvaluationResult) {\n                if (this.debug || this.dfa_debug) {\n                    console.log(\"PREDICT \" + pair.alt);\n                }\n                predictions.add(pair.alt);\n                if (! complete) {\n                    break;\n                }\n            }\n        }\n        return predictions;\n    }\n\n// TODO: If we are doing predicates, there is no point in pursuing\n//     closure operations if we reach a DFA state that uniquely predicts\n//     alternative. We will not be caching that DFA state and it is a\n//     waste to pursue the closure. Might have to advance when we do\n//     ambig detection thought :(\n//\n    closure(config, configs, closureBusy, collectPredicates, fullCtx, treatEofAsEpsilon) {\n        const initialDepth = 0;\n        this.closureCheckingStopState(config, configs, closureBusy, collectPredicates,\n                                 fullCtx, initialDepth, treatEofAsEpsilon);\n    }\n\n    closureCheckingStopState(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon) {\n        if (this.debug || this.debug_closure) {\n            console.log(\"closure(\" + config.toString(this.parser,true) + \")\");\n            // console.log(\"configs(\" + configs.toString() + \")\");\n            if(config.reachesIntoOuterContext>50) {\n                throw \"problem\";\n            }\n        }\n        if (config.state instanceof RuleStopState) {\n            // We hit rule end. If we have context info, use it\n            // run thru all possible stack tops in ctx\n            if (! config.context.isEmpty()) {\n                for (let i =0; i<config.context.length; i++) {\n                    if (config.context.getReturnState(i) === PredictionContext.EMPTY_RETURN_STATE) {\n                        if (fullCtx) {\n                            configs.add(new ATNConfig({state:config.state, context:PredictionContext.EMPTY}, config), this.mergeCache);\n                            continue;\n                        } else {\n                            // we have no context info, just chase follow links (if greedy)\n                            if (this.debug) {\n                                console.log(\"FALLING off rule \" + this.getRuleName(config.state.ruleIndex));\n                            }\n                            this.closure_(config, configs, closureBusy, collectPredicates,\n                                     fullCtx, depth, treatEofAsEpsilon);\n                        }\n                        continue;\n                    }\n                    const returnState = this.atn.states[config.context.getReturnState(i)];\n                    const newContext = config.context.getParent(i); // \"pop\" return state\n                    const parms = {state:returnState, alt:config.alt, context:newContext, semanticContext:config.semanticContext};\n                    const c = new ATNConfig(parms, null);\n                    // While we have context to pop back from, we may have\n                    // gotten that context AFTER having falling off a rule.\n                    // Make sure we track that we are now out of context.\n                    c.reachesIntoOuterContext = config.reachesIntoOuterContext;\n                    this.closureCheckingStopState(c, configs, closureBusy, collectPredicates, fullCtx, depth - 1, treatEofAsEpsilon);\n                }\n                return;\n            } else if( fullCtx) {\n                // reached end of start rule\n                configs.add(config, this.mergeCache);\n                return;\n            } else {\n                // else if we have no context info, just chase follow links (if greedy)\n                if (this.debug) {\n                    console.log(\"FALLING off rule \" + this.getRuleName(config.state.ruleIndex));\n                }\n            }\n        }\n        this.closure_(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon);\n    }\n\n    // Do the actual work of walking epsilon edges//\n    closure_(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon) {\n        const p = config.state;\n        // optimization\n        if (! p.epsilonOnlyTransitions) {\n            configs.add(config, this.mergeCache);\n            // make sure to not return here, because EOF transitions can act as\n            // both epsilon transitions and non-epsilon transitions.\n        }\n        for(let i = 0;i<p.transitions.length; i++) {\n            if(i === 0 && this.canDropLoopEntryEdgeInLeftRecursiveRule(config))\n                continue;\n\n            const t = p.transitions[i];\n            const continueCollecting = collectPredicates && !(t instanceof ActionTransition);\n            const c = this.getEpsilonTarget(config, t, continueCollecting, depth === 0, fullCtx, treatEofAsEpsilon);\n            if (c!==null) {\n                let newDepth = depth;\n                if ( config.state instanceof RuleStopState) {\n                    // target fell off end of rule; mark resulting c as having dipped into outer context\n                    // We can't get here if incoming config was rule stop and we had context\n                    // track how far we dip into outer context.  Might\n                    // come in handy and we avoid evaluating context dependent\n                    // preds if this is > 0.\n                    if (this._dfa !== null && this._dfa.precedenceDfa) {\n                        if (t.outermostPrecedenceReturn === this._dfa.atnStartState.ruleIndex) {\n                            c.precedenceFilterSuppressed = true;\n                        }\n                    }\n\n                    c.reachesIntoOuterContext += 1;\n                    if (closureBusy.add(c)!==c) {\n                        // avoid infinite recursion for right-recursive rules\n                        continue;\n                    }\n                    configs.dipsIntoOuterContext = true; // TODO: can remove? only care when we add to set per middle of this method\n                    newDepth -= 1;\n                    if (this.debug) {\n                        console.log(\"dips into outer ctx: \" + c);\n                    }\n                } else {\n                    if (!t.isEpsilon && closureBusy.add(c)!==c){\n                        // avoid infinite recursion for EOF* and EOF+\n                        continue;\n                    }\n                    if (t instanceof RuleTransition) {\n                        // latch when newDepth goes negative - once we step out of the entry context we can't return\n                        if (newDepth >= 0) {\n                            newDepth += 1;\n                        }\n                    }\n                }\n                this.closureCheckingStopState(c, configs, closureBusy, continueCollecting, fullCtx, newDepth, treatEofAsEpsilon);\n            }\n        }\n    }\n\n    canDropLoopEntryEdgeInLeftRecursiveRule(config) {\n        // return False\n        const p = config.state;\n        // First check to see if we are in StarLoopEntryState generated during\n        // left-recursion elimination. For efficiency, also check if\n        // the context has an empty stack case. If so, it would mean\n        // global FOLLOW so we can't perform optimization\n        // Are we the special loop entry/exit state? or SLL wildcard\n        if(p.stateType !== ATNState.STAR_LOOP_ENTRY)\n            return false;\n        if(p.stateType !== ATNState.STAR_LOOP_ENTRY || !p.isPrecedenceDecision ||\n               config.context.isEmpty() || config.context.hasEmptyPath())\n            return false;\n\n        // Require all return states to return back to the same rule that p is in.\n        const numCtxs = config.context.length;\n        for(let i=0; i<numCtxs; i++) { // for each stack context\n            const returnState = this.atn.states[config.context.getReturnState(i)];\n            if (returnState.ruleIndex !== p.ruleIndex)\n                return false;\n        }\n\n        const decisionStartState = p.transitions[0].target;\n        const blockEndStateNum = decisionStartState.endState.stateNumber;\n        const blockEndState = this.atn.states[blockEndStateNum];\n\n        // Verify that the top of each stack context leads to loop entry/exit\n        // state through epsilon edges and w/o leaving rule.\n        for(let i=0; i<numCtxs; i++) { // for each stack context\n            const returnStateNumber = config.context.getReturnState(i);\n            const returnState = this.atn.states[returnStateNumber];\n            // all states must have single outgoing epsilon edge\n            if (returnState.transitions.length !== 1 || !returnState.transitions[0].isEpsilon)\n                return false;\n\n            // Look for prefix op case like 'not expr', (' type ')' expr\n            const returnStateTarget = returnState.transitions[0].target;\n            if ( returnState.stateType === ATNState.BLOCK_END && returnStateTarget === p )\n                continue;\n\n            // Look for 'expr op expr' or case where expr's return state is block end\n            // of (...)* internal block; the block end points to loop back\n            // which points to p but we don't need to check that\n            if ( returnState === blockEndState )\n                continue;\n\n            // Look for ternary expr ? expr : expr. The return state points at block end,\n            // which points at loop entry state\n            if ( returnStateTarget === blockEndState )\n                continue;\n\n            // Look for complex prefix 'between expr and expr' case where 2nd expr's\n            // return state points at block end state of (...)* internal block\n            if (returnStateTarget.stateType === ATNState.BLOCK_END && returnStateTarget.transitions.length === 1\n                    && returnStateTarget.transitions[0].isEpsilon && returnStateTarget.transitions[0].target === p)\n                continue;\n\n            // anything else ain't conforming\n            return false;\n        }\n        return true;\n    }\n\n    getRuleName(index) {\n        if (this.parser!==null && index>=0) {\n            return this.parser.ruleNames[index];\n        } else {\n            return \"<rule \" + index + \">\";\n        }\n    }\n\n    getEpsilonTarget(config, t, collectPredicates, inContext, fullCtx, treatEofAsEpsilon) {\n        switch(t.serializationType) {\n        case Transition.RULE:\n            return this.ruleTransition(config, t);\n        case Transition.PRECEDENCE:\n            return this.precedenceTransition(config, t, collectPredicates, inContext, fullCtx);\n        case Transition.PREDICATE:\n            return this.predTransition(config, t, collectPredicates, inContext, fullCtx);\n        case Transition.ACTION:\n            return this.actionTransition(config, t);\n        case Transition.EPSILON:\n            return new ATNConfig({state:t.target}, config);\n        case Transition.ATOM:\n        case Transition.RANGE:\n        case Transition.SET:\n            // EOF transitions act like epsilon transitions after the first EOF\n            // transition is traversed\n            if (treatEofAsEpsilon) {\n                if (t.matches(Token.EOF, 0, 1)) {\n                    return new ATNConfig({state: t.target}, config);\n                }\n            }\n            return null;\n        default:\n            return null;\n        }\n    }\n\n    actionTransition(config, t) {\n        if (this.debug) {\n            const index = t.actionIndex === -1 ? 65535 : t.actionIndex;\n            console.log(\"ACTION edge \" + t.ruleIndex + \":\" + index);\n        }\n        return new ATNConfig({state:t.target}, config);\n    }\n\n    precedenceTransition(config, pt, collectPredicates, inContext, fullCtx) {\n        if (this.debug) {\n            console.log(\"PRED (collectPredicates=\" + collectPredicates + \") \" +\n                    pt.precedence + \">=_p, ctx dependent=true\");\n            if (this.parser!==null) {\n                console.log(\"context surrounding pred is \" + Utils.arrayToString(this.parser.getRuleInvocationStack()));\n            }\n        }\n        let c = null;\n        if (collectPredicates && inContext) {\n            if (fullCtx) {\n                // In full context mode, we can evaluate predicates on-the-fly\n                // during closure, which dramatically reduces the size of\n                // the config sets. It also obviates the need to test predicates\n                // later during conflict resolution.\n                const currentPosition = this._input.index;\n                this._input.seek(this._startIndex);\n                const predSucceeds = pt.getPredicate().evaluate(this.parser, this._outerContext);\n                this._input.seek(currentPosition);\n                if (predSucceeds) {\n                    c = new ATNConfig({state:pt.target}, config); // no pred context\n                }\n            } else {\n                const newSemCtx = SemanticContext.andContext(config.semanticContext, pt.getPredicate());\n                c = new ATNConfig({state:pt.target, semanticContext:newSemCtx}, config);\n            }\n        } else {\n            c = new ATNConfig({state:pt.target}, config);\n        }\n        if (this.debug) {\n            console.log(\"config from pred transition=\" + c);\n        }\n        return c;\n    }\n\n    predTransition(config, pt, collectPredicates, inContext, fullCtx) {\n        if (this.debug) {\n            console.log(\"PRED (collectPredicates=\" + collectPredicates + \") \" + pt.ruleIndex +\n                    \":\" + pt.predIndex + \", ctx dependent=\" + pt.isCtxDependent);\n            if (this.parser!==null) {\n                console.log(\"context surrounding pred is \" + Utils.arrayToString(this.parser.getRuleInvocationStack()));\n            }\n        }\n        let c = null;\n        if (collectPredicates && ((pt.isCtxDependent && inContext) || ! pt.isCtxDependent)) {\n            if (fullCtx) {\n                // In full context mode, we can evaluate predicates on-the-fly\n                // during closure, which dramatically reduces the size of\n                // the config sets. It also obviates the need to test predicates\n                // later during conflict resolution.\n                const currentPosition = this._input.index;\n                this._input.seek(this._startIndex);\n                const predSucceeds = pt.getPredicate().evaluate(this.parser, this._outerContext);\n                this._input.seek(currentPosition);\n                if (predSucceeds) {\n                    c = new ATNConfig({state:pt.target}, config); // no pred context\n                }\n            } else {\n                const newSemCtx = SemanticContext.andContext(config.semanticContext, pt.getPredicate());\n                c = new ATNConfig({state:pt.target, semanticContext:newSemCtx}, config);\n            }\n        } else {\n            c = new ATNConfig({state:pt.target}, config);\n        }\n        if (this.debug) {\n            console.log(\"config from pred transition=\" + c);\n        }\n        return c;\n    }\n\n    ruleTransition(config, t) {\n        if (this.debug) {\n            console.log(\"CALL rule \" + this.getRuleName(t.target.ruleIndex) + \", ctx=\" + config.context);\n        }\n        const returnState = t.followState;\n        const newContext = SingletonPredictionContext.create(config.context, returnState.stateNumber);\n        return new ATNConfig({state:t.target, context:newContext}, config );\n    }\n\n    getConflictingAlts(configs) {\n        const altsets = PredictionMode.getConflictingAltSubsets(configs);\n        return PredictionMode.getAlts(altsets);\n    }\n\n    /**\n     * Sam pointed out a problem with the previous definition, v3, of\n     * ambiguous states. If we have another state associated with conflicting\n     * alternatives, we should keep going. For example, the following grammar\n     *\n     * s : (ID | ID ID?) ';' ;\n     *\n     * When the ATN simulation reaches the state before ';', it has a DFA\n     * state that looks like: [12|1|[], 6|2|[], 12|2|[]]. Naturally\n     * 12|1|[] and 12|2|[] conflict, but we cannot stop processing this node\n     * because alternative to has another way to continue, via [6|2|[]].\n     * The key is that we have a single state that has config's only associated\n     * with a single alternative, 2, and crucially the state transitions\n     * among the configurations are all non-epsilon transitions. That means\n     * we don't consider any conflicts that include alternative 2. So, we\n     * ignore the conflict between alts 1 and 2. We ignore a set of\n     * conflicting alts when there is an intersection with an alternative\n     * associated with a single alt state in the state&rarr;config-list map.\n     *\n     * It's also the case that we might have two conflicting configurations but\n     * also a 3rd nonconflicting configuration for a different alternative:\n     * [1|1|[], 1|2|[], 8|3|[]]. This can come about from grammar:\n     *\n     * a : A | A | A B ;\n     *\n     * After matching input A, we reach the stop state for rule A, state 1.\n     * State 8 is the state right before B. Clearly alternatives 1 and 2\n     * conflict and no amount of further lookahead will separate the two.\n     * However, alternative 3 will be able to continue and so we do not\n     * stop working on this state. In the previous example, we're concerned\n     * with states associated with the conflicting alternatives. Here alt\n     * 3 is not associated with the conflicting configs, but since we can continue\n     * looking for input reasonably, I don't declare the state done. We\n     * ignore a set of conflicting alts when we have an alternative\n     * that we still need to pursue\n     */\n    getConflictingAltsOrUniqueAlt(configs) {\n        let conflictingAlts = null;\n        if (configs.uniqueAlt!== ATN.INVALID_ALT_NUMBER) {\n            conflictingAlts = new BitSet();\n            conflictingAlts.add(configs.uniqueAlt);\n        } else {\n            conflictingAlts = configs.conflictingAlts;\n        }\n        return conflictingAlts;\n    }\n\n    getTokenName(t) {\n        if (t===Token.EOF) {\n            return \"EOF\";\n        }\n        if( this.parser!==null && this.parser.literalNames!==null) {\n            if (t >= this.parser.literalNames.length && t >= this.parser.symbolicNames.length) {\n                console.log(\"\" + t + \" ttype out of range: \" + this.parser.literalNames);\n                console.log(\"\" + this.parser.getInputStream().getTokens());\n            } else {\n                const name = this.parser.literalNames[t] || this.parser.symbolicNames[t];\n                return name + \"<\" + t + \">\";\n            }\n        }\n        return \"\" + t;\n    }\n\n    getLookaheadName(input) {\n        return this.getTokenName(input.LA(1));\n    }\n\n    /**\n     * Used for debugging in adaptivePredict around execATN but I cut\n     * it out for clarity now that alg. works well. We can leave this\n     * \"dead\" code for a bit\n     */\n    dumpDeadEndConfigs(nvae) {\n        console.log(\"dead end configs: \");\n        const decs = nvae.getDeadEndConfigs();\n        for(let i=0; i<decs.length; i++) {\n            const c = decs[i];\n            let trans = \"no edges\";\n            if (c.state.transitions.length>0) {\n                const t = c.state.transitions[0];\n                if (t instanceof AtomTransition) {\n                    trans = \"Atom \"+ this.getTokenName(t.label);\n                } else if (t instanceof SetTransition) {\n                    const neg = (t instanceof NotSetTransition);\n                    trans = (neg ? \"~\" : \"\") + \"Set \" + t.set;\n                }\n            }\n            console.error(c.toString(this.parser, true) + \":\" + trans);\n        }\n    }\n\n    noViableAlt(input, outerContext, configs, startIndex) {\n        return new NoViableAltException(this.parser, input, input.get(startIndex), input.LT(1), configs, outerContext);\n    }\n\n    getUniqueAlt(configs) {\n        let alt = ATN.INVALID_ALT_NUMBER;\n        for(let i=0;i<configs.items.length;i++) {\n            const c = configs.items[i];\n            if (alt === ATN.INVALID_ALT_NUMBER) {\n                alt = c.alt // found first alt\n            } else if( c.alt!==alt) {\n                return ATN.INVALID_ALT_NUMBER;\n            }\n        }\n        return alt;\n    }\n\n    /**\n     * Add an edge to the DFA, if possible. This method calls\n     * {@link //addDFAState} to ensure the {@code to} state is present in the\n     * DFA. If {@code from} is {@code null}, or if {@code t} is outside the\n     * range of edges that can be represented in the DFA tables, this method\n     * returns without adding the edge to the DFA.\n     *\n     * <p>If {@code to} is {@code null}, this method returns {@code null}.\n     * Otherwise, this method returns the {@link DFAState} returned by calling\n     * {@link //addDFAState} for the {@code to} state.</p>\n     *\n     * @param dfa The DFA\n     * @param from_ The source state for the edge\n     * @param t The input symbol\n     * @param to The target state for the edge\n     *\n     * @return If {@code to} is {@code null}, this method returns {@code null};\n     * otherwise this method returns the result of calling {@link //addDFAState}\n     * on {@code to}\n     */\n    addDFAEdge(dfa, from_, t, to) {\n        if( this.debug) {\n            console.log(\"EDGE \" + from_ + \" -> \" + to + \" upon \" + this.getTokenName(t));\n        }\n        if (to===null) {\n            return null;\n        }\n        to = this.addDFAState(dfa, to); // used existing if possible not incoming\n        if (from_===null || t < -1 || t > this.atn.maxTokenType) {\n            return to;\n        }\n        if (from_.edges===null) {\n            from_.edges = [];\n        }\n        from_.edges[t+1] = to; // connect\n\n        if (this.debug) {\n            const literalNames = this.parser===null ? null : this.parser.literalNames;\n            const symbolicNames = this.parser===null ? null : this.parser.symbolicNames;\n            console.log(\"DFA=\\n\" + dfa.toString(literalNames, symbolicNames));\n        }\n        return to;\n    }\n\n    /**\n     * Add state {@code D} to the DFA if it is not already present, and return\n     * the actual instance stored in the DFA. If a state equivalent to {@code D}\n     * is already in the DFA, the existing state is returned. Otherwise this\n     * method returns {@code D} after adding it to the DFA.\n     *\n     * <p>If {@code D} is {@link //ERROR}, this method returns {@link //ERROR} and\n     * does not change the DFA.</p>\n     *\n     * @param dfa The dfa\n     * @param D The DFA state to add\n     * @return The state stored in the DFA. This will be either the existing\n     * state if {@code D} is already in the DFA, or {@code D} itself if the\n     * state was not already present\n     */\n    addDFAState(dfa, D) {\n        if (D === ATNSimulator.ERROR) {\n            return D;\n        }\n        const existing = dfa.states.get(D);\n        if(existing!==null) {\n            return existing;\n        }\n        D.stateNumber = dfa.states.length;\n        if (! D.configs.readOnly) {\n            D.configs.optimizeConfigs(this);\n            D.configs.setReadonly(true);\n        }\n        dfa.states.add(D);\n        if (this.debug) {\n            console.log(\"adding new DFA state: \" + D);\n        }\n        return D;\n    }\n\n    reportAttemptingFullContext(dfa, conflictingAlts, configs, startIndex, stopIndex) {\n        if (this.debug || this.retry_debug) {\n            const interval = new Interval(startIndex, stopIndex + 1);\n            console.log(\"reportAttemptingFullContext decision=\" + dfa.decision + \":\" + configs +\n                               \", input=\" + this.parser.getTokenStream().getText(interval));\n        }\n        if (this.parser!==null) {\n            this.parser.getErrorListenerDispatch().reportAttemptingFullContext(this.parser, dfa, startIndex, stopIndex, conflictingAlts, configs);\n        }\n    }\n\n    reportContextSensitivity(dfa, prediction, configs, startIndex, stopIndex) {\n        if (this.debug || this.retry_debug) {\n            const interval = new Interval(startIndex, stopIndex + 1);\n            console.log(\"reportContextSensitivity decision=\" + dfa.decision + \":\" + configs +\n                               \", input=\" + this.parser.getTokenStream().getText(interval));\n        }\n        if (this.parser!==null) {\n            this.parser.getErrorListenerDispatch().reportContextSensitivity(this.parser, dfa, startIndex, stopIndex, prediction, configs);\n        }\n    }\n\n    // If context sensitive parsing, we know it's ambiguity not conflict//\n    reportAmbiguity(dfa, D, startIndex, stopIndex,\n                                   exact, ambigAlts, configs ) {\n        if (this.debug || this.retry_debug) {\n            const interval = new Interval(startIndex, stopIndex + 1);\n            console.log(\"reportAmbiguity \" + ambigAlts + \":\" + configs +\n                               \", input=\" + this.parser.getTokenStream().getText(interval));\n        }\n        if (this.parser!==null) {\n            this.parser.getErrorListenerDispatch().reportAmbiguity(this.parser, dfa, startIndex, stopIndex, exact, ambigAlts, configs);\n        }\n    }\n}\n\nmodule.exports = ParserATNSimulator;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Map, BitSet, AltDict, hashStuff} = require('./../Utils');\nconst ATN = require('./ATN');\nconst {RuleStopState} = require('./ATNState');\nconst {ATNConfigSet} = require('./ATNConfigSet');\nconst {ATNConfig} = require('./ATNConfig');\nconst {SemanticContext} = require('./SemanticContext');\n\n/**\n * This enumeration defines the prediction modes available in ANTLR 4 along with\n * utility methods for analyzing configuration sets for conflicts and/or\n * ambiguities.\n */\nconst PredictionMode = {\n    /**\n     * The SLL(*) prediction mode. This prediction mode ignores the current\n     * parser context when making predictions. This is the fastest prediction\n     * mode, and provides correct results for many grammars. This prediction\n     * mode is more powerful than the prediction mode provided by ANTLR 3, but\n     * may result in syntax errors for grammar and input combinations which are\n     * not SLL.\n     *\n     * <p>\n     * When using this prediction mode, the parser will either return a correct\n     * parse tree (i.e. the same parse tree that would be returned with the\n     * {@link //LL} prediction mode), or it will report a syntax error. If a\n     * syntax error is encountered when using the {@link //SLL} prediction mode,\n     * it may be due to either an actual syntax error in the input or indicate\n     * that the particular combination of grammar and input requires the more\n     * powerful {@link //LL} prediction abilities to complete successfully.</p>\n     *\n     * <p>\n     * This prediction mode does not provide any guarantees for prediction\n     * behavior for syntactically-incorrect inputs.</p>\n     */\n    SLL: 0,\n\n    /**\n     * The LL(*) prediction mode. This prediction mode allows the current parser\n     * context to be used for resolving SLL conflicts that occur during\n     * prediction. This is the fastest prediction mode that guarantees correct\n     * parse results for all combinations of grammars with syntactically correct\n     * inputs.\n     *\n     * <p>\n     * When using this prediction mode, the parser will make correct decisions\n     * for all syntactically-correct grammar and input combinations. However, in\n     * cases where the grammar is truly ambiguous this prediction mode might not\n     * report a precise answer for <em>exactly which</em> alternatives are\n     * ambiguous.</p>\n     *\n     * <p>\n     * This prediction mode does not provide any guarantees for prediction\n     * behavior for syntactically-incorrect inputs.</p>\n     */\n    LL: 1,\n\n    /**\n     *\n     * The LL(*) prediction mode with exact ambiguity detection. In addition to\n     * the correctness guarantees provided by the {@link //LL} prediction mode,\n     * this prediction mode instructs the prediction algorithm to determine the\n     * complete and exact set of ambiguous alternatives for every ambiguous\n     * decision encountered while parsing.\n     *\n     * <p>\n     * This prediction mode may be used for diagnosing ambiguities during\n     * grammar development. Due to the performance overhead of calculating sets\n     * of ambiguous alternatives, this prediction mode should be avoided when\n     * the exact results are not necessary.</p>\n     *\n     * <p>\n     * This prediction mode does not provide any guarantees for prediction\n     * behavior for syntactically-incorrect inputs.</p>\n     */\n    LL_EXACT_AMBIG_DETECTION: 2,\n\n    /**\n     *\n     * Computes the SLL prediction termination condition.\n     *\n     * <p>\n     * This method computes the SLL prediction termination condition for both of\n     * the following cases.</p>\n     *\n     * <ul>\n     * <li>The usual SLL+LL fallback upon SLL conflict</li>\n     * <li>Pure SLL without LL fallback</li>\n     * </ul>\n     *\n     * <p><strong>COMBINED SLL+LL PARSING</strong></p>\n     *\n     * <p>When LL-fallback is enabled upon SLL conflict, correct predictions are\n     * ensured regardless of how the termination condition is computed by this\n     * method. Due to the substantially higher cost of LL prediction, the\n     * prediction should only fall back to LL when the additional lookahead\n     * cannot lead to a unique SLL prediction.</p>\n     *\n     * <p>Assuming combined SLL+LL parsing, an SLL configuration set with only\n     * conflicting subsets should fall back to full LL, even if the\n     * configuration sets don't resolve to the same alternative (e.g.\n     * {@code {1,2}} and {@code {3,4}}. If there is at least one non-conflicting\n     * configuration, SLL could continue with the hopes that more lookahead will\n     * resolve via one of those non-conflicting configurations.</p>\n     *\n     * <p>Here's the prediction termination rule them: SLL (for SLL+LL parsing)\n     * stops when it sees only conflicting configuration subsets. In contrast,\n     * full LL keeps going when there is uncertainty.</p>\n     *\n     * <p><strong>HEURISTIC</strong></p>\n     *\n     * <p>As a heuristic, we stop prediction when we see any conflicting subset\n     * unless we see a state that only has one alternative associated with it.\n     * The single-alt-state thing lets prediction continue upon rules like\n     * (otherwise, it would admit defeat too soon):</p>\n     *\n     * <p>{@code [12|1|[], 6|2|[], 12|2|[]]. s : (ID | ID ID?) ';' ;}</p>\n     *\n     * <p>When the ATN simulation reaches the state before {@code ';'}, it has a\n     * DFA state that looks like: {@code [12|1|[], 6|2|[], 12|2|[]]}. Naturally\n     * {@code 12|1|[]} and {@code 12|2|[]} conflict, but we cannot stop\n     * processing this node because alternative to has another way to continue,\n     * via {@code [6|2|[]]}.</p>\n     *\n     * <p>It also let's us continue for this rule:</p>\n     *\n     * <p>{@code [1|1|[], 1|2|[], 8|3|[]] a : A | A | A B ;}</p>\n     *\n     * <p>After matching input A, we reach the stop state for rule A, state 1.\n     * State 8 is the state right before B. Clearly alternatives 1 and 2\n     * conflict and no amount of further lookahead will separate the two.\n     * However, alternative 3 will be able to continue and so we do not stop\n     * working on this state. In the previous example, we're concerned with\n     * states associated with the conflicting alternatives. Here alt 3 is not\n     * associated with the conflicting configs, but since we can continue\n     * looking for input reasonably, don't declare the state done.</p>\n     *\n     * <p><strong>PURE SLL PARSING</strong></p>\n     *\n     * <p>To handle pure SLL parsing, all we have to do is make sure that we\n     * combine stack contexts for configurations that differ only by semantic\n     * predicate. From there, we can do the usual SLL termination heuristic.</p>\n     *\n     * <p><strong>PREDICATES IN SLL+LL PARSING</strong></p>\n     *\n     * <p>SLL decisions don't evaluate predicates until after they reach DFA stop\n     * states because they need to create the DFA cache that works in all\n     * semantic situations. In contrast, full LL evaluates predicates collected\n     * during start state computation so it can ignore predicates thereafter.\n     * This means that SLL termination detection can totally ignore semantic\n     * predicates.</p>\n     *\n     * <p>Implementation-wise, {@link ATNConfigSet} combines stack contexts but not\n     * semantic predicate contexts so we might see two configurations like the\n     * following.</p>\n     *\n     * <p>{@code (s, 1, x, {}), (s, 1, x', {p})}</p>\n     *\n     * <p>Before testing these configurations against others, we have to merge\n     * {@code x} and {@code x'} (without modifying the existing configurations).\n     * For example, we test {@code (x+x')==x''} when looking for conflicts in\n     * the following configurations.</p>\n     *\n     * <p>{@code (s, 1, x, {}), (s, 1, x', {p}), (s, 2, x'', {})}</p>\n     *\n     * <p>If the configuration set has predicates (as indicated by\n     * {@link ATNConfigSet//hasSemanticContext}), this algorithm makes a copy of\n     * the configurations to strip out all of the predicates so that a standard\n     * {@link ATNConfigSet} will merge everything ignoring predicates.</p>\n     */\n    hasSLLConflictTerminatingPrediction: function( mode, configs) {\n        // Configs in rule stop states indicate reaching the end of the decision\n        // rule (local context) or end of start rule (full context). If all\n        // configs meet this condition, then none of the configurations is able\n        // to match additional input so we terminate prediction.\n        //\n        if (PredictionMode.allConfigsInRuleStopStates(configs)) {\n            return true;\n        }\n        // pure SLL mode parsing\n        if (mode === PredictionMode.SLL) {\n            // Don't bother with combining configs from different semantic\n            // contexts if we can fail over to full LL; costs more time\n            // since we'll often fail over anyway.\n            if (configs.hasSemanticContext) {\n                // dup configs, tossing out semantic predicates\n                const dup = new ATNConfigSet();\n                for(let i=0;i<configs.items.length;i++) {\n                    let c = configs.items[i];\n                    c = new ATNConfig({semanticContext:SemanticContext.NONE}, c);\n                    dup.add(c);\n                }\n                configs = dup;\n            }\n            // now we have combined contexts for configs with dissimilar preds\n        }\n        // pure SLL or combined SLL+LL mode parsing\n        const altsets = PredictionMode.getConflictingAltSubsets(configs);\n        return PredictionMode.hasConflictingAltSet(altsets) && !PredictionMode.hasStateAssociatedWithOneAlt(configs);\n    },\n\n    /**\n     * Checks if any configuration in {@code configs} is in a\n     * {@link RuleStopState}. Configurations meeting this condition have reached\n     * the end of the decision rule (local context) or end of start rule (full\n     * context).\n     *\n     * @param configs the configuration set to test\n     * @return {@code true} if any configuration in {@code configs} is in a\n     * {@link RuleStopState}, otherwise {@code false}\n     */\n    hasConfigInRuleStopState: function(configs) {\n        for(let i=0;i<configs.items.length;i++) {\n            const c = configs.items[i];\n            if (c.state instanceof RuleStopState) {\n                return true;\n            }\n        }\n        return false;\n    },\n\n    /**\n     * Checks if all configurations in {@code configs} are in a\n     * {@link RuleStopState}. Configurations meeting this condition have reached\n     * the end of the decision rule (local context) or end of start rule (full\n     * context).\n     *\n     * @param configs the configuration set to test\n     * @return {@code true} if all configurations in {@code configs} are in a\n     * {@link RuleStopState}, otherwise {@code false}\n     */\n    allConfigsInRuleStopStates: function(configs) {\n        for(let i=0;i<configs.items.length;i++) {\n            const c = configs.items[i];\n            if (!(c.state instanceof RuleStopState)) {\n                return false;\n            }\n        }\n        return true;\n    },\n\n    /**\n     *\n     * Full LL prediction termination.\n     *\n     * <p>Can we stop looking ahead during ATN simulation or is there some\n     * uncertainty as to which alternative we will ultimately pick, after\n     * consuming more input? Even if there are partial conflicts, we might know\n     * that everything is going to resolve to the same minimum alternative. That\n     * means we can stop since no more lookahead will change that fact. On the\n     * other hand, there might be multiple conflicts that resolve to different\n     * minimums. That means we need more look ahead to decide which of those\n     * alternatives we should predict.</p>\n     *\n     * <p>The basic idea is to split the set of configurations {@code C}, into\n     * conflicting subsets {@code (s, _, ctx, _)} and singleton subsets with\n     * non-conflicting configurations. Two configurations conflict if they have\n     * identical {@link ATNConfig//state} and {@link ATNConfig//context} values\n     * but different {@link ATNConfig//alt} value, e.g. {@code (s, i, ctx, _)}\n     * and {@code (s, j, ctx, _)} for {@code i!=j}.</p>\n     *\n     * <p>Reduce these configuration subsets to the set of possible alternatives.\n     * You can compute the alternative subsets in one pass as follows:</p>\n     *\n     * <p>{@code A_s,ctx = {i | (s, i, ctx, _)}} for each configuration in\n     * {@code C} holding {@code s} and {@code ctx} fixed.</p>\n     *\n     * <p>Or in pseudo-code, for each configuration {@code c} in {@code C}:</p>\n     *\n     * <pre>\n     * map[c] U= c.{@link ATNConfig//alt alt} // map hash/equals uses s and x, not\n     * alt and not pred\n     * </pre>\n     *\n     * <p>The values in {@code map} are the set of {@code A_s,ctx} sets.</p>\n     *\n     * <p>If {@code |A_s,ctx|=1} then there is no conflict associated with\n     * {@code s} and {@code ctx}.</p>\n     *\n     * <p>Reduce the subsets to singletons by choosing a minimum of each subset. If\n     * the union of these alternative subsets is a singleton, then no amount of\n     * more lookahead will help us. We will always pick that alternative. If,\n     * however, there is more than one alternative, then we are uncertain which\n     * alternative to predict and must continue looking for resolution. We may\n     * or may not discover an ambiguity in the future, even if there are no\n     * conflicting subsets this round.</p>\n     *\n     * <p>The biggest sin is to terminate early because it means we've made a\n     * decision but were uncertain as to the eventual outcome. We haven't used\n     * enough lookahead. On the other hand, announcing a conflict too late is no\n     * big deal; you will still have the conflict. It's just inefficient. It\n     * might even look until the end of file.</p>\n     *\n     * <p>No special consideration for semantic predicates is required because\n     * predicates are evaluated on-the-fly for full LL prediction, ensuring that\n     * no configuration contains a semantic context during the termination\n     * check.</p>\n     *\n     * <p><strong>CONFLICTING CONFIGS</strong></p>\n     *\n     * <p>Two configurations {@code (s, i, x)} and {@code (s, j, x')}, conflict\n     * when {@code i!=j} but {@code x=x'}. Because we merge all\n     * {@code (s, i, _)} configurations together, that means that there are at\n     * most {@code n} configurations associated with state {@code s} for\n     * {@code n} possible alternatives in the decision. The merged stacks\n     * complicate the comparison of configuration contexts {@code x} and\n     * {@code x'}. Sam checks to see if one is a subset of the other by calling\n     * merge and checking to see if the merged result is either {@code x} or\n     * {@code x'}. If the {@code x} associated with lowest alternative {@code i}\n     * is the superset, then {@code i} is the only possible prediction since the\n     * others resolve to {@code min(i)} as well. However, if {@code x} is\n     * associated with {@code j>i} then at least one stack configuration for\n     * {@code j} is not in conflict with alternative {@code i}. The algorithm\n     * should keep going, looking for more lookahead due to the uncertainty.</p>\n     *\n     * <p>For simplicity, I'm doing a equality check between {@code x} and\n     * {@code x'} that lets the algorithm continue to consume lookahead longer\n     * than necessary. The reason I like the equality is of course the\n     * simplicity but also because that is the test you need to detect the\n     * alternatives that are actually in conflict.</p>\n     *\n     * <p><strong>CONTINUE/STOP RULE</strong></p>\n     *\n     * <p>Continue if union of resolved alternative sets from non-conflicting and\n     * conflicting alternative subsets has more than one alternative. We are\n     * uncertain about which alternative to predict.</p>\n     *\n     * <p>The complete set of alternatives, {@code [i for (_,i,_)]}, tells us which\n     * alternatives are still in the running for the amount of input we've\n     * consumed at this point. The conflicting sets let us to strip away\n     * configurations that won't lead to more states because we resolve\n     * conflicts to the configuration with a minimum alternate for the\n     * conflicting set.</p>\n     *\n     * <p><strong>CASES</strong></p>\n     *\n     * <ul>\n     *\n     * <li>no conflicts and more than 1 alternative in set =&gt; continue</li>\n     *\n     * <li> {@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s, 3, z)},\n     * {@code (s', 1, y)}, {@code (s', 2, y)} yields non-conflicting set\n     * {@code {3}} U conflicting sets {@code min({1,2})} U {@code min({1,2})} =\n     * {@code {1,3}} =&gt; continue\n     * </li>\n     *\n     * <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 1, y)},\n     * {@code (s', 2, y)}, {@code (s'', 1, z)} yields non-conflicting set\n     * {@code {1}} U conflicting sets {@code min({1,2})} U {@code min({1,2})} =\n     * {@code {1}} =&gt; stop and predict 1</li>\n     *\n     * <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 1, y)},\n     * {@code (s', 2, y)} yields conflicting, reduced sets {@code {1}} U\n     * {@code {1}} = {@code {1}} =&gt; stop and predict 1, can announce\n     * ambiguity {@code {1,2}}</li>\n     *\n     * <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 2, y)},\n     * {@code (s', 3, y)} yields conflicting, reduced sets {@code {1}} U\n     * {@code {2}} = {@code {1,2}} =&gt; continue</li>\n     *\n     * <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 3, y)},\n     * {@code (s', 4, y)} yields conflicting, reduced sets {@code {1}} U\n     * {@code {3}} = {@code {1,3}} =&gt; continue</li>\n     *\n     * </ul>\n     *\n     * <p><strong>EXACT AMBIGUITY DETECTION</strong></p>\n     *\n     * <p>If all states report the same conflicting set of alternatives, then we\n     * know we have the exact ambiguity set.</p>\n     *\n     * <p><code>|A_<em>i</em>|&gt;1</code> and\n     * <code>A_<em>i</em> = A_<em>j</em></code> for all <em>i</em>, <em>j</em>.</p>\n     *\n     * <p>In other words, we continue examining lookahead until all {@code A_i}\n     * have more than one alternative and all {@code A_i} are the same. If\n     * {@code A={{1,2}, {1,3}}}, then regular LL prediction would terminate\n     * because the resolved set is {@code {1}}. To determine what the real\n     * ambiguity is, we have to know whether the ambiguity is between one and\n     * two or one and three so we keep going. We can only stop prediction when\n     * we need exact ambiguity detection when the sets look like\n     * {@code A={{1,2}}} or {@code {{1,2},{1,2}}}, etc...</p>\n     */\n    resolvesToJustOneViableAlt: function(altsets) {\n        return PredictionMode.getSingleViableAlt(altsets);\n    },\n\n    /**\n     * Determines if every alternative subset in {@code altsets} contains more\n     * than one alternative.\n     *\n     * @param altsets a collection of alternative subsets\n     * @return {@code true} if every {@link BitSet} in {@code altsets} has\n     * {@link BitSet//cardinality cardinality} &gt; 1, otherwise {@code false}\n     */\n    allSubsetsConflict: function(altsets) {\n        return ! PredictionMode.hasNonConflictingAltSet(altsets);\n    },\n    /**\n     * Determines if any single alternative subset in {@code altsets} contains\n     * exactly one alternative.\n     *\n     * @param altsets a collection of alternative subsets\n     * @return {@code true} if {@code altsets} contains a {@link BitSet} with\n     * {@link BitSet//cardinality cardinality} 1, otherwise {@code false}\n     */\n    hasNonConflictingAltSet: function(altsets) {\n        for(let i=0;i<altsets.length;i++) {\n            const alts = altsets[i];\n            if (alts.length===1) {\n                return true;\n            }\n        }\n        return false;\n    },\n\n\n    /**\n     * Determines if any single alternative subset in {@code altsets} contains\n     * more than one alternative.\n     *\n     * @param altsets a collection of alternative subsets\n     * @return {@code true} if {@code altsets} contains a {@link BitSet} with\n     * {@link BitSet//cardinality cardinality} &gt; 1, otherwise {@code false}\n     */\n    hasConflictingAltSet: function(altsets) {\n        for(let i=0;i<altsets.length;i++) {\n            const alts = altsets[i];\n            if (alts.length>1) {\n                return true;\n            }\n        }\n        return false;\n    },\n\n\n    /**\n     * Determines if every alternative subset in {@code altsets} is equivalent.\n     *\n     * @param altsets a collection of alternative subsets\n     * @return {@code true} if every member of {@code altsets} is equal to the\n     * others, otherwise {@code false}\n     */\n    allSubsetsEqual: function(altsets) {\n        let first = null;\n        for(let i=0;i<altsets.length;i++) {\n            const alts = altsets[i];\n            if (first === null) {\n                first = alts;\n            } else if (alts!==first) {\n                return false;\n            }\n        }\n        return true;\n    },\n\n\n    /**\n     * Returns the unique alternative predicted by all alternative subsets in\n     * {@code altsets}. If no such alternative exists, this method returns\n     * {@link ATN//INVALID_ALT_NUMBER}.\n     *\n     * @param altsets a collection of alternative subsets\n     */\n    getUniqueAlt: function(altsets) {\n        const all = PredictionMode.getAlts(altsets);\n        if (all.length===1) {\n            return all.minValue();\n        } else {\n            return ATN.INVALID_ALT_NUMBER;\n        }\n    },\n\n    /**\n     * Gets the complete set of represented alternatives for a collection of\n     * alternative subsets. This method returns the union of each {@link BitSet}\n     * in {@code altsets}.\n     *\n     * @param altsets a collection of alternative subsets\n     * @return the set of represented alternatives in {@code altsets}\n     */\n    getAlts: function(altsets) {\n        const all = new BitSet();\n        altsets.map( function(alts) { all.or(alts); });\n        return all;\n    },\n\n    /**\n     * This function gets the conflicting alt subsets from a configuration set.\n     * For each configuration {@code c} in {@code configs}:\n     *\n     * <pre>\n     * map[c] U= c.{@link ATNConfig//alt alt} // map hash/equals uses s and x, not\n     * alt and not pred\n     * </pre>\n     */\n    getConflictingAltSubsets: function(configs) {\n        const configToAlts = new Map();\n        configToAlts.hashFunction = function(cfg) { hashStuff(cfg.state.stateNumber, cfg.context); };\n        configToAlts.equalsFunction = function(c1, c2) { return c1.state.stateNumber === c2.state.stateNumber && c1.context.equals(c2.context);};\n        configs.items.map(function(cfg) {\n            let alts = configToAlts.get(cfg);\n            if (alts === null) {\n                alts = new BitSet();\n                configToAlts.put(cfg, alts);\n            }\n            alts.add(cfg.alt);\n        });\n        return configToAlts.getValues();\n    },\n\n    /**\n     * Get a map from state to alt subset from a configuration set. For each\n     * configuration {@code c} in {@code configs}:\n     *\n     * <pre>\n     * map[c.{@link ATNConfig//state state}] U= c.{@link ATNConfig//alt alt}\n     * </pre>\n     */\n    getStateToAltMap: function(configs) {\n        const m = new AltDict();\n        configs.items.map(function(c) {\n            let alts = m.get(c.state);\n            if (alts === null) {\n                alts = new BitSet();\n                m.put(c.state, alts);\n            }\n            alts.add(c.alt);\n        });\n        return m;\n    },\n\n    hasStateAssociatedWithOneAlt: function(configs) {\n        const values = PredictionMode.getStateToAltMap(configs).values();\n        for(let i=0;i<values.length;i++) {\n            if (values[i].length===1) {\n                return true;\n            }\n        }\n        return false;\n    },\n\n    getSingleViableAlt: function(altsets) {\n        let result = null;\n        for(let i=0;i<altsets.length;i++) {\n            const alts = altsets[i];\n            const minAlt = alts.minValue();\n            if(result===null) {\n                result = minAlt;\n            } else if(result!==minAlt) { // more than 1 viable alt\n                return ATN.INVALID_ALT_NUMBER;\n            }\n        }\n        return result;\n    }\n};\n\nmodule.exports = PredictionMode;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst { Set, Hash, equalArrays } = require('./../Utils');\n\n/**\n * A tree structure used to record the semantic context in which\n * an ATN configuration is valid.  It's either a single predicate,\n * a conjunction {@code p1&&p2}, or a sum of products {@code p1||p2}.\n *\n * <p>I have scoped the {@link AND}, {@link OR}, and {@link Predicate} subclasses of\n * {@link SemanticContext} within the scope of this outer class.</p>\n */\nclass SemanticContext {\n\n\thashCode() {\n\t\tconst hash = new Hash();\n\t\tthis.updateHashCode(hash);\n\t\treturn hash.finish();\n\t}\n\n\t/**\n\t * For context independent predicates, we evaluate them without a local\n\t * context (i.e., null context). That way, we can evaluate them without\n\t * having to create proper rule-specific context during prediction (as\n\t * opposed to the parser, which creates them naturally). In a practical\n\t * sense, this avoids a cast exception from RuleContext to myruleContext.\n\t *\n\t * <p>For context dependent predicates, we must pass in a local context so that\n\t * references such as $arg evaluate properly as _localctx.arg. We only\n\t * capture context dependent predicates in the context in which we begin\n\t * prediction, so we passed in the outer context here in case of context\n\t * dependent predicate evaluation.</p>\n\t */\n\tevaluate(parser, outerContext) {}\n\n\t/**\n\t * Evaluate the precedence predicates for the context and reduce the result.\n\t *\n\t * @param parser The parser instance.\n\t * @param outerContext The current parser context object.\n\t * @return The simplified semantic context after precedence predicates are\n\t * evaluated, which will be one of the following values.\n\t * <ul>\n\t * <li>{@link //NONE}: if the predicate simplifies to {@code true} after\n\t * precedence predicates are evaluated.</li>\n\t * <li>{@code null}: if the predicate simplifies to {@code false} after\n\t * precedence predicates are evaluated.</li>\n\t * <li>{@code this}: if the semantic context is not changed as a result of\n\t * precedence predicate evaluation.</li>\n\t * <li>A non-{@code null} {@link SemanticContext}: the new simplified\n\t * semantic context after precedence predicates are evaluated.</li>\n\t * </ul>\n\t */\n\tevalPrecedence(parser, outerContext) {\n\t\treturn this;\n\t}\n\n\tstatic andContext(a, b) {\n\t\tif (a === null || a === SemanticContext.NONE) {\n\t\t\treturn b;\n\t\t}\n\t\tif (b === null || b === SemanticContext.NONE) {\n\t\t\treturn a;\n\t\t}\n\t\tconst result = new AND(a, b);\n\t\tif (result.opnds.length === 1) {\n\t\t\treturn result.opnds[0];\n\t\t} else {\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tstatic orContext(a, b) {\n\t\tif (a === null) {\n\t\t\treturn b;\n\t\t}\n\t\tif (b === null) {\n\t\t\treturn a;\n\t\t}\n\t\tif (a === SemanticContext.NONE || b === SemanticContext.NONE) {\n\t\t\treturn SemanticContext.NONE;\n\t\t}\n\t\tconst result = new OR(a, b);\n\t\tif (result.opnds.length === 1) {\n\t\t\treturn result.opnds[0];\n\t\t} else {\n\t\t\treturn result;\n\t\t}\n\t}\n}\n\n\nclass Predicate extends SemanticContext {\n\n\tconstructor(ruleIndex, predIndex, isCtxDependent) {\n\t\tsuper();\n\t\tthis.ruleIndex = ruleIndex === undefined ? -1 : ruleIndex;\n\t\tthis.predIndex = predIndex === undefined ? -1 : predIndex;\n\t\tthis.isCtxDependent = isCtxDependent === undefined ? false : isCtxDependent; // e.g., $i ref in pred\n\t}\n\n\tevaluate(parser, outerContext) {\n\t\tconst localctx = this.isCtxDependent ? outerContext : null;\n\t\treturn parser.sempred(localctx, this.ruleIndex, this.predIndex);\n\t}\n\n\tupdateHashCode(hash) {\n\t\thash.update(this.ruleIndex, this.predIndex, this.isCtxDependent);\n\t}\n\n\tequals(other) {\n\t\tif (this === other) {\n\t\t\treturn true;\n\t\t} else if (!(other instanceof Predicate)) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn this.ruleIndex === other.ruleIndex &&\n\t\t\t\t\tthis.predIndex === other.predIndex &&\n\t\t\t\t\tthis.isCtxDependent === other.isCtxDependent;\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn \"{\" + this.ruleIndex + \":\" + this.predIndex + \"}?\";\n\t}\n}\n\n/**\n * The default {@link SemanticContext}, which is semantically equivalent to\n * a predicate of the form {@code {true}?}\n */\nSemanticContext.NONE = new Predicate();\n\n\nclass PrecedencePredicate extends SemanticContext {\n\n\tconstructor(precedence) {\n\t\tsuper();\n\t\tthis.precedence = precedence === undefined ? 0 : precedence;\n\t}\n\n\tevaluate(parser, outerContext) {\n\t\treturn parser.precpred(outerContext, this.precedence);\n\t}\n\n\tevalPrecedence(parser, outerContext) {\n\t\tif (parser.precpred(outerContext, this.precedence)) {\n\t\t\treturn SemanticContext.NONE;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tcompareTo(other) {\n\t\treturn this.precedence - other.precedence;\n\t}\n\n\tupdateHashCode(hash) {\n\t\thash.update(this.precedence);\n\t}\n\n\tequals(other) {\n\t\tif (this === other) {\n\t\t\treturn true;\n\t\t} else if (!(other instanceof PrecedencePredicate)) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn this.precedence === other.precedence;\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn \"{\" + this.precedence + \">=prec}?\";\n\t}\n\n\tstatic filterPrecedencePredicates(set) {\n\t\tconst result = [];\n\t\tset.values().map( function(context) {\n\t\t\tif (context instanceof PrecedencePredicate) {\n\t\t\t\tresult.push(context);\n\t\t\t}\n\t\t});\n\t\treturn result;\n\t}\n}\n\nclass AND extends SemanticContext {\n\t/**\n\t * A semantic context which is true whenever none of the contained contexts\n\t * is false\n\t */\n\tconstructor(a, b) {\n\t\tsuper();\n\t\tconst operands = new Set();\n\t\tif (a instanceof AND) {\n\t\t\ta.opnds.map(function(o) {\n\t\t\t\toperands.add(o);\n\t\t\t});\n\t\t} else {\n\t\t\toperands.add(a);\n\t\t}\n\t\tif (b instanceof AND) {\n\t\t\tb.opnds.map(function(o) {\n\t\t\t\toperands.add(o);\n\t\t\t});\n\t\t} else {\n\t\t\toperands.add(b);\n\t\t}\n\t\tconst precedencePredicates = PrecedencePredicate.filterPrecedencePredicates(operands);\n\t\tif (precedencePredicates.length > 0) {\n\t\t\t// interested in the transition with the lowest precedence\n\t\t\tlet reduced = null;\n\t\t\tprecedencePredicates.map( function(p) {\n\t\t\t\tif(reduced===null || p.precedence<reduced.precedence) {\n\t\t\t\t\treduced = p;\n\t\t\t\t}\n\t\t\t});\n\t\t\toperands.add(reduced);\n\t\t}\n\t\tthis.opnds = Array.from(operands.values());\n\t}\n\n\tequals(other) {\n\t\tif (this === other) {\n\t\t\treturn true;\n\t\t} else if (!(other instanceof AND)) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn equalArrays(this.opnds, other.opnds);\n\t\t}\n\t}\n\n\tupdateHashCode(hash) {\n\t\thash.update(this.opnds, \"AND\");\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t *\n\t * <p>\n\t * The evaluation of predicates by this context is short-circuiting, but\n\t * unordered.</p>\n\t */\n\tevaluate(parser, outerContext) {\n\t\tfor (let i = 0; i < this.opnds.length; i++) {\n\t\t\tif (!this.opnds[i].evaluate(parser, outerContext)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tevalPrecedence(parser, outerContext) {\n\t\tlet differs = false;\n\t\tconst operands = [];\n\t\tfor (let i = 0; i < this.opnds.length; i++) {\n\t\t\tconst context = this.opnds[i];\n\t\t\tconst evaluated = context.evalPrecedence(parser, outerContext);\n\t\t\tdiffers |= (evaluated !== context);\n\t\t\tif (evaluated === null) {\n\t\t\t\t// The AND context is false if any element is false\n\t\t\t\treturn null;\n\t\t\t} else if (evaluated !== SemanticContext.NONE) {\n\t\t\t\t// Reduce the result by skipping true elements\n\t\t\t\toperands.push(evaluated);\n\t\t\t}\n\t\t}\n\t\tif (!differs) {\n\t\t\treturn this;\n\t\t}\n\t\tif (operands.length === 0) {\n\t\t\t// all elements were true, so the AND context is true\n\t\t\treturn SemanticContext.NONE;\n\t\t}\n\t\tlet result = null;\n\t\toperands.map(function(o) {\n\t\t\tresult = result === null ? o : SemanticContext.andContext(result, o);\n\t\t});\n\t\treturn result;\n\t}\n\n\ttoString() {\n\t\tconst s = this.opnds.map(o => o.toString());\n\t\treturn (s.length > 3 ? s.slice(3) : s).join(\"&&\");\n\t}\n}\n\n\nclass OR extends SemanticContext {\n\t/**\n\t * A semantic context which is true whenever at least one of the contained\n\t * contexts is true\n\t */\n\tconstructor(a, b) {\n\t\tsuper();\n\t\tconst operands = new Set();\n\t\tif (a instanceof OR) {\n\t\t\ta.opnds.map(function(o) {\n\t\t\t\toperands.add(o);\n\t\t\t});\n\t\t} else {\n\t\t\toperands.add(a);\n\t\t}\n\t\tif (b instanceof OR) {\n\t\t\tb.opnds.map(function(o) {\n\t\t\t\toperands.add(o);\n\t\t\t});\n\t\t} else {\n\t\t\toperands.add(b);\n\t\t}\n\n\t\tconst precedencePredicates = PrecedencePredicate.filterPrecedencePredicates(operands);\n\t\tif (precedencePredicates.length > 0) {\n\t\t\t// interested in the transition with the highest precedence\n\t\t\tconst s = precedencePredicates.sort(function(a, b) {\n\t\t\t\treturn a.compareTo(b);\n\t\t\t});\n\t\t\tconst reduced = s[s.length-1];\n\t\t\toperands.add(reduced);\n\t\t}\n\t\tthis.opnds = Array.from(operands.values());\n\t}\n\n\tequals(other) {\n\t\tif (this === other) {\n\t\t\treturn true;\n\t\t} else if (!(other instanceof OR)) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn equalArrays(this.opnds, other.opnds);\n\t\t}\n\t}\n\n\tupdateHashCode(hash) {\n\t\thash.update(this.opnds, \"OR\");\n\t}\n\n\t/**\n\t * <p>\n\t * The evaluation of predicates by this context is short-circuiting, but\n\t * unordered.</p>\n\t */\n\tevaluate(parser, outerContext) {\n\t\tfor (let i = 0; i < this.opnds.length; i++) {\n\t\t\tif (this.opnds[i].evaluate(parser, outerContext)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tevalPrecedence(parser, outerContext) {\n\t\tlet differs = false;\n\t\tconst operands = [];\n\t\tfor (let i = 0; i < this.opnds.length; i++) {\n\t\t\tconst context = this.opnds[i];\n\t\t\tconst evaluated = context.evalPrecedence(parser, outerContext);\n\t\t\tdiffers |= (evaluated !== context);\n\t\t\tif (evaluated === SemanticContext.NONE) {\n\t\t\t\t// The OR context is true if any element is true\n\t\t\t\treturn SemanticContext.NONE;\n\t\t\t} else if (evaluated !== null) {\n\t\t\t\t// Reduce the result by skipping false elements\n\t\t\t\toperands.push(evaluated);\n\t\t\t}\n\t\t}\n\t\tif (!differs) {\n\t\t\treturn this;\n\t\t}\n\t\tif (operands.length === 0) {\n\t\t\t// all elements were false, so the OR context is false\n\t\t\treturn null;\n\t\t}\n\t\tconst result = null;\n\t\toperands.map(function(o) {\n\t\t\treturn result === null ? o : SemanticContext.orContext(result, o);\n\t\t});\n\t\treturn result;\n\t}\n\n\ttoString() {\n\t\tconst s = this.opnds.map(o => o.toString());\n\t\treturn (s.length > 3 ? s.slice(3) : s).join(\"||\");\n\t}\n}\n\nmodule.exports = {\n\tSemanticContext,\n\tPrecedencePredicate,\n\tPredicate\n}\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Token} = require('./../Token');\nconst {IntervalSet} = require('./../IntervalSet');\nconst {Predicate, PrecedencePredicate} = require('./SemanticContext');\n\n/**\n * An ATN transition between any two ATN states.  Subclasses define\n * atom, set, epsilon, action, predicate, rule transitions.\n *\n * <p>This is a one way link.  It emanates from a state (usually via a list of\n * transitions) and has a target state.</p>\n *\n * <p>Since we never have to change the ATN transitions once we construct it,\n * we can fix these transitions as specific classes. The DFA transitions\n * on the other hand need to update the labels as it adds transitions to\n * the states. We'll use the term Edge for the DFA to distinguish them from\n * ATN transitions.</p>\n */\nclass Transition {\n    constructor(target) {\n        // The target of this transition.\n        if (target===undefined || target===null) {\n            throw \"target cannot be null.\";\n        }\n        this.target = target;\n        // Are we epsilon, action, sempred?\n        this.isEpsilon = false;\n        this.label = null;\n    }\n}\n\n// constants for serialization\n\nTransition.EPSILON = 1;\nTransition.RANGE = 2;\nTransition.RULE = 3;\n// e.g., {isType(input.LT(1))}?\nTransition.PREDICATE = 4;\nTransition.ATOM = 5;\nTransition.ACTION = 6;\n// ~(A|B) or ~atom, wildcard, which convert to next 2\nTransition.SET = 7;\nTransition.NOT_SET = 8;\nTransition.WILDCARD = 9;\nTransition.PRECEDENCE = 10;\n\nTransition.serializationNames = [\n            \"INVALID\",\n            \"EPSILON\",\n            \"RANGE\",\n            \"RULE\",\n            \"PREDICATE\",\n            \"ATOM\",\n            \"ACTION\",\n            \"SET\",\n            \"NOT_SET\",\n            \"WILDCARD\",\n            \"PRECEDENCE\"\n        ];\n\nTransition.serializationTypes = {\n        EpsilonTransition: Transition.EPSILON,\n        RangeTransition: Transition.RANGE,\n        RuleTransition: Transition.RULE,\n        PredicateTransition: Transition.PREDICATE,\n        AtomTransition: Transition.ATOM,\n        ActionTransition: Transition.ACTION,\n        SetTransition: Transition.SET,\n        NotSetTransition: Transition.NOT_SET,\n        WildcardTransition: Transition.WILDCARD,\n        PrecedencePredicateTransition: Transition.PRECEDENCE\n    };\n\n\n// TODO: make all transitions sets? no, should remove set edges\n\nclass AtomTransition extends Transition {\n    constructor(target, label) {\n        super(target);\n        // The token type or character value; or, signifies special label.\n        this.label_ = label;\n        this.label = this.makeLabel();\n        this.serializationType = Transition.ATOM;\n    }\n\n    makeLabel() {\n        const s = new IntervalSet();\n        s.addOne(this.label_);\n        return s;\n    }\n\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n        return this.label_ === symbol;\n    }\n\n    toString() {\n        return this.label_;\n    }\n}\n\n\nclass RuleTransition extends Transition {\n    constructor(ruleStart, ruleIndex, precedence, followState) {\n        super(ruleStart);\n        // ptr to the rule definition object for this rule ref\n        this.ruleIndex = ruleIndex;\n        this.precedence = precedence;\n        // what node to begin computations following ref to rule\n        this.followState = followState;\n        this.serializationType = Transition.RULE;\n        this.isEpsilon = true;\n    }\n\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n        return false;\n    }\n}\n\nclass EpsilonTransition extends Transition {\n    constructor(target, outermostPrecedenceReturn) {\n        super(target);\n        this.serializationType = Transition.EPSILON;\n        this.isEpsilon = true;\n        this.outermostPrecedenceReturn = outermostPrecedenceReturn;\n    }\n\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n        return false;\n    }\n\n    toString() {\n        return \"epsilon\";\n    }\n}\n\n\nclass RangeTransition extends Transition {\n    constructor(target, start, stop) {\n        super(target);\n        this.serializationType = Transition.RANGE;\n        this.start = start;\n        this.stop = stop;\n        this.label = this.makeLabel();\n    }\n\n    makeLabel() {\n        const s = new IntervalSet();\n        s.addRange(this.start, this.stop);\n        return s;\n    }\n\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n        return symbol >= this.start && symbol <= this.stop;\n    }\n\n    toString() {\n        return \"'\" + String.fromCharCode(this.start) + \"'..'\" + String.fromCharCode(this.stop) + \"'\";\n    }\n}\n\n\nclass AbstractPredicateTransition extends Transition {\n    constructor(target) {\n        super(target);\n    }\n}\n\nclass PredicateTransition extends AbstractPredicateTransition {\n    constructor(target, ruleIndex, predIndex, isCtxDependent) {\n        super(target);\n        this.serializationType = Transition.PREDICATE;\n        this.ruleIndex = ruleIndex;\n        this.predIndex = predIndex;\n        this.isCtxDependent = isCtxDependent; // e.g., $i ref in pred\n        this.isEpsilon = true;\n    }\n\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n        return false;\n    }\n\n    getPredicate() {\n        return new Predicate(this.ruleIndex, this.predIndex, this.isCtxDependent);\n    }\n\n    toString() {\n        return \"pred_\" + this.ruleIndex + \":\" + this.predIndex;\n    }\n}\n\n\nclass ActionTransition extends Transition {\n    constructor(target, ruleIndex, actionIndex, isCtxDependent) {\n        super(target);\n        this.serializationType = Transition.ACTION;\n        this.ruleIndex = ruleIndex;\n        this.actionIndex = actionIndex===undefined ? -1 : actionIndex;\n        this.isCtxDependent = isCtxDependent===undefined ? false : isCtxDependent; // e.g., $i ref in pred\n        this.isEpsilon = true;\n    }\n\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n        return false;\n    }\n\n    toString() {\n        return \"action_\" + this.ruleIndex + \":\" + this.actionIndex;\n    }\n}\n\n\n// A transition containing a set of values.\nclass SetTransition extends Transition {\n    constructor(target, set) {\n        super(target);\n        this.serializationType = Transition.SET;\n        if (set !==undefined && set !==null) {\n            this.label = set;\n        } else {\n            this.label = new IntervalSet();\n            this.label.addOne(Token.INVALID_TYPE);\n        }\n    }\n\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n        return this.label.contains(symbol);\n    }\n\n    toString() {\n        return this.label.toString();\n    }\n}\n\nclass NotSetTransition extends SetTransition {\n    constructor(target, set) {\n        super(target, set);\n        this.serializationType = Transition.NOT_SET;\n    }\n\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n        return symbol >= minVocabSymbol && symbol <= maxVocabSymbol &&\n                !super.matches(symbol, minVocabSymbol, maxVocabSymbol);\n    }\n\n    toString() {\n        return '~' + super.toString();\n    }\n}\n\nclass WildcardTransition extends Transition {\n    constructor(target) {\n        super(target);\n        this.serializationType = Transition.WILDCARD;\n    }\n\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n        return symbol >= minVocabSymbol && symbol <= maxVocabSymbol;\n    }\n\n    toString() {\n        return \".\";\n    }\n}\n\nclass PrecedencePredicateTransition extends AbstractPredicateTransition {\n    constructor(target, precedence) {\n        super(target);\n        this.serializationType = Transition.PRECEDENCE;\n        this.precedence = precedence;\n        this.isEpsilon = true;\n    }\n\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n        return false;\n    }\n\n    getPredicate() {\n        return new PrecedencePredicate(this.precedence);\n    }\n\n    toString() {\n        return this.precedence + \" >= _p\";\n    }\n}\n\nmodule.exports = {\n    Transition,\n    AtomTransition,\n    SetTransition,\n    NotSetTransition,\n    RuleTransition,\n    ActionTransition,\n    EpsilonTransition,\n    RangeTransition,\n    WildcardTransition,\n    PredicateTransition,\n    PrecedencePredicateTransition,\n    AbstractPredicateTransition\n}\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nexports.ATN = require('./ATN');\nexports.ATNDeserializer = require('./ATNDeserializer');\nexports.LexerATNSimulator = require('./LexerATNSimulator');\nexports.ParserATNSimulator = require('./ParserATNSimulator');\nexports.PredictionMode = require('./PredictionMode');\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Set} = require(\"../Utils\");\nconst {DFAState} = require('./DFAState');\nconst {StarLoopEntryState} = require('../atn/ATNState');\nconst {ATNConfigSet} = require('./../atn/ATNConfigSet');\nconst {DFASerializer} = require('./DFASerializer');\nconst {LexerDFASerializer} = require('./DFASerializer');\n\nclass DFA {\n\tconstructor(atnStartState, decision) {\n\t\tif (decision === undefined) {\n\t\t\tdecision = 0;\n\t\t}\n\t\t/**\n\t\t * From which ATN state did we create this DFA?\n\t\t */\n\t\tthis.atnStartState = atnStartState;\n\t\tthis.decision = decision;\n\t\t/**\n\t\t * A set of all DFA states. Use {@link Map} so we can get old state back\n\t\t * ({@link Set} only allows you to see if it's there).\n\t\t */\n\t\tthis._states = new Set();\n\t\tthis.s0 = null;\n\t\t/**\n\t\t * {@code true} if this DFA is for a precedence decision; otherwise,\n\t\t * {@code false}. This is the backing field for {@link //isPrecedenceDfa},\n\t\t * {@link //setPrecedenceDfa}\n\t\t */\n\t\tthis.precedenceDfa = false;\n\t\tif (atnStartState instanceof StarLoopEntryState)\n\t\t{\n\t\t\tif (atnStartState.isPrecedenceDecision) {\n\t\t\t\tthis.precedenceDfa = true;\n\t\t\t\tconst precedenceState = new DFAState(null, new ATNConfigSet());\n\t\t\t\tprecedenceState.edges = [];\n\t\t\t\tprecedenceState.isAcceptState = false;\n\t\t\t\tprecedenceState.requiresFullContext = false;\n\t\t\t\tthis.s0 = precedenceState;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get the start state for a specific precedence value.\n\t *\n\t * @param precedence The current precedence.\n\t * @return The start state corresponding to the specified precedence, or\n\t * {@code null} if no start state exists for the specified precedence.\n\t *\n\t * @throws IllegalStateException if this is not a precedence DFA.\n\t * @see //isPrecedenceDfa()\n\t */\n\tgetPrecedenceStartState(precedence) {\n\t\tif (!(this.precedenceDfa)) {\n\t\t\tthrow (\"Only precedence DFAs may contain a precedence start state.\");\n\t\t}\n\t\t// s0.edges is never null for a precedence DFA\n\t\tif (precedence < 0 || precedence >= this.s0.edges.length) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this.s0.edges[precedence] || null;\n\t}\n\n\t/**\n\t * Set the start state for a specific precedence value.\n\t *\n\t * @param precedence The current precedence.\n\t * @param startState The start state corresponding to the specified\n\t * precedence.\n\t *\n\t * @throws IllegalStateException if this is not a precedence DFA.\n\t * @see //isPrecedenceDfa()\n\t */\n\tsetPrecedenceStartState(precedence, startState) {\n\t\tif (!(this.precedenceDfa)) {\n\t\t\tthrow (\"Only precedence DFAs may contain a precedence start state.\");\n\t\t}\n\t\tif (precedence < 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t/**\n\t\t * synchronization on s0 here is ok. when the DFA is turned into a\n\t\t * precedence DFA, s0 will be initialized once and not updated again\n\t\t * s0.edges is never null for a precedence DFA\n\t\t */\n\t\tthis.s0.edges[precedence] = startState;\n\t}\n\n\t/**\n\t * Sets whether this is a precedence DFA. If the specified value differs\n\t * from the current DFA configuration, the following actions are taken;\n\t * otherwise no changes are made to the current DFA.\n\t *\n\t * <ul>\n\t * <li>The {@link //states} map is cleared</li>\n\t * <li>If {@code precedenceDfa} is {@code false}, the initial state\n\t * {@link //s0} is set to {@code null}; otherwise, it is initialized to a new\n\t * {@link DFAState} with an empty outgoing {@link DFAState//edges} array to\n\t * store the start states for individual precedence values.</li>\n\t * <li>The {@link //precedenceDfa} field is updated</li>\n\t * </ul>\n\t *\n\t * @param precedenceDfa {@code true} if this is a precedence DFA; otherwise,\n\t * {@code false}\n\t */\n\tsetPrecedenceDfa(precedenceDfa) {\n\t\tif (this.precedenceDfa!==precedenceDfa) {\n\t\t\tthis._states = new Set();\n\t\t\tif (precedenceDfa) {\n\t\t\t\tconst precedenceState = new DFAState(null, new ATNConfigSet());\n\t\t\t\tprecedenceState.edges = [];\n\t\t\t\tprecedenceState.isAcceptState = false;\n\t\t\t\tprecedenceState.requiresFullContext = false;\n\t\t\t\tthis.s0 = precedenceState;\n\t\t\t} else {\n\t\t\t\tthis.s0 = null;\n\t\t\t}\n\t\t\tthis.precedenceDfa = precedenceDfa;\n\t\t}\n\t}\n\n\t/**\n\t * Return a list of all states in this DFA, ordered by state number.\n\t */\n\tsortedStates() {\n\t\tconst list = this._states.values();\n\t\treturn list.sort(function(a, b) {\n\t\t\treturn a.stateNumber - b.stateNumber;\n\t\t});\n\t}\n\n\ttoString(literalNames, symbolicNames) {\n\t\tliteralNames = literalNames || null;\n\t\tsymbolicNames = symbolicNames || null;\n\t\tif (this.s0 === null) {\n\t\t\treturn \"\";\n\t\t}\n\t\tconst serializer = new DFASerializer(this, literalNames, symbolicNames);\n\t\treturn serializer.toString();\n\t}\n\n\ttoLexerString() {\n\t\tif (this.s0 === null) {\n\t\t\treturn \"\";\n\t\t}\n\t\tconst serializer = new LexerDFASerializer(this);\n\t\treturn serializer.toString();\n\t}\n\n\tget states(){\n\t\treturn this._states;\n\t}\n}\n\n\nmodule.exports = DFA;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\nconst Utils = require('./../Utils');\n\n/**\n * A DFA walker that knows how to dump them to serialized strings.\n */\nclass DFASerializer {\n    constructor(dfa, literalNames, symbolicNames) {\n        this.dfa = dfa;\n        this.literalNames = literalNames || [];\n        this.symbolicNames = symbolicNames || [];\n    }\n\n    toString() {\n       if(this.dfa.s0 === null) {\n           return null;\n       }\n       let buf = \"\";\n       const states = this.dfa.sortedStates();\n       for(let i=0; i<states.length; i++) {\n           const s = states[i];\n           if(s.edges!==null) {\n                const n = s.edges.length;\n                for(let j=0;j<n;j++) {\n                    const t = s.edges[j] || null;\n                    if(t!==null && t.stateNumber !== 0x7FFFFFFF) {\n                        buf = buf.concat(this.getStateString(s));\n                        buf = buf.concat(\"-\");\n                        buf = buf.concat(this.getEdgeLabel(j));\n                        buf = buf.concat(\"->\");\n                        buf = buf.concat(this.getStateString(t));\n                        buf = buf.concat('\\n');\n                    }\n                }\n           }\n       }\n       return buf.length===0 ? null : buf;\n    }\n\n    getEdgeLabel(i) {\n        if (i===0) {\n            return \"EOF\";\n        } else if(this.literalNames !==null || this.symbolicNames!==null) {\n            return this.literalNames[i-1] || this.symbolicNames[i-1];\n        } else {\n            return String.fromCharCode(i-1);\n        }\n    }\n\n    getStateString(s) {\n        const baseStateStr = ( s.isAcceptState ? \":\" : \"\") + \"s\" + s.stateNumber + ( s.requiresFullContext ? \"^\" : \"\");\n        if(s.isAcceptState) {\n            if (s.predicates !== null) {\n                return baseStateStr + \"=>\" + Utils.arrayToString(s.predicates);\n            } else {\n                return baseStateStr + \"=>\" + s.prediction.toString();\n            }\n        } else {\n            return baseStateStr;\n        }\n    }\n}\n\nclass LexerDFASerializer extends DFASerializer {\n    constructor(dfa) {\n        super(dfa, null);\n    }\n\n    getEdgeLabel(i) {\n        return \"'\" + String.fromCharCode(i) + \"'\";\n    }\n}\n\nmodule.exports = { DFASerializer , LexerDFASerializer };\n\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {ATNConfigSet} = require('./../atn/ATNConfigSet');\nconst {Hash, Set} = require('./../Utils');\n\n/**\n * Map a predicate to a predicted alternative.\n */\nclass PredPrediction {\n\tconstructor(pred, alt) {\n\t\tthis.alt = alt;\n\t\tthis.pred = pred;\n\t}\n\n\ttoString() {\n\t\treturn \"(\" + this.pred + \", \" + this.alt + \")\";\n\t}\n}\n\n/**\n * A DFA state represents a set of possible ATN configurations.\n * As Aho, Sethi, Ullman p. 117 says \"The DFA uses its state\n * to keep track of all possible states the ATN can be in after\n * reading each input symbol. That is to say, after reading\n * input a1a2..an, the DFA is in a state that represents the\n * subset T of the states of the ATN that are reachable from the\n * ATN's start state along some path labeled a1a2..an.\"\n * In conventional NFA&rarr;DFA conversion, therefore, the subset T\n * would be a bitset representing the set of states the\n * ATN could be in. We need to track the alt predicted by each\n * state as well, however. More importantly, we need to maintain\n * a stack of states, tracking the closure operations as they\n * jump from rule to rule, emulating rule invocations (method calls).\n * I have to add a stack to simulate the proper lookahead sequences for\n * the underlying LL grammar from which the ATN was derived.\n *\n * <p>I use a set of ATNConfig objects not simple states. An ATNConfig\n * is both a state (ala normal conversion) and a RuleContext describing\n * the chain of rules (if any) followed to arrive at that state.</p>\n *\n * <p>A DFA state may have multiple references to a particular state,\n * but with different ATN contexts (with same or different alts)\n * meaning that state was reached via a different set of rule invocations.</p>\n */\nclass DFAState {\n\tconstructor(stateNumber, configs) {\n\t\tif (stateNumber === null) {\n\t\t\tstateNumber = -1;\n\t\t}\n\t\tif (configs === null) {\n\t\t\tconfigs = new ATNConfigSet();\n\t\t}\n\t\tthis.stateNumber = stateNumber;\n\t\tthis.configs = configs;\n\t\t/**\n\t\t * {@code edges[symbol]} points to target of symbol. Shift up by 1 so (-1)\n\t\t * {@link Token//EOF} maps to {@code edges[0]}.\n\t\t */\n\t\tthis.edges = null;\n\t\tthis.isAcceptState = false;\n\t\t/**\n\t\t * if accept state, what ttype do we match or alt do we predict?\n\t\t * This is set to {@link ATN//INVALID_ALT_NUMBER} when {@link//predicates}\n\t\t * {@code !=null} or {@link //requiresFullContext}.\n\t\t */\n\t\tthis.prediction = 0;\n\t\tthis.lexerActionExecutor = null;\n\t\t/**\n\t\t * Indicates that this state was created during SLL prediction that\n\t\t * discovered a conflict between the configurations in the state. Future\n\t\t * {@link ParserATNSimulator//execATN} invocations immediately jumped doing\n\t\t * full context prediction if this field is true.\n\t\t */\n\t\tthis.requiresFullContext = false;\n\t\t/**\n\t\t * During SLL parsing, this is a list of predicates associated with the\n\t\t * ATN configurations of the DFA state. When we have predicates,\n\t\t * {@link //requiresFullContext} is {@code false} since full context\n\t\t * prediction evaluates predicates\n\t\t * on-the-fly. If this is not null, then {@link //prediction} is\n\t\t * {@link ATN//INVALID_ALT_NUMBER}.\n\t\t *\n\t\t * <p>We only use these for non-{@link //requiresFullContext} but\n\t\t * conflicting states. That\n\t\t * means we know from the context (it's $ or we don't dip into outer\n\t\t * context) that it's an ambiguity not a conflict.</p>\n\t\t *\n\t\t * <p>This list is computed by {@link\n\t\t * ParserATNSimulator//predicateDFAState}.</p>\n\t\t */\n\t\tthis.predicates = null;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the set of all alts mentioned by all ATN configurations in this\n\t * DFA state.\n\t */\n\tgetAltSet() {\n\t\tconst alts = new Set();\n\t\tif (this.configs !== null) {\n\t\t\tfor (let i = 0; i < this.configs.length; i++) {\n\t\t\t\tconst c = this.configs[i];\n\t\t\t\talts.add(c.alt);\n\t\t\t}\n\t\t}\n\t\tif (alts.length === 0) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\treturn alts;\n\t\t}\n\t}\n\n\t/**\n\t * Two {@link DFAState} instances are equal if their ATN configuration sets\n\t * are the same. This method is used to see if a state already exists.\n\t *\n\t * <p>Because the number of alternatives and number of ATN configurations are\n\t * finite, there is a finite number of DFA states that can be processed.\n\t * This is necessary to show that the algorithm terminates.</p>\n\t *\n\t * <p>Cannot test the DFA state numbers here because in\n\t * {@link ParserATNSimulator//addDFAState} we need to know if any other state\n\t * exists that has this exact set of ATN configurations. The\n\t * {@link //stateNumber} is irrelevant.</p>\n\t */\n\tequals(other) {\n\t\t// compare set of ATN configurations in this set with other\n\t\treturn this === other ||\n\t\t\t\t(other instanceof DFAState &&\n\t\t\t\t\tthis.configs.equals(other.configs));\n\t}\n\n\ttoString() {\n\t\tlet s = \"\" + this.stateNumber + \":\" + this.configs;\n\t\tif(this.isAcceptState) {\n\t\t\ts = s + \"=>\";\n\t\t\tif (this.predicates !== null)\n\t\t\t\ts = s + this.predicates;\n\t\t\telse\n\t\t\t\ts = s + this.prediction;\n\t\t}\n\t\treturn s;\n\t}\n\n\thashCode() {\n\t\tconst hash = new Hash();\n\t\thash.update(this.configs);\n\t\treturn hash.finish();\n\t}\n}\n\nmodule.exports = { DFAState, PredPrediction };\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nexports.DFA = require('./DFA');\nexports.DFASerializer = require('./DFASerializer').DFASerializer;\nexports.LexerDFASerializer = require('./DFASerializer').LexerDFASerializer;\nexports.PredPrediction = require('./DFAState').PredPrediction;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {BitSet} = require('./../Utils');\nconst {ErrorListener} = require('./ErrorListener')\nconst {Interval} = require('./../IntervalSet')\n\n\n/**\n * This implementation of {@link ANTLRErrorListener} can be used to identify\n *  certain potential correctness and performance problems in grammars. \"Reports\"\n *  are made by calling {@link Parser//notifyErrorListeners} with the appropriate\n *  message.\n *\n *  <ul>\n *  <li><b>Ambiguities</b>: These are cases where more than one path through the\n *  grammar can match the input.</li>\n *  <li><b>Weak context sensitivity</b>: These are cases where full-context\n *  prediction resolved an SLL conflict to a unique alternative which equaled the\n *  minimum alternative of the SLL conflict.</li>\n *  <li><b>Strong (forced) context sensitivity</b>: These are cases where the\n *  full-context prediction resolved an SLL conflict to a unique alternative,\n *  <em>and</em> the minimum alternative of the SLL conflict was found to not be\n *  a truly viable alternative. Two-stage parsing cannot be used for inputs where\n *  this situation occurs.</li>\n *  </ul>\n */\nclass DiagnosticErrorListener extends ErrorListener {\n\tconstructor(exactOnly) {\n\t\tsuper();\n\t\texactOnly = exactOnly || true;\n\t\t// whether all ambiguities or only exact ambiguities are reported.\n\t\tthis.exactOnly = exactOnly;\n\t}\n\n\treportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {\n\t\tif (this.exactOnly && !exact) {\n\t\t\treturn;\n\t\t}\n\t\tconst msg = \"reportAmbiguity d=\" +\n\t\t\tthis.getDecisionDescription(recognizer, dfa) +\n\t\t\t\": ambigAlts=\" +\n\t\t\tthis.getConflictingAlts(ambigAlts, configs) +\n\t\t\t\", input='\" +\n\t\t\trecognizer.getTokenStream().getText(new Interval(startIndex, stopIndex)) + \"'\"\n\t\trecognizer.notifyErrorListeners(msg);\n\t}\n\n\treportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {\n\t\tconst msg = \"reportAttemptingFullContext d=\" +\n\t\t\tthis.getDecisionDescription(recognizer, dfa) +\n\t\t\t\", input='\" +\n\t\t\trecognizer.getTokenStream().getText(new Interval(startIndex, stopIndex)) + \"'\"\n\t\trecognizer.notifyErrorListeners(msg);\n\t}\n\n\treportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs) {\n\t\tconst msg = \"reportContextSensitivity d=\" +\n\t\t\tthis.getDecisionDescription(recognizer, dfa) +\n\t\t\t\", input='\" +\n\t\t\trecognizer.getTokenStream().getText(new Interval(startIndex, stopIndex)) + \"'\"\n\t\trecognizer.notifyErrorListeners(msg);\n\t}\n\n\tgetDecisionDescription(recognizer, dfa) {\n\t\tconst decision = dfa.decision\n\t\tconst ruleIndex = dfa.atnStartState.ruleIndex\n\n\t\tconst ruleNames = recognizer.ruleNames\n\t\tif (ruleIndex < 0 || ruleIndex >= ruleNames.length) {\n\t\t\treturn \"\" + decision;\n\t\t}\n\t\tconst ruleName = ruleNames[ruleIndex] || null\n\t\tif (ruleName === null || ruleName.length === 0) {\n\t\t\treturn \"\" + decision;\n\t\t}\n\t\treturn `${decision} (${ruleName})`;\n\t}\n\n\t/**\n\t * Computes the set of conflicting or ambiguous alternatives from a\n\t * configuration set, if that information was not already provided by the\n\t * parser.\n\t *\n\t * @param reportedAlts The set of conflicting or ambiguous alternatives, as\n\t * reported by the parser.\n\t * @param configs The conflicting or ambiguous configuration set.\n\t * @return Returns {@code reportedAlts} if it is not {@code null}, otherwise\n\t * returns the set of alternatives represented in {@code configs}.\n     */\n\tgetConflictingAlts(reportedAlts, configs) {\n\t\tif (reportedAlts !== null) {\n\t\t\treturn reportedAlts;\n\t\t}\n\t\tconst result = new BitSet()\n\t\tfor (let i = 0; i < configs.items.length; i++) {\n\t\t\tresult.add(configs.items[i].alt);\n\t\t}\n\t\treturn `{${result.values().join(\", \")}}`;\n\t}\n}\n\nmodule.exports = DiagnosticErrorListener\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\n/**\n * Provides an empty default implementation of {@link ANTLRErrorListener}. The\n * default implementation of each method does nothing, but can be overridden as\n * necessary.\n */\nclass ErrorListener {\n    syntaxError(recognizer, offendingSymbol, line, column, msg, e) {\n    }\n\n    reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {\n    }\n\n    reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {\n    }\n\n    reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs) {\n    }\n}\n\n/**\n * {@inheritDoc}\n *\n * <p>\n * This implementation prints messages to {@link System//err} containing the\n * values of {@code line}, {@code charPositionInLine}, and {@code msg} using\n * the following format.</p>\n *\n * <pre>\n * line <em>line</em>:<em>charPositionInLine</em> <em>msg</em>\n * </pre>\n *\n */\nclass ConsoleErrorListener extends ErrorListener {\n    constructor() {\n        super();\n    }\n\n    syntaxError(recognizer, offendingSymbol, line, column, msg, e) {\n        console.error(\"line \" + line + \":\" + column + \" \" + msg);\n    }\n}\n\n\n/**\n * Provides a default instance of {@link ConsoleErrorListener}.\n */\nConsoleErrorListener.INSTANCE = new ConsoleErrorListener();\n\nclass ProxyErrorListener extends ErrorListener {\n    constructor(delegates) {\n        super();\n        if (delegates===null) {\n            throw \"delegates\";\n        }\n        this.delegates = delegates;\n        return this;\n    }\n\n    syntaxError(recognizer, offendingSymbol, line, column, msg, e) {\n        this.delegates.map(d => d.syntaxError(recognizer, offendingSymbol, line, column, msg, e));\n    }\n\n    reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {\n        this.delegates.map(d => d.reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs));\n    }\n\n    reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {\n        this.delegates.map(d => d.reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs));\n    }\n\n    reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs) {\n        this.delegates.map(d => d.reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs));\n    }\n}\n\nmodule.exports = {ErrorListener, ConsoleErrorListener, ProxyErrorListener}\n\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Token} = require('./../Token')\nconst {NoViableAltException, InputMismatchException, FailedPredicateException, ParseCancellationException} = require('./Errors')\nconst {ATNState} = require('./../atn/ATNState')\nconst {Interval, IntervalSet} = require('./../IntervalSet')\n\nclass ErrorStrategy {\n\n    reset(recognizer) {\n    }\n\n    recoverInline(recognizer) {\n    }\n\n    recover(recognizer, e) {\n    }\n\n    sync(recognizer) {\n    }\n\n    inErrorRecoveryMode(recognizer) {\n    }\n\n    reportError(recognizer) {\n    }\n}\n\n\n/**\n * This is the default implementation of {@link ANTLRErrorStrategy} used for\n * error reporting and recovery in ANTLR parsers.\n*/\nclass DefaultErrorStrategy extends ErrorStrategy {\n    constructor() {\n        super();\n        /**\n         * Indicates whether the error strategy is currently \"recovering from an\n         * error\". This is used to suppress reporting multiple error messages while\n         * attempting to recover from a detected syntax error.\n         *\n         * @see //inErrorRecoveryMode\n         */\n        this.errorRecoveryMode = false;\n\n        /**\n         * The index into the input stream where the last error occurred.\n         * This is used to prevent infinite loops where an error is found\n         * but no token is consumed during recovery...another error is found,\n         * ad nauseum. This is a failsafe mechanism to guarantee that at least\n         * one token/tree node is consumed for two errors.\n         */\n        this.lastErrorIndex = -1;\n        this.lastErrorStates = null;\n        this.nextTokensContext = null;\n        this.nextTokenState = 0;\n    }\n\n    /**\n     * <p>The default implementation simply calls {@link //endErrorCondition} to\n     * ensure that the handler is not in error recovery mode.</p>\n    */\n    reset(recognizer) {\n        this.endErrorCondition(recognizer);\n    }\n\n    /**\n     * This method is called to enter error recovery mode when a recognition\n     * exception is reported.\n     *\n     * @param recognizer the parser instance\n    */\n    beginErrorCondition(recognizer) {\n        this.errorRecoveryMode = true;\n    }\n\n    inErrorRecoveryMode(recognizer) {\n        return this.errorRecoveryMode;\n    }\n\n    /**\n     * This method is called to leave error recovery mode after recovering from\n     * a recognition exception.\n     * @param recognizer\n     */\n    endErrorCondition(recognizer) {\n        this.errorRecoveryMode = false;\n        this.lastErrorStates = null;\n        this.lastErrorIndex = -1;\n    }\n\n    /**\n     * {@inheritDoc}\n     * <p>The default implementation simply calls {@link //endErrorCondition}.</p>\n     */\n    reportMatch(recognizer) {\n        this.endErrorCondition(recognizer);\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * <p>The default implementation returns immediately if the handler is already\n     * in error recovery mode. Otherwise, it calls {@link //beginErrorCondition}\n     * and dispatches the reporting task based on the runtime type of {@code e}\n     * according to the following table.</p>\n     *\n     * <ul>\n     * <li>{@link NoViableAltException}: Dispatches the call to\n     * {@link //reportNoViableAlternative}</li>\n     * <li>{@link InputMismatchException}: Dispatches the call to\n     * {@link //reportInputMismatch}</li>\n     * <li>{@link FailedPredicateException}: Dispatches the call to\n     * {@link //reportFailedPredicate}</li>\n     * <li>All other types: calls {@link Parser//notifyErrorListeners} to report\n     * the exception</li>\n     * </ul>\n     */\n    reportError(recognizer, e) {\n       // if we've already reported an error and have not matched a token\n       // yet successfully, don't report any errors.\n        if(this.inErrorRecoveryMode(recognizer)) {\n            return; // don't report spurious errors\n        }\n        this.beginErrorCondition(recognizer);\n        if ( e instanceof NoViableAltException ) {\n            this.reportNoViableAlternative(recognizer, e);\n        } else if ( e instanceof InputMismatchException ) {\n            this.reportInputMismatch(recognizer, e);\n        } else if ( e instanceof FailedPredicateException ) {\n            this.reportFailedPredicate(recognizer, e);\n        } else {\n            console.log(\"unknown recognition error type: \" + e.constructor.name);\n            console.log(e.stack);\n            recognizer.notifyErrorListeners(e.getOffendingToken(), e.getMessage(), e);\n        }\n    }\n\n    /**\n     *\n     * {@inheritDoc}\n     *\n     * <p>The default implementation resynchronizes the parser by consuming tokens\n     * until we find one in the resynchronization set--loosely the set of tokens\n     * that can follow the current rule.</p>\n     *\n     */\n    recover(recognizer, e) {\n        if (this.lastErrorIndex===recognizer.getInputStream().index &&\n            this.lastErrorStates !== null && this.lastErrorStates.indexOf(recognizer.state)>=0) {\n            // uh oh, another error at same token index and previously-visited\n            // state in ATN; must be a case where LT(1) is in the recovery\n            // token set so nothing got consumed. Consume a single token\n            // at least to prevent an infinite loop; this is a failsafe.\n            recognizer.consume();\n        }\n        this.lastErrorIndex = recognizer._input.index;\n        if (this.lastErrorStates === null) {\n            this.lastErrorStates = [];\n        }\n        this.lastErrorStates.push(recognizer.state);\n        const followSet = this.getErrorRecoverySet(recognizer)\n        this.consumeUntil(recognizer, followSet);\n    }\n\n    /**\n     * The default implementation of {@link ANTLRErrorStrategy//sync} makes sure\n     * that the current lookahead symbol is consistent with what were expecting\n     * at this point in the ATN. You can call this anytime but ANTLR only\n     * generates code to check before subrules/loops and each iteration.\n     *\n     * <p>Implements Jim Idle's magic sync mechanism in closures and optional\n     * subrules. E.g.,</p>\n     *\n     * <pre>\n     * a : sync ( stuff sync )* ;\n     * sync : {consume to what can follow sync} ;\n     * </pre>\n     *\n     * At the start of a sub rule upon error, {@link //sync} performs single\n     * token deletion, if possible. If it can't do that, it bails on the current\n     * rule and uses the default error recovery, which consumes until the\n     * resynchronization set of the current rule.\n     *\n     * <p>If the sub rule is optional ({@code (...)?}, {@code (...)*}, or block\n     * with an empty alternative), then the expected set includes what follows\n     * the subrule.</p>\n     *\n     * <p>During loop iteration, it consumes until it sees a token that can start a\n     * sub rule or what follows loop. Yes, that is pretty aggressive. We opt to\n     * stay in the loop as long as possible.</p>\n     *\n     * <p><strong>ORIGINS</strong></p>\n     *\n     * <p>Previous versions of ANTLR did a poor job of their recovery within loops.\n     * A single mismatch token or missing token would force the parser to bail\n     * out of the entire rules surrounding the loop. So, for rule</p>\n     *\n     * <pre>\n     * classDef : 'class' ID '{' member* '}'\n     * </pre>\n     *\n     * input with an extra token between members would force the parser to\n     * consume until it found the next class definition rather than the next\n     * member definition of the current class.\n     *\n     * <p>This functionality cost a little bit of effort because the parser has to\n     * compare token set at the start of the loop and at each iteration. If for\n     * some reason speed is suffering for you, you can turn off this\n     * functionality by simply overriding this method as a blank { }.</p>\n     *\n     */\n    sync(recognizer) {\n        // If already recovering, don't try to sync\n        if (this.inErrorRecoveryMode(recognizer)) {\n            return;\n        }\n        const s = recognizer._interp.atn.states[recognizer.state];\n        const la = recognizer.getTokenStream().LA(1);\n        // try cheaper subset first; might get lucky. seems to shave a wee bit off\n        const nextTokens = recognizer.atn.nextTokens(s);\n        if(nextTokens.contains(la)) {\n            this.nextTokensContext = null;\n            this.nextTokenState = ATNState.INVALID_STATE_NUMBER;\n            return;\n        } else if (nextTokens.contains(Token.EPSILON)) {\n            if(this.nextTokensContext === null) {\n                // It's possible the next token won't match information tracked\n                // by sync is restricted for performance.\n                this.nextTokensContext = recognizer._ctx;\n                this.nextTokensState = recognizer._stateNumber;\n            }\n            return;\n        }\n        switch (s.stateType) {\n        case ATNState.BLOCK_START:\n        case ATNState.STAR_BLOCK_START:\n        case ATNState.PLUS_BLOCK_START:\n        case ATNState.STAR_LOOP_ENTRY:\n           // report error and recover if possible\n            if( this.singleTokenDeletion(recognizer) !== null) {\n                return;\n            } else {\n                throw new InputMismatchException(recognizer);\n            }\n        case ATNState.PLUS_LOOP_BACK:\n        case ATNState.STAR_LOOP_BACK:\n            this.reportUnwantedToken(recognizer);\n            const expecting = new IntervalSet()\n            expecting.addSet(recognizer.getExpectedTokens());\n            const whatFollowsLoopIterationOrRule = expecting.addSet(this.getErrorRecoverySet(recognizer))\n            this.consumeUntil(recognizer, whatFollowsLoopIterationOrRule);\n            break;\n        default:\n            // do nothing if we can't identify the exact kind of ATN state\n        }\n    }\n\n    /**\n     * This is called by {@link //reportError} when the exception is a\n     * {@link NoViableAltException}.\n     *\n     * @see //reportError\n     *\n     * @param recognizer the parser instance\n     * @param e the recognition exception\n     */\n    reportNoViableAlternative(recognizer, e) {\n        const tokens = recognizer.getTokenStream()\n        let input\n        if(tokens !== null) {\n            if (e.startToken.type===Token.EOF) {\n                input = \"<EOF>\";\n            } else {\n                input = tokens.getText(new Interval(e.startToken.tokenIndex, e.offendingToken.tokenIndex));\n            }\n        } else {\n            input = \"<unknown input>\";\n        }\n        const msg = \"no viable alternative at input \" + this.escapeWSAndQuote(input)\n        recognizer.notifyErrorListeners(msg, e.offendingToken, e);\n    }\n\n    /**\n     * This is called by {@link //reportError} when the exception is an\n     * {@link InputMismatchException}.\n     *\n     * @see //reportError\n     *\n     * @param recognizer the parser instance\n     * @param e the recognition exception\n     */\n    reportInputMismatch(recognizer, e) {\n        const msg = \"mismatched input \" + this.getTokenErrorDisplay(e.offendingToken) +\n            \" expecting \" + e.getExpectedTokens().toString(recognizer.literalNames, recognizer.symbolicNames)\n        recognizer.notifyErrorListeners(msg, e.offendingToken, e);\n    }\n\n    /**\n     * This is called by {@link //reportError} when the exception is a\n     * {@link FailedPredicateException}.\n     *\n     * @see //reportError\n     *\n     * @param recognizer the parser instance\n     * @param e the recognition exception\n     */\n    reportFailedPredicate(recognizer, e) {\n        const ruleName = recognizer.ruleNames[recognizer._ctx.ruleIndex]\n        const msg = \"rule \" + ruleName + \" \" + e.message\n        recognizer.notifyErrorListeners(msg, e.offendingToken, e);\n    }\n\n    /**\n     * This method is called to report a syntax error which requires the removal\n     * of a token from the input stream. At the time this method is called, the\n     * erroneous symbol is current {@code LT(1)} symbol and has not yet been\n     * removed from the input stream. When this method returns,\n     * {@code recognizer} is in error recovery mode.\n     *\n     * <p>This method is called when {@link //singleTokenDeletion} identifies\n     * single-token deletion as a viable recovery strategy for a mismatched\n     * input error.</p>\n     *\n     * <p>The default implementation simply returns if the handler is already in\n     * error recovery mode. Otherwise, it calls {@link //beginErrorCondition} to\n     * enter error recovery mode, followed by calling\n     * {@link Parser//notifyErrorListeners}.</p>\n     *\n     * @param recognizer the parser instance\n     *\n     */\n    reportUnwantedToken(recognizer) {\n        if (this.inErrorRecoveryMode(recognizer)) {\n            return;\n        }\n        this.beginErrorCondition(recognizer);\n        const t = recognizer.getCurrentToken()\n        const tokenName = this.getTokenErrorDisplay(t)\n        const expecting = this.getExpectedTokens(recognizer)\n        const msg = \"extraneous input \" + tokenName + \" expecting \" +\n            expecting.toString(recognizer.literalNames, recognizer.symbolicNames)\n        recognizer.notifyErrorListeners(msg, t, null);\n    }\n\n    /**\n     * This method is called to report a syntax error which requires the\n     * insertion of a missing token into the input stream. At the time this\n     * method is called, the missing token has not yet been inserted. When this\n     * method returns, {@code recognizer} is in error recovery mode.\n     *\n     * <p>This method is called when {@link //singleTokenInsertion} identifies\n     * single-token insertion as a viable recovery strategy for a mismatched\n     * input error.</p>\n     *\n     * <p>The default implementation simply returns if the handler is already in\n     * error recovery mode. Otherwise, it calls {@link //beginErrorCondition} to\n     * enter error recovery mode, followed by calling\n     * {@link Parser//notifyErrorListeners}.</p>\n     *\n     * @param recognizer the parser instance\n     */\n    reportMissingToken(recognizer) {\n        if ( this.inErrorRecoveryMode(recognizer)) {\n            return;\n        }\n        this.beginErrorCondition(recognizer);\n        const t = recognizer.getCurrentToken()\n        const expecting = this.getExpectedTokens(recognizer)\n        const msg = \"missing \" + expecting.toString(recognizer.literalNames, recognizer.symbolicNames) +\n            \" at \" + this.getTokenErrorDisplay(t)\n        recognizer.notifyErrorListeners(msg, t, null);\n    }\n\n    /**\n     * <p>The default implementation attempts to recover from the mismatched input\n     * by using single token insertion and deletion as described below. If the\n     * recovery attempt fails, this method throws an\n     * {@link InputMismatchException}.</p>\n     *\n     * <p><strong>EXTRA TOKEN</strong> (single token deletion)</p>\n     *\n     * <p>{@code LA(1)} is not what we are looking for. If {@code LA(2)} has the\n     * right token, however, then assume {@code LA(1)} is some extra spurious\n     * token and delete it. Then consume and return the next token (which was\n     * the {@code LA(2)} token) as the successful result of the match operation.</p>\n     *\n     * <p>This recovery strategy is implemented by {@link\n     * //singleTokenDeletion}.</p>\n     *\n     * <p><strong>MISSING TOKEN</strong> (single token insertion)</p>\n     *\n     * <p>If current token (at {@code LA(1)}) is consistent with what could come\n     * after the expected {@code LA(1)} token, then assume the token is missing\n     * and use the parser's {@link TokenFactory} to create it on the fly. The\n     * \"insertion\" is performed by returning the created token as the successful\n     * result of the match operation.</p>\n     *\n     * <p>This recovery strategy is implemented by {@link\n     * //singleTokenInsertion}.</p>\n     *\n     * <p><strong>EXAMPLE</strong></p>\n     *\n     * <p>For example, Input {@code i=(3;} is clearly missing the {@code ')'}. When\n     * the parser returns from the nested call to {@code expr}, it will have\n     * call chain:</p>\n     *\n     * <pre>\n     * stat &rarr; expr &rarr; atom\n     * </pre>\n     *\n     * and it will be trying to match the {@code ')'} at this point in the\n     * derivation:\n     *\n     * <pre>\n     * =&gt; ID '=' '(' INT ')' ('+' atom)* ';'\n     * ^\n     * </pre>\n     *\n     * The attempt to match {@code ')'} will fail when it sees {@code ';'} and\n     * call {@link //recoverInline}. To recover, it sees that {@code LA(1)==';'}\n     * is in the set of tokens that can follow the {@code ')'} token reference\n     * in rule {@code atom}. It can assume that you forgot the {@code ')'}.\n     */\n    recoverInline(recognizer) {\n        // SINGLE TOKEN DELETION\n        const matchedSymbol = this.singleTokenDeletion(recognizer)\n        if (matchedSymbol !== null) {\n            // we have deleted the extra token.\n            // now, move past ttype token as if all were ok\n            recognizer.consume();\n            return matchedSymbol;\n        }\n        // SINGLE TOKEN INSERTION\n        if (this.singleTokenInsertion(recognizer)) {\n            return this.getMissingSymbol(recognizer);\n        }\n        // even that didn't work; must throw the exception\n        throw new InputMismatchException(recognizer);\n    }\n\n    /**\n     * This method implements the single-token insertion inline error recovery\n     * strategy. It is called by {@link //recoverInline} if the single-token\n     * deletion strategy fails to recover from the mismatched input. If this\n     * method returns {@code true}, {@code recognizer} will be in error recovery\n     * mode.\n     *\n     * <p>This method determines whether or not single-token insertion is viable by\n     * checking if the {@code LA(1)} input symbol could be successfully matched\n     * if it were instead the {@code LA(2)} symbol. If this method returns\n     * {@code true}, the caller is responsible for creating and inserting a\n     * token with the correct type to produce this behavior.</p>\n     *\n     * @param recognizer the parser instance\n     * @return {@code true} if single-token insertion is a viable recovery\n     * strategy for the current mismatched input, otherwise {@code false}\n     */\n    singleTokenInsertion(recognizer) {\n        const currentSymbolType = recognizer.getTokenStream().LA(1)\n        // if current token is consistent with what could come after current\n        // ATN state, then we know we're missing a token; error recovery\n        // is free to conjure up and insert the missing token\n        const atn = recognizer._interp.atn\n        const currentState = atn.states[recognizer.state]\n        const next = currentState.transitions[0].target\n        const expectingAtLL2 = atn.nextTokens(next, recognizer._ctx)\n        if (expectingAtLL2.contains(currentSymbolType) ){\n            this.reportMissingToken(recognizer);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * This method implements the single-token deletion inline error recovery\n     * strategy. It is called by {@link //recoverInline} to attempt to recover\n     * from mismatched input. If this method returns null, the parser and error\n     * handler state will not have changed. If this method returns non-null,\n     * {@code recognizer} will <em>not</em> be in error recovery mode since the\n     * returned token was a successful match.\n     *\n     * <p>If the single-token deletion is successful, this method calls\n     * {@link //reportUnwantedToken} to report the error, followed by\n     * {@link Parser//consume} to actually \"delete\" the extraneous token. Then,\n     * before returning {@link //reportMatch} is called to signal a successful\n     * match.</p>\n     *\n     * @param recognizer the parser instance\n     * @return the successfully matched {@link Token} instance if single-token\n     * deletion successfully recovers from the mismatched input, otherwise\n     * {@code null}\n     */\n    singleTokenDeletion(recognizer) {\n        const nextTokenType = recognizer.getTokenStream().LA(2)\n        const expecting = this.getExpectedTokens(recognizer)\n        if (expecting.contains(nextTokenType)) {\n            this.reportUnwantedToken(recognizer);\n            // print(\"recoverFromMismatchedToken deleting \" \\\n            // + str(recognizer.getTokenStream().LT(1)) \\\n            // + \" since \" + str(recognizer.getTokenStream().LT(2)) \\\n            // + \" is what we want\", file=sys.stderr)\n            recognizer.consume(); // simply delete extra token\n            // we want to return the token we're actually matching\n            const matchedSymbol = recognizer.getCurrentToken()\n            this.reportMatch(recognizer); // we know current token is correct\n            return matchedSymbol;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Conjure up a missing token during error recovery.\n     *\n     * The recognizer attempts to recover from single missing\n     * symbols. But, actions might refer to that missing symbol.\n     * For example, x=ID {f($x);}. The action clearly assumes\n     * that there has been an identifier matched previously and that\n     * $x points at that token. If that token is missing, but\n     * the next token in the stream is what we want we assume that\n     * this token is missing and we keep going. Because we\n     * have to return some token to replace the missing token,\n     * we have to conjure one up. This method gives the user control\n     * over the tokens returned for missing tokens. Mostly,\n     * you will want to create something special for identifier\n     * tokens. For literals such as '{' and ',', the default\n     * action in the parser or tree parser works. It simply creates\n     * a CommonToken of the appropriate type. The text will be the token.\n     * If you change what tokens must be created by the lexer,\n     * override this method to create the appropriate tokens.\n     *\n     */\n    getMissingSymbol(recognizer) {\n        const currentSymbol = recognizer.getCurrentToken()\n        const expecting = this.getExpectedTokens(recognizer)\n        const expectedTokenType = expecting.first() // get any element\n        let tokenText\n        if (expectedTokenType===Token.EOF) {\n            tokenText = \"<missing EOF>\";\n        } else {\n            tokenText = \"<missing \" + recognizer.literalNames[expectedTokenType] + \">\";\n        }\n        let current = currentSymbol\n        const lookback = recognizer.getTokenStream().LT(-1)\n        if (current.type===Token.EOF && lookback !== null) {\n            current = lookback;\n        }\n        return recognizer.getTokenFactory().create(current.source,\n            expectedTokenType, tokenText, Token.DEFAULT_CHANNEL,\n            -1, -1, current.line, current.column);\n    }\n\n    getExpectedTokens(recognizer) {\n        return recognizer.getExpectedTokens();\n    }\n\n    /**\n     * How should a token be displayed in an error message? The default\n     * is to display just the text, but during development you might\n     * want to have a lot of information spit out. Override in that case\n     * to use t.toString() (which, for CommonToken, dumps everything about\n     * the token). This is better than forcing you to override a method in\n     * your token objects because you don't have to go modify your lexer\n     * so that it creates a new Java type.\n     */\n    getTokenErrorDisplay(t) {\n        if (t === null) {\n            return \"<no token>\";\n        }\n        let s = t.text\n        if (s === null) {\n            if (t.type===Token.EOF) {\n                s = \"<EOF>\";\n            } else {\n                s = \"<\" + t.type + \">\";\n            }\n        }\n        return this.escapeWSAndQuote(s);\n    }\n\n    escapeWSAndQuote(s) {\n        s = s.replace(/\\n/g,\"\\\\n\");\n        s = s.replace(/\\r/g,\"\\\\r\");\n        s = s.replace(/\\t/g,\"\\\\t\");\n        return \"'\" + s + \"'\";\n    }\n\n    /**\n     * Compute the error recovery set for the current rule. During\n     * rule invocation, the parser pushes the set of tokens that can\n     * follow that rule reference on the stack; this amounts to\n     * computing FIRST of what follows the rule reference in the\n     * enclosing rule. See LinearApproximator.FIRST().\n     * This local follow set only includes tokens\n     * from within the rule; i.e., the FIRST computation done by\n     * ANTLR stops at the end of a rule.\n     *\n     * EXAMPLE\n     *\n     * When you find a \"no viable alt exception\", the input is not\n     * consistent with any of the alternatives for rule r. The best\n     * thing to do is to consume tokens until you see something that\n     * can legally follow a call to r//or* any rule that called r.\n     * You don't want the exact set of viable next tokens because the\n     * input might just be missing a token--you might consume the\n     * rest of the input looking for one of the missing tokens.\n     *\n     * Consider grammar:\n     *\n     * a : '[' b ']'\n     * | '(' b ')'\n     * ;\n     * b : c '^' INT ;\n     * c : ID\n     * | INT\n     * ;\n     *\n     * At each rule invocation, the set of tokens that could follow\n     * that rule is pushed on a stack. Here are the various\n     * context-sensitive follow sets:\n     *\n     * FOLLOW(b1_in_a) = FIRST(']') = ']'\n     * FOLLOW(b2_in_a) = FIRST(')') = ')'\n     * FOLLOW(c_in_b) = FIRST('^') = '^'\n     *\n     * Upon erroneous input \"[]\", the call chain is\n     *\n     * a -> b -> c\n     *\n     * and, hence, the follow context stack is:\n     *\n     * depth follow set start of rule execution\n     * 0 <EOF> a (from main())\n     * 1 ']' b\n     * 2 '^' c\n     *\n     * Notice that ')' is not included, because b would have to have\n     * been called from a different context in rule a for ')' to be\n     * included.\n     *\n     * For error recovery, we cannot consider FOLLOW(c)\n     * (context-sensitive or otherwise). We need the combined set of\n     * all context-sensitive FOLLOW sets--the set of all tokens that\n     * could follow any reference in the call chain. We need to\n     * resync to one of those tokens. Note that FOLLOW(c)='^' and if\n     * we resync'd to that token, we'd consume until EOF. We need to\n     * sync to context-sensitive FOLLOWs for a, b, and c: {']','^'}.\n     * In this case, for input \"[]\", LA(1) is ']' and in the set, so we would\n     * not consume anything. After printing an error, rule c would\n     * return normally. Rule b would not find the required '^' though.\n     * At this point, it gets a mismatched token error and throws an\n     * exception (since LA(1) is not in the viable following token\n     * set). The rule exception handler tries to recover, but finds\n     * the same recovery set and doesn't consume anything. Rule b\n     * exits normally returning to rule a. Now it finds the ']' (and\n     * with the successful match exits errorRecovery mode).\n     *\n     * So, you can see that the parser walks up the call chain looking\n     * for the token that was a member of the recovery set.\n     *\n     * Errors are not generated in errorRecovery mode.\n     *\n     * ANTLR's error recovery mechanism is based upon original ideas:\n     *\n     * \"Algorithms + Data Structures = Programs\" by Niklaus Wirth\n     *\n     * and\n     *\n     * \"A note on error recovery in recursive descent parsers\":\n     * http://portal.acm.org/citation.cfm?id=947902.947905\n     *\n     * Later, Josef Grosch had some good ideas:\n     *\n     * \"Efficient and Comfortable Error Recovery in Recursive Descent\n     * Parsers\":\n     * ftp://www.cocolab.com/products/cocktail/doca4.ps/ell.ps.zip\n     *\n     * Like Grosch I implement context-sensitive FOLLOW sets that are combined\n     * at run-time upon error to avoid overhead during parsing.\n     */\n    getErrorRecoverySet(recognizer) {\n        const atn = recognizer._interp.atn\n        let ctx = recognizer._ctx\n        const recoverSet = new IntervalSet()\n        while (ctx !== null && ctx.invokingState>=0) {\n            // compute what follows who invoked us\n            const invokingState = atn.states[ctx.invokingState]\n            const rt = invokingState.transitions[0]\n            const follow = atn.nextTokens(rt.followState)\n            recoverSet.addSet(follow);\n            ctx = ctx.parentCtx;\n        }\n        recoverSet.removeOne(Token.EPSILON);\n        return recoverSet;\n    }\n\n// Consume tokens until one matches the given token set.//\n    consumeUntil(recognizer, set) {\n        let ttype = recognizer.getTokenStream().LA(1)\n        while( ttype !== Token.EOF && !set.contains(ttype)) {\n            recognizer.consume();\n            ttype = recognizer.getTokenStream().LA(1);\n        }\n    }\n}\n\n\n/**\n * This implementation of {@link ANTLRErrorStrategy} responds to syntax errors\n * by immediately canceling the parse operation with a\n * {@link ParseCancellationException}. The implementation ensures that the\n * {@link ParserRuleContext//exception} field is set for all parse tree nodes\n * that were not completed prior to encountering the error.\n *\n * <p>\n * This error strategy is useful in the following scenarios.</p>\n *\n * <ul>\n * <li><strong>Two-stage parsing:</strong> This error strategy allows the first\n * stage of two-stage parsing to immediately terminate if an error is\n * encountered, and immediately fall back to the second stage. In addition to\n * avoiding wasted work by attempting to recover from errors here, the empty\n * implementation of {@link BailErrorStrategy//sync} improves the performance of\n * the first stage.</li>\n * <li><strong>Silent validation:</strong> When syntax errors are not being\n * reported or logged, and the parse result is simply ignored if errors occur,\n * the {@link BailErrorStrategy} avoids wasting work on recovering from errors\n * when the result will be ignored either way.</li>\n * </ul>\n *\n * <p>\n * {@code myparser.setErrorHandler(new BailErrorStrategy());}</p>\n *\n * @see Parser//setErrorHandler(ANTLRErrorStrategy)\n * */\nclass BailErrorStrategy extends DefaultErrorStrategy {\n    constructor() {\n        super();\n    }\n\n    /**\n     * Instead of recovering from exception {@code e}, re-throw it wrapped\n     * in a {@link ParseCancellationException} so it is not caught by the\n     * rule function catches. Use {@link Exception//getCause()} to get the\n     * original {@link RecognitionException}.\n     */\n    recover(recognizer, e) {\n        let context = recognizer._ctx\n        while (context !== null) {\n            context.exception = e;\n            context = context.parentCtx;\n        }\n        throw new ParseCancellationException(e);\n    }\n\n    /**\n     * Make sure we don't attempt to recover inline; if the parser\n     * successfully recovers, it won't throw an exception.\n     */\n    recoverInline(recognizer) {\n        this.recover(recognizer, new InputMismatchException(recognizer));\n    }\n\n// Make sure we don't attempt to recover from problems in subrules.//\n    sync(recognizer) {\n        // pass\n    }\n}\n\n\nmodule.exports = {BailErrorStrategy, DefaultErrorStrategy};\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\n/**\n * The root of the ANTLR exception hierarchy. In general, ANTLR tracks just\n *  3 kinds of errors: prediction errors, failed predicate errors, and\n *  mismatched input errors. In each case, the parser knows where it is\n *  in the input, where it is in the ATN, the rule invocation stack,\n *  and what kind of problem occurred.\n */\n\nconst {PredicateTransition} = require('./../atn/Transition');\nconst {Interval} = require('../IntervalSet').Interval;\n\nclass RecognitionException extends Error {\n    constructor(params) {\n        super(params.message);\n        if (!!Error.captureStackTrace) {\n            Error.captureStackTrace(this, RecognitionException);\n        } else {\n            var stack = new Error().stack;\n        }\n        this.message = params.message;\n        this.recognizer = params.recognizer;\n        this.input = params.input;\n        this.ctx = params.ctx;\n        /**\n         * The current {@link Token} when an error occurred. Since not all streams\n         * support accessing symbols by index, we have to track the {@link Token}\n         * instance itself\n        */\n        this.offendingToken = null;\n        /**\n         * Get the ATN state number the parser was in at the time the error\n         * occurred. For {@link NoViableAltException} and\n         * {@link LexerNoViableAltException} exceptions, this is the\n         * {@link DecisionState} number. For others, it is the state whose outgoing\n         * edge we couldn't match.\n         */\n        this.offendingState = -1;\n        if (this.recognizer!==null) {\n            this.offendingState = this.recognizer.state;\n        }\n    }\n\n    /**\n     * Gets the set of input symbols which could potentially follow the\n     * previously matched symbol at the time this exception was thrown.\n     *\n     * <p>If the set of expected tokens is not known and could not be computed,\n     * this method returns {@code null}.</p>\n     *\n     * @return The set of token types that could potentially follow the current\n     * state in the ATN, or {@code null} if the information is not available.\n     */\n    getExpectedTokens() {\n        if (this.recognizer!==null) {\n            return this.recognizer.atn.getExpectedTokens(this.offendingState, this.ctx);\n        } else {\n            return null;\n        }\n    }\n\n    // <p>If the state number is not known, this method returns -1.</p>\n    toString() {\n        return this.message;\n    }\n}\n\nclass LexerNoViableAltException extends RecognitionException {\n    constructor(lexer, input, startIndex, deadEndConfigs) {\n        super({message: \"\", recognizer: lexer, input: input, ctx: null});\n        this.startIndex = startIndex;\n        this.deadEndConfigs = deadEndConfigs;\n    }\n\n    toString() {\n        let symbol = \"\";\n        if (this.startIndex >= 0 && this.startIndex < this.input.size) {\n            symbol = this.input.getText(new Interval(this.startIndex,this.startIndex));\n        }\n        return \"LexerNoViableAltException\" + symbol;\n    }\n}\n\n\n/**\n * Indicates that the parser could not decide which of two or more paths\n * to take based upon the remaining input. It tracks the starting token\n * of the offending input and also knows where the parser was\n * in the various paths when the error. Reported by reportNoViableAlternative()\n */\nclass NoViableAltException extends RecognitionException {\n    constructor(recognizer, input, startToken, offendingToken, deadEndConfigs, ctx) {\n        ctx = ctx || recognizer._ctx;\n        offendingToken = offendingToken || recognizer.getCurrentToken();\n        startToken = startToken || recognizer.getCurrentToken();\n        input = input || recognizer.getInputStream();\n        super({message: \"\", recognizer: recognizer, input: input, ctx: ctx});\n        // Which configurations did we try at input.index() that couldn't match\n        // input.LT(1)?//\n        this.deadEndConfigs = deadEndConfigs;\n        // The token object at the start index; the input stream might\n        // not be buffering tokens so get a reference to it. (At the\n        // time the error occurred, of course the stream needs to keep a\n        // buffer all of the tokens but later we might not have access to those.)\n        this.startToken = startToken;\n        this.offendingToken = offendingToken;\n    }\n}\n\n/**\n * This signifies any kind of mismatched input exceptions such as\n * when the current input does not match the expected token.\n*/\nclass InputMismatchException extends RecognitionException {\n    constructor(recognizer) {\n        super({message: \"\", recognizer: recognizer, input: recognizer.getInputStream(), ctx: recognizer._ctx});\n        this.offendingToken = recognizer.getCurrentToken();\n    }\n}\n\nfunction formatMessage(predicate, message) {\n    if (message !==null) {\n        return message;\n    } else {\n        return \"failed predicate: {\" + predicate + \"}?\";\n    }\n}\n\n/**\n * A semantic predicate failed during validation. Validation of predicates\n * occurs when normally parsing the alternative just like matching a token.\n * Disambiguating predicate evaluation occurs when we test a predicate during\n * prediction.\n*/\nclass FailedPredicateException extends RecognitionException {\n    constructor(recognizer, predicate, message) {\n        super({\n            message: formatMessage(predicate, message || null), recognizer: recognizer,\n            input: recognizer.getInputStream(), ctx: recognizer._ctx\n        });\n        const s = recognizer._interp.atn.states[recognizer.state]\n        const trans = s.transitions[0]\n        if (trans instanceof PredicateTransition) {\n            this.ruleIndex = trans.ruleIndex;\n            this.predicateIndex = trans.predIndex;\n        } else {\n            this.ruleIndex = 0;\n            this.predicateIndex = 0;\n        }\n        this.predicate = predicate;\n        this.offendingToken = recognizer.getCurrentToken();\n    }\n}\n\n\nclass ParseCancellationException extends Error{\n    constructor() {\n        super()\n        Error.captureStackTrace(this, ParseCancellationException);\n    }\n}\n\nmodule.exports = {\n    RecognitionException,\n    NoViableAltException,\n    LexerNoViableAltException,\n    InputMismatchException,\n    FailedPredicateException,\n    ParseCancellationException\n};\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nmodule.exports.RecognitionException = require('./Errors').RecognitionException;\nmodule.exports.NoViableAltException = require('./Errors').NoViableAltException;\nmodule.exports.LexerNoViableAltException = require('./Errors').LexerNoViableAltException;\nmodule.exports.InputMismatchException = require('./Errors').InputMismatchException;\nmodule.exports.FailedPredicateException = require('./Errors').FailedPredicateException;\nmodule.exports.DiagnosticErrorListener = require('./DiagnosticErrorListener');\nmodule.exports.BailErrorStrategy = require('./ErrorStrategy').BailErrorStrategy;\nmodule.exports.DefaultErrorStrategy = require('./ErrorStrategy').DefaultErrorStrategy;\nmodule.exports.ErrorListener = require('./ErrorListener').ErrorListener;\n","/*! https://mths.be/codepointat v0.2.0 by @mathias */\nif (!String.prototype.codePointAt) {\n\t(function() {\n\t\t'use strict'; // needed to support `apply`/`call` with `undefined`/`null`\n\t\tvar defineProperty = (function() {\n\t\t\t// IE 8 only supports `Object.defineProperty` on DOM elements\n\t\t\tlet result;\n\t\t\ttry {\n\t\t\t\tconst object = {};\n\t\t\t\tconst $defineProperty = Object.defineProperty;\n\t\t\t\tresult = $defineProperty(object, object, object) && $defineProperty;\n\t\t\t} catch(error) {\n\t\t\t}\n\t\t\treturn result;\n\t\t}());\n\t\tconst codePointAt = function(position) {\n\t\t\tif (this == null) {\n\t\t\t\tthrow TypeError();\n\t\t\t}\n\t\t\tconst string = String(this);\n\t\t\tconst size = string.length;\n\t\t\t// `ToInteger`\n\t\t\tlet index = position ? Number(position) : 0;\n\t\t\tif (index !== index) { // better `isNaN`\n\t\t\t\tindex = 0;\n\t\t\t}\n\t\t\t// Account for out-of-bounds indices:\n\t\t\tif (index < 0 || index >= size) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\t// Get the first code unit\n\t\t\tconst first = string.charCodeAt(index);\n\t\t\tlet second;\n\t\t\tif ( // check if its the start of a surrogate pair\n\t\t\t\tfirst >= 0xD800 && first <= 0xDBFF && // high surrogate\n\t\t\t\tsize > index + 1 // there is a next code unit\n\t\t\t) {\n\t\t\t\tsecond = string.charCodeAt(index + 1);\n\t\t\t\tif (second >= 0xDC00 && second <= 0xDFFF) { // low surrogate\n\t\t\t\t\t// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\t\t\t\t\treturn (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn first;\n\t\t};\n\t\tif (defineProperty) {\n\t\t\tdefineProperty(String.prototype, 'codePointAt', {\n\t\t\t\t'value': codePointAt,\n\t\t\t\t'configurable': true,\n\t\t\t\t'writable': true\n\t\t\t});\n\t\t} else {\n\t\t\tString.prototype.codePointAt = codePointAt;\n\t\t}\n\t}());\n}\n","/*! https://mths.be/fromcodepoint v0.2.1 by @mathias */\nif (!String.fromCodePoint) {\n\t(function() {\n\t\tconst defineProperty = (function() {\n\t\t\t// IE 8 only supports `Object.defineProperty` on DOM elements\n\t\t\tlet result;\n\t\t\ttry {\n\t\t\t\tconst object = {};\n\t\t\t\tconst $defineProperty = Object.defineProperty;\n\t\t\t\tresult = $defineProperty(object, object, object) && $defineProperty;\n\t\t\t} catch(error) {}\n\t\t\treturn result;\n\t\t}());\n\t\tconst stringFromCharCode = String.fromCharCode;\n\t\tconst floor = Math.floor;\n\t\tconst fromCodePoint = function(_) {\n\t\t\tconst MAX_SIZE = 0x4000;\n\t\t\tconst codeUnits = [];\n\t\t\tlet highSurrogate;\n\t\t\tlet lowSurrogate;\n\t\t\tlet index = -1;\n\t\t\tconst length = arguments.length;\n\t\t\tif (!length) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\tlet result = '';\n\t\t\twhile (++index < length) {\n\t\t\t\tlet codePoint = Number(arguments[index]);\n\t\t\t\tif (\n\t\t\t\t\t!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n\t\t\t\t\tcodePoint < 0 || // not a valid Unicode code point\n\t\t\t\t\tcodePoint > 0x10FFFF || // not a valid Unicode code point\n\t\t\t\t\tfloor(codePoint) !== codePoint // not an integer\n\t\t\t\t) {\n\t\t\t\t\tthrow RangeError('Invalid code point: ' + codePoint);\n\t\t\t\t}\n\t\t\t\tif (codePoint <= 0xFFFF) { // BMP code point\n\t\t\t\t\tcodeUnits.push(codePoint);\n\t\t\t\t} else { // Astral code point; split in surrogate halves\n\t\t\t\t\t// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\t\t\t\t\tcodePoint -= 0x10000;\n\t\t\t\t\thighSurrogate = (codePoint >> 10) + 0xD800;\n\t\t\t\t\tlowSurrogate = (codePoint % 0x400) + 0xDC00;\n\t\t\t\t\tcodeUnits.push(highSurrogate, lowSurrogate);\n\t\t\t\t}\n\t\t\t\tif (index + 1 === length || codeUnits.length > MAX_SIZE) {\n\t\t\t\t\tresult += stringFromCharCode.apply(null, codeUnits);\n\t\t\t\t\tcodeUnits.length = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\t\tif (defineProperty) {\n\t\t\tdefineProperty(String, 'fromCodePoint', {\n\t\t\t\t'value': fromCodePoint,\n\t\t\t\t'configurable': true,\n\t\t\t\t'writable': true\n\t\t\t});\n\t\t} else {\n\t\t\tString.fromCodePoint = fromCodePoint;\n\t\t}\n\t}());\n}\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Token} = require('./../Token');\nconst {Interval} = require('./../IntervalSet');\nconst INVALID_INTERVAL = new Interval(-1, -2);\n\n/**\n * The basic notion of a tree has a parent, a payload, and a list of children.\n * It is the most abstract interface for all the trees used by ANTLR.\n */\nclass Tree {}\n\nclass SyntaxTree extends Tree {\n\tconstructor() {\n\t\tsuper();\n\t}\n}\n\nclass ParseTree extends SyntaxTree {\n\tconstructor() {\n\t\tsuper();\n\t}\n}\n\nclass RuleNode extends ParseTree {\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\tgetRuleContext(){\n\t\tthrow new Error(\"missing interface implementation\")\n\t}\n}\n\nclass TerminalNode extends ParseTree {\n\tconstructor() {\n\t\tsuper();\n\t}\n}\n\nclass ErrorNode extends TerminalNode {\n\tconstructor() {\n\t\tsuper();\n\t}\n}\n\nclass ParseTreeVisitor {\n\tvisit(ctx) {\n\t\t if (Array.isArray(ctx)) {\n\t\t\treturn ctx.map(function(child) {\n\t\t\t\treturn child.accept(this);\n\t\t\t}, this);\n\t\t} else {\n\t\t\treturn ctx.accept(this);\n\t\t}\n\t}\n\n\tvisitChildren(ctx) {\n\t\tif (ctx.children) {\n\t\t\treturn this.visit(ctx.children);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tvisitTerminal(node) {\n\t}\n\n\tvisitErrorNode(node) {\n\t}\n}\n\nclass ParseTreeListener {\n\tvisitTerminal(node) {\n\t}\n\n\tvisitErrorNode(node) {\n\t}\n\n\tenterEveryRule(node) {\n\t}\n\n\texitEveryRule(node) {\n\t}\n}\n\nclass TerminalNodeImpl extends TerminalNode {\n\tconstructor(symbol) {\n\t\tsuper();\n\t\tthis.parentCtx = null;\n\t\tthis.symbol = symbol;\n\t}\n\n\tgetChild(i) {\n\t\treturn null;\n\t}\n\n\tgetSymbol() {\n\t\treturn this.symbol;\n\t}\n\n\tgetParent() {\n\t\treturn this.parentCtx;\n\t}\n\n\tgetPayload() {\n\t\treturn this.symbol;\n\t}\n\n\tgetSourceInterval() {\n\t\tif (this.symbol === null) {\n\t\t\treturn INVALID_INTERVAL;\n\t\t}\n\t\tconst tokenIndex = this.symbol.tokenIndex;\n\t\treturn new Interval(tokenIndex, tokenIndex);\n\t}\n\n\tgetChildCount() {\n\t\treturn 0;\n\t}\n\n\taccept(visitor) {\n\t\treturn visitor.visitTerminal(this);\n\t}\n\n\tgetText() {\n\t\treturn this.symbol.text;\n\t}\n\n\ttoString() {\n\t\tif (this.symbol.type === Token.EOF) {\n\t\t\treturn \"<EOF>\";\n\t\t} else {\n\t\t\treturn this.symbol.text;\n\t\t}\n\t}\n}\n\n\n/**\n * Represents a token that was consumed during resynchronization\n * rather than during a valid match operation. For example,\n * we will create this kind of a node during single token insertion\n * and deletion as well as during \"consume until error recovery set\"\n * upon no viable alternative exceptions.\n */\nclass ErrorNodeImpl extends TerminalNodeImpl {\n\tconstructor(token) {\n\t\tsuper(token);\n\t}\n\n\tisErrorNode() {\n\t\treturn true;\n\t}\n\n\taccept(visitor) {\n\t\treturn visitor.visitErrorNode(this);\n\t}\n}\n\nclass ParseTreeWalker {\n\n\t/**\n\t * Performs a walk on the given parse tree starting at the root and going down recursively\n\t * with depth-first search. On each node, {@link ParseTreeWalker//enterRule} is called before\n\t * recursively walking down into child nodes, then\n\t * {@link ParseTreeWalker//exitRule} is called after the recursive call to wind up.\n\t * @param listener The listener used by the walker to process grammar rules\n\t * @param t The parse tree to be walked on\n\t */\n\twalk(listener, t) {\n\t\tconst errorNode = t instanceof ErrorNode ||\n\t\t\t\t(t.isErrorNode !== undefined && t.isErrorNode());\n\t\tif (errorNode) {\n\t\t\tlistener.visitErrorNode(t);\n\t\t} else if (t instanceof TerminalNode) {\n\t\t\tlistener.visitTerminal(t);\n\t\t} else {\n\t\t\tthis.enterRule(listener, t);\n\t\t\tfor (let i = 0; i < t.getChildCount(); i++) {\n\t\t\t\tconst child = t.getChild(i);\n\t\t\t\tthis.walk(listener, child);\n\t\t\t}\n\t\t\tthis.exitRule(listener, t);\n\t\t}\n\t}\n\n\t/**\n\t * Enters a grammar rule by first triggering the generic event {@link ParseTreeListener//enterEveryRule}\n\t * then by triggering the event specific to the given parse tree node\n\t * @param listener The listener responding to the trigger events\n\t * @param r The grammar rule containing the rule context\n\t */\n\tenterRule(listener, r) {\n\t\tconst ctx = r.getRuleContext();\n\t\tlistener.enterEveryRule(ctx);\n\t\tctx.enterRule(listener);\n\t}\n\n\t/**\n\t * Exits a grammar rule by first triggering the event specific to the given parse tree node\n\t * then by triggering the generic event {@link ParseTreeListener//exitEveryRule}\n\t * @param listener The listener responding to the trigger events\n\t * @param r The grammar rule containing the rule context\n\t */\n\texitRule(listener, r) {\n\t\tconst ctx = r.getRuleContext();\n\t\tctx.exitRule(listener);\n\t\tlistener.exitEveryRule(ctx);\n\t}\n}\n\nParseTreeWalker.DEFAULT = new ParseTreeWalker();\n\nmodule.exports = {\n\tRuleNode,\n\tErrorNode,\n\tTerminalNode,\n\tErrorNodeImpl,\n\tTerminalNodeImpl,\n\tParseTreeListener,\n\tParseTreeVisitor,\n\tParseTreeWalker,\n\tINVALID_INTERVAL\n}\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst Utils = require('./../Utils');\nconst {Token} = require('./../Token');\nconst {ErrorNode, TerminalNode, RuleNode} = require('./Tree');\n\n/** A set of utility routines useful for all kinds of ANTLR trees. */\nconst Trees = {\n    /**\n     * Print out a whole tree in LISP form. {@link //getNodeText} is used on the\n     *  node payloads to get the text for the nodes.  Detect\n     *  parse trees and extract data appropriately.\n     */\n    toStringTree: function(tree, ruleNames, recog) {\n        ruleNames = ruleNames || null;\n        recog = recog || null;\n        if(recog!==null) {\n            ruleNames = recog.ruleNames;\n        }\n        let s = Trees.getNodeText(tree, ruleNames);\n        s = Utils.escapeWhitespace(s, false);\n        const c = tree.getChildCount();\n        if(c===0) {\n            return s;\n        }\n        let res = \"(\" + s + ' ';\n        if(c>0) {\n            s = Trees.toStringTree(tree.getChild(0), ruleNames);\n            res = res.concat(s);\n        }\n        for(let i=1;i<c;i++) {\n            s = Trees.toStringTree(tree.getChild(i), ruleNames);\n            res = res.concat(' ' + s);\n        }\n        res = res.concat(\")\");\n        return res;\n    },\n\n    getNodeText: function(t, ruleNames, recog) {\n        ruleNames = ruleNames || null;\n        recog = recog || null;\n        if(recog!==null) {\n            ruleNames = recog.ruleNames;\n        }\n        if(ruleNames!==null) {\n            if (t instanceof RuleNode) {\n                const context = t.getRuleContext()\n                const altNumber = context.getAltNumber();\n                // use const value of ATN.INVALID_ALT_NUMBER to avoid circular dependency\n                if ( altNumber != 0 ) {\n                    return ruleNames[t.ruleIndex]+\":\"+altNumber;\n                }\n                return ruleNames[t.ruleIndex];\n            } else if ( t instanceof ErrorNode) {\n                return t.toString();\n            } else if(t instanceof TerminalNode) {\n                if(t.symbol!==null) {\n                    return t.symbol.text;\n                }\n            }\n        }\n        // no recog for rule names\n        const payload = t.getPayload();\n        if (payload instanceof Token ) {\n            return payload.text;\n        }\n        return t.getPayload().toString();\n    },\n\n    /**\n     * Return ordered list of all children of this node\n     */\n    getChildren: function(t) {\n        const list = [];\n        for(let i=0;i<t.getChildCount();i++) {\n            list.push(t.getChild(i));\n        }\n        return list;\n    },\n\n    /**\n     * Return a list of all ancestors of this node.  The first node of\n     * list is the root and the last is the parent of this node.\n     */\n    getAncestors: function(t) {\n        let ancestors = [];\n        t = t.getParent();\n        while(t!==null) {\n            ancestors = [t].concat(ancestors);\n            t = t.getParent();\n        }\n        return ancestors;\n    },\n\n    findAllTokenNodes: function(t, ttype) {\n        return Trees.findAllNodes(t, ttype, true);\n    },\n\n    findAllRuleNodes: function(t, ruleIndex) {\n        return Trees.findAllNodes(t, ruleIndex, false);\n    },\n\n    findAllNodes: function(t, index, findTokens) {\n        const nodes = [];\n        Trees._findAllNodes(t, index, findTokens, nodes);\n        return nodes;\n    },\n\n    _findAllNodes: function(t, index, findTokens, nodes) {\n        // check this node (the root) first\n        if(findTokens && (t instanceof TerminalNode)) {\n            if(t.symbol.type===index) {\n                nodes.push(t);\n            }\n        } else if(!findTokens && (t instanceof RuleNode)) {\n            if(t.ruleIndex===index) {\n                nodes.push(t);\n            }\n        }\n        // check children\n        for(let i=0;i<t.getChildCount();i++) {\n            Trees._findAllNodes(t.getChild(i), index, findTokens, nodes);\n        }\n    },\n\n    descendants: function(t) {\n        let nodes = [t];\n        for(let i=0;i<t.getChildCount();i++) {\n            nodes = nodes.concat(Trees.descendants(t.getChild(i)));\n        }\n        return nodes;\n    }\n}\n\nmodule.exports = Trees;\n","/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst Tree = require('./Tree');\nconst Trees = require('./Trees');\nmodule.exports = {...Tree, Trees}\n","'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\n\nvar callBind = require('./');\n\nvar $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));\n\nmodule.exports = function callBoundIntrinsic(name, allowMissing) {\n\tvar intrinsic = GetIntrinsic(name, !!allowMissing);\n\tif (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {\n\t\treturn callBind(intrinsic);\n\t}\n\treturn intrinsic;\n};\n","'use strict';\n\nvar bind = require('function-bind');\nvar GetIntrinsic = require('get-intrinsic');\n\nvar $apply = GetIntrinsic('%Function.prototype.apply%');\nvar $call = GetIntrinsic('%Function.prototype.call%');\nvar $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);\n\nvar $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);\nvar $defineProperty = GetIntrinsic('%Object.defineProperty%', true);\nvar $max = GetIntrinsic('%Math.max%');\n\nif ($defineProperty) {\n\ttry {\n\t\t$defineProperty({}, 'a', { value: 1 });\n\t} catch (e) {\n\t\t// IE 8 has a broken defineProperty\n\t\t$defineProperty = null;\n\t}\n}\n\nmodule.exports = function callBind(originalFunction) {\n\tvar func = $reflectApply(bind, $call, arguments);\n\tif ($gOPD && $defineProperty) {\n\t\tvar desc = $gOPD(func, 'length');\n\t\tif (desc.configurable) {\n\t\t\t// original length, plus the receiver, minus any additional arguments (after the receiver)\n\t\t\t$defineProperty(\n\t\t\t\tfunc,\n\t\t\t\t'length',\n\t\t\t\t{ value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }\n\t\t\t);\n\t\t}\n\t}\n\treturn func;\n};\n\nvar applyBind = function applyBind() {\n\treturn $reflectApply(bind, $apply, arguments);\n};\n\nif ($defineProperty) {\n\t$defineProperty(module.exports, 'apply', { value: applyBind });\n} else {\n\tmodule.exports.apply = applyBind;\n}\n","var MILLISECONDS_IN_MINUTE = 60000\n\n/**\n * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.\n * They usually appear for dates that denote time before the timezones were introduced\n * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891\n * and GMT+01:00:00 after that date)\n *\n * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,\n * which would lead to incorrect calculations.\n *\n * This function returns the timezone offset in milliseconds that takes seconds in account.\n */\nmodule.exports = function getTimezoneOffsetInMilliseconds (dirtyDate) {\n  var date = new Date(dirtyDate.getTime())\n  var baseTimezoneOffset = date.getTimezoneOffset()\n  date.setSeconds(0, 0)\n  var millisecondsPartOfTimezoneOffset = date.getTime() % MILLISECONDS_IN_MINUTE\n\n  return baseTimezoneOffset * MILLISECONDS_IN_MINUTE + millisecondsPartOfTimezoneOffset\n}\n","var parse = require('../parse/index.js')\n\n/**\n * @category Day Helpers\n * @summary Add the specified number of days to the given date.\n *\n * @description\n * Add the specified number of days to the given date.\n *\n * @param {Date|String|Number} date - the date to be changed\n * @param {Number} amount - the amount of days to be added\n * @returns {Date} the new date with the days added\n *\n * @example\n * // Add 10 days to 1 September 2014:\n * var result = addDays(new Date(2014, 8, 1), 10)\n * //=> Thu Sep 11 2014 00:00:00\n */\nfunction addDays (dirtyDate, dirtyAmount) {\n  var date = parse(dirtyDate)\n  var amount = Number(dirtyAmount)\n  date.setDate(date.getDate() + amount)\n  return date\n}\n\nmodule.exports = addDays\n","var addMilliseconds = require('../add_milliseconds/index.js')\n\nvar MILLISECONDS_IN_HOUR = 3600000\n\n/**\n * @category Hour Helpers\n * @summary Add the specified number of hours to the given date.\n *\n * @description\n * Add the specified number of hours to the given date.\n *\n * @param {Date|String|Number} date - the date to be changed\n * @param {Number} amount - the amount of hours to be added\n * @returns {Date} the new date with the hours added\n *\n * @example\n * // Add 2 hours to 10 July 2014 23:00:00:\n * var result = addHours(new Date(2014, 6, 10, 23, 0), 2)\n * //=> Fri Jul 11 2014 01:00:00\n */\nfunction addHours (dirtyDate, dirtyAmount) {\n  var amount = Number(dirtyAmount)\n  return addMilliseconds(dirtyDate, amount * MILLISECONDS_IN_HOUR)\n}\n\nmodule.exports = addHours\n","var parse = require('../parse/index.js')\n\n/**\n * @category Millisecond Helpers\n * @summary Add the specified number of milliseconds to the given date.\n *\n * @description\n * Add the specified number of milliseconds to the given date.\n *\n * @param {Date|String|Number} date - the date to be changed\n * @param {Number} amount - the amount of milliseconds to be added\n * @returns {Date} the new date with the milliseconds added\n *\n * @example\n * // Add 750 milliseconds to 10 July 2014 12:45:30.000:\n * var result = addMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)\n * //=> Thu Jul 10 2014 12:45:30.750\n */\nfunction addMilliseconds (dirtyDate, dirtyAmount) {\n  var timestamp = parse(dirtyDate).getTime()\n  var amount = Number(dirtyAmount)\n  return new Date(timestamp + amount)\n}\n\nmodule.exports = addMilliseconds\n","var addMilliseconds = require('../add_milliseconds/index.js')\n\nvar MILLISECONDS_IN_MINUTE = 60000\n\n/**\n * @category Minute Helpers\n * @summary Add the specified number of minutes to the given date.\n *\n * @description\n * Add the specified number of minutes to the given date.\n *\n * @param {Date|String|Number} date - the date to be changed\n * @param {Number} amount - the amount of minutes to be added\n * @returns {Date} the new date with the minutes added\n *\n * @example\n * // Add 30 minutes to 10 July 2014 12:00:00:\n * var result = addMinutes(new Date(2014, 6, 10, 12, 0), 30)\n * //=> Thu Jul 10 2014 12:30:00\n */\nfunction addMinutes (dirtyDate, dirtyAmount) {\n  var amount = Number(dirtyAmount)\n  return addMilliseconds(dirtyDate, amount * MILLISECONDS_IN_MINUTE)\n}\n\nmodule.exports = addMinutes\n","var parse = require('../parse/index.js')\nvar getDaysInMonth = require('../get_days_in_month/index.js')\n\n/**\n * @category Month Helpers\n * @summary Add the specified number of months to the given date.\n *\n * @description\n * Add the specified number of months to the given date.\n *\n * @param {Date|String|Number} date - the date to be changed\n * @param {Number} amount - the amount of months to be added\n * @returns {Date} the new date with the months added\n *\n * @example\n * // Add 5 months to 1 September 2014:\n * var result = addMonths(new Date(2014, 8, 1), 5)\n * //=> Sun Feb 01 2015 00:00:00\n */\nfunction addMonths (dirtyDate, dirtyAmount) {\n  var date = parse(dirtyDate)\n  var amount = Number(dirtyAmount)\n  var desiredMonth = date.getMonth() + amount\n  var dateWithDesiredMonth = new Date(0)\n  dateWithDesiredMonth.setFullYear(date.getFullYear(), desiredMonth, 1)\n  dateWithDesiredMonth.setHours(0, 0, 0, 0)\n  var daysInMonth = getDaysInMonth(dateWithDesiredMonth)\n  // Set the last day of the new month\n  // if the original date was the last day of the longer month\n  date.setMonth(desiredMonth, Math.min(daysInMonth, date.getDate()))\n  return date\n}\n\nmodule.exports = addMonths\n","var addMilliseconds = require('../add_milliseconds/index.js')\n\n/**\n * @category Second Helpers\n * @summary Add the specified number of seconds to the given date.\n *\n * @description\n * Add the specified number of seconds to the given date.\n *\n * @param {Date|String|Number} date - the date to be changed\n * @param {Number} amount - the amount of seconds to be added\n * @returns {Date} the new date with the seconds added\n *\n * @example\n * // Add 30 seconds to 10 July 2014 12:45:00:\n * var result = addSeconds(new Date(2014, 6, 10, 12, 45, 0), 30)\n * //=> Thu Jul 10 2014 12:45:30\n */\nfunction addSeconds (dirtyDate, dirtyAmount) {\n  var amount = Number(dirtyAmount)\n  return addMilliseconds(dirtyDate, amount * 1000)\n}\n\nmodule.exports = addSeconds\n","var addDays = require('../add_days/index.js')\n\n/**\n * @category Week Helpers\n * @summary Add the specified number of weeks to the given date.\n *\n * @description\n * Add the specified number of week to the given date.\n *\n * @param {Date|String|Number} date - the date to be changed\n * @param {Number} amount - the amount of weeks to be added\n * @returns {Date} the new date with the weeks added\n *\n * @example\n * // Add 4 weeks to 1 September 2014:\n * var result = addWeeks(new Date(2014, 8, 1), 4)\n * //=> Mon Sep 29 2014 00:00:00\n */\nfunction addWeeks (dirtyDate, dirtyAmount) {\n  var amount = Number(dirtyAmount)\n  var days = amount * 7\n  return addDays(dirtyDate, days)\n}\n\nmodule.exports = addWeeks\n","var addMonths = require('../add_months/index.js')\n\n/**\n * @category Year Helpers\n * @summary Add the specified number of years to the given date.\n *\n * @description\n * Add the specified number of years to the given date.\n *\n * @param {Date|String|Number} date - the date to be changed\n * @param {Number} amount - the amount of years to be added\n * @returns {Date} the new date with the years added\n *\n * @example\n * // Add 5 years to 1 September 2014:\n * var result = addYears(new Date(2014, 8, 1), 5)\n * //=> Sun Sep 01 2019 00:00:00\n */\nfunction addYears (dirtyDate, dirtyAmount) {\n  var amount = Number(dirtyAmount)\n  return addMonths(dirtyDate, amount * 12)\n}\n\nmodule.exports = addYears\n","var parse = require('../parse/index.js')\n\n/**\n * @category Month Helpers\n * @summary Get the number of days in a month of the given date.\n *\n * @description\n * Get the number of days in a month of the given date.\n *\n * @param {Date|String|Number} date - the given date\n * @returns {Number} the number of days in a month\n *\n * @example\n * // How many days are in February 2000?\n * var result = getDaysInMonth(new Date(2000, 1))\n * //=> 29\n */\nfunction getDaysInMonth (dirtyDate) {\n  var date = parse(dirtyDate)\n  var year = date.getFullYear()\n  var monthIndex = date.getMonth()\n  var lastDayOfMonth = new Date(0)\n  lastDayOfMonth.setFullYear(year, monthIndex + 1, 0)\n  lastDayOfMonth.setHours(0, 0, 0, 0)\n  return lastDayOfMonth.getDate()\n}\n\nmodule.exports = getDaysInMonth\n","/**\n * @category Common Helpers\n * @summary Is the given argument an instance of Date?\n *\n * @description\n * Is the given argument an instance of Date?\n *\n * @param {*} argument - the argument to check\n * @returns {Boolean} the given argument is an instance of Date\n *\n * @example\n * // Is 'mayonnaise' a Date?\n * var result = isDate('mayonnaise')\n * //=> false\n */\nfunction isDate (argument) {\n  return argument instanceof Date\n}\n\nmodule.exports = isDate\n","var getTimezoneOffsetInMilliseconds = require('../_lib/getTimezoneOffsetInMilliseconds/index.js')\nvar isDate = require('../is_date/index.js')\n\nvar MILLISECONDS_IN_HOUR = 3600000\nvar MILLISECONDS_IN_MINUTE = 60000\nvar DEFAULT_ADDITIONAL_DIGITS = 2\n\nvar parseTokenDateTimeDelimeter = /[T ]/\nvar parseTokenPlainTime = /:/\n\n// year tokens\nvar parseTokenYY = /^(\\d{2})$/\nvar parseTokensYYY = [\n  /^([+-]\\d{2})$/, // 0 additional digits\n  /^([+-]\\d{3})$/, // 1 additional digit\n  /^([+-]\\d{4})$/ // 2 additional digits\n]\n\nvar parseTokenYYYY = /^(\\d{4})/\nvar parseTokensYYYYY = [\n  /^([+-]\\d{4})/, // 0 additional digits\n  /^([+-]\\d{5})/, // 1 additional digit\n  /^([+-]\\d{6})/ // 2 additional digits\n]\n\n// date tokens\nvar parseTokenMM = /^-(\\d{2})$/\nvar parseTokenDDD = /^-?(\\d{3})$/\nvar parseTokenMMDD = /^-?(\\d{2})-?(\\d{2})$/\nvar parseTokenWww = /^-?W(\\d{2})$/\nvar parseTokenWwwD = /^-?W(\\d{2})-?(\\d{1})$/\n\n// time tokens\nvar parseTokenHH = /^(\\d{2}([.,]\\d*)?)$/\nvar parseTokenHHMM = /^(\\d{2}):?(\\d{2}([.,]\\d*)?)$/\nvar parseTokenHHMMSS = /^(\\d{2}):?(\\d{2}):?(\\d{2}([.,]\\d*)?)$/\n\n// timezone tokens\nvar parseTokenTimezone = /([Z+-].*)$/\nvar parseTokenTimezoneZ = /^(Z)$/\nvar parseTokenTimezoneHH = /^([+-])(\\d{2})$/\nvar parseTokenTimezoneHHMM = /^([+-])(\\d{2}):?(\\d{2})$/\n\n/**\n * @category Common Helpers\n * @summary Convert the given argument to an instance of Date.\n *\n * @description\n * Convert the given argument to an instance of Date.\n *\n * If the argument is an instance of Date, the function returns its clone.\n *\n * If the argument is a number, it is treated as a timestamp.\n *\n * If an argument is a string, the function tries to parse it.\n * Function accepts complete ISO 8601 formats as well as partial implementations.\n * ISO 8601: http://en.wikipedia.org/wiki/ISO_8601\n *\n * If all above fails, the function passes the given argument to Date constructor.\n *\n * @param {Date|String|Number} argument - the value to convert\n * @param {Object} [options] - the object with options\n * @param {0 | 1 | 2} [options.additionalDigits=2] - the additional number of digits in the extended year format\n * @returns {Date} the parsed date in the local time zone\n *\n * @example\n * // Convert string '2014-02-11T11:30:30' to date:\n * var result = parse('2014-02-11T11:30:30')\n * //=> Tue Feb 11 2014 11:30:30\n *\n * @example\n * // Parse string '+02014101',\n * // if the additional number of digits in the extended year format is 1:\n * var result = parse('+02014101', {additionalDigits: 1})\n * //=> Fri Apr 11 2014 00:00:00\n */\nfunction parse (argument, dirtyOptions) {\n  if (isDate(argument)) {\n    // Prevent the date to lose the milliseconds when passed to new Date() in IE10\n    return new Date(argument.getTime())\n  } else if (typeof argument !== 'string') {\n    return new Date(argument)\n  }\n\n  var options = dirtyOptions || {}\n  var additionalDigits = options.additionalDigits\n  if (additionalDigits == null) {\n    additionalDigits = DEFAULT_ADDITIONAL_DIGITS\n  } else {\n    additionalDigits = Number(additionalDigits)\n  }\n\n  var dateStrings = splitDateString(argument)\n\n  var parseYearResult = parseYear(dateStrings.date, additionalDigits)\n  var year = parseYearResult.year\n  var restDateString = parseYearResult.restDateString\n\n  var date = parseDate(restDateString, year)\n\n  if (date) {\n    var timestamp = date.getTime()\n    var time = 0\n    var offset\n\n    if (dateStrings.time) {\n      time = parseTime(dateStrings.time)\n    }\n\n    if (dateStrings.timezone) {\n      offset = parseTimezone(dateStrings.timezone) * MILLISECONDS_IN_MINUTE\n    } else {\n      var fullTime = timestamp + time\n      var fullTimeDate = new Date(fullTime)\n\n      offset = getTimezoneOffsetInMilliseconds(fullTimeDate)\n\n      // Adjust time when it's coming from DST\n      var fullTimeDateNextDay = new Date(fullTime)\n      fullTimeDateNextDay.setDate(fullTimeDate.getDate() + 1)\n      var offsetDiff =\n        getTimezoneOffsetInMilliseconds(fullTimeDateNextDay) -\n        getTimezoneOffsetInMilliseconds(fullTimeDate)\n      if (offsetDiff > 0) {\n        offset += offsetDiff\n      }\n    }\n\n    return new Date(timestamp + time + offset)\n  } else {\n    return new Date(argument)\n  }\n}\n\nfunction splitDateString (dateString) {\n  var dateStrings = {}\n  var array = dateString.split(parseTokenDateTimeDelimeter)\n  var timeString\n\n  if (parseTokenPlainTime.test(array[0])) {\n    dateStrings.date = null\n    timeString = array[0]\n  } else {\n    dateStrings.date = array[0]\n    timeString = array[1]\n  }\n\n  if (timeString) {\n    var token = parseTokenTimezone.exec(timeString)\n    if (token) {\n      dateStrings.time = timeString.replace(token[1], '')\n      dateStrings.timezone = token[1]\n    } else {\n      dateStrings.time = timeString\n    }\n  }\n\n  return dateStrings\n}\n\nfunction parseYear (dateString, additionalDigits) {\n  var parseTokenYYY = parseTokensYYY[additionalDigits]\n  var parseTokenYYYYY = parseTokensYYYYY[additionalDigits]\n\n  var token\n\n  // YYYY or YYYYY\n  token = parseTokenYYYY.exec(dateString) || parseTokenYYYYY.exec(dateString)\n  if (token) {\n    var yearString = token[1]\n    return {\n      year: parseInt(yearString, 10),\n      restDateString: dateString.slice(yearString.length)\n    }\n  }\n\n  // YY or YYY\n  token = parseTokenYY.exec(dateString) || parseTokenYYY.exec(dateString)\n  if (token) {\n    var centuryString = token[1]\n    return {\n      year: parseInt(centuryString, 10) * 100,\n      restDateString: dateString.slice(centuryString.length)\n    }\n  }\n\n  // Invalid ISO-formatted year\n  return {\n    year: null\n  }\n}\n\nfunction parseDate (dateString, year) {\n  // Invalid ISO-formatted year\n  if (year === null) {\n    return null\n  }\n\n  var token\n  var date\n  var month\n  var week\n\n  // YYYY\n  if (dateString.length === 0) {\n    date = new Date(0)\n    date.setUTCFullYear(year)\n    return date\n  }\n\n  // YYYY-MM\n  token = parseTokenMM.exec(dateString)\n  if (token) {\n    date = new Date(0)\n    month = parseInt(token[1], 10) - 1\n    date.setUTCFullYear(year, month)\n    return date\n  }\n\n  // YYYY-DDD or YYYYDDD\n  token = parseTokenDDD.exec(dateString)\n  if (token) {\n    date = new Date(0)\n    var dayOfYear = parseInt(token[1], 10)\n    date.setUTCFullYear(year, 0, dayOfYear)\n    return date\n  }\n\n  // YYYY-MM-DD or YYYYMMDD\n  token = parseTokenMMDD.exec(dateString)\n  if (token) {\n    date = new Date(0)\n    month = parseInt(token[1], 10) - 1\n    var day = parseInt(token[2], 10)\n    date.setUTCFullYear(year, month, day)\n    return date\n  }\n\n  // YYYY-Www or YYYYWww\n  token = parseTokenWww.exec(dateString)\n  if (token) {\n    week = parseInt(token[1], 10) - 1\n    return dayOfISOYear(year, week)\n  }\n\n  // YYYY-Www-D or YYYYWwwD\n  token = parseTokenWwwD.exec(dateString)\n  if (token) {\n    week = parseInt(token[1], 10) - 1\n    var dayOfWeek = parseInt(token[2], 10) - 1\n    return dayOfISOYear(year, week, dayOfWeek)\n  }\n\n  // Invalid ISO-formatted date\n  return null\n}\n\nfunction parseTime (timeString) {\n  var token\n  var hours\n  var minutes\n\n  // hh\n  token = parseTokenHH.exec(timeString)\n  if (token) {\n    hours = parseFloat(token[1].replace(',', '.'))\n    return (hours % 24) * MILLISECONDS_IN_HOUR\n  }\n\n  // hh:mm or hhmm\n  token = parseTokenHHMM.exec(timeString)\n  if (token) {\n    hours = parseInt(token[1], 10)\n    minutes = parseFloat(token[2].replace(',', '.'))\n    return (hours % 24) * MILLISECONDS_IN_HOUR +\n      minutes * MILLISECONDS_IN_MINUTE\n  }\n\n  // hh:mm:ss or hhmmss\n  token = parseTokenHHMMSS.exec(timeString)\n  if (token) {\n    hours = parseInt(token[1], 10)\n    minutes = parseInt(token[2], 10)\n    var seconds = parseFloat(token[3].replace(',', '.'))\n    return (hours % 24) * MILLISECONDS_IN_HOUR +\n      minutes * MILLISECONDS_IN_MINUTE +\n      seconds * 1000\n  }\n\n  // Invalid ISO-formatted time\n  return null\n}\n\nfunction parseTimezone (timezoneString) {\n  var token\n  var absoluteOffset\n\n  // Z\n  token = parseTokenTimezoneZ.exec(timezoneString)\n  if (token) {\n    return 0\n  }\n\n  // hh\n  token = parseTokenTimezoneHH.exec(timezoneString)\n  if (token) {\n    absoluteOffset = parseInt(token[2], 10) * 60\n    return (token[1] === '+') ? -absoluteOffset : absoluteOffset\n  }\n\n  // hh:mm or hhmm\n  token = parseTokenTimezoneHHMM.exec(timezoneString)\n  if (token) {\n    absoluteOffset = parseInt(token[2], 10) * 60 + parseInt(token[3], 10)\n    return (token[1] === '+') ? -absoluteOffset : absoluteOffset\n  }\n\n  return 0\n}\n\nfunction dayOfISOYear (isoYear, week, day) {\n  week = week || 0\n  day = day || 0\n  var date = new Date(0)\n  date.setUTCFullYear(isoYear, 0, 4)\n  var fourthOfJanuaryDay = date.getUTCDay() || 7\n  var diff = week * 7 + day + 1 - fourthOfJanuaryDay\n  date.setUTCDate(date.getUTCDate() + diff)\n  return date\n}\n\nmodule.exports = parse\n","'use strict';\n\nvar objectKeys = require('object-keys');\nvar isArguments = require('is-arguments');\nvar is = require('object-is');\nvar isRegex = require('is-regex');\nvar flags = require('regexp.prototype.flags');\nvar isArray = require('isarray');\nvar isDate = require('is-date-object');\nvar whichBoxedPrimitive = require('which-boxed-primitive');\nvar GetIntrinsic = require('get-intrinsic');\nvar callBound = require('call-bind/callBound');\nvar whichCollection = require('which-collection');\nvar getIterator = require('es-get-iterator');\nvar getSideChannel = require('side-channel');\nvar whichTypedArray = require('which-typed-array');\nvar assign = require('object.assign');\n\nvar $getTime = callBound('Date.prototype.getTime');\nvar gPO = Object.getPrototypeOf;\nvar $objToString = callBound('Object.prototype.toString');\n\nvar $Set = GetIntrinsic('%Set%', true);\nvar $mapHas = callBound('Map.prototype.has', true);\nvar $mapGet = callBound('Map.prototype.get', true);\nvar $mapSize = callBound('Map.prototype.size', true);\nvar $setAdd = callBound('Set.prototype.add', true);\nvar $setDelete = callBound('Set.prototype.delete', true);\nvar $setHas = callBound('Set.prototype.has', true);\nvar $setSize = callBound('Set.prototype.size', true);\n\n// taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L401-L414\nfunction setHasEqualElement(set, val1, opts, channel) {\n  var i = getIterator(set);\n  var result;\n  while ((result = i.next()) && !result.done) {\n    if (internalDeepEqual(val1, result.value, opts, channel)) { // eslint-disable-line no-use-before-define\n      // Remove the matching element to make sure we do not check that again.\n      $setDelete(set, result.value);\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L416-L439\nfunction findLooseMatchingPrimitives(prim) {\n  if (typeof prim === 'undefined') {\n    return null;\n  }\n  if (typeof prim === 'object') { // Only pass in null as object!\n    return void 0;\n  }\n  if (typeof prim === 'symbol') {\n    return false;\n  }\n  if (typeof prim === 'string' || typeof prim === 'number') {\n    // Loose equal entries exist only if the string is possible to convert to a regular number and not NaN.\n    return +prim === +prim; // eslint-disable-line no-implicit-coercion\n  }\n  return true;\n}\n\n// taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L449-L460\nfunction mapMightHaveLoosePrim(a, b, prim, item, opts, channel) {\n  var altValue = findLooseMatchingPrimitives(prim);\n  if (altValue != null) {\n    return altValue;\n  }\n  var curB = $mapGet(b, altValue);\n  var looseOpts = assign({}, opts, { strict: false });\n  if (\n    (typeof curB === 'undefined' && !$mapHas(b, altValue))\n    // eslint-disable-next-line no-use-before-define\n    || !internalDeepEqual(item, curB, looseOpts, channel)\n  ) {\n    return false;\n  }\n  // eslint-disable-next-line no-use-before-define\n  return !$mapHas(a, altValue) && internalDeepEqual(item, curB, looseOpts, channel);\n}\n\n// taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L441-L447\nfunction setMightHaveLoosePrim(a, b, prim) {\n  var altValue = findLooseMatchingPrimitives(prim);\n  if (altValue != null) {\n    return altValue;\n  }\n\n  return $setHas(b, altValue) && !$setHas(a, altValue);\n}\n\n// taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L518-L533\nfunction mapHasEqualEntry(set, map, key1, item1, opts, channel) {\n  var i = getIterator(set);\n  var result;\n  var key2;\n  while ((result = i.next()) && !result.done) {\n    key2 = result.value;\n    if (\n      // eslint-disable-next-line no-use-before-define\n      internalDeepEqual(key1, key2, opts, channel)\n      // eslint-disable-next-line no-use-before-define\n      && internalDeepEqual(item1, $mapGet(map, key2), opts, channel)\n    ) {\n      $setDelete(set, key2);\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction internalDeepEqual(actual, expected, options, channel) {\n  var opts = options || {};\n\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (opts.strict ? is(actual, expected) : actual === expected) {\n    return true;\n  }\n\n  var actualBoxed = whichBoxedPrimitive(actual);\n  var expectedBoxed = whichBoxedPrimitive(expected);\n  if (actualBoxed !== expectedBoxed) {\n    return false;\n  }\n\n  // 7.3. Other pairs that do not both pass typeof value == 'object', equivalence is determined by ==.\n  if (!actual || !expected || (typeof actual !== 'object' && typeof expected !== 'object')) {\n    return opts.strict ? is(actual, expected) : actual == expected; // eslint-disable-line eqeqeq\n  }\n\n  /*\n   * 7.4. For all other Object pairs, including Array objects, equivalence is\n   * determined by having the same number of owned properties (as verified\n   * with Object.prototype.hasOwnProperty.call), the same set of keys\n   * (although not necessarily the same order), equivalent values for every\n   * corresponding key, and an identical 'prototype' property. Note: this\n   * accounts for both named and indexed properties on Arrays.\n   */\n  // see https://github.com/nodejs/node/commit/d3aafd02efd3a403d646a3044adcf14e63a88d32 for memos/channel inspiration\n\n  var hasActual = channel.has(actual);\n  var hasExpected = channel.has(expected);\n  var sentinel;\n  if (hasActual && hasExpected) {\n    if (channel.get(actual) === channel.get(expected)) {\n      return true;\n    }\n  } else {\n    sentinel = {};\n  }\n  if (!hasActual) { channel.set(actual, sentinel); }\n  if (!hasExpected) { channel.set(expected, sentinel); }\n\n  // eslint-disable-next-line no-use-before-define\n  return objEquiv(actual, expected, opts, channel);\n}\n\nfunction isBuffer(x) {\n  if (!x || typeof x !== 'object' || typeof x.length !== 'number') {\n    return false;\n  }\n  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {\n    return false;\n  }\n  if (x.length > 0 && typeof x[0] !== 'number') {\n    return false;\n  }\n\n  return !!(x.constructor && x.constructor.isBuffer && x.constructor.isBuffer(x));\n}\n\nfunction setEquiv(a, b, opts, channel) {\n  if ($setSize(a) !== $setSize(b)) {\n    return false;\n  }\n  var iA = getIterator(a);\n  var iB = getIterator(b);\n  var resultA;\n  var resultB;\n  var set;\n  while ((resultA = iA.next()) && !resultA.done) {\n    if (resultA.value && typeof resultA.value === 'object') {\n      if (!set) { set = new $Set(); }\n      $setAdd(set, resultA.value);\n    } else if (!$setHas(b, resultA.value)) {\n      if (opts.strict) { return false; }\n      if (!setMightHaveLoosePrim(a, b, resultA.value)) {\n        return false;\n      }\n      if (!set) { set = new $Set(); }\n      $setAdd(set, resultA.value);\n    }\n  }\n  if (set) {\n    while ((resultB = iB.next()) && !resultB.done) {\n      // We have to check if a primitive value is already matching and only if it's not, go hunting for it.\n      if (resultB.value && typeof resultB.value === 'object') {\n        if (!setHasEqualElement(set, resultB.value, opts.strict, channel)) {\n          return false;\n        }\n      } else if (\n        !opts.strict\n        && !$setHas(a, resultB.value)\n        && !setHasEqualElement(set, resultB.value, opts.strict, channel)\n      ) {\n        return false;\n      }\n    }\n    return $setSize(set) === 0;\n  }\n  return true;\n}\n\nfunction mapEquiv(a, b, opts, channel) {\n  if ($mapSize(a) !== $mapSize(b)) {\n    return false;\n  }\n  var iA = getIterator(a);\n  var iB = getIterator(b);\n  var resultA;\n  var resultB;\n  var set;\n  var key;\n  var item1;\n  var item2;\n  while ((resultA = iA.next()) && !resultA.done) {\n    key = resultA.value[0];\n    item1 = resultA.value[1];\n    if (key && typeof key === 'object') {\n      if (!set) { set = new $Set(); }\n      $setAdd(set, key);\n    } else {\n      item2 = $mapGet(b, key);\n      if ((typeof item2 === 'undefined' && !$mapHas(b, key)) || !internalDeepEqual(item1, item2, opts, channel)) {\n        if (opts.strict) {\n          return false;\n        }\n        if (!mapMightHaveLoosePrim(a, b, key, item1, opts, channel)) {\n          return false;\n        }\n        if (!set) { set = new $Set(); }\n        $setAdd(set, key);\n      }\n    }\n  }\n\n  if (set) {\n    while ((resultB = iB.next()) && !resultB.done) {\n      key = resultB.value[0];\n      item2 = resultB.value[1];\n      if (key && typeof key === 'object') {\n        if (!mapHasEqualEntry(set, a, key, item2, opts, channel)) {\n          return false;\n        }\n      } else if (\n        !opts.strict\n        && (!a.has(key) || !internalDeepEqual($mapGet(a, key), item2, opts, channel))\n        && !mapHasEqualEntry(set, a, key, item2, assign({}, opts, { strict: false }), channel)\n      ) {\n        return false;\n      }\n    }\n    return $setSize(set) === 0;\n  }\n  return true;\n}\n\nfunction objEquiv(a, b, opts, channel) {\n  /* eslint max-statements: [2, 100], max-lines-per-function: [2, 120], max-depth: [2, 5] */\n  var i, key;\n\n  if (typeof a !== typeof b) { return false; }\n  if (a == null || b == null) { return false; }\n\n  if ($objToString(a) !== $objToString(b)) { return false; }\n\n  if (isArguments(a) !== isArguments(b)) { return false; }\n\n  var aIsArray = isArray(a);\n  var bIsArray = isArray(b);\n  if (aIsArray !== bIsArray) { return false; }\n\n  // TODO: replace when a cross-realm brand check is available\n  var aIsError = a instanceof Error;\n  var bIsError = b instanceof Error;\n  if (aIsError !== bIsError) { return false; }\n  if (aIsError || bIsError) {\n    if (a.name !== b.name || a.message !== b.message) { return false; }\n  }\n\n  var aIsRegex = isRegex(a);\n  var bIsRegex = isRegex(b);\n  if (aIsRegex !== bIsRegex) { return false; }\n  if ((aIsRegex || bIsRegex) && (a.source !== b.source || flags(a) !== flags(b))) {\n    return false;\n  }\n\n  var aIsDate = isDate(a);\n  var bIsDate = isDate(b);\n  if (aIsDate !== bIsDate) { return false; }\n  if (aIsDate || bIsDate) { // && would work too, because both are true or both false here\n    if ($getTime(a) !== $getTime(b)) { return false; }\n  }\n  if (opts.strict && gPO && gPO(a) !== gPO(b)) { return false; }\n\n  if (whichTypedArray(a) !== whichTypedArray(b)) {\n    return false;\n  }\n\n  var aIsBuffer = isBuffer(a);\n  var bIsBuffer = isBuffer(b);\n  if (aIsBuffer !== bIsBuffer) { return false; }\n  if (aIsBuffer || bIsBuffer) { // && would work too, because both are true or both false here\n    if (a.length !== b.length) { return false; }\n    for (i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) { return false; }\n    }\n    return true;\n  }\n\n  if (typeof a !== typeof b) { return false; }\n\n  var ka = objectKeys(a);\n  var kb = objectKeys(b);\n  // having the same number of owned properties (keys incorporates hasOwnProperty)\n  if (ka.length !== kb.length) { return false; }\n\n  // the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  // ~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i]) { return false; } // eslint-disable-line eqeqeq\n  }\n\n  // equivalent values for every corresponding key, and ~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!internalDeepEqual(a[key], b[key], opts, channel)) { return false; }\n  }\n\n  var aCollection = whichCollection(a);\n  var bCollection = whichCollection(b);\n  if (aCollection !== bCollection) {\n    return false;\n  }\n  if (aCollection === 'Set' || bCollection === 'Set') { // aCollection === bCollection\n    return setEquiv(a, b, opts, channel);\n  }\n  if (aCollection === 'Map') { // aCollection === bCollection\n    return mapEquiv(a, b, opts, channel);\n  }\n\n  return true;\n}\n\nmodule.exports = function deepEqual(a, b, opts) {\n  return internalDeepEqual(a, b, opts, getSideChannel());\n};\n","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n","'use strict';\n\nvar keys = require('object-keys');\nvar hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';\n\nvar toStr = Object.prototype.toString;\nvar concat = Array.prototype.concat;\nvar origDefineProperty = Object.defineProperty;\n\nvar isFunction = function (fn) {\n\treturn typeof fn === 'function' && toStr.call(fn) === '[object Function]';\n};\n\nvar hasPropertyDescriptors = require('has-property-descriptors')();\n\nvar supportsDescriptors = origDefineProperty && hasPropertyDescriptors;\n\nvar defineProperty = function (object, name, value, predicate) {\n\tif (name in object && (!isFunction(predicate) || !predicate())) {\n\t\treturn;\n\t}\n\tif (supportsDescriptors) {\n\t\torigDefineProperty(object, name, {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: false,\n\t\t\tvalue: value,\n\t\t\twritable: true\n\t\t});\n\t} else {\n\t\tobject[name] = value; // eslint-disable-line no-param-reassign\n\t}\n};\n\nvar defineProperties = function (object, map) {\n\tvar predicates = arguments.length > 2 ? arguments[2] : {};\n\tvar props = keys(map);\n\tif (hasSymbols) {\n\t\tprops = concat.call(props, Object.getOwnPropertySymbols(map));\n\t}\n\tfor (var i = 0; i < props.length; i += 1) {\n\t\tdefineProperty(object, props[i], map[props[i]], predicates[props[i]]);\n\t}\n};\n\ndefineProperties.supportsDescriptors = !!supportsDescriptors;\n\nmodule.exports = defineProperties;\n","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n","const { toString: toStringFunction } = Function.prototype;\nconst {\n  create,\n  defineProperty,\n  getOwnPropertyDescriptor,\n  getOwnPropertyNames,\n  getOwnPropertySymbols,\n  getPrototypeOf,\n} = Object;\nconst { hasOwnProperty, propertyIsEnumerable } = Object.prototype;\n\nconst SYMBOL_PROPERTIES = typeof getOwnPropertySymbols === 'function';\nconst WEAK_MAP = typeof WeakMap === 'function';\n\n/**\n * @function createCache\n *\n * @description\n * get a new cache object to prevent circular references\n *\n * @returns the new cache object\n */\nexport const createCache = (() => {\n  if (WEAK_MAP) {\n    return (): FastCopy.Cache => new WeakMap();\n  }\n\n  class Cache {\n    _keys: any[] = [];\n    _values: any[] = [];\n\n    has(key: any) {\n      return !!~this._keys.indexOf(key);\n    }\n\n    get(key: any) {\n      return this._values[this._keys.indexOf(key)];\n    }\n\n    set(key: any, value: any) {\n      this._keys.push(key);\n      this._values.push(value);\n    }\n  }\n\n  return (): FastCopy.Cache => new Cache();\n})();\n\n/**\n * @function getCleanClone\n *\n * @description\n * get an empty version of the object with the same prototype it has\n *\n * @param object the object to build a clean clone from\n * @param realm the realm the object resides in\n * @returns the empty cloned object\n */\nexport const getCleanClone = (object: any, realm: FastCopy.Realm): any => {\n  const prototype = object.__proto__ || getPrototypeOf(object);\n\n  if (!prototype) {\n    return create(null);\n  }\n\n  const Constructor = prototype.constructor;\n\n  if (Constructor === realm.Object) {\n    return prototype === realm.Object.prototype ? {} : create(prototype);\n  }\n\n  if (~toStringFunction.call(Constructor).indexOf('[native code]')) {\n    try {\n      return new Constructor();\n    } catch {}\n  }\n\n  return create(prototype);\n};\n\n/**\n * @function getObjectCloneLoose\n *\n * @description\n * get a copy of the object based on loose rules, meaning all enumerable keys\n * and symbols are copied, but property descriptors are not considered\n *\n * @param object the object to clone\n * @param realm the realm the object resides in\n * @param handleCopy the function that handles copying the object\n * @returns the copied object\n */\nexport const getObjectCloneLoose: FastCopy.ObjectCloner = (\n  object: any,\n  realm: FastCopy.Realm,\n  handleCopy: FastCopy.Copier,\n  cache: FastCopy.Cache,\n): any => {\n  const clone: any = getCleanClone(object, realm);\n\n  // set in the cache immediately to be able to reuse the object recursively\n  cache.set(object, clone);\n\n  for (const key in object) {\n    if (hasOwnProperty.call(object, key)) {\n      clone[key] = handleCopy(object[key], cache);\n    }\n  }\n\n  if (SYMBOL_PROPERTIES) {\n    const symbols: symbol[] = getOwnPropertySymbols(object);\n\n    for (\n      let index = 0, length = symbols.length, symbol;\n      index < length;\n      ++index\n    ) {\n      symbol = symbols[index];\n\n      if (propertyIsEnumerable.call(object, symbol)) {\n        clone[symbol] = handleCopy(object[symbol], cache);\n      }\n    }\n  }\n\n  return clone;\n};\n\n/**\n * @function getObjectCloneStrict\n *\n * @description\n * get a copy of the object based on strict rules, meaning all keys and symbols\n * are copied based on the original property descriptors\n *\n * @param object the object to clone\n * @param realm the realm the object resides in\n * @param handleCopy the function that handles copying the object\n * @returns the copied object\n */\nexport const getObjectCloneStrict: FastCopy.ObjectCloner = (\n  object: any,\n  realm: FastCopy.Realm,\n  handleCopy: FastCopy.Copier,\n  cache: FastCopy.Cache,\n): any => {\n  const clone: any = getCleanClone(object, realm);\n\n  // set in the cache immediately to be able to reuse the object recursively\n  cache.set(object, clone);\n\n  const properties: (string | symbol)[] = SYMBOL_PROPERTIES\n    ? getOwnPropertyNames(object).concat(\n        getOwnPropertySymbols(object) as unknown as string[],\n      )\n    : getOwnPropertyNames(object);\n\n  for (\n    let index = 0, length = properties.length, property, descriptor;\n    index < length;\n    ++index\n  ) {\n    property = properties[index];\n\n    if (property !== 'callee' && property !== 'caller') {\n      descriptor = getOwnPropertyDescriptor(object, property);\n\n      if (descriptor) {\n        // Only clone the value if actually a value, not a getter / setter.\n        if (!descriptor.get && !descriptor.set) {\n          descriptor.value = handleCopy(object[property], cache);\n        }\n\n        try {\n          defineProperty(clone, property, descriptor);\n        } catch (error) {\n          // Tee above can fail on node in edge cases, so fall back to the loose assignment.\n          clone[property] = descriptor.value;\n        }\n      } else {\n        // In extra edge cases where the property descriptor cannot be retrived, fall back to\n        // the loose assignment.\n        clone[property] = handleCopy(object[property], cache);\n      }\n    }\n  }\n\n  return clone;\n};\n\n/**\n * @function getRegExpFlags\n *\n * @description\n * get the flags to apply to the copied regexp\n *\n * @param regExp the regexp to get the flags of\n * @returns the flags for the regexp\n */\nexport const getRegExpFlags = (regExp: RegExp): string => {\n  let flags = '';\n\n  if (regExp.global) {\n    flags += 'g';\n  }\n\n  if (regExp.ignoreCase) {\n    flags += 'i';\n  }\n\n  if (regExp.multiline) {\n    flags += 'm';\n  }\n\n  if (regExp.unicode) {\n    flags += 'u';\n  }\n\n  if (regExp.sticky) {\n    flags += 'y';\n  }\n\n  return flags;\n};\n","// utils\nimport {\n  createCache,\n  getObjectCloneLoose,\n  getObjectCloneStrict,\n  getRegExpFlags,\n} from './utils';\n\nconst { isArray } = Array;\nconst { getPrototypeOf } = Object;\n\nconst GLOBAL_THIS: FastCopy.Realm = (function () {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  }\n\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n\n  if (console && console.error) {\n    console.error('Unable to locate global object, returning \"this\".');\n  }\n\n  return this;\n})();\n\n/**\n * @function copy\n *\n * @description\n * copy an value deeply as much as possible\n *\n * If `strict` is applied, then all properties (including non-enumerable ones)\n * are copied with their original property descriptors on both objects and arrays.\n *\n * The value is compared to the global constructors in the `realm` provided,\n * and the native constructor is always used to ensure that extensions of native\n * objects (allows in ES2015+) are maintained.\n *\n * @param value the value to copy\n * @param [options] the options for copying with\n * @param [options.isStrict] should the copy be strict\n * @param [options.realm] the realm (this) value the value is copied from\n * @returns the copied value\n */\nfunction copy<Value>(value: Value, options?: FastCopy.Options): Value {\n  // manually coalesced instead of default parameters for performance\n  const isStrict = !!(options && options.isStrict);\n  const realm = (options && options.realm) || GLOBAL_THIS;\n  const getObjectClone = isStrict ? getObjectCloneStrict : getObjectCloneLoose;\n\n  /**\n   * @function handleCopy\n   *\n   * @description\n   * copy the value recursively based on its type\n   *\n   * @param value the value to copy\n   * @returns the copied value\n   */\n  const handleCopy: FastCopy.Copier = (\n    value: any,\n    cache: FastCopy.Cache,\n  ): any => {\n    if (!value || typeof value !== 'object') {\n      return value;\n    }\n\n    if (cache.has(value)) {\n      return cache.get(value);\n    }\n\n    const prototype = value.__proto__ || getPrototypeOf(value);\n    const Constructor = prototype && prototype.constructor;\n\n    // plain objects\n    if (!Constructor || Constructor === realm.Object) {\n      return getObjectClone(value, realm, handleCopy, cache);\n    }\n\n    let clone: any;\n\n    // arrays\n    if (isArray(value)) {\n      // if strict, include non-standard properties\n      if (isStrict) {\n        return getObjectCloneStrict(value, realm, handleCopy, cache);\n      }\n\n      clone = new Constructor();\n      cache.set(value, clone);\n\n      for (\n        let index: number = 0, length = value.length;\n        index < length;\n        ++index\n      ) {\n        clone[index] = handleCopy(value[index], cache);\n      }\n\n      return clone;\n    }\n\n    // dates\n    if (value instanceof realm.Date) {\n      return new Constructor(value.getTime());\n    }\n\n    // regexps\n    if (value instanceof realm.RegExp) {\n      clone = new Constructor(\n        value.source,\n        value.flags || getRegExpFlags(value),\n      );\n\n      clone.lastIndex = value.lastIndex;\n\n      return clone;\n    }\n\n    // maps\n    if (realm.Map && value instanceof realm.Map) {\n      clone = new Constructor();\n      cache.set(value, clone);\n\n      value.forEach((value: any, key: any) => {\n        clone.set(key, handleCopy(value, cache));\n      });\n\n      return clone;\n    }\n\n    // sets\n    if (realm.Set && value instanceof realm.Set) {\n      clone = new Constructor();\n      cache.set(value, clone);\n\n      value.forEach((value: any) => {\n        clone.add(handleCopy(value, cache));\n      });\n\n      return clone;\n    }\n\n    // blobs\n    if (realm.Blob && value instanceof realm.Blob) {\n      return value.slice(0, value.size, value.type);\n    }\n\n    // buffers (node-only)\n    if (realm.Buffer && realm.Buffer.isBuffer(value)) {\n      clone = realm.Buffer.allocUnsafe\n        ? realm.Buffer.allocUnsafe(value.length)\n        : new Constructor(value.length);\n\n      cache.set(value, clone);\n      value.copy(clone);\n\n      return clone;\n    }\n\n    // arraybuffers / dataviews\n    if (realm.ArrayBuffer) {\n      // dataviews\n      if (realm.ArrayBuffer.isView(value)) {\n        clone = new Constructor(value.buffer.slice(0));\n        cache.set(value, clone);\n        return clone;\n      }\n\n      // arraybuffers\n      if (value instanceof realm.ArrayBuffer) {\n        clone = value.slice(0);\n        cache.set(value, clone);\n        return clone;\n      }\n    }\n\n    // if the value cannot / should not be cloned, don't\n    if (\n      // promise-like\n      typeof value.then === 'function' ||\n      // errors\n      value instanceof Error ||\n      // weakmaps\n      (realm.WeakMap && value instanceof realm.WeakMap) ||\n      // weaksets\n      (realm.WeakSet && value instanceof realm.WeakSet)\n    ) {\n      return value;\n    }\n\n    // assume anything left is a custom constructor\n    return getObjectClone(value, realm, handleCopy, cache);\n  };\n\n  return handleCopy(value, createCache());\n}\n\n// Adding reference to allow usage in CommonJS libraries compiled using TSC, which\n// expects there to be a default property on the exported value. See\n// [#37](https://github.com/planttheidea/fast-copy/issues/37) for details.\ncopy.default = copy;\n\n/**\n * @function strictCopy\n *\n * @description\n * copy the value with `strict` option pre-applied\n *\n * @param value the value to copy\n * @param [options] the options for copying with\n * @param [options.realm] the realm (this) value the value is copied from\n * @returns the copied value\n */\ncopy.strict = function strictCopy(value: any, options?: FastCopy.Options) {\n  return copy(value, {\n    isStrict: true,\n    realm: options ? options.realm : void 0,\n  });\n};\n\nexport default copy;\n","/**\n *  Exports the FHIR model data for R4.  This is an internal structure that\n *  will likely evolve as more FHIR specific processing is added.\n */\nmodule.exports = {\n  /**\n   *  A hash of resource element paths (e.g. Observation.value) that are known\n   *  to point to fiels that are choice types.\n   */\n  choiceTypePaths: require('./choiceTypePaths.json'),\n\n  /**\n   *  A hash from paths to the path for which their content is defined, e.g.\n   *  Questionnaire.item.item -> Questionnaire.item.\n   */\n  pathsDefinedElsewhere: require('./pathsDefinedElsewhere.json')\n}\n","// Contains the FHIRPath Aggregate functions.\n// (Section 7 of the FHIRPath 2.0.0 (N1) specification).\n\nlet engine = {};\nconst math = require(\"./math\");\nconst equality  = require(\"./equality\");\nconst util = require('./utilities');\n\nengine.aggregateMacro = function(data, expr, initialValue) {\n  return data.reduce((total, x, i) => {\n    this.$index = i;\n    return this.$total = expr(x);\n  }, this.$total = initialValue);\n};\n\nengine.countFn = function(x) {\n  if (x && x.length) {\n    return x.length;\n  } else {\n    return 0;\n  }\n};\n\n// Shortcut for \"value.aggregate($this+$total, 0)\"\nengine.sumFn = function(data) {\n  return engine.aggregateMacro.apply(this, [data, ($this) => {\n    return math.plus(util.arraify($this), util.arraify(this.$total));\n  }, 0]);\n};\n\n// Shortcut for \"value.aggregate(iif($total.empty(), $this, iif($this < $total, $this, $total)))\"\nengine.minFn = function (data) {\n  return engine.aggregateMacro.apply(this, [data, (curr) => {\n    const $this = util.arraify(curr);\n    const $total = util.arraify(this.$total);\n    return util.isEmpty($total)\n      ? $this\n      : equality.lt($this, $total) ? $this : $total;\n  }]);\n};\n\n// Shortcut for \"value.aggregate(iif($total.empty(), $this, iif($this > $total, $this, $total)))\"\nengine.maxFn = function (data) {\n  return engine.aggregateMacro.apply(this, [data, (curr) => {\n    const $this = util.arraify(curr);\n    const $total = util.arraify(this.$total);\n    return util.isEmpty($total)\n      ? $this\n      : equality.gt($this, $total) ? $this : $total;\n  }]);\n};\n\n// Shortcut for \"value.sum()/value.count()\"\nengine.avgFn = function (data) {\n  return math.div(engine.sumFn(data), engine.countFn(data));\n};\n\nmodule.exports = engine;\n","// This file holds code to hande the FHIRPath Math functions.\n\nvar deepEqual = require('./deep-equal');\n\nvar engine = {};\n\n\n// b is assumed to have one element and it tests whether b[0] is in a\nfunction containsImpl(a,b){\n  if(b.length == 0) { return true; }\n  for(var i = 0; i < a.length; i++){\n    if(deepEqual(a[i], b[0])) { return true; }\n  }\n  return false;\n}\n\nengine.contains = function(a, b){\n  if(b.length == 0) { return []; }\n  if(a.length == 0) { return false; }\n  if(b.length > 1) {\n    throw new Error(\"Expected singleton on right side of contains, got \" + JSON.stringify(b));\n  }\n  return containsImpl(a,b);\n};\n\nengine.in = function(a, b){\n  if(a.length == 0) { return []; }\n  if(b.length == 0) { return false; }\n  if(a.length > 1) {\n    throw new Error(\"Expected singleton on right side of in, got \" + JSON.stringify(b));\n  }\n  return containsImpl(b,a);\n};\n\nmodule.exports = engine;\n","// This file holds code to hande the FHIRPath Combining functions.\n\nconst combineFns = {};\nconst {distinctFn} = require('./filtering');\nconst hashObject = require('./hash-object');\n\ncombineFns.union = function(coll1, coll2){\n  return distinctFn(coll1.concat(coll2));\n};\n\ncombineFns.combineFn = function(coll1, coll2){\n  return coll1.concat(coll2);\n};\n\ncombineFns.intersect = function(coll1, coll2) {\n  let result = [];\n  const coll1Length = coll1.length;\n  let uncheckedLength = coll2.length;\n\n  if (coll1Length && uncheckedLength) {\n    let coll2hash = {};\n    coll2.forEach(item => {\n      const hash = hashObject(item);\n      if (coll2hash[hash]) {\n        uncheckedLength--;\n      } else {\n        coll2hash[hash] = true;\n      }\n    });\n\n    for (let i=0; i<coll1Length && uncheckedLength > 0; ++i) {\n      let item = coll1[i];\n      let hash = hashObject(item);\n      if (coll2hash[hash]) {\n        result.push(item);\n        coll2hash[hash] = false;\n        uncheckedLength--;\n      }\n    }\n  }\n\n  return result;\n};\n\n\nmodule.exports = combineFns;\n","// These are values that should not change during an evaluation of a FHIRPath\n// expression (e.g. the return value of today(), per the spec.)  They are\n// constant during at least one evaluation.\n\nmodule.exports = {\n  /**\n   *  Resets the constants.  Should be called when before the engine starts its\n   *  processing.\n   */\n  reset: function() {\n    this.nowDate = new Date(); // a Date object representing \"now\"\n    this.today = null;\n    this.now = null;\n    this.timeOfDay = null;\n    this.localTimezoneOffset = null;\n  },\n\n  /**\n   *  The cached value of today().\n   */\n  today: null,\n\n  /**\n   *  The cached value of now().\n   */\n  now: null,\n\n  /**\n   *  The cached value of timeOfDay().\n   */\n  timeOfDay: null\n};\n","var engine = {};\nconst types = require('./types');\nconst constants = require('./constants');\nconst FP_DateTime = types.FP_DateTime;\nconst FP_Time = types.FP_Time;\n\n/**\n *  Implements FHIRPath now().\n */\nengine.now = function(){\n  if (!constants.now) {\n    // return new FP_DateTime((new Date()).toISOString());\n    // The above would construct an FP_DateTime with a timezone of \"Z\", which\n    // would not make a difference for computation, but if the end result of an\n    // expression is \"now()\", then it would look different when output to a user.\n    // Construct it ourselves to preserve timezone\n    var now = constants.nowDate; // a JS Date\n    var isoStr = FP_DateTime.isoDateTime(now);\n    constants.now = new FP_DateTime(isoStr);\n  }\n  return constants.now;\n};\n\n\n/**\n *  Implements FHIRPath today().  See comments in now(). This does not\n *  include a timezone offset.\n */\nengine.today = function(){\n  if (!constants.today) {\n    // Construct the string ourselves to preserve timezone\n    var now = constants.nowDate; // a JS Date\n    var isoStr = FP_DateTime.isoDate(now);\n    constants.today = new FP_DateTime(isoStr);\n  }\n  return constants.today;\n};\n\n/**\n *  Implements FHIRPath timeOfDay().  See comments in now(). This does not\n *  include a timezone offset.\n */\nengine.timeOfDay = function() {\n  if (!constants.timeOfDay) {\n    // Construct the string ourselves to preserve timezone\n    const now = constants.nowDate; // a JS Date\n    const isoStr = FP_DateTime.isoTime(now);\n    constants.timeOfDay = new FP_Time(isoStr);\n  }\n  return constants.timeOfDay;\n};\n\nmodule.exports = engine;\n","// Originally copied from node-deep-equal\n// (https://github.com/substack/node-deep-equal), with modifications.\n// For the license for node-deep-equal, see the bottom of this file.\n\nvar types = require('./types');\nvar FP_Type = types.FP_Type;\nvar util = require('./utilities');\nvar numbers = require('./numbers');\nvar pSlice = Array.prototype.slice;\nvar objectKeys = Object.keys;\nvar isArguments = function (object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n};\n\nfunction isString(myVar) {\n  return (typeof myVar === 'string' || myVar instanceof String);\n}\n\nfunction isNumber(n) {\n  return !isNaN(parseFloat(n)) && isFinite(n);\n}\n\nfunction normalizeStr(x) {\n  return x.toUpperCase().replace(/\\s+/, ' ');\n}\n\n/**\n * Performs a deep comparison between two values to determine if they are equal.\n * When you need to compare many objects, you can use hashObject instead for\n * optimization (if changes are needed here, they are likely also needed there).\n * @param {any} actual - one of the comparing objects\n * @param {any} expected - one of the comparing objects\n * @param {Object} [opts] - comparison options\n * @param {boolean} [opts.fuzzy] - false (by default), if comparing objects for\n *   equality (see https://hl7.org/fhirpath/#equals).\n *   true, if comparing objects for equivalence\n *   (see https://hl7.org/fhirpath/#equivalent).\n * @return {boolean}\n */\nfunction deepEqual(actual, expected, opts) {\n  actual = util.valDataConverted(actual);\n  expected = util.valDataConverted(expected);\n  if (!opts) opts = {};\n\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n  }\n\n  if (opts.fuzzy) {\n    if(isString(actual) && isString(expected)) {\n      return normalizeStr(actual) == normalizeStr(expected);\n    }\n    if(isNumber(actual) && isNumber(expected)) {\n      return numbers.isEquivalent(actual, expected);\n    }\n  }\n  else { // !opts.fuzzy\n    // If these are numbers, they need to be rounded to the maximum supported\n    // precision to remove floating point arithmetic errors (e.g. 0.1+0.1+0.1 should\n    // equal 0.3) before comparing.\n    if (typeof actual === 'number' && typeof expected === 'number') {\n      return numbers.isEqual(actual, expected);\n    }\n  }\n\n  if (actual instanceof Date && expected instanceof Date) {\n    return actual.getTime() === expected.getTime();\n  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {\n    return actual === expected;\n  }\n  else {\n    var actualIsFPT = actual instanceof FP_Type;\n    var expectedIsFPT = expected instanceof FP_Type;\n    if (actualIsFPT && expectedIsFPT) { // if both are FP_Type\n      let rtn = opts.fuzzy ? actual.equivalentTo(expected) :\n        actual.equals(expected); // May return undefined\n      return rtn;\n    }\n    else if (actualIsFPT || expectedIsFPT) { // if only one is an FP_Type\n      // See if the other is convertible.\n      let fpt, nonFPT;\n      if (actualIsFPT) {\n        fpt = actual;\n        nonFPT = expected;\n      }\n      else {\n        fpt = expected;\n        nonFPT = actual;\n      }\n      let rtn = typeof nonFPT === 'string';\n      if (rtn) {\n        let d = fpt.constructor.checkString(nonFPT);\n        if (d) {\n          rtn = opts.fuzzy ? actual.equivalentTo(d) :\n            fpt.equals(d); // May return undefined\n        }\n        else\n          rtn = false; // not a date string\n      }\n      return rtn;\n    }\n    // 7.4. For all other Object pairs, including Array objects, equivalence is\n    // determined by having the same number of owned properties (as verified\n    // with Object.prototype.hasOwnProperty.call), the same set of keys\n    // (although not necessarily the same order), equivalent values for every\n    // corresponding key, and an identical 'prototype' property. Note: this\n    // accounts for both named and indexed properties on Arrays.\n    return objEquiv(actual, expected, opts);\n  }\n}\n\nfunction isUndefinedOrNull(value) {\n  return value === null || value === undefined;\n}\n\nfunction objEquiv(a, b, opts) {\n  var i, key;\n  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))\n    return false;\n  // an identical 'prototype' property.\n  if (a.prototype !== b.prototype) return false;\n  //~~~I've managed to break Object.keys through screwy arguments passing.\n  //   Converting to array solves the problem.\n  if(isArguments(a) || isArguments(b)) {\n    a = isArguments(a) ? pSlice.call(a) : a;\n    b = isArguments(b) ? pSlice.call(b) : b;\n    return deepEqual(a, b, opts);\n  }\n  try {\n    var ka = objectKeys(a), kb = objectKeys(b);\n  } catch (e) {//happens when one is a string literal and the other isn't\n    return false;\n  }\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length != kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  // If the length of the array is one, return the value of deepEqual (which can\n  // be \"undefined\".\n  if (ka.length === 1) {\n    key = ka[0];\n    return deepEqual(a[key], b[key], opts);\n  }\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!deepEqual(a[key], b[key], opts)) return false;\n  }\n  return typeof a === typeof b;\n}\n\nmodule.exports = deepEqual;\n\n// The license for node-deep-equal, on which the above code is based, is as\n// follows:\n//\n// This software is released under the MIT license:\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\n// this software and associated documentation files (the \"Software\"), to deal in\n// the Software without restriction, including without limitation the rights to\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n// the Software, and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n","// This file holds code to handle the FHIRPath Math functions.\n\nvar util = require(\"./utilities\");\nvar deepEqual = require('./deep-equal');\nvar types = require('./types');\nconst FP_Type = types.FP_Type;\nconst FP_DateTime = types.FP_DateTime;\nconst FP_Time = types.FP_Time;\n\nvar engine = {};\n\nfunction equality(x,y){\n  if(util.isEmpty(x) || util.isEmpty(y)) { return []; }\n  return deepEqual(x, y);\n}\n\nfunction equivalence(x,y){\n  if(util.isEmpty(x) && util.isEmpty(y)) { return [true]; }\n  if(util.isEmpty(x) || util.isEmpty(y)) { return []; }\n  return deepEqual(x, y, {fuzzy: true});\n}\n\nengine.equal = function(a, b){\n  return equality(a, b);\n};\n\nengine.unequal = function(a, b){\n  var eq = equality(a, b);\n  return eq === undefined ? undefined : !eq;\n};\n\nengine.equival = function(a, b){\n  return equivalence(a, b);\n};\n\nengine.unequival = function(a, b){\n  return !equivalence(a, b);\n};\n\n/**\n *  Checks that the types of a and b are suitable for comparison in an\n *  inequality expression.  It is assumed that a check has already been made\n *  that there is at least one value in a and b.\n * @param a the left side of the inequality expression (which should be an array of\n *  one value).\n * @param b the right side of the inequality expression (which should be an array of\n *  one value).\n * @return the singleton values of the arrays a, and b.  If one was an FP_Type\n *  and the other was convertible, the coverted value will be retureed.\n */\nfunction typecheck(a, b){\n  let rtn = null;\n  util.assertAtMostOne(a, \"Singleton was expected\");\n  util.assertAtMostOne(b, \"Singleton was expected\");\n  a = util.valDataConverted(a[0]);\n  b = util.valDataConverted(b[0]);\n  let lClass = a.constructor;\n  let rClass = b.constructor;\n  if (lClass != rClass) {\n    // See if one is an FPDateTime or FTTime while the other is a string.\n    var d;\n    if (lClass === String && (rClass === FP_DateTime || rClass === FP_Time)) {\n      d = rClass.checkString(a);\n      if (d)\n        rtn = [d, b];\n    }\n    else if (rClass === String && (lClass===FP_DateTime || lClass===FP_Time)) {\n      d = lClass.checkString(b);\n      if (d)\n        rtn = [a, d];\n    }\n\n    if (!rtn) {\n      util.raiseError('Type of \"'+a+'\" ('+lClass.name+') did not match type of \"'+\n        b+'\" ('+rClass.name+')', 'InequalityExpression');\n    }\n  }\n  return rtn ? rtn : [a, b];\n}\n\nengine.lt = function(a, b){\n  if (!a.length || !b.length) return [];\n  const [a0, b0] = typecheck(a,b);\n  if (a0 instanceof FP_Type) {\n    const compare = a0.compare(b0);\n    return compare === null ? [] : compare < 0;\n  }\n  return a0 < b0;\n};\n\nengine.gt = function(a, b){\n  if (!a.length || !b.length) return [];\n  const [a0, b0] = typecheck(a,b);\n  if (a0 instanceof FP_Type) {\n    const compare = a0.compare(b0);\n    return compare === null ? [] : compare > 0;\n  }\n  return a0 > b0;\n};\n\nengine.lte = function(a, b){\n  if (!a.length || !b.length) return [];\n  const [a0, b0] = typecheck(a,b);\n  if (a0 instanceof FP_Type) {\n    const compare = a0.compare(b0);\n    return compare === null ? [] : compare <= 0;\n  }\n  return  a0 <= b0;\n};\n\nengine.gte = function(a, b){\n  if (!a.length || !b.length) return [];\n  const [a0, b0] = typecheck(a,b);\n  if (a0 instanceof FP_Type) {\n    const compare = a0.compare(b0);\n    return compare === null ? [] : compare >= 0;\n  }\n  return a0 >= b0;\n};\n\n\nmodule.exports = engine;\n","// This file holds code to hande the FHIRPath Existence functions (5.1 in the\n// specification).\n\nconst util = require(\"./utilities\");\nconst {whereMacro, distinctFn} = require(\"./filtering\");\nconst misc = require(\"./misc\");\nconst hashObject = require('./hash-object');\n\nconst engine = {};\nengine.emptyFn = util.isEmpty;\n\nengine.notFn = function(coll) {\n  let d = misc.singleton(coll, 'Boolean');\n  return (typeof (d) === 'boolean') ? !d : [];\n};\n\nengine.existsMacro  = function(coll, expr) {\n  var vec = coll;\n  if (expr) {\n    return engine.existsMacro(whereMacro(coll, expr));\n  }\n  return !util.isEmpty(vec);\n};\n\nengine.allMacro = function(coll, expr) {\n  for (let i=0, len=coll.length; i<len; ++i) {\n    this.$index = i;\n    if(!util.isTrue(expr(coll[i]))){\n      return [false];\n    }\n  }\n  return [true];\n};\n\nengine.allTrueFn  = function(x) {\n  let rtn = true;\n  for (let i=0, len=x.length; i<len && rtn; ++i) {\n    let xi = util.assertType(x[i], [\"boolean\"], \"allTrue\");\n    rtn = xi === true;\n  }\n  return [rtn];\n};\n\nengine.anyTrueFn  = function(x) {\n  let rtn = false;\n  for (let i=0, len=x.length; i<len && !rtn; ++i) {\n    let xi = util.assertType(x[i], [\"boolean\"], \"anyTrue\");\n    rtn = xi === true;\n  }\n  return [rtn];\n};\n\nengine.allFalseFn  = function(x) {\n  let rtn = true;\n  for (let i=0, len=x.length; i<len && rtn; ++i) {\n    let xi = util.assertType(x[i], [\"boolean\"], \"allFalse\");\n    rtn = xi === false;\n  }\n  return [rtn];\n};\n\nengine.anyFalseFn  = function(x) {\n  let rtn = false;\n  for (let i=0, len=x.length; i<len && !rtn; ++i) {\n    let xi = util.assertType(x[i], [\"boolean\"], \"anyFalse\");\n    rtn = xi === false;\n  }\n  return [rtn];\n};\n\n\n/**\n *  Returns true if coll1 is a subset of coll2.\n */\nfunction subsetOf(coll1, coll2) {\n  const coll1Length = coll1.length;\n  let rtn = coll1Length <= coll2.length;\n  if (rtn && coll1Length) {\n    const c2Hash = coll2.reduce((hash, item) => {\n      hash[hashObject(item)] = true;\n      return hash;\n    }, {});\n    rtn = !coll1.some(item => !c2Hash[hashObject(item)]);\n  }\n  return rtn;\n}\n\nengine.subsetOfFn = function(coll1, coll2) {\n  return [subsetOf(coll1, coll2)];\n};\n\nengine.supersetOfFn = function(coll1, coll2) {\n  return [subsetOf(coll2, coll1)];\n};\n\nengine.isDistinctFn = function(x) {\n  return [x.length === distinctFn(x).length];\n};\n\nmodule.exports = engine;\n","// This is fhirpath interpreter\n// everything starts at evaluate function,\n// which is passed  fhirpath AST and resource.\n//\n// We reduce/eval recursively each node in AST\n// passing the context and current data\n//\n// each AST node has eval function, which should be registered in evalTable\n// and named after node type\n// if node needs to eval father it's children it has to call `doEval` function\n//\n// most of nodes do function or operator invocation at the end\n//\n// For invocation's and operator's there is one lookup table -\n// invocationTable and two helper functions doInvoke and infixInvoke for\n// operators\n// 1. operator or function is looked up in table\n// 2. using signature (in  .arity property) unpack parameters\n// 3. check params types\n// 4. do call function\n// 5. wrap result by util.arraify\n//\n// if function is nullable\n// and one of parameters is empty/null - function will not be invoked and empty\n// result returned\n//\n// Not solved problem is overloading functions by types - for example + operator defined\n// for strings and numbers\n// we can make dispatching params type dependent - let see\n\nconst {version} = require('../package.json');\nconst parser = require(\"./parser\");\nconst util = require(\"./utilities\");\nrequire(\"./polyfill\");\nconst constants = require('./constants');\n\nlet engine    = {}; // the object with all FHIRPath functions and operations\nlet existence = require(\"./existence\");\nlet filtering = require(\"./filtering\");\nlet aggregate = require(\"./aggregate\");\nlet combining = require(\"./combining\");\nlet misc      = require(\"./misc\");\nlet equality  = require(\"./equality\");\nlet collections  = require(\"./collections\");\nlet math      = require(\"./math\");\nlet strings   = require(\"./strings\");\nlet navigation= require(\"./navigation\");\nlet datetime  = require(\"./datetime\");\nlet logic  = require(\"./logic\");\nconst types = require(\"./types\");\nconst {\n  FP_DateTime, FP_Time, FP_Quantity,\n  FP_Type, ResourceNode, TypeInfo\n} = types;\nlet makeResNode = ResourceNode.makeResNode;\n\n// * fn: handler\n// * arity: is index map with type signature\n//   if type is in array (like [Boolean]) - this means\n//   function accepts value of this type or empty value {}\n// * nullable - means propagate empty result, i.e. instead\n//   calling function if one of params is  empty return empty\n\nengine.invocationTable = {\n  empty:        {fn: existence.emptyFn},\n  not:          {fn: existence.notFn},\n  exists:       {fn: existence.existsMacro, arity: {0: [], 1: [\"Expr\"]}},\n  all:          {fn: existence.allMacro, arity: {1: [\"Expr\"]}},\n  allTrue:      {fn: existence.allTrueFn},\n  anyTrue:      {fn: existence.anyTrueFn},\n  allFalse:     {fn: existence.allFalseFn},\n  anyFalse:     {fn: existence.anyFalseFn},\n  subsetOf:     {fn: existence.subsetOfFn, arity: {1: [\"AnyAtRoot\"]}},\n  supersetOf:   {fn: existence.supersetOfFn, arity: {1: [\"AnyAtRoot\"]}},\n  isDistinct:   {fn: existence.isDistinctFn},\n  distinct:     {fn: filtering.distinctFn},\n  count:        {fn: aggregate.countFn},\n  where:        {fn: filtering.whereMacro, arity: {1: [\"Expr\"]}},\n  extension:    {fn: filtering.extension, arity: {1: [\"String\"]}},\n  select:       {fn: filtering.selectMacro, arity: {1: [\"Expr\"]}},\n  aggregate:    {fn: aggregate.aggregateMacro, arity: {1: [\"Expr\"], 2: [\"Expr\", \"Integer\"]}},\n  sum:          {fn: aggregate.sumFn},\n  min:          {fn: aggregate.minFn},\n  max:          {fn: aggregate.maxFn},\n  avg:          {fn: aggregate.avgFn},\n  single:       {fn: filtering.singleFn},\n  first:        {fn: filtering.firstFn},\n  last:         {fn: filtering.lastFn},\n  type:         {fn: types.typeFn, arity: {0: []}},\n  ofType:       {fn: filtering.ofTypeFn, arity: {1: [\"TypeSpecifier\"]}},\n  is:           {fn: types.isFn, arity: {1: [\"TypeSpecifier\"]}},\n  tail:         {fn: filtering.tailFn},\n  take:         {fn: filtering.takeFn, arity: {1: [\"Integer\"]}},\n  skip:         {fn: filtering.skipFn, arity: {1: [\"Integer\"]}},\n  combine:      {fn: combining.combineFn, arity: {1: [\"AnyAtRoot\"]}},\n  union:        {fn: combining.union,   arity: {1: [\"AnyAtRoot\"]}},\n  intersect:    {fn: combining.intersect,   arity: {1: [\"AnyAtRoot\"]}},\n  iif:          {fn: misc.iifMacro,    arity: {2: [\"Expr\", \"Expr\"], 3: [\"Expr\", \"Expr\", \"Expr\"]}},\n  trace:        {fn: misc.traceFn,     arity: {0: [], 1: [\"String\"]}},\n  toInteger:    {fn: misc.toInteger},\n  toDecimal:    {fn: misc.toDecimal},\n  toString:     {fn: misc.toString},\n  toDateTime:   {fn: misc.toDateTime},\n  toTime:       {fn: misc.toTime},\n  toBoolean:    {fn: misc.toBoolean},\n  toQuantity:   {fn: misc.toQuantity, arity: {0: [], 1: [\"String\"]}},\n  convertsToBoolean:    {fn: misc.createConvertsToFn(misc.toBoolean, 'boolean')},\n  convertsToInteger:    {fn: misc.createConvertsToFn(misc.toInteger, 'number')},\n  convertsToDecimal:    {fn: misc.createConvertsToFn(misc.toDecimal, 'number')},\n  convertsToString:     {fn: misc.createConvertsToFn(misc.toString, 'string')},\n  convertsToDateTime:   {fn: misc.createConvertsToFn(misc.toDateTime, FP_DateTime)},\n  convertsToTime:       {fn: misc.createConvertsToFn(misc.toTime, FP_Time)},\n  convertsToQuantity:   {fn: misc.createConvertsToFn(misc.toQuantity, FP_Quantity)},\n\n  indexOf:        {fn: strings.indexOf,          arity: {1: [\"String\"]}},\n  substring:      {fn: strings.substring,        arity: {1: [\"Integer\"], 2: [\"Integer\",\"Integer\"]}},\n  startsWith:     {fn: strings.startsWith,       arity: {1: [\"String\"]}},\n  endsWith:       {fn: strings.endsWith,         arity: {1: [\"String\"]}},\n  contains:       {fn: strings.containsFn,       arity: {1: [\"String\"]}},\n  upper:          {fn: strings.upper},\n  lower:          {fn: strings.lower},\n  replace:        {fn: strings.replace,          arity: {2: [\"String\", \"String\"]}},\n  matches:        {fn: strings.matches,          arity: {1: [\"String\"]}},\n  replaceMatches: {fn: strings.replaceMatches,   arity: {2: [\"String\", \"String\"]}},\n  length:         {fn: strings.length },\n  toChars:        {fn: strings.toChars },\n\n  abs:            {fn: math.abs},\n  ceiling:        {fn: math.ceiling},\n  exp:            {fn: math.exp},\n  floor:          {fn: math.floor},\n  ln:             {fn: math.ln},\n  log:            {fn: math.log, arity:  {1: [\"Number\"]}, nullable: true},\n  power:          {fn: math.power, arity:  {1: [\"Number\"]}, nullable: true},\n  round:          {fn: math.round, arity:  {1: [\"Number\"]}},\n  sqrt:           {fn: math.sqrt},\n  truncate:       {fn: math.truncate},\n\n  now:            {fn: datetime.now },\n  today:          {fn: datetime.today },\n  timeOfDay:      {fn: datetime.timeOfDay },\n\n  repeat:          {fn: filtering.repeatMacro, arity: {1: [\"Expr\"]}},\n  children:        {fn: navigation.children },\n  descendants:     {fn: navigation.descendants },\n\n  \"|\":          {fn: combining.union,   arity: {2: [\"Any\", \"Any\"]}},\n  \"=\":          {fn: equality.equal,   arity: {2: [\"Any\", \"Any\"]}, nullable: true},\n  \"!=\":         {fn: equality.unequal,   arity: {2: [\"Any\", \"Any\"]}, nullable: true},\n  \"~\":          {fn: equality.equival,   arity: {2: [\"Any\", \"Any\"]}},\n  \"!~\":         {fn: equality.unequival,   arity: {2: [\"Any\", \"Any\"]}},\n  \"<\":          {fn: equality.lt,   arity: {2: [\"Any\", \"Any\"]}, nullable: true},\n  \">\":          {fn: equality.gt,   arity: {2: [\"Any\", \"Any\"]}, nullable: true},\n  \"<=\":         {fn: equality.lte,  arity: {2: [\"Any\", \"Any\"]}, nullable: true},\n  \">=\":         {fn: equality.gte,  arity: {2: [\"Any\", \"Any\"]}, nullable: true},\n  \"containsOp\": {fn: collections.contains,   arity: {2: [\"Any\", \"Any\"]}},\n  \"inOp\":       {fn: collections.in,  arity: {2: [\"Any\", \"Any\"]}},\n  \"isOp\":       {fn: types.isFn,  arity: {2: [\"Any\", \"TypeSpecifier\"]}},\n  \"&\":          {fn: math.amp,     arity:  {2: [\"String\", \"String\"]}},\n  \"+\":          {fn: math.plus,    arity:  {2: [\"Any\", \"Any\"]}, nullable: true},\n  \"-\":          {fn: math.minus,   arity:  {2: [\"Any\", \"Any\"]}, nullable: true},\n  \"*\":          {fn: math.mul,     arity:  {2: [\"Number\", \"Number\"]}, nullable: true},\n  \"/\":          {fn: math.div,     arity:  {2: [\"Number\", \"Number\"]}, nullable: true},\n  \"mod\":        {fn: math.mod,     arity:  {2: [\"Number\", \"Number\"]}, nullable: true},\n  \"div\":        {fn: math.intdiv,  arity:  {2: [\"Number\", \"Number\"]}, nullable: true},\n\n  \"or\":        {fn: logic.orOp,  arity:       {2: [[\"Boolean\"], [\"Boolean\"]]}},\n  \"and\":       {fn: logic.andOp,  arity:      {2: [[\"Boolean\"], [\"Boolean\"]]}},\n  \"xor\":       {fn: logic.xorOp,  arity:      {2: [[\"Boolean\"], [\"Boolean\"]]}},\n  \"implies\":   {fn: logic.impliesOp,  arity:  {2: [[\"Boolean\"], [\"Boolean\"]]}},\n};\n\nengine.InvocationExpression = function(ctx, parentData, node) {\n  return node.children.reduce(function(acc, ch) {\n    return engine.doEval(ctx, acc, ch);\n  }, parentData);\n};\n\nengine.TermExpression = function(ctx, parentData, node) {\n  if (parentData) {\n    parentData = parentData.map((x) => {\n      if (x instanceof Object && x.resourceType) {\n        return makeResNode(x, x.resourceType);\n      }\n      return x;\n    });\n  }\n\n  return engine.doEval(ctx,parentData, node.children[0]);\n};\n\nengine.PolarityExpression = function(ctx, parentData, node) {\n  var sign = node.terminalNodeText[0]; // either - or + per grammar\n  var rtn = engine.doEval(ctx,parentData, node.children[0]);\n  if (rtn.length !== 1) {  // not yet in spec, but per Bryn Rhodes\n    throw new Error('Unary ' + sign +\n     ' can only be applied to an individual number.');\n  }\n  if (typeof rtn[0] != 'number' || isNaN(rtn[0]))\n    throw new Error('Unary ' + sign + ' can only be applied to a number.');\n  if (sign === '-')\n    rtn[0] = -rtn[0];\n  return rtn;\n};\n\nengine.TypeSpecifier = function(ctx, parentData, node) {\n  let namespace, name;\n  const identifiers = node.text.split('.').map(i => i.replace(/(^`|`$)/g, \"\"));\n  switch (identifiers.length) {\n    case 2:\n      [namespace, name] = identifiers;\n      break;\n    case 1:\n      [name] = identifiers;\n      break;\n    default:\n      throw new Error(\"Expected TypeSpecifier node, got \" + JSON.stringify(node));\n  }\n\n  return new TypeInfo({ namespace, name });\n};\n\nengine.ExternalConstantTerm = function(ctx, parentData, node) {\n  var extConstant = node.children[0];\n  var identifier = extConstant.children[0];\n  var varName = engine.Identifier(ctx, parentData, identifier)[0];\n  var value = ctx.vars[varName];\n  if (!(varName in ctx.vars)) {\n    throw new Error(\n      \"Attempting to access an undefined environment variable: \" + varName\n    );\n  }\n  // For convenience, we all variable values to be passed in without their array\n  // wrapper.  However, when evaluating, we need to put the array back in.\n  return value === undefined || value === null\n    ? []\n    : value instanceof Array ? value : [value];\n};\n\nengine.LiteralTerm = function(ctx, parentData, node) {\n  var term = node.children[0];\n  if(term){\n    return engine.doEval(ctx, parentData, term);\n  } else {\n    return [node.text];\n  }\n};\n\nengine.StringLiteral = function(ctx, parentData, node) {\n  // Remove the beginning and ending quotes.\n  var rtn = node.text.replace(/(^'|'$)/g, \"\");\n  rtn = rtn.replace(/\\\\(u\\d{4}|.)/g, function(match, submatch) {\n    switch(match) {\n      case '\\\\r':\n        return '\\r';\n      case '\\\\n':\n        return \"\\n\";\n      case '\\\\t':\n        return '\\t';\n      case '\\\\f':\n        return '\\f';\n      default:\n        if (submatch.length > 1)\n          return String.fromCharCode('0x'+submatch.slice(1));\n        else\n          return submatch;\n    }\n  });\n  return [rtn];\n};\n\nengine.BooleanLiteral = function(ctx, parentData, node) {\n  if(node.text  === \"true\") {\n    return [true];\n  } else {\n    return [false];\n  }\n};\n\nengine.QuantityLiteral = function(ctx, parentData, node) {\n  var valueNode = node.children[0];\n  var value = Number(valueNode.terminalNodeText[0]);\n  var unitNode = valueNode.children[0];\n  var unit = unitNode.terminalNodeText[0];\n  // Sometimes the unit is in a child node of the child\n  if (!unit && unitNode.children)\n    unit = unitNode.children[0].terminalNodeText[0];\n\n  return [new FP_Quantity(value, unit)];\n};\n\nengine.DateTimeLiteral = function(ctx, parentData, node) {\n  var dateStr = node.text.slice(1); // Remove the @\n  return [new FP_DateTime(dateStr)];\n};\n\nengine.TimeLiteral = function(ctx, parentData, node) {\n  var timeStr = node.text.slice(1); // Remove the @\n  return [new FP_Time(timeStr)];\n};\n\nengine.NumberLiteral = function(ctx, parentData, node) {\n  return [Number(node.text)];\n};\n\nengine.Identifier = function(ctx, parentData, node) {\n  return [node.text.replace(/(^`|`$)/g, \"\")];\n};\n\nengine.InvocationTerm = function(ctx, parentData, node) {\n  return engine.doEval(ctx,parentData, node.children[0]);\n};\n\n\nengine.MemberInvocation = function(ctx, parentData, node ) {\n  const key = engine.doEval(ctx, parentData, node.children[0])[0];\n  const model = ctx.model;\n\n  if (parentData) {\n    if(util.isCapitalized(key)) {\n      return parentData\n        .filter((x) => x instanceof ResourceNode && x.path === key);\n    } else {\n      const path = parentData.path || parentData.__path__;\n      return parentData.reduce(function(acc, res) {\n        res = makeResNode(res, path);\n        var childPath = res.path + '.' + key;\n        if (model) {\n          let defPath = model.pathsDefinedElsewhere[childPath];\n          if (defPath)\n            childPath = defPath;\n        }\n        let toAdd, _toAdd;\n        let actualTypes = model && model.choiceTypePaths[childPath];\n        if (actualTypes) {\n          // Use actualTypes to find the field's value\n          for (let t of actualTypes) {\n            let field = key + t;\n            toAdd = res.data?.[field];\n            _toAdd = res.data?.['_' + field];\n            if (toAdd !== undefined || _toAdd !== undefined) {\n              childPath = t;\n              break;\n            }\n          }\n        }\n        else {\n          toAdd = res.data?.[key];\n          _toAdd = res.data?.['_' + key];\n          if (toAdd === undefined && _toAdd === undefined) {\n            toAdd = res._data[key];\n          }\n          if (key === 'extension') {\n            childPath = 'Extension';\n          }\n        }\n\n        if (util.isSome(toAdd) || util.isSome(_toAdd)) {\n          if(Array.isArray(toAdd)) {\n            acc = acc.concat(toAdd.map((x, i)=>\n              makeResNode(x, childPath, _toAdd && _toAdd[i])));\n          } else {\n            acc.push(makeResNode(toAdd, childPath, _toAdd));\n          }\n          return acc;\n        } else {\n          return acc;\n        }\n      }, []);\n    }\n  } else {\n    return [];\n  }\n};\n\nengine.IndexerExpression = function(ctx, parentData, node) {\n  const coll_node = node.children[0];\n  const idx_node = node.children[1];\n  var coll = engine.doEval(ctx, parentData, coll_node);\n  var idx = engine.doEval(ctx, parentData, idx_node);\n\n  if(util.isEmpty(idx)) {\n    return [];\n  }\n\n  var idxNum = parseInt(idx[0]);\n  if(coll && util.isSome(idxNum) && coll.length>idxNum && idxNum>=0) {\n    return [coll[idxNum]];\n  } else {\n    return [];\n  }\n};\n\nengine.Functn = function(ctx, parentData, node) {\n  return node.children.map(function(x) {\n    return engine.doEval(ctx, parentData, x);\n  });\n};\n\nengine.realizeParams = function(ctx, parentData, args) {\n  if(args && args[0] && args[0].children) {\n    return args[0].children.map(function(x) {\n      return engine.doEval(ctx, parentData, x);\n    });\n  } else {\n    return [];\n  }\n};\n\nfunction makeParam(ctx, parentData, type, param) {\n  if(type === \"Expr\"){\n    return function(data) {\n      ctx.$this = util.arraify(data);\n      return engine.doEval(ctx, ctx.$this, param);\n    };\n  }\n  if(type === \"AnyAtRoot\"){\n    ctx.$this = ctx.$this || ctx.dataRoot;\n    return engine.doEval(ctx, ctx.$this, param);\n  }\n  if(type === \"Identifier\"){\n    if(param.type === \"TermExpression\") {\n      return param.text;\n    } else {\n      throw new Error(\"Expected identifier node, got \" + JSON.stringify(param));\n    }\n  }\n\n  if(type === \"TypeSpecifier\") {\n    return engine.TypeSpecifier(ctx, parentData, param);\n  }\n\n  ctx.$this = parentData;\n  const res = engine.doEval(ctx, parentData, param);\n  if(type === \"Any\") {\n    return res;\n  }\n  if(Array.isArray(type)) {\n    if(res.length === 0) {\n      return [];\n    } else {\n      type = type[0];\n    }\n  }\n  return misc.singleton(res, type);\n}\n\nfunction doInvoke(ctx, fnName, data, rawParams){\n  var invoc = engine.invocationTable[fnName];\n  var res;\n  if(invoc) {\n    if(!invoc.arity){\n      if(!rawParams){\n        res = invoc.fn.call(ctx, util.arraify(data));\n        return util.arraify(res);\n      } else {\n        throw new Error(fnName + \" expects no params\");\n      }\n    } else {\n      var paramsNumber = rawParams ? rawParams.length : 0;\n      var argTypes = invoc.arity[paramsNumber];\n      if(argTypes){\n        var params = [];\n        for(var i = 0; i < paramsNumber; i++){\n          var tp = argTypes[i];\n          var pr = rawParams[i];\n          params.push(makeParam(ctx, data, tp, pr));\n        }\n        params.unshift(data);\n        if(invoc.nullable) {\n          if(params.some(isNullable)){\n            return [];\n          }\n        }\n        res = invoc.fn.apply(ctx, params);\n        return util.arraify(res);\n      } else {\n        console.log(fnName + \" wrong arity: got \" + paramsNumber );\n        return [];\n      }\n    }\n  } else {\n    throw new Error(\"Not implemented: \" + fnName);\n  }\n}\nfunction isNullable(x) {\n  return x === null || x === undefined || util.isEmpty(x);\n}\n\nfunction infixInvoke(ctx, fnName, data, rawParams){\n  var invoc = engine.invocationTable[fnName];\n  if(invoc && invoc.fn) {\n    var paramsNumber = rawParams ? rawParams.length : 0;\n    if(paramsNumber !== 2) { throw new Error(\"Infix invoke should have arity 2\"); }\n    var argTypes = invoc.arity[paramsNumber];\n    if(argTypes){\n      var params = [];\n      for(var i = 0; i < paramsNumber; i++){\n        var tp = argTypes[i];\n        var pr = rawParams[i];\n        params.push(makeParam(ctx, data, tp, pr));\n      }\n      if(invoc.nullable) {\n        if(params.some(isNullable)){\n          return [];\n        }\n      }\n      var res = invoc.fn.apply(ctx, params);\n      return util.arraify(res);\n    } else {\n      console.log(fnName + \" wrong arity: got \" + paramsNumber );\n      return [];\n    }\n  } else {\n    throw new Error(\"Not impl \" + fnName);\n  }\n}\n\nengine.FunctionInvocation = function(ctx, parentData, node) {\n  var args = engine.doEval(ctx, parentData, node.children[0]);\n  const fnName = args[0];\n  args.shift();\n  var rawParams = args && args[0] && args[0].children;\n  return doInvoke(ctx, fnName, parentData, rawParams);\n};\n\nengine.ParamList = function(ctx, parentData, node) {\n  // we do not eval param list because sometimes it should be passed as\n  // lambda/macro (for example in case of where(...)\n  return node;\n};\n\n\nengine.UnionExpression = function(ctx, parentData, node) {\n  return infixInvoke(ctx, '|', parentData, node.children);\n};\n\nengine.ThisInvocation = function(ctx) {\n  return ctx.$this;\n};\n\nengine.TotalInvocation = function(ctx) {\n  return util.arraify(ctx.$total);\n};\n\nengine.IndexInvocation = function(ctx) {\n  return util.arraify(ctx.$index);\n};\n\nengine.OpExpression = function(ctx, parentData, node) {\n  var op = node.terminalNodeText[0];\n  return infixInvoke(ctx, op, parentData, node.children);\n};\n\nengine.AliasOpExpression = function(map){\n  return function(ctx, parentData, node) {\n    var op = node.terminalNodeText[0];\n    var alias = map[op];\n    if(!alias) { throw new Error(\"Do not know how to alias \" + op + \" by \" + JSON.stringify(map)); }\n    return infixInvoke(ctx, alias, parentData, node.children);\n  };\n};\n\nengine.NullLiteral = function() {\n  return [];\n};\n\nengine.ParenthesizedTerm = function(ctx, parentData, node) {\n  return engine.doEval(ctx, parentData, node.children[0]);\n};\n\n\nengine.evalTable = { // not every evaluator is listed if they are defined on engine\n  BooleanLiteral: engine.BooleanLiteral,\n  EqualityExpression: engine.OpExpression,\n  FunctionInvocation: engine.FunctionInvocation,\n  Functn: engine.Functn,\n  Identifier: engine.Identifier,\n  IndexerExpression: engine.IndexerExpression,\n  InequalityExpression: engine.OpExpression,\n  InvocationExpression: engine.InvocationExpression,\n  AdditiveExpression: engine.OpExpression,\n  MultiplicativeExpression: engine.OpExpression,\n  TypeExpression: engine.AliasOpExpression({\"is\": \"isOp\"}),\n  MembershipExpression: engine.AliasOpExpression({\"contains\": \"containsOp\", \"in\": \"inOp\"}),\n  NullLiteral: engine.NullLiteral,\n  EntireExpression: engine.InvocationTerm,\n  InvocationTerm: engine.InvocationTerm,\n  LiteralTerm: engine.LiteralTerm,\n  MemberInvocation: engine.MemberInvocation,\n  NumberLiteral: engine.NumberLiteral,\n  ParamList: engine.ParamList,\n  ParenthesizedTerm: engine.ParenthesizedTerm,\n  StringLiteral: engine.StringLiteral,\n  TermExpression: engine.TermExpression,\n  ThisInvocation: engine.ThisInvocation,\n  TotalInvocation: engine.TotalInvocation,\n  IndexInvocation: engine.IndexInvocation,\n  UnionExpression: engine.UnionExpression,\n  OrExpression: engine.OpExpression,\n  ImpliesExpression: engine.OpExpression,\n  AndExpression: engine.OpExpression,\n  XorExpression: engine.OpExpression\n};\n\n\nengine.doEval = function(ctx, parentData, node) {\n  const evaluator = engine.evalTable[node.type] || engine[node.type];\n  if(evaluator){\n    return evaluator.call(engine, ctx, parentData, node);\n  } else {\n    throw new Error(\"No \" + node.type + \" evaluator \");\n  }\n};\n\nfunction parse(path) {\n  return parser.parse(path);\n}\n\n\n/**\n *  Applies the given parsed FHIRPath expression to the given resource,\n *  returning the result of doEval.\n * @param {(object|object[])} resource -  FHIR resource, bundle as js object or array of resources\n *  This resource will be modified by this function to add type information.\n * @param {object} parsedPath - a special object created by the parser that describes the structure of a fhirpath expression.\n * @param {object} context - a hash of variable name/value pairs.\n * @param {object} model - The \"model\" data object specific to a domain, e.g. R4.\n *  For example, you could pass in the result of require(\"fhirpath/fhir-context/r4\");\n * @param {object} [options] - additional options:\n * @param {boolean} [options.resolveInternalTypes] - whether values of internal\n *  types should be converted to strings, true by default.\n */\nfunction applyParsedPath(resource, parsedPath, context, model, options) {\n  constants.reset();\n  let dataRoot = util.arraify(resource);\n  // doEval takes a \"ctx\" object, and we store things in that as we parse, so we\n  // need to put user-provided variable data in a sub-object, ctx.vars.\n  // Set up default standard variables, and allow override from the variables.\n  // However, we'll keep our own copy of dataRoot for internal processing.\n  let vars = {context: resource, ucum: 'http://unitsofmeasure.org'};\n  // Restore the ResourceNodes for the top-level objects of the context\n  // variables. The nested objects will be converted to ResourceNodes\n  // in the MemberInvocation method.\n  if (context) {\n    context = Object.keys(context).reduce((restoredContext, key) => {\n      const path = context[key]?.__path__;\n      if (path) {\n        if (Array.isArray(context[key])) {\n          restoredContext[key] = context[key].map(i => makeResNode(i, path));\n        } else {\n          restoredContext[key] = makeResNode(context[key], path);\n        }\n      } else {\n        restoredContext[key] = context[key];\n      }\n      return restoredContext;\n    }, {});\n  }\n  let ctx = {dataRoot, vars: Object.assign(vars, context), model};\n  let rtn = engine.doEval(ctx, dataRoot, parsedPath.children[0]);\n  let firstRtn = Array.isArray(rtn) ? rtn[0] : rtn;\n  // Path for the data extracted from the resource.\n  let path = firstRtn instanceof ResourceNode ? firstRtn.path : null;\n\n  // Resolve any internal \"ResourceNode\" instances to plain objects and if\n  // options.resolveInternalTypes is true, resolve any internal \"FP_Type\"\n  // instances to strings.\n  rtn = (function visit(n) {\n    n = util.valData(n);\n    if (Array.isArray(n)) {\n      for (let i=0, len=n.length; i<len; ++i)\n        n[i] = visit(n[i]);\n    }\n    else if (n instanceof FP_Type) {\n      if (options.resolveInternalTypes) {\n        n = n.toString();\n      }\n    }\n    else if (typeof n === 'object') {\n      for (let k of Object.keys(n))\n        n[k] = visit(n[k]);\n    }\n    return n;\n  })(rtn);\n  // Add a hidden (non-enumerable) property with the path to the data extracted\n  // from the resource.\n  if (path && typeof rtn === 'object') {\n    Object.defineProperty(rtn, '__path__', {value: path});\n  }\n  return rtn;\n}\n\n/**\n * Resolves any internal \"FP_Type\" instances in a result of FHIRPath expression\n * evaluation to standard JavaScript types.\n * @param {any} val - a result of FHIRPath expression evaluation\n * @returns {any} a new object with resolved values.\n */\nfunction resolveInternalTypes(val) {\n  if (Array.isArray(val)) {\n    for (let i=0, len=val.length; i<len; ++i)\n      val[i] = resolveInternalTypes(val[i]);\n  }\n  else if (val instanceof FP_Type) {\n    val = val.toString();\n  }\n  else if (typeof val === 'object') {\n    for (let k of Object.keys(val))\n      val[k] = resolveInternalTypes(val[k]);\n  }\n  return val;\n}\n\n/**\n *  Evaluates the \"path\" FHIRPath expression on the given resource or part of the resource,\n *  using data from \"context\" for variables mentioned in the \"path\" expression.\n * @param {(object|object[])} fhirData -  FHIR resource, part of a resource (in this case\n *  path.base should be provided), bundle as js object or array of resources.\n *  This object/array will be modified by this function to add type information.\n * @param {string|object} path - string with FHIRPath expression, sample 'Patient.name.given',\n *  or object, if fhirData represents the part of the FHIR resource:\n * @param {string} path.base - base path in resource from which fhirData was extracted\n * @param {string} path.expression - FHIRPath expression relative to path.base\n * @param {object} context - a hash of variable name/value pairs.\n * @param {object} model - The \"model\" data object specific to a domain, e.g. R4.\n *  For example, you could pass in the result of require(\"fhirpath/fhir-context/r4\");\n * @param {object} [options] - additional options:\n * @param {boolean} [options.resolveInternalTypes] - whether values of internal\n *  types should be converted to standard JavaScript types (true by default).\n *  If false is passed, this conversion can be done later by calling\n *  resolveInternalTypes().\n */\nfunction evaluate(fhirData, path, context, model, options) {\n  return compile(path, model, options)(fhirData, context);\n}\n\n/**\n *  Returns a function that takes a resource or part of the resource and an\n *  optional context hash (see \"evaluate\"), and returns the result of evaluating\n *  the given FHIRPath expression on that resource.  The advantage of this\n *  function over \"evaluate\" is that if you have multiple resources, the given\n *  FHIRPath expression will only be parsed once.\n * @param {string|object} path - string with FHIRPath expression to be parsed or object:\n * @param {string} path.base - base path in resource from which a part of\n *   the resource was extracted\n * @param {string} path.expression - FHIRPath expression relative to path.base\n * @param {object} model - The \"model\" data object specific to a domain, e.g. R4.\n *  For example, you could pass in the result of require(\"fhirpath/fhir-context/r4\");\n * @param {object} [options] - additional options:\n * @param {boolean} [options.resolveInternalTypes] - whether values of internal\n *  types should be converted to strings, true by default.\n */\nfunction compile(path, model, options) {\n  options = {\n    resolveInternalTypes: true,\n    ... options\n  };\n  if (typeof path === 'object') {\n    const node = parse(path.expression);\n    return function (fhirData, context) {\n      const inObjPath = fhirData && fhirData.__path__;\n      const resource = makeResNode(fhirData, path.base || inObjPath);\n      return applyParsedPath(resource, node, context, model, options);\n    };\n  } else {\n    const node = parse(path);\n    return function (fhirData, context) {\n      const inObjPath = fhirData && fhirData.__path__;\n      const resource = inObjPath ? makeResNode(fhirData, inObjPath) : fhirData;\n      return applyParsedPath(resource, node, context, model, options);\n    };\n  }\n}\n\nmodule.exports = {\n  version,\n  parse,\n  compile,\n  evaluate,\n  resolveInternalTypes,\n  // Might as well export the UCUM library, since we are using it.\n  ucumUtils: require('@lhncbc/ucum-lhc').UcumLhcUtils.getInstance()\n};\n","// Contains the FHIRPath Filtering and Projection functions.  (Section 5.2 of\n// the FHIRPath 1.0.0 specification).\n\n/**\n *  Adds the filtering and projection functions to the given FHIRPath engine.\n */\nconst util = require('./utilities');\nconst {TypeInfo, ResourceNode} = require('./types');\nconst hashObject = require('./hash-object');\n\nvar engine = {};\nengine.whereMacro = function(parentData, expr) {\n  if(parentData !== false && ! parentData) { return []; }\n\n  return util.flatten(parentData.filter((x, i) => {\n    this.$index = i;\n    return expr(x)[0];\n  }));\n};\n\nengine.extension = function(parentData, url) {\n  if(parentData !== false && ! parentData || !url) { return []; }\n\n  return util.flatten(parentData.map((x, i) => {\n    this.$index = i;\n    const extensions = (x && (x.data && x.data.extension || x._data && x._data.extension));\n    if (extensions) {\n      return extensions\n        .filter(extension => extension.url === url)\n        .map(x => ResourceNode.makeResNode(x, 'Extension'));\n    }\n    return [];\n  }));\n};\n\nengine.selectMacro = function(data, expr) {\n  if(data !== false && ! data) { return []; }\n  return util.flatten(data.map((x, i) => {\n    this.$index = i;\n    return expr(x);\n  }));\n};\n\nengine.repeatMacro = function(parentData, expr) {\n  if(parentData !== false && ! parentData) { return []; }\n\n  let res = [];\n  const unique = {};\n  const length = parentData.length;\n  for(let i = 0; i < length; ++i) {\n    let newItems = parentData[i];\n    do {\n      newItems = expr(newItems)\n        .filter(item => {\n          const key = hashObject(item);\n          const isUnique = !unique[key];\n          if (isUnique) {\n            unique[key] = true;\n          }\n          return isUnique;\n        });\n    } while (res.length < res.push.apply(res, newItems));\n  }\n  return res;\n};\n\n//TODO: behavior on object?\nengine.singleFn = function(x) {\n  if(x.length == 1){\n    return x;\n  } else if (x.length == 0) {\n    return [];\n  } else {\n    //TODO: should throw error?\n    return {$status: \"error\", $error: \"Expected single\"};\n  }\n};\n\n\nengine.firstFn = function(x) {\n  return x[0];\n};\n\nengine.lastFn = function(x) {\n  return x[x.length - 1];\n};\n\nengine.tailFn = function(x) {\n  return x.slice(1, x.length);\n};\n\nengine.takeFn = function(x, n) {\n  return x.slice(0, n);\n};\n\nengine.skipFn = function(x, num) {\n  return x.slice(num, x.length);\n};\n\nengine.ofTypeFn = function(coll, typeInfo) {\n  return coll.filter(value => {\n    return TypeInfo.fromValue(value).is(typeInfo);\n  });\n};\n\nengine.distinctFn = function(x) {\n  let unique = [];\n  // Since this requires a deep equals, use a hash table (on JSON strings) for\n  // efficiency.\n  if (x.length > 0) {\n    let uniqueHash = {};\n    for (let i=0, len=x.length; i<len; ++i) {\n      let xObj = x[i];\n      let xStr = hashObject(xObj);\n      if (!uniqueHash[xStr]) {\n        unique.push(xObj);\n        uniqueHash[xStr] = true;\n      }\n    }\n  }\n  return unique;\n};\n\nmodule.exports = engine;\n","const ucumUtils = require('@lhncbc/ucum-lhc').UcumLhcUtils.getInstance();\nconst {roundToMaxPrecision} = require('./numbers');\nconst {valDataConverted} = require('./utilities');\nconst {FP_Type, FP_Quantity} = require('./types');\n\n/**\n *  Returns a JSON version of the given object, but with the object's keys\n *  in sorted order (or at least stable order,\n *  see https://stackoverflow.com/a/35810961/360782) and the values in\n *  unified forms, e.g. \"1 year\" is converted to the same value as \"12 months\",\n *  \"3 'min'\" is converted to the same value as \"120 'sec'\".\n *  This function is used instead of deepEqual for optimization when you need\n *  to compare many objects.\n */\nfunction hashObject(obj) {\n  return JSON.stringify(prepareObject(obj));\n}\n\n/**\n * Brings an object to the unified form so that it can be serialized to JSON to\n * compare with other objects according to https://hl7.org/fhirpath/#equals\n * This function is following the logic from deepEqual (if changes are needed\n * here they are likely also needed there).\n */\nfunction prepareObject(value) {\n  value = valDataConverted(value);\n\n  if (typeof value === 'number') {\n    return roundToMaxPrecision(value);\n  } else if (value instanceof Date) {\n    return value.toISOString();\n  } if (value instanceof FP_Quantity) {\n    const magnitude = FP_Quantity._yearMonthConversionFactor[value.unit];\n    if (magnitude) {\n      return '_!yearMonth!_:' + magnitude * value.value;\n    } else {\n      const ucumQuantity = FP_Quantity.toUcumQuantity(value.value, value.unit);\n      const unit = ucumUtils.getSpecifiedUnit(ucumQuantity.unit).unit;\n      return '_!' + unit.property_ + '!_:' + unit.magnitude_ * ucumQuantity.value;\n    }\n  } else if (value instanceof FP_Type) {\n    return value.toString();\n  } else if (typeof value === 'object') {\n    return Array.isArray(value) ?\n      value.map(prepareObject) :\n      Object.keys(value).sort().reduce(\n        (o, key) => {\n          const v = value[key];\n          o[key] = prepareObject(v);\n          return o;\n        }, {});\n  }\n\n  return  value;\n}\n\nmodule.exports = hashObject;\n","var engine = {};\n\nengine.orOp = function(a, b) {\n  if(Array.isArray(b)){\n    if(a === true){\n      return true;\n    } else if (a === false) {\n      return [];\n    } else if (Array.isArray(a)) {\n      return [];\n    }\n  }\n  if(Array.isArray(a)){\n    if(b === true ){\n      return true;\n    } else {\n      return [];\n    }\n  }\n  return a || b;\n};\n\nengine.andOp = function(a, b) {\n  if(Array.isArray(b)){\n    if(a === true){\n      return [];\n    } else if (a === false) {\n      return false;\n    } else if (Array.isArray(a)) {\n      return [];\n    }\n  }\n  if(Array.isArray(a)){\n    if(b === true ){\n      return [];\n    } else {\n      return false;\n    }\n  }\n  return a && b;\n};\n\nengine.xorOp = function(a, b) {\n  // If a or b are arrays, they must be the empty set.\n  // In that case, the result is always the empty set.\n  if (Array.isArray(a) || Array.isArray(b))\n    return [];\n  return ( a && !b ) || ( !a && b );\n};\n\nengine.impliesOp = function(a, b) {\n  if(Array.isArray(b)){\n    if(a === true){\n      return [];\n    } else if (a === false) {\n      return true;\n    } else if (Array.isArray(a)) {\n      return [];\n    }\n  }\n  if(Array.isArray(a)){\n    if(b === true ){\n      return true;\n    } else {\n      return [];\n    }\n  }\n  if(a === false) { return true; }\n  return (a && b);\n};\n\n\nmodule.exports = engine;\n","// This file holds code to hande the FHIRPath Math functions.\n\nvar types = require('./types');\nlet {FP_TimeBase, FP_Quantity} = types;\nconst util = require(\"./utilities\");\n\n/**\n *  Adds the math functions to the given FHIRPath engine.\n */\n\nvar engine = {};\n\nfunction ensureNumberSingleton(x){\n  let d = util.valData(x);\n  if (typeof d !== 'number') {\n    if (d.length == 1 && typeof (d=util.valData(d[0])) === 'number') {\n      return d;\n    }else{\n      throw new Error(\"Expected number, but got \" + JSON.stringify(d || x));\n    }\n  }\n  else\n    return d;\n}\n\nfunction isEmpty(x) {\n  if(typeof(x) == 'number'){\n    return false;\n  }\n  return x.length == 0;\n}\n\nengine.amp = function(x, y){\n  return (x || \"\") + (y || \"\");\n};\n\n//HACK: for only polymorphic function\n//  Actually, \"minus\" is now also polymorphic\nengine.plus = function(xs, ys){\n  if(xs.length == 1 && ys.length == 1) {\n    var x = util.valDataConverted(xs[0]);\n    var y = util.valDataConverted(ys[0]);\n    // In the future, this and other functions might need to return ResourceNode\n    // to preserve the type information (integer vs decimal, and maybe decimal\n    // vs string if decimals are represented as strings), in order to support\n    // \"as\" and \"is\", but that support is deferred for now.\n    if(typeof x == \"string\" && typeof y == \"string\") {\n      return x + y;\n    }\n    if(typeof x == \"number\" && typeof y == \"number\") {\n      return x + y;\n    }\n    if(x instanceof FP_TimeBase && y instanceof FP_Quantity) {\n      return x.plus(y);\n    }\n  }\n  throw new Error(\"Cannot \" + JSON.stringify(xs) + \" + \" + JSON.stringify(ys));\n};\n\nengine.minus = function(xs, ys){\n  if(xs.length == 1 && ys.length == 1) {\n    var x = util.valDataConverted(xs[0]);\n    var y = util.valDataConverted(ys[0]);\n    if(typeof x == \"number\" && typeof y == \"number\")\n      return x - y;\n    if(x instanceof FP_TimeBase && y instanceof FP_Quantity)\n      return x.plus(new FP_Quantity(-y.value, y.unit));\n  }\n  throw new Error(\"Cannot \" + JSON.stringify(xs) + \" - \" + JSON.stringify(ys));\n};\n\n\nengine.mul = function(x, y){\n  return x * y;\n};\n\nengine.div = function(x, y){\n  if (y === 0) return [];\n  return x / y;\n};\n\nengine.intdiv = function(x, y){\n  if (y === 0) return [];\n  return Math.floor(x / y);\n};\n\nengine.mod = function(x, y){\n  if (y === 0) return [];\n  return x % y;\n};\n\nengine.abs = function(x){\n  if (isEmpty(x)){\n    return [];\n  }else{\n    let num = ensureNumberSingleton(x);\n    return Math.abs(num);\n  }\n};\n\nengine.ceiling = function(x){\n  if (isEmpty(x)){\n    return [];\n  }else{\n    let num = ensureNumberSingleton(x);\n    return Math.ceil(num);\n  }\n};\n\nengine.exp = function(x){\n  if (isEmpty(x)){\n    return [];\n  }else{\n    let num = ensureNumberSingleton(x);\n    return Math.exp(num);\n  }\n};\n\nengine.floor = function(x){\n  if (isEmpty(x)){\n    return [];\n  }else{\n    let num = ensureNumberSingleton(x);\n    return Math.floor(num);\n  }\n};\n\nengine.ln = function(x){\n  if (isEmpty(x)){\n    return [];\n  }else{\n    let num = ensureNumberSingleton(x);\n    return Math.log(num);\n  }\n};\n\nengine.log = function(x, base){\n  if (isEmpty(x) || isEmpty(base)){\n    return [];\n  }else{\n    let num = ensureNumberSingleton(x);\n    let num2 = ensureNumberSingleton(base);\n    return (Math.log(num) / Math.log(num2));\n  }\n};\n\nengine.power = function(x, degree){\n  if (isEmpty(x) || isEmpty(degree)){\n    return [];\n  }else{\n    let num = ensureNumberSingleton(x);\n    let num2 = ensureNumberSingleton(degree);\n    if (num < 0 && (Math.floor(num2) != num2)){\n      return [];\n    }else{\n      return Math.pow(num, num2);\n    }\n  }\n};\n\nengine.round = function(x, acc){\n  if (isEmpty(x)){\n    return [];\n  }else{\n    let num = ensureNumberSingleton(x);\n    if (isEmpty(acc)){\n      return (Math.round(num));\n    }else{\n      let num2 = ensureNumberSingleton(acc);\n      let degree = Math.pow(10, num2);\n      return (Math.round(num * degree) / degree);\n    }\n  }\n};\n\nengine.sqrt = function(x){\n  if (isEmpty(x)){\n    return [];\n  }else{\n    let num = ensureNumberSingleton(x);\n    if (num < 0) {\n      return [];\n    }else{\n      return Math.sqrt(num);\n    }\n  }\n};\n\nengine.truncate = function(x){\n  if (isEmpty(x)){\n    return [];\n  }else{\n    let num = ensureNumberSingleton(x);\n    return Math.trunc(num);\n  }\n};\n\nmodule.exports = engine;\n","\n// This file holds code to hande the FHIRPath Existence functions (5.1 in the\n// specification).\n\nvar util = require(\"./utilities\");\nvar types = require(\"./types\");\n\nconst { FP_Quantity } = types;\n\nvar engine = {};\n\nengine.iifMacro = function(data, cond, ok, fail) {\n  if(util.isTrue(cond(data))) {\n    return ok(data);\n  } else {\n    return fail ? fail(data) : [];\n  }\n};\n\nengine.traceFn = function(x, label) {\n  console.log(\"TRACE:[\" + (label || \"\") + \"]\", JSON.stringify(x, null, \" \"));\n  return x;\n};\n\nvar intRegex = /^[+-]?\\d+$/;\nengine.toInteger = function(coll){\n  if(coll.length !== 1) { return []; }\n  var v = util.valData(coll[0]);\n  if(v === false) {return 0;}\n  if(v === true) {return 1;}\n  if(typeof v === \"number\") {\n    if(Number.isInteger(v)) {\n      return v;\n    } else {\n      return [];\n    }\n  }\n  if(typeof v === \"string\" && intRegex.test(v)) {\n    return parseInt(v);\n  }\n  return [];\n};\n\nconst quantityRegex = /^((\\+|-)?\\d+(\\.\\d+)?)\\s*(('[^']+')|([a-zA-Z]+))?$/,\n  quantityRegexMap = {value:1,unit:5,time:6};\nengine.toQuantity = function (coll, toUnit) {\n  let result;\n  // Surround UCUM unit code in the toUnit parameter with single quotes\n  if (toUnit && !FP_Quantity.mapTimeUnitsToUCUMCode[toUnit]) {\n    toUnit = `'${toUnit}'`;\n  }\n\n  if (coll.length > 1) {\n    throw new Error(\"Could not convert to quantity: input collection contains multiple items\");\n  } else if (coll.length === 1) {\n    var v = util.valDataConverted(coll[0]);\n    let quantityRegexRes;\n\n    if (typeof v === \"number\") {\n      result = new FP_Quantity(v, '\\'1\\'');\n    } else if (v instanceof FP_Quantity) {\n      result = v;\n    } else if (typeof v === 'boolean') {\n      result = new FP_Quantity(v ? 1 : 0, '\\'1\\'');\n    } else if (typeof v === \"string\" && (quantityRegexRes = quantityRegex.exec(v)) ) {\n      const value = quantityRegexRes[quantityRegexMap.value],\n        unit = quantityRegexRes[quantityRegexMap.unit],\n        time = quantityRegexRes[quantityRegexMap.time];\n\n      // UCUM unit code in the input string must be surrounded with single quotes\n      if (!time || FP_Quantity.mapTimeUnitsToUCUMCode[time]) {\n        result = new FP_Quantity(Number(value), unit || time || '\\'1\\'');\n      }\n    }\n\n    if (result && toUnit && result.unit !== toUnit) {\n      result = FP_Quantity.convUnitTo(result.unit, result.value, toUnit);\n    }\n  }\n\n  return result || [];\n};\n\nvar numRegex = /^[+-]?\\d+(\\.\\d+)?$/;\nengine.toDecimal = function(coll){\n  if(coll.length !== 1) { return []; }\n  var v = util.valData(coll[0]);\n  if(v === false) {return 0;}\n  if(v === true) {return 1.0;}\n  if(typeof v === \"number\") {\n    return v;\n  }\n  if(typeof v === \"string\" && numRegex.test(v)) {\n    return parseFloat(v);\n  }\n  return [];\n};\n\nengine.toString = function(coll){\n  if(coll.length !== 1) { return []; }\n  var v = util.valDataConverted(coll[0]);\n  return v.toString();\n};\n\n\n/**\n *  Defines a function on engine called to+timeType (e.g., toDateTime, etc.).\n * @param timeType The string name of a class for a time type (e.g. \"FP_DateTime\").\n */\nfunction defineTimeConverter(timeType) {\n  let timeName = timeType.slice(3); // Remove 'FP_'\n  engine['to'+timeName] = function(coll) {\n    var rtn = [];\n    if (coll.length > 1)\n      throw Error('to '+timeName+' called for a collection of length '+coll.length);\n    if (coll.length === 1) {\n      var t = types[timeType].checkString(util.valData(coll[0]));\n      if (t)\n        rtn = t;\n    }\n    return rtn;\n  };\n}\ndefineTimeConverter('FP_DateTime');\ndefineTimeConverter('FP_Time');\n\n// Possible string values convertible to the true boolean value\nconst trueStrings = ['true', 't', 'yes', 'y', '1', '1.0'].reduce((acc, val) => {\n  acc[val] = true;\n  return acc;\n}, {});\n\n// Possible string values convertible to the false boolean value\nconst falseStrings = ['false', 'f', 'no', 'n', '0', '0.0'].reduce((acc, val) => {\n  acc[val] = true;\n  return acc;\n}, {});\n\nengine.toBoolean = function (coll) {\n  if(coll.length !== 1) {\n    return [];\n  }\n\n  const v = util.valData(coll[0]);\n  switch (typeof v) {\n    case 'boolean':\n      return v;\n    case 'number':\n      if (v === 1) {\n        return true;\n      }\n      if (v === 0) {\n        return false;\n      }\n      break;\n    case 'string':\n      // eslint-disable-next-line no-case-declarations\n      const lowerCaseValue = v.toLowerCase();\n      if (trueStrings[lowerCaseValue]) {\n        return true;\n      }\n      if (falseStrings[lowerCaseValue]) {\n        return false;\n      }\n  }\n  return [];\n};\n\n/**\n * Creates function that checks if toFunction returns specified type\n * @param {function(coll: array): <type|[]>} toFunction\n * @param {string|class} type - specifies type, for example: 'string' or FP_Quantity\n * @return {function(coll: array)}\n */\nengine.createConvertsToFn = function (toFunction, type) {\n  if (typeof type === 'string') {\n    return function (coll) {\n      if (coll.length !== 1) {\n        return [];\n      }\n\n      return typeof toFunction(coll) === type;\n    };\n  }\n\n  return function (coll) {\n    if (coll.length !== 1) {\n      return [];\n    }\n\n    return toFunction(coll) instanceof type;\n  };\n};\n\nconst singletonEvalByType = {\n  \"Integer\": function(coll){\n    const d = util.valData(coll[0]);\n    if (Number.isInteger(d)) {\n      return d;\n    }\n  },\n  \"Boolean\": function(coll){\n    const d = util.valData(coll[0]);\n    if (d === true || d === false) {\n      return d;\n    } else if (coll.length === 1) {\n      return true;\n    }\n  },\n  \"Number\": function(coll) {\n    const d = util.valData(coll[0]);\n    if (typeof d === \"number\") {\n      return d;\n    }\n  },\n  \"String\": function(coll){\n    const d = util.valData(coll[0]);\n    if (typeof d === \"string\") {\n      return d;\n    }\n  }\n};\n\n/**\n * Converts a collection to a singleton of the specified type.\n * The result can be an empty array if input collection is empty.\n * See http://hl7.org/fhirpath/#singleton-evaluation-of-collections for details.\n * @param {Array} coll - collection\n * @param {string} type - 'Integer', 'Boolean', 'Number' or 'String'\n * @throws {Error}  if there is more than one item in input collection,\n *   or an item that is not a specified type\n * @return {*|[]} the value of specified type or empty array\n */\nengine.singleton = function (coll, type) {\n  if(coll.length > 1){\n    throw new Error(\"Unexpected collection\" + JSON.stringify(coll) +\n      \"; expected singleton of type \" + type);\n  } else if (coll.length === 0) {\n    return [];\n  }\n  const toSingleton = singletonEvalByType[type];\n  if (toSingleton) {\n    const value = toSingleton(coll);\n    if (value !== undefined) {\n      return value;\n    }\n    throw new Error(`Expected ${type.toLowerCase()}, but got: ${JSON.stringify(coll)}`);\n  }\n  throw new Error('Not supported type ' + type);\n};\n\nmodule.exports = engine;\n","const util = require(\"./utilities\");\nconst {ResourceNode}  = require(\"./types\");\nlet makeResNode = ResourceNode.makeResNode;\n\nvar engine = {};\n\nengine.children = function(coll){\n  let model = this.model; // \"this\" is the context object\n\n  return coll.reduce(function(acc, x){\n    let d = util.valData(x);\n    x = makeResNode(x);\n    if(typeof d === 'object'){\n      for (var prop of Object.keys(d)) {\n        var v = d[prop];\n        var childPath = x.path + '.' + prop;\n        if (model) {\n          let defPath = model.pathsDefinedElsewhere[childPath];\n          if (defPath)\n            childPath = defPath;\n        }\n        if(Array.isArray(v)){\n          acc.push.apply(acc, v.map((n)=>makeResNode(n, childPath)));\n        } else {\n          acc.push(makeResNode(v, childPath));\n        }\n      }\n      return acc;\n    } else {\n      return acc;\n    }\n  }, []);\n};\n\nengine.descendants = function(coll){\n  var ch = engine.children.call(this, coll); // \"this\" is the context object\n  var res = [];\n  while(ch.length > 0){\n    res.push.apply(res, ch);\n    ch = engine.children.call(this, ch);\n  }\n  return res;\n};\n\nmodule.exports = engine;\n","let numberFns = {};\n\n// Returns the number of digits in the number after the decimal point, ignoring\n// trailing zeros.\nfunction decimalPlaces(x) {\n  // Based on https://stackoverflow.com/a/9539746/360782\n  // Make sure it is a number and use the builtin number -> string.\n  const s = \"\" + (+x),\n    match = /(\\d+)(?:\\.(\\d+))?(?:[eE]([+-]?\\d+))?$/.exec(s);\n  // NaN or Infinity or integer.\n  // We arbitrarily decide that Infinity is integral.\n  if (!match) { return 0; }\n  // Count the number of digits in the fraction and subtract the\n  // exponent to simulate moving the decimal point left by exponent places.\n  // 1.234e+2 has 1 fraction digit and '234'.length -  2 == 1\n  // 1.234e-2 has 5 fraction digit and '234'.length - -2 == 5\n  //var wholeNum = match[1];\n  const fraction = match[2],\n    exponent = match[3];\n  return Math.max(\n    0,  // lower limit.\n    (fraction === '0' ? 0 : (fraction || '').length)  // fraction length\n    - (exponent || 0));  // exponent\n}\n\n/**\n *  Rounds a number to the specified number of decimal places.\n * @param x the decimal number to be rounded\n * @param n the (maximum) number of decimal places to preserve.  (The result\n *  could contain fewer if the decimal digits in x contain zeros).\n */\nfunction roundToDecimalPlaces (x, n) {\n  const scale = Math.pow(10, n);\n  return Math.round(x*scale)/scale;\n}\n\n/**\n *  The smallest representable number in FHIRPath.\n */\nconst PRECISION_STEP = 1e-8;\n\n/**\n *  Rounds a number to the nearest multiple of PRECISION_STEP.\n */\nconst roundToMaxPrecision = numberFns.roundToMaxPrecision = function (x) {\n  return Math.round(x/PRECISION_STEP)*PRECISION_STEP;\n};\n\n/**\n * Determines numbers equivalence\n * @param {number} actual\n * @param {number} expected\n * @return {boolean}\n */\nnumberFns.isEquivalent = function(actual, expected) {\n  if(Number.isInteger(actual) && Number.isInteger(expected)) {\n    return actual === expected;\n  }\n\n  const prec = Math.min(decimalPlaces(actual), decimalPlaces(expected));\n\n  if(prec === 0){\n    return Math.round(actual) === Math.round(expected);\n  } else {\n    // Note: parseFloat(0.00000011).toPrecision(7) ===  \"1.100000e-7\"\n    // It does # of significant digits, not decimal places.\n    return roundToDecimalPlaces(actual, prec) ===\n      roundToDecimalPlaces(expected, prec);\n  }\n};\n\n/**\n * Determines numbers equality\n * @param {number} actual\n * @param {number} expected\n * @return {boolean}\n */\nnumberFns.isEqual = function(actual, expected) {\n  return roundToMaxPrecision(actual) === roundToMaxPrecision(expected);\n};\n\nmodule.exports = numberFns;\n","// This is a modified version of antr4's index.js, in which\n// the \"require\" statements of two unused classes are commented out\n// to avoid introducing a dependency on Node.js' \"fs\" package.\n\n/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\nexports.atn = require('antlr4/src/antlr4/atn/index');\nexports.codepointat = require('antlr4/src/antlr4/polyfills/codepointat');\nexports.dfa = require('antlr4/src/antlr4/dfa/index');\nexports.fromcodepoint = require('antlr4/src/antlr4/polyfills/fromcodepoint');\nexports.tree = require('antlr4/src/antlr4/tree/index');\nexports.error = require('antlr4/src/antlr4/error/index');\nexports.Token = require('antlr4/src/antlr4/Token').Token;\n// Commented out to avoid the problem with 'fs' during the webpack build\n// exports.CharStreams = require('antlr4/src/antlr4/CharStreams');\nexports.CommonToken = require('antlr4/src/antlr4/Token').CommonToken;\nexports.InputStream = require('antlr4/src/antlr4/InputStream');\n// Commented out to avoid the problem with 'fs' during the webpack build\n// exports.FileStream = require('antlr4/src/antlr4/FileStream');\nexports.CommonTokenStream = require('antlr4/src/antlr4/CommonTokenStream');\nexports.Lexer = require('antlr4/src/antlr4/Lexer');\nexports.Parser = require('antlr4/src/antlr4/Parser');\nvar pc = require('antlr4/src/antlr4/PredictionContext');\nexports.PredictionContextCache = pc.PredictionContextCache;\nexports.ParserRuleContext = require('antlr4/src/antlr4/ParserRuleContext');\nexports.Interval = require('antlr4/src/antlr4/IntervalSet').Interval;\nexports.IntervalSet = require('antlr4/src/antlr4/IntervalSet').IntervalSet;\nexports.Utils = require('antlr4/src/antlr4/Utils');\nexports.LL1Analyzer = require('antlr4/src/antlr4/LL1Analyzer').LL1Analyzer;\n","// Generated from FHIRPath.g4 by ANTLR 4.9.3\n// jshint ignore: start\nconst antlr4 = require('../antlr4-index');\n\n\n\nconst serializedATN = [\"\\u0003\\u608b\\ua72a\\u8133\\ub9ed\\u417c\\u3be7\\u7786\",\n    \"\\u5964\\u0002A\\u0203\\b\\u0001\\u0004\\u0002\\t\\u0002\\u0004\\u0003\\t\\u0003\",\n    \"\\u0004\\u0004\\t\\u0004\\u0004\\u0005\\t\\u0005\\u0004\\u0006\\t\\u0006\\u0004\\u0007\",\n    \"\\t\\u0007\\u0004\\b\\t\\b\\u0004\\t\\t\\t\\u0004\\n\\t\\n\\u0004\\u000b\\t\\u000b\\u0004\",\n    \"\\f\\t\\f\\u0004\\r\\t\\r\\u0004\\u000e\\t\\u000e\\u0004\\u000f\\t\\u000f\\u0004\\u0010\",\n    \"\\t\\u0010\\u0004\\u0011\\t\\u0011\\u0004\\u0012\\t\\u0012\\u0004\\u0013\\t\\u0013\",\n    \"\\u0004\\u0014\\t\\u0014\\u0004\\u0015\\t\\u0015\\u0004\\u0016\\t\\u0016\\u0004\\u0017\",\n    \"\\t\\u0017\\u0004\\u0018\\t\\u0018\\u0004\\u0019\\t\\u0019\\u0004\\u001a\\t\\u001a\",\n    \"\\u0004\\u001b\\t\\u001b\\u0004\\u001c\\t\\u001c\\u0004\\u001d\\t\\u001d\\u0004\\u001e\",\n    \"\\t\\u001e\\u0004\\u001f\\t\\u001f\\u0004 \\t \\u0004!\\t!\\u0004\\\"\\t\\\"\\u0004#\",\n    \"\\t#\\u0004$\\t$\\u0004%\\t%\\u0004&\\t&\\u0004\\'\\t\\'\\u0004(\\t(\\u0004)\\t)\\u0004\",\n    \"*\\t*\\u0004+\\t+\\u0004,\\t,\\u0004-\\t-\\u0004.\\t.\\u0004/\\t/\\u00040\\t0\\u0004\",\n    \"1\\t1\\u00042\\t2\\u00043\\t3\\u00044\\t4\\u00045\\t5\\u00046\\t6\\u00047\\t7\\u0004\",\n    \"8\\t8\\u00049\\t9\\u0004:\\t:\\u0004;\\t;\\u0004<\\t<\\u0004=\\t=\\u0004>\\t>\\u0004\",\n    \"?\\t?\\u0004@\\t@\\u0004A\\tA\\u0004B\\tB\\u0004C\\tC\\u0004D\\tD\\u0003\\u0002\\u0003\",\n    \"\\u0002\\u0003\\u0003\\u0003\\u0003\\u0003\\u0004\\u0003\\u0004\\u0003\\u0005\\u0003\",\n    \"\\u0005\\u0003\\u0006\\u0003\\u0006\\u0003\\u0007\\u0003\\u0007\\u0003\\b\\u0003\",\n    \"\\b\\u0003\\t\\u0003\\t\\u0003\\t\\u0003\\t\\u0003\\n\\u0003\\n\\u0003\\n\\u0003\\n\\u0003\",\n    \"\\u000b\\u0003\\u000b\\u0003\\f\\u0003\\f\\u0003\\r\\u0003\\r\\u0003\\r\\u0003\\u000e\",\n    \"\\u0003\\u000e\\u0003\\u000f\\u0003\\u000f\\u0003\\u0010\\u0003\\u0010\\u0003\\u0010\",\n    \"\\u0003\\u0011\\u0003\\u0011\\u0003\\u0011\\u0003\\u0012\\u0003\\u0012\\u0003\\u0012\",\n    \"\\u0003\\u0013\\u0003\\u0013\\u0003\\u0014\\u0003\\u0014\\u0003\\u0015\\u0003\\u0015\",\n    \"\\u0003\\u0015\\u0003\\u0016\\u0003\\u0016\\u0003\\u0016\\u0003\\u0017\\u0003\\u0017\",\n    \"\\u0003\\u0017\\u0003\\u0018\\u0003\\u0018\\u0003\\u0018\\u0003\\u0018\\u0003\\u0018\",\n    \"\\u0003\\u0018\\u0003\\u0018\\u0003\\u0018\\u0003\\u0018\\u0003\\u0019\\u0003\\u0019\",\n    \"\\u0003\\u0019\\u0003\\u0019\\u0003\\u001a\\u0003\\u001a\\u0003\\u001a\\u0003\\u001b\",\n    \"\\u0003\\u001b\\u0003\\u001b\\u0003\\u001b\\u0003\\u001c\\u0003\\u001c\\u0003\\u001c\",\n    \"\\u0003\\u001c\\u0003\\u001c\\u0003\\u001c\\u0003\\u001c\\u0003\\u001c\\u0003\\u001d\",\n    \"\\u0003\\u001d\\u0003\\u001e\\u0003\\u001e\\u0003\\u001f\\u0003\\u001f\\u0003 \",\n    \"\\u0003 \\u0003!\\u0003!\\u0003!\\u0003!\\u0003!\\u0003\\\"\\u0003\\\"\\u0003\\\"\\u0003\",\n    \"\\\"\\u0003\\\"\\u0003\\\"\\u0003#\\u0003#\\u0003$\\u0003$\\u0003$\\u0003$\\u0003$\",\n    \"\\u0003$\\u0003%\\u0003%\\u0003%\\u0003%\\u0003%\\u0003%\\u0003%\\u0003&\\u0003\",\n    \"&\\u0003&\\u0003&\\u0003&\\u0003&\\u0003&\\u0003\\'\\u0003\\'\\u0003(\\u0003(\\u0003\",\n    \"(\\u0003(\\u0003(\\u0003)\\u0003)\\u0003)\\u0003)\\u0003)\\u0003)\\u0003*\\u0003\",\n    \"*\\u0003*\\u0003*\\u0003*\\u0003+\\u0003+\\u0003+\\u0003+\\u0003,\\u0003,\\u0003\",\n    \",\\u0003,\\u0003,\\u0003-\\u0003-\\u0003-\\u0003-\\u0003-\\u0003-\\u0003-\\u0003\",\n    \".\\u0003.\\u0003.\\u0003.\\u0003.\\u0003.\\u0003.\\u0003/\\u0003/\\u0003/\\u0003\",\n    \"/\\u0003/\\u0003/\\u0003/\\u0003/\\u0003/\\u0003/\\u0003/\\u0003/\\u00030\\u0003\",\n    \"0\\u00030\\u00030\\u00030\\u00030\\u00031\\u00031\\u00031\\u00031\\u00031\\u0003\",\n    \"1\\u00031\\u00032\\u00032\\u00032\\u00032\\u00032\\u00032\\u00033\\u00033\\u0003\",\n    \"3\\u00033\\u00033\\u00034\\u00034\\u00034\\u00034\\u00034\\u00034\\u00035\\u0003\",\n    \"5\\u00035\\u00035\\u00035\\u00035\\u00035\\u00035\\u00036\\u00036\\u00036\\u0003\",\n    \"6\\u00036\\u00036\\u00036\\u00036\\u00037\\u00037\\u00037\\u00037\\u00037\\u0003\",\n    \"7\\u00037\\u00037\\u00037\\u00037\\u00037\\u00037\\u00037\\u00038\\u00038\\u0003\",\n    \"8\\u00038\\u00038\\u00038\\u00038\\u00038\\u00038\\u00038\\u00038\\u00038\\u0003\",\n    \"8\\u00058\\u0183\\n8\\u00058\\u0185\\n8\\u00058\\u0187\\n8\\u00038\\u00058\\u018a\",\n    \"\\n8\\u00039\\u00039\\u00039\\u00039\\u0003:\\u0003:\\u0003:\\u0003:\\u0003:\\u0003\",\n    \":\\u0003:\\u0003:\\u0003:\\u0003:\\u0006:\\u019a\\n:\\r:\\u000e:\\u019b\\u0005\",\n    \":\\u019e\\n:\\u0005:\\u01a0\\n:\\u0005:\\u01a2\\n:\\u0003:\\u0003:\\u0003:\\u0003\",\n    \":\\u0003:\\u0003:\\u0003:\\u0005:\\u01ab\\n:\\u0003;\\u0005;\\u01ae\\n;\\u0003\",\n    \";\\u0007;\\u01b1\\n;\\f;\\u000e;\\u01b4\\u000b;\\u0003<\\u0003<\\u0003<\\u0007\",\n    \"<\\u01b9\\n<\\f<\\u000e<\\u01bc\\u000b<\\u0003<\\u0003<\\u0003=\\u0003=\\u0003\",\n    \"=\\u0007=\\u01c3\\n=\\f=\\u000e=\\u01c6\\u000b=\\u0003=\\u0003=\\u0003>\\u0006\",\n    \">\\u01cb\\n>\\r>\\u000e>\\u01cc\\u0003>\\u0003>\\u0006>\\u01d1\\n>\\r>\\u000e>\\u01d2\",\n    \"\\u0005>\\u01d5\\n>\\u0003?\\u0006?\\u01d8\\n?\\r?\\u000e?\\u01d9\\u0003?\\u0003\",\n    \"?\\u0003@\\u0003@\\u0003@\\u0003@\\u0007@\\u01e2\\n@\\f@\\u000e@\\u01e5\\u000b\",\n    \"@\\u0003@\\u0003@\\u0003@\\u0003@\\u0003@\\u0003A\\u0003A\\u0003A\\u0003A\\u0007\",\n    \"A\\u01f0\\nA\\fA\\u000eA\\u01f3\\u000bA\\u0003A\\u0003A\\u0003B\\u0003B\\u0003\",\n    \"B\\u0005B\\u01fa\\nB\\u0003C\\u0003C\\u0003C\\u0003C\\u0003C\\u0003C\\u0003D\\u0003\",\n    \"D\\u0003\\u01e3\\u0002E\\u0003\\u0003\\u0005\\u0004\\u0007\\u0005\\t\\u0006\\u000b\",\n    \"\\u0007\\r\\b\\u000f\\t\\u0011\\n\\u0013\\u000b\\u0015\\f\\u0017\\r\\u0019\\u000e\\u001b\",\n    \"\\u000f\\u001d\\u0010\\u001f\\u0011!\\u0012#\\u0013%\\u0014\\'\\u0015)\\u0016+\",\n    \"\\u0017-\\u0018/\\u00191\\u001a3\\u001b5\\u001c7\\u001d9\\u001e;\\u001f= ?!A\",\n    \"\\\"C#E$G%I&K\\'M(O)Q*S+U,W-Y.[/]0_1a2c3e4g5i6k7m8o9q:s\\u0002u;w<y={>}\",\n    \"?\\u007f@\\u0081A\\u0083\\u0002\\u0085\\u0002\\u0087\\u0002\\u0003\\u0002\\f\\u0003\",\n    \"\\u00022;\\u0004\\u0002--//\\u0005\\u0002C\\\\aac|\\u0006\\u00022;C\\\\aac|\\u0004\",\n    \"\\u0002^^bb\\u0003\\u0002))\\u0005\\u0002\\u000b\\f\\u000f\\u000f\\\"\\\"\\u0004\\u0002\",\n    \"\\f\\f\\u000f\\u000f\\n\\u0002))11^^bbhhppttvv\\u0005\\u00022;CHch\\u0002\\u0214\",\n    \"\\u0002\\u0003\\u0003\\u0002\\u0002\\u0002\\u0002\\u0005\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0002\\u0007\\u0003\\u0002\\u0002\\u0002\\u0002\\t\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0002\\u000b\\u0003\\u0002\\u0002\\u0002\\u0002\\r\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0002\\u000f\\u0003\\u0002\\u0002\\u0002\\u0002\\u0011\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0002\\u0013\\u0003\\u0002\\u0002\\u0002\\u0002\\u0015\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0002\\u0017\\u0003\\u0002\\u0002\\u0002\\u0002\\u0019\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0002\\u001b\\u0003\\u0002\\u0002\\u0002\\u0002\\u001d\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0002\\u001f\\u0003\\u0002\\u0002\\u0002\\u0002!\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0002#\\u0003\\u0002\\u0002\\u0002\\u0002%\\u0003\\u0002\\u0002\\u0002\\u0002\",\n    \"\\'\\u0003\\u0002\\u0002\\u0002\\u0002)\\u0003\\u0002\\u0002\\u0002\\u0002+\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0002-\\u0003\\u0002\\u0002\\u0002\\u0002/\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u00021\\u0003\\u0002\\u0002\\u0002\\u00023\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u00025\\u0003\\u0002\\u0002\\u0002\\u00027\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u00029\\u0003\\u0002\\u0002\\u0002\\u0002;\\u0003\\u0002\\u0002\\u0002\\u0002\",\n    \"=\\u0003\\u0002\\u0002\\u0002\\u0002?\\u0003\\u0002\\u0002\\u0002\\u0002A\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0002C\\u0003\\u0002\\u0002\\u0002\\u0002E\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u0002G\\u0003\\u0002\\u0002\\u0002\\u0002I\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u0002K\\u0003\\u0002\\u0002\\u0002\\u0002M\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0002O\\u0003\\u0002\\u0002\\u0002\\u0002Q\\u0003\\u0002\\u0002\\u0002\\u0002\",\n    \"S\\u0003\\u0002\\u0002\\u0002\\u0002U\\u0003\\u0002\\u0002\\u0002\\u0002W\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0002Y\\u0003\\u0002\\u0002\\u0002\\u0002[\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u0002]\\u0003\\u0002\\u0002\\u0002\\u0002_\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u0002a\\u0003\\u0002\\u0002\\u0002\\u0002c\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0002e\\u0003\\u0002\\u0002\\u0002\\u0002g\\u0003\\u0002\\u0002\\u0002\\u0002\",\n    \"i\\u0003\\u0002\\u0002\\u0002\\u0002k\\u0003\\u0002\\u0002\\u0002\\u0002m\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0002o\\u0003\\u0002\\u0002\\u0002\\u0002q\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u0002u\\u0003\\u0002\\u0002\\u0002\\u0002w\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u0002y\\u0003\\u0002\\u0002\\u0002\\u0002{\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0002}\\u0003\\u0002\\u0002\\u0002\\u0002\\u007f\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0002\\u0081\\u0003\\u0002\\u0002\\u0002\\u0003\\u0089\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0005\\u008b\\u0003\\u0002\\u0002\\u0002\\u0007\\u008d\\u0003\\u0002\\u0002\\u0002\",\n    \"\\t\\u008f\\u0003\\u0002\\u0002\\u0002\\u000b\\u0091\\u0003\\u0002\\u0002\\u0002\",\n    \"\\r\\u0093\\u0003\\u0002\\u0002\\u0002\\u000f\\u0095\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0011\\u0097\\u0003\\u0002\\u0002\\u0002\\u0013\\u009b\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0015\\u009f\\u0003\\u0002\\u0002\\u0002\\u0017\\u00a1\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0019\\u00a3\\u0003\\u0002\\u0002\\u0002\\u001b\\u00a6\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u001d\\u00a8\\u0003\\u0002\\u0002\\u0002\\u001f\\u00aa\\u0003\\u0002\\u0002\\u0002\",\n    \"!\\u00ad\\u0003\\u0002\\u0002\\u0002#\\u00b0\\u0003\\u0002\\u0002\\u0002%\\u00b3\",\n    \"\\u0003\\u0002\\u0002\\u0002\\'\\u00b5\\u0003\\u0002\\u0002\\u0002)\\u00b7\\u0003\",\n    \"\\u0002\\u0002\\u0002+\\u00ba\\u0003\\u0002\\u0002\\u0002-\\u00bd\\u0003\\u0002\",\n    \"\\u0002\\u0002/\\u00c0\\u0003\\u0002\\u0002\\u00021\\u00c9\\u0003\\u0002\\u0002\",\n    \"\\u00023\\u00cd\\u0003\\u0002\\u0002\\u00025\\u00d0\\u0003\\u0002\\u0002\\u0002\",\n    \"7\\u00d4\\u0003\\u0002\\u0002\\u00029\\u00dc\\u0003\\u0002\\u0002\\u0002;\\u00de\",\n    \"\\u0003\\u0002\\u0002\\u0002=\\u00e0\\u0003\\u0002\\u0002\\u0002?\\u00e2\\u0003\",\n    \"\\u0002\\u0002\\u0002A\\u00e4\\u0003\\u0002\\u0002\\u0002C\\u00e9\\u0003\\u0002\",\n    \"\\u0002\\u0002E\\u00ef\\u0003\\u0002\\u0002\\u0002G\\u00f1\\u0003\\u0002\\u0002\",\n    \"\\u0002I\\u00f7\\u0003\\u0002\\u0002\\u0002K\\u00fe\\u0003\\u0002\\u0002\\u0002\",\n    \"M\\u0105\\u0003\\u0002\\u0002\\u0002O\\u0107\\u0003\\u0002\\u0002\\u0002Q\\u010c\",\n    \"\\u0003\\u0002\\u0002\\u0002S\\u0112\\u0003\\u0002\\u0002\\u0002U\\u0117\\u0003\",\n    \"\\u0002\\u0002\\u0002W\\u011b\\u0003\\u0002\\u0002\\u0002Y\\u0120\\u0003\\u0002\",\n    \"\\u0002\\u0002[\\u0127\\u0003\\u0002\\u0002\\u0002]\\u012e\\u0003\\u0002\\u0002\",\n    \"\\u0002_\\u013a\\u0003\\u0002\\u0002\\u0002a\\u0140\\u0003\\u0002\\u0002\\u0002\",\n    \"c\\u0147\\u0003\\u0002\\u0002\\u0002e\\u014d\\u0003\\u0002\\u0002\\u0002g\\u0152\",\n    \"\\u0003\\u0002\\u0002\\u0002i\\u0158\\u0003\\u0002\\u0002\\u0002k\\u0160\\u0003\",\n    \"\\u0002\\u0002\\u0002m\\u0168\\u0003\\u0002\\u0002\\u0002o\\u0175\\u0003\\u0002\",\n    \"\\u0002\\u0002q\\u018b\\u0003\\u0002\\u0002\\u0002s\\u018f\\u0003\\u0002\\u0002\",\n    \"\\u0002u\\u01ad\\u0003\\u0002\\u0002\\u0002w\\u01b5\\u0003\\u0002\\u0002\\u0002\",\n    \"y\\u01bf\\u0003\\u0002\\u0002\\u0002{\\u01ca\\u0003\\u0002\\u0002\\u0002}\\u01d7\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u007f\\u01dd\\u0003\\u0002\\u0002\\u0002\\u0081\\u01eb\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0083\\u01f6\\u0003\\u0002\\u0002\\u0002\\u0085\\u01fb\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0087\\u0201\\u0003\\u0002\\u0002\\u0002\\u0089\\u008a\",\n    \"\\u00070\\u0002\\u0002\\u008a\\u0004\\u0003\\u0002\\u0002\\u0002\\u008b\\u008c\",\n    \"\\u0007]\\u0002\\u0002\\u008c\\u0006\\u0003\\u0002\\u0002\\u0002\\u008d\\u008e\",\n    \"\\u0007_\\u0002\\u0002\\u008e\\b\\u0003\\u0002\\u0002\\u0002\\u008f\\u0090\\u0007\",\n    \"-\\u0002\\u0002\\u0090\\n\\u0003\\u0002\\u0002\\u0002\\u0091\\u0092\\u0007/\\u0002\",\n    \"\\u0002\\u0092\\f\\u0003\\u0002\\u0002\\u0002\\u0093\\u0094\\u0007,\\u0002\\u0002\",\n    \"\\u0094\\u000e\\u0003\\u0002\\u0002\\u0002\\u0095\\u0096\\u00071\\u0002\\u0002\",\n    \"\\u0096\\u0010\\u0003\\u0002\\u0002\\u0002\\u0097\\u0098\\u0007f\\u0002\\u0002\",\n    \"\\u0098\\u0099\\u0007k\\u0002\\u0002\\u0099\\u009a\\u0007x\\u0002\\u0002\\u009a\",\n    \"\\u0012\\u0003\\u0002\\u0002\\u0002\\u009b\\u009c\\u0007o\\u0002\\u0002\\u009c\",\n    \"\\u009d\\u0007q\\u0002\\u0002\\u009d\\u009e\\u0007f\\u0002\\u0002\\u009e\\u0014\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u009f\\u00a0\\u0007(\\u0002\\u0002\\u00a0\\u0016\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u00a1\\u00a2\\u0007~\\u0002\\u0002\\u00a2\\u0018\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u00a3\\u00a4\\u0007>\\u0002\\u0002\\u00a4\\u00a5\",\n    \"\\u0007?\\u0002\\u0002\\u00a5\\u001a\\u0003\\u0002\\u0002\\u0002\\u00a6\\u00a7\",\n    \"\\u0007>\\u0002\\u0002\\u00a7\\u001c\\u0003\\u0002\\u0002\\u0002\\u00a8\\u00a9\",\n    \"\\u0007@\\u0002\\u0002\\u00a9\\u001e\\u0003\\u0002\\u0002\\u0002\\u00aa\\u00ab\",\n    \"\\u0007@\\u0002\\u0002\\u00ab\\u00ac\\u0007?\\u0002\\u0002\\u00ac \\u0003\\u0002\",\n    \"\\u0002\\u0002\\u00ad\\u00ae\\u0007k\\u0002\\u0002\\u00ae\\u00af\\u0007u\\u0002\",\n    \"\\u0002\\u00af\\\"\\u0003\\u0002\\u0002\\u0002\\u00b0\\u00b1\\u0007c\\u0002\\u0002\",\n    \"\\u00b1\\u00b2\\u0007u\\u0002\\u0002\\u00b2$\\u0003\\u0002\\u0002\\u0002\\u00b3\",\n    \"\\u00b4\\u0007?\\u0002\\u0002\\u00b4&\\u0003\\u0002\\u0002\\u0002\\u00b5\\u00b6\",\n    \"\\u0007\\u0080\\u0002\\u0002\\u00b6(\\u0003\\u0002\\u0002\\u0002\\u00b7\\u00b8\",\n    \"\\u0007#\\u0002\\u0002\\u00b8\\u00b9\\u0007?\\u0002\\u0002\\u00b9*\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u00ba\\u00bb\\u0007#\\u0002\\u0002\\u00bb\\u00bc\\u0007\\u0080\",\n    \"\\u0002\\u0002\\u00bc,\\u0003\\u0002\\u0002\\u0002\\u00bd\\u00be\\u0007k\\u0002\",\n    \"\\u0002\\u00be\\u00bf\\u0007p\\u0002\\u0002\\u00bf.\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u00c0\\u00c1\\u0007e\\u0002\\u0002\\u00c1\\u00c2\\u0007q\\u0002\\u0002\\u00c2\",\n    \"\\u00c3\\u0007p\\u0002\\u0002\\u00c3\\u00c4\\u0007v\\u0002\\u0002\\u00c4\\u00c5\",\n    \"\\u0007c\\u0002\\u0002\\u00c5\\u00c6\\u0007k\\u0002\\u0002\\u00c6\\u00c7\\u0007\",\n    \"p\\u0002\\u0002\\u00c7\\u00c8\\u0007u\\u0002\\u0002\\u00c80\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u00c9\\u00ca\\u0007c\\u0002\\u0002\\u00ca\\u00cb\\u0007p\\u0002\\u0002\",\n    \"\\u00cb\\u00cc\\u0007f\\u0002\\u0002\\u00cc2\\u0003\\u0002\\u0002\\u0002\\u00cd\",\n    \"\\u00ce\\u0007q\\u0002\\u0002\\u00ce\\u00cf\\u0007t\\u0002\\u0002\\u00cf4\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u00d0\\u00d1\\u0007z\\u0002\\u0002\\u00d1\\u00d2\\u0007\",\n    \"q\\u0002\\u0002\\u00d2\\u00d3\\u0007t\\u0002\\u0002\\u00d36\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u00d4\\u00d5\\u0007k\\u0002\\u0002\\u00d5\\u00d6\\u0007o\\u0002\\u0002\",\n    \"\\u00d6\\u00d7\\u0007r\\u0002\\u0002\\u00d7\\u00d8\\u0007n\\u0002\\u0002\\u00d8\",\n    \"\\u00d9\\u0007k\\u0002\\u0002\\u00d9\\u00da\\u0007g\\u0002\\u0002\\u00da\\u00db\",\n    \"\\u0007u\\u0002\\u0002\\u00db8\\u0003\\u0002\\u0002\\u0002\\u00dc\\u00dd\\u0007\",\n    \"*\\u0002\\u0002\\u00dd:\\u0003\\u0002\\u0002\\u0002\\u00de\\u00df\\u0007+\\u0002\",\n    \"\\u0002\\u00df<\\u0003\\u0002\\u0002\\u0002\\u00e0\\u00e1\\u0007}\\u0002\\u0002\",\n    \"\\u00e1>\\u0003\\u0002\\u0002\\u0002\\u00e2\\u00e3\\u0007\\u007f\\u0002\\u0002\",\n    \"\\u00e3@\\u0003\\u0002\\u0002\\u0002\\u00e4\\u00e5\\u0007v\\u0002\\u0002\\u00e5\",\n    \"\\u00e6\\u0007t\\u0002\\u0002\\u00e6\\u00e7\\u0007w\\u0002\\u0002\\u00e7\\u00e8\",\n    \"\\u0007g\\u0002\\u0002\\u00e8B\\u0003\\u0002\\u0002\\u0002\\u00e9\\u00ea\\u0007\",\n    \"h\\u0002\\u0002\\u00ea\\u00eb\\u0007c\\u0002\\u0002\\u00eb\\u00ec\\u0007n\\u0002\",\n    \"\\u0002\\u00ec\\u00ed\\u0007u\\u0002\\u0002\\u00ed\\u00ee\\u0007g\\u0002\\u0002\",\n    \"\\u00eeD\\u0003\\u0002\\u0002\\u0002\\u00ef\\u00f0\\u0007\\'\\u0002\\u0002\\u00f0\",\n    \"F\\u0003\\u0002\\u0002\\u0002\\u00f1\\u00f2\\u0007&\\u0002\\u0002\\u00f2\\u00f3\",\n    \"\\u0007v\\u0002\\u0002\\u00f3\\u00f4\\u0007j\\u0002\\u0002\\u00f4\\u00f5\\u0007\",\n    \"k\\u0002\\u0002\\u00f5\\u00f6\\u0007u\\u0002\\u0002\\u00f6H\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u00f7\\u00f8\\u0007&\\u0002\\u0002\\u00f8\\u00f9\\u0007k\\u0002\\u0002\",\n    \"\\u00f9\\u00fa\\u0007p\\u0002\\u0002\\u00fa\\u00fb\\u0007f\\u0002\\u0002\\u00fb\",\n    \"\\u00fc\\u0007g\\u0002\\u0002\\u00fc\\u00fd\\u0007z\\u0002\\u0002\\u00fdJ\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u00fe\\u00ff\\u0007&\\u0002\\u0002\\u00ff\\u0100\\u0007\",\n    \"v\\u0002\\u0002\\u0100\\u0101\\u0007q\\u0002\\u0002\\u0101\\u0102\\u0007v\\u0002\",\n    \"\\u0002\\u0102\\u0103\\u0007c\\u0002\\u0002\\u0103\\u0104\\u0007n\\u0002\\u0002\",\n    \"\\u0104L\\u0003\\u0002\\u0002\\u0002\\u0105\\u0106\\u0007.\\u0002\\u0002\\u0106\",\n    \"N\\u0003\\u0002\\u0002\\u0002\\u0107\\u0108\\u0007{\\u0002\\u0002\\u0108\\u0109\",\n    \"\\u0007g\\u0002\\u0002\\u0109\\u010a\\u0007c\\u0002\\u0002\\u010a\\u010b\\u0007\",\n    \"t\\u0002\\u0002\\u010bP\\u0003\\u0002\\u0002\\u0002\\u010c\\u010d\\u0007o\\u0002\",\n    \"\\u0002\\u010d\\u010e\\u0007q\\u0002\\u0002\\u010e\\u010f\\u0007p\\u0002\\u0002\",\n    \"\\u010f\\u0110\\u0007v\\u0002\\u0002\\u0110\\u0111\\u0007j\\u0002\\u0002\\u0111\",\n    \"R\\u0003\\u0002\\u0002\\u0002\\u0112\\u0113\\u0007y\\u0002\\u0002\\u0113\\u0114\",\n    \"\\u0007g\\u0002\\u0002\\u0114\\u0115\\u0007g\\u0002\\u0002\\u0115\\u0116\\u0007\",\n    \"m\\u0002\\u0002\\u0116T\\u0003\\u0002\\u0002\\u0002\\u0117\\u0118\\u0007f\\u0002\",\n    \"\\u0002\\u0118\\u0119\\u0007c\\u0002\\u0002\\u0119\\u011a\\u0007{\\u0002\\u0002\",\n    \"\\u011aV\\u0003\\u0002\\u0002\\u0002\\u011b\\u011c\\u0007j\\u0002\\u0002\\u011c\",\n    \"\\u011d\\u0007q\\u0002\\u0002\\u011d\\u011e\\u0007w\\u0002\\u0002\\u011e\\u011f\",\n    \"\\u0007t\\u0002\\u0002\\u011fX\\u0003\\u0002\\u0002\\u0002\\u0120\\u0121\\u0007\",\n    \"o\\u0002\\u0002\\u0121\\u0122\\u0007k\\u0002\\u0002\\u0122\\u0123\\u0007p\\u0002\",\n    \"\\u0002\\u0123\\u0124\\u0007w\\u0002\\u0002\\u0124\\u0125\\u0007v\\u0002\\u0002\",\n    \"\\u0125\\u0126\\u0007g\\u0002\\u0002\\u0126Z\\u0003\\u0002\\u0002\\u0002\\u0127\",\n    \"\\u0128\\u0007u\\u0002\\u0002\\u0128\\u0129\\u0007g\\u0002\\u0002\\u0129\\u012a\",\n    \"\\u0007e\\u0002\\u0002\\u012a\\u012b\\u0007q\\u0002\\u0002\\u012b\\u012c\\u0007\",\n    \"p\\u0002\\u0002\\u012c\\u012d\\u0007f\\u0002\\u0002\\u012d\\\\\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u012e\\u012f\\u0007o\\u0002\\u0002\\u012f\\u0130\\u0007k\\u0002\\u0002\",\n    \"\\u0130\\u0131\\u0007n\\u0002\\u0002\\u0131\\u0132\\u0007n\\u0002\\u0002\\u0132\",\n    \"\\u0133\\u0007k\\u0002\\u0002\\u0133\\u0134\\u0007u\\u0002\\u0002\\u0134\\u0135\",\n    \"\\u0007g\\u0002\\u0002\\u0135\\u0136\\u0007e\\u0002\\u0002\\u0136\\u0137\\u0007\",\n    \"q\\u0002\\u0002\\u0137\\u0138\\u0007p\\u0002\\u0002\\u0138\\u0139\\u0007f\\u0002\",\n    \"\\u0002\\u0139^\\u0003\\u0002\\u0002\\u0002\\u013a\\u013b\\u0007{\\u0002\\u0002\",\n    \"\\u013b\\u013c\\u0007g\\u0002\\u0002\\u013c\\u013d\\u0007c\\u0002\\u0002\\u013d\",\n    \"\\u013e\\u0007t\\u0002\\u0002\\u013e\\u013f\\u0007u\\u0002\\u0002\\u013f`\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0140\\u0141\\u0007o\\u0002\\u0002\\u0141\\u0142\\u0007\",\n    \"q\\u0002\\u0002\\u0142\\u0143\\u0007p\\u0002\\u0002\\u0143\\u0144\\u0007v\\u0002\",\n    \"\\u0002\\u0144\\u0145\\u0007j\\u0002\\u0002\\u0145\\u0146\\u0007u\\u0002\\u0002\",\n    \"\\u0146b\\u0003\\u0002\\u0002\\u0002\\u0147\\u0148\\u0007y\\u0002\\u0002\\u0148\",\n    \"\\u0149\\u0007g\\u0002\\u0002\\u0149\\u014a\\u0007g\\u0002\\u0002\\u014a\\u014b\",\n    \"\\u0007m\\u0002\\u0002\\u014b\\u014c\\u0007u\\u0002\\u0002\\u014cd\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u014d\\u014e\\u0007f\\u0002\\u0002\\u014e\\u014f\\u0007c\\u0002\",\n    \"\\u0002\\u014f\\u0150\\u0007{\\u0002\\u0002\\u0150\\u0151\\u0007u\\u0002\\u0002\",\n    \"\\u0151f\\u0003\\u0002\\u0002\\u0002\\u0152\\u0153\\u0007j\\u0002\\u0002\\u0153\",\n    \"\\u0154\\u0007q\\u0002\\u0002\\u0154\\u0155\\u0007w\\u0002\\u0002\\u0155\\u0156\",\n    \"\\u0007t\\u0002\\u0002\\u0156\\u0157\\u0007u\\u0002\\u0002\\u0157h\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u0158\\u0159\\u0007o\\u0002\\u0002\\u0159\\u015a\\u0007k\\u0002\",\n    \"\\u0002\\u015a\\u015b\\u0007p\\u0002\\u0002\\u015b\\u015c\\u0007w\\u0002\\u0002\",\n    \"\\u015c\\u015d\\u0007v\\u0002\\u0002\\u015d\\u015e\\u0007g\\u0002\\u0002\\u015e\",\n    \"\\u015f\\u0007u\\u0002\\u0002\\u015fj\\u0003\\u0002\\u0002\\u0002\\u0160\\u0161\",\n    \"\\u0007u\\u0002\\u0002\\u0161\\u0162\\u0007g\\u0002\\u0002\\u0162\\u0163\\u0007\",\n    \"e\\u0002\\u0002\\u0163\\u0164\\u0007q\\u0002\\u0002\\u0164\\u0165\\u0007p\\u0002\",\n    \"\\u0002\\u0165\\u0166\\u0007f\\u0002\\u0002\\u0166\\u0167\\u0007u\\u0002\\u0002\",\n    \"\\u0167l\\u0003\\u0002\\u0002\\u0002\\u0168\\u0169\\u0007o\\u0002\\u0002\\u0169\",\n    \"\\u016a\\u0007k\\u0002\\u0002\\u016a\\u016b\\u0007n\\u0002\\u0002\\u016b\\u016c\",\n    \"\\u0007n\\u0002\\u0002\\u016c\\u016d\\u0007k\\u0002\\u0002\\u016d\\u016e\\u0007\",\n    \"u\\u0002\\u0002\\u016e\\u016f\\u0007g\\u0002\\u0002\\u016f\\u0170\\u0007e\\u0002\",\n    \"\\u0002\\u0170\\u0171\\u0007q\\u0002\\u0002\\u0171\\u0172\\u0007p\\u0002\\u0002\",\n    \"\\u0172\\u0173\\u0007f\\u0002\\u0002\\u0173\\u0174\\u0007u\\u0002\\u0002\\u0174\",\n    \"n\\u0003\\u0002\\u0002\\u0002\\u0175\\u0176\\u0007B\\u0002\\u0002\\u0176\\u0177\",\n    \"\\t\\u0002\\u0002\\u0002\\u0177\\u0178\\t\\u0002\\u0002\\u0002\\u0178\\u0179\\t\\u0002\",\n    \"\\u0002\\u0002\\u0179\\u0186\\t\\u0002\\u0002\\u0002\\u017a\\u017b\\u0007/\\u0002\",\n    \"\\u0002\\u017b\\u017c\\t\\u0002\\u0002\\u0002\\u017c\\u0184\\t\\u0002\\u0002\\u0002\",\n    \"\\u017d\\u017e\\u0007/\\u0002\\u0002\\u017e\\u017f\\t\\u0002\\u0002\\u0002\\u017f\",\n    \"\\u0182\\t\\u0002\\u0002\\u0002\\u0180\\u0181\\u0007V\\u0002\\u0002\\u0181\\u0183\",\n    \"\\u0005s:\\u0002\\u0182\\u0180\\u0003\\u0002\\u0002\\u0002\\u0182\\u0183\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0183\\u0185\\u0003\\u0002\\u0002\\u0002\\u0184\\u017d\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0184\\u0185\\u0003\\u0002\\u0002\\u0002\\u0185\\u0187\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0186\\u017a\\u0003\\u0002\\u0002\\u0002\\u0186\\u0187\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0187\\u0189\\u0003\\u0002\\u0002\\u0002\\u0188\\u018a\\u0007\",\n    \"\\\\\\u0002\\u0002\\u0189\\u0188\\u0003\\u0002\\u0002\\u0002\\u0189\\u018a\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u018ap\\u0003\\u0002\\u0002\\u0002\\u018b\\u018c\\u0007\",\n    \"B\\u0002\\u0002\\u018c\\u018d\\u0007V\\u0002\\u0002\\u018d\\u018e\\u0005s:\\u0002\",\n    \"\\u018er\\u0003\\u0002\\u0002\\u0002\\u018f\\u0190\\t\\u0002\\u0002\\u0002\\u0190\",\n    \"\\u01a1\\t\\u0002\\u0002\\u0002\\u0191\\u0192\\u0007<\\u0002\\u0002\\u0192\\u0193\",\n    \"\\t\\u0002\\u0002\\u0002\\u0193\\u019f\\t\\u0002\\u0002\\u0002\\u0194\\u0195\\u0007\",\n    \"<\\u0002\\u0002\\u0195\\u0196\\t\\u0002\\u0002\\u0002\\u0196\\u019d\\t\\u0002\\u0002\",\n    \"\\u0002\\u0197\\u0199\\u00070\\u0002\\u0002\\u0198\\u019a\\t\\u0002\\u0002\\u0002\",\n    \"\\u0199\\u0198\\u0003\\u0002\\u0002\\u0002\\u019a\\u019b\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u019b\\u0199\\u0003\\u0002\\u0002\\u0002\\u019b\\u019c\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u019c\\u019e\\u0003\\u0002\\u0002\\u0002\\u019d\\u0197\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u019d\\u019e\\u0003\\u0002\\u0002\\u0002\\u019e\\u01a0\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u019f\\u0194\\u0003\\u0002\\u0002\\u0002\\u019f\\u01a0\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u01a0\\u01a2\\u0003\\u0002\\u0002\\u0002\\u01a1\\u0191\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u01a1\\u01a2\\u0003\\u0002\\u0002\\u0002\\u01a2\\u01aa\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u01a3\\u01ab\\u0007\\\\\\u0002\\u0002\\u01a4\\u01a5\\t\\u0003\\u0002\\u0002\\u01a5\",\n    \"\\u01a6\\t\\u0002\\u0002\\u0002\\u01a6\\u01a7\\t\\u0002\\u0002\\u0002\\u01a7\\u01a8\",\n    \"\\u0007<\\u0002\\u0002\\u01a8\\u01a9\\t\\u0002\\u0002\\u0002\\u01a9\\u01ab\\t\\u0002\",\n    \"\\u0002\\u0002\\u01aa\\u01a3\\u0003\\u0002\\u0002\\u0002\\u01aa\\u01a4\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u01aa\\u01ab\\u0003\\u0002\\u0002\\u0002\\u01abt\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u01ac\\u01ae\\t\\u0004\\u0002\\u0002\\u01ad\\u01ac\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u01ae\\u01b2\\u0003\\u0002\\u0002\\u0002\\u01af\\u01b1\\t\\u0005\",\n    \"\\u0002\\u0002\\u01b0\\u01af\\u0003\\u0002\\u0002\\u0002\\u01b1\\u01b4\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u01b2\\u01b0\\u0003\\u0002\\u0002\\u0002\\u01b2\\u01b3\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u01b3v\\u0003\\u0002\\u0002\\u0002\\u01b4\\u01b2\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u01b5\\u01ba\\u0007b\\u0002\\u0002\\u01b6\\u01b9\\u0005\\u0083\",\n    \"B\\u0002\\u01b7\\u01b9\\n\\u0006\\u0002\\u0002\\u01b8\\u01b6\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u01b8\\u01b7\\u0003\\u0002\\u0002\\u0002\\u01b9\\u01bc\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u01ba\\u01b8\\u0003\\u0002\\u0002\\u0002\\u01ba\\u01bb\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u01bb\\u01bd\\u0003\\u0002\\u0002\\u0002\\u01bc\\u01ba\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u01bd\\u01be\\u0007b\\u0002\\u0002\\u01bex\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u01bf\\u01c4\\u0007)\\u0002\\u0002\\u01c0\\u01c3\\u0005\\u0083B\\u0002\\u01c1\",\n    \"\\u01c3\\n\\u0007\\u0002\\u0002\\u01c2\\u01c0\\u0003\\u0002\\u0002\\u0002\\u01c2\",\n    \"\\u01c1\\u0003\\u0002\\u0002\\u0002\\u01c3\\u01c6\\u0003\\u0002\\u0002\\u0002\\u01c4\",\n    \"\\u01c2\\u0003\\u0002\\u0002\\u0002\\u01c4\\u01c5\\u0003\\u0002\\u0002\\u0002\\u01c5\",\n    \"\\u01c7\\u0003\\u0002\\u0002\\u0002\\u01c6\\u01c4\\u0003\\u0002\\u0002\\u0002\\u01c7\",\n    \"\\u01c8\\u0007)\\u0002\\u0002\\u01c8z\\u0003\\u0002\\u0002\\u0002\\u01c9\\u01cb\",\n    \"\\t\\u0002\\u0002\\u0002\\u01ca\\u01c9\\u0003\\u0002\\u0002\\u0002\\u01cb\\u01cc\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u01cc\\u01ca\\u0003\\u0002\\u0002\\u0002\\u01cc\\u01cd\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u01cd\\u01d4\\u0003\\u0002\\u0002\\u0002\\u01ce\\u01d0\",\n    \"\\u00070\\u0002\\u0002\\u01cf\\u01d1\\t\\u0002\\u0002\\u0002\\u01d0\\u01cf\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u01d1\\u01d2\\u0003\\u0002\\u0002\\u0002\\u01d2\\u01d0\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u01d2\\u01d3\\u0003\\u0002\\u0002\\u0002\\u01d3\\u01d5\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u01d4\\u01ce\\u0003\\u0002\\u0002\\u0002\\u01d4\\u01d5\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u01d5|\\u0003\\u0002\\u0002\\u0002\\u01d6\\u01d8\\t\\b\\u0002\",\n    \"\\u0002\\u01d7\\u01d6\\u0003\\u0002\\u0002\\u0002\\u01d8\\u01d9\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u01d9\\u01d7\\u0003\\u0002\\u0002\\u0002\\u01d9\\u01da\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u01da\\u01db\\u0003\\u0002\\u0002\\u0002\\u01db\\u01dc\\b?\\u0002\\u0002\",\n    \"\\u01dc~\\u0003\\u0002\\u0002\\u0002\\u01dd\\u01de\\u00071\\u0002\\u0002\\u01de\",\n    \"\\u01df\\u0007,\\u0002\\u0002\\u01df\\u01e3\\u0003\\u0002\\u0002\\u0002\\u01e0\",\n    \"\\u01e2\\u000b\\u0002\\u0002\\u0002\\u01e1\\u01e0\\u0003\\u0002\\u0002\\u0002\\u01e2\",\n    \"\\u01e5\\u0003\\u0002\\u0002\\u0002\\u01e3\\u01e4\\u0003\\u0002\\u0002\\u0002\\u01e3\",\n    \"\\u01e1\\u0003\\u0002\\u0002\\u0002\\u01e4\\u01e6\\u0003\\u0002\\u0002\\u0002\\u01e5\",\n    \"\\u01e3\\u0003\\u0002\\u0002\\u0002\\u01e6\\u01e7\\u0007,\\u0002\\u0002\\u01e7\",\n    \"\\u01e8\\u00071\\u0002\\u0002\\u01e8\\u01e9\\u0003\\u0002\\u0002\\u0002\\u01e9\",\n    \"\\u01ea\\b@\\u0002\\u0002\\u01ea\\u0080\\u0003\\u0002\\u0002\\u0002\\u01eb\\u01ec\",\n    \"\\u00071\\u0002\\u0002\\u01ec\\u01ed\\u00071\\u0002\\u0002\\u01ed\\u01f1\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u01ee\\u01f0\\n\\t\\u0002\\u0002\\u01ef\\u01ee\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u01f0\\u01f3\\u0003\\u0002\\u0002\\u0002\\u01f1\\u01ef\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u01f1\\u01f2\\u0003\\u0002\\u0002\\u0002\\u01f2\\u01f4\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u01f3\\u01f1\\u0003\\u0002\\u0002\\u0002\\u01f4\\u01f5\\bA\\u0002\",\n    \"\\u0002\\u01f5\\u0082\\u0003\\u0002\\u0002\\u0002\\u01f6\\u01f9\\u0007^\\u0002\",\n    \"\\u0002\\u01f7\\u01fa\\t\\n\\u0002\\u0002\\u01f8\\u01fa\\u0005\\u0085C\\u0002\\u01f9\",\n    \"\\u01f7\\u0003\\u0002\\u0002\\u0002\\u01f9\\u01f8\\u0003\\u0002\\u0002\\u0002\\u01fa\",\n    \"\\u0084\\u0003\\u0002\\u0002\\u0002\\u01fb\\u01fc\\u0007w\\u0002\\u0002\\u01fc\",\n    \"\\u01fd\\u0005\\u0087D\\u0002\\u01fd\\u01fe\\u0005\\u0087D\\u0002\\u01fe\\u01ff\",\n    \"\\u0005\\u0087D\\u0002\\u01ff\\u0200\\u0005\\u0087D\\u0002\\u0200\\u0086\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0201\\u0202\\t\\u000b\\u0002\\u0002\\u0202\\u0088\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u001a\\u0002\\u0182\\u0184\\u0186\\u0189\\u019b\\u019d\\u019f\",\n    \"\\u01a1\\u01aa\\u01ad\\u01b0\\u01b2\\u01b8\\u01ba\\u01c2\\u01c4\\u01cc\\u01d2\\u01d4\",\n    \"\\u01d9\\u01e3\\u01f1\\u01f9\\u0003\\u0002\\u0003\\u0002\"].join(\"\");\n\n\nconst atn = new antlr4.atn.ATNDeserializer().deserialize(serializedATN);\n\nconst decisionsToDFA = atn.decisionToState.map( (ds, index) => new antlr4.dfa.DFA(ds, index) );\n\nclass FHIRPathLexer extends antlr4.Lexer {\n\n    static grammarFileName = \"FHIRPath.g4\";\n    static channelNames = [ \"DEFAULT_TOKEN_CHANNEL\", \"HIDDEN\" ];\n\tstatic modeNames = [ \"DEFAULT_MODE\" ];\n\tstatic literalNames = [ null, \"'.'\", \"'['\", \"']'\", \"'+'\", \"'-'\", \"'*'\", \n                         \"'/'\", \"'div'\", \"'mod'\", \"'&'\", \"'|'\", \"'<='\", \n                         \"'<'\", \"'>'\", \"'>='\", \"'is'\", \"'as'\", \"'='\", \"'~'\", \n                         \"'!='\", \"'!~'\", \"'in'\", \"'contains'\", \"'and'\", \n                         \"'or'\", \"'xor'\", \"'implies'\", \"'('\", \"')'\", \"'{'\", \n                         \"'}'\", \"'true'\", \"'false'\", \"'%'\", \"'$this'\", \"'$index'\", \n                         \"'$total'\", \"','\", \"'year'\", \"'month'\", \"'week'\", \n                         \"'day'\", \"'hour'\", \"'minute'\", \"'second'\", \"'millisecond'\", \n                         \"'years'\", \"'months'\", \"'weeks'\", \"'days'\", \"'hours'\", \n                         \"'minutes'\", \"'seconds'\", \"'milliseconds'\" ];\n\tstatic symbolicNames = [ null, null, null, null, null, null, null, null, \n                          null, null, null, null, null, null, null, null, \n                          null, null, null, null, null, null, null, null, \n                          null, null, null, null, null, null, null, null, \n                          null, null, null, null, null, null, null, null, \n                          null, null, null, null, null, null, null, null, \n                          null, null, null, null, null, null, null, \"DATETIME\", \n                          \"TIME\", \"IDENTIFIER\", \"DELIMITEDIDENTIFIER\", \"STRING\", \n                          \"NUMBER\", \"WS\", \"COMMENT\", \"LINE_COMMENT\" ];\n\tstatic ruleNames = [ \"T__0\", \"T__1\", \"T__2\", \"T__3\", \"T__4\", \"T__5\", \"T__6\", \n                      \"T__7\", \"T__8\", \"T__9\", \"T__10\", \"T__11\", \"T__12\", \n                      \"T__13\", \"T__14\", \"T__15\", \"T__16\", \"T__17\", \"T__18\", \n                      \"T__19\", \"T__20\", \"T__21\", \"T__22\", \"T__23\", \"T__24\", \n                      \"T__25\", \"T__26\", \"T__27\", \"T__28\", \"T__29\", \"T__30\", \n                      \"T__31\", \"T__32\", \"T__33\", \"T__34\", \"T__35\", \"T__36\", \n                      \"T__37\", \"T__38\", \"T__39\", \"T__40\", \"T__41\", \"T__42\", \n                      \"T__43\", \"T__44\", \"T__45\", \"T__46\", \"T__47\", \"T__48\", \n                      \"T__49\", \"T__50\", \"T__51\", \"T__52\", \"T__53\", \"DATETIME\", \n                      \"TIME\", \"TIMEFORMAT\", \"IDENTIFIER\", \"DELIMITEDIDENTIFIER\", \n                      \"STRING\", \"NUMBER\", \"WS\", \"COMMENT\", \"LINE_COMMENT\", \n                      \"ESC\", \"UNICODE\", \"HEX\" ];\n\n    constructor(input) {\n        super(input)\n        this._interp = new antlr4.atn.LexerATNSimulator(this, atn, decisionsToDFA, new antlr4.PredictionContextCache());\n    }\n\n    get atn() {\n        return atn;\n    }\n}\n\nFHIRPathLexer.EOF = antlr4.Token.EOF;\nFHIRPathLexer.T__0 = 1;\nFHIRPathLexer.T__1 = 2;\nFHIRPathLexer.T__2 = 3;\nFHIRPathLexer.T__3 = 4;\nFHIRPathLexer.T__4 = 5;\nFHIRPathLexer.T__5 = 6;\nFHIRPathLexer.T__6 = 7;\nFHIRPathLexer.T__7 = 8;\nFHIRPathLexer.T__8 = 9;\nFHIRPathLexer.T__9 = 10;\nFHIRPathLexer.T__10 = 11;\nFHIRPathLexer.T__11 = 12;\nFHIRPathLexer.T__12 = 13;\nFHIRPathLexer.T__13 = 14;\nFHIRPathLexer.T__14 = 15;\nFHIRPathLexer.T__15 = 16;\nFHIRPathLexer.T__16 = 17;\nFHIRPathLexer.T__17 = 18;\nFHIRPathLexer.T__18 = 19;\nFHIRPathLexer.T__19 = 20;\nFHIRPathLexer.T__20 = 21;\nFHIRPathLexer.T__21 = 22;\nFHIRPathLexer.T__22 = 23;\nFHIRPathLexer.T__23 = 24;\nFHIRPathLexer.T__24 = 25;\nFHIRPathLexer.T__25 = 26;\nFHIRPathLexer.T__26 = 27;\nFHIRPathLexer.T__27 = 28;\nFHIRPathLexer.T__28 = 29;\nFHIRPathLexer.T__29 = 30;\nFHIRPathLexer.T__30 = 31;\nFHIRPathLexer.T__31 = 32;\nFHIRPathLexer.T__32 = 33;\nFHIRPathLexer.T__33 = 34;\nFHIRPathLexer.T__34 = 35;\nFHIRPathLexer.T__35 = 36;\nFHIRPathLexer.T__36 = 37;\nFHIRPathLexer.T__37 = 38;\nFHIRPathLexer.T__38 = 39;\nFHIRPathLexer.T__39 = 40;\nFHIRPathLexer.T__40 = 41;\nFHIRPathLexer.T__41 = 42;\nFHIRPathLexer.T__42 = 43;\nFHIRPathLexer.T__43 = 44;\nFHIRPathLexer.T__44 = 45;\nFHIRPathLexer.T__45 = 46;\nFHIRPathLexer.T__46 = 47;\nFHIRPathLexer.T__47 = 48;\nFHIRPathLexer.T__48 = 49;\nFHIRPathLexer.T__49 = 50;\nFHIRPathLexer.T__50 = 51;\nFHIRPathLexer.T__51 = 52;\nFHIRPathLexer.T__52 = 53;\nFHIRPathLexer.T__53 = 54;\nFHIRPathLexer.DATETIME = 55;\nFHIRPathLexer.TIME = 56;\nFHIRPathLexer.IDENTIFIER = 57;\nFHIRPathLexer.DELIMITEDIDENTIFIER = 58;\nFHIRPathLexer.STRING = 59;\nFHIRPathLexer.NUMBER = 60;\nFHIRPathLexer.WS = 61;\nFHIRPathLexer.COMMENT = 62;\nFHIRPathLexer.LINE_COMMENT = 63;\n\n\n\n\nmodule.exports = FHIRPathLexer;","// Generated from FHIRPath.g4 by ANTLR 4.9.3\n// jshint ignore: start\nconst antlr4 = require('../antlr4-index');\n\n// This class defines a complete listener for a parse tree produced by FHIRPathParser.\nclass FHIRPathListener extends antlr4.tree.ParseTreeListener {\n\n\t// Enter a parse tree produced by FHIRPathParser#entireExpression.\n\tenterEntireExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#entireExpression.\n\texitEntireExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#indexerExpression.\n\tenterIndexerExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#indexerExpression.\n\texitIndexerExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#polarityExpression.\n\tenterPolarityExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#polarityExpression.\n\texitPolarityExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#additiveExpression.\n\tenterAdditiveExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#additiveExpression.\n\texitAdditiveExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#multiplicativeExpression.\n\tenterMultiplicativeExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#multiplicativeExpression.\n\texitMultiplicativeExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#unionExpression.\n\tenterUnionExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#unionExpression.\n\texitUnionExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#orExpression.\n\tenterOrExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#orExpression.\n\texitOrExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#andExpression.\n\tenterAndExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#andExpression.\n\texitAndExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#membershipExpression.\n\tenterMembershipExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#membershipExpression.\n\texitMembershipExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#inequalityExpression.\n\tenterInequalityExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#inequalityExpression.\n\texitInequalityExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#invocationExpression.\n\tenterInvocationExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#invocationExpression.\n\texitInvocationExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#equalityExpression.\n\tenterEqualityExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#equalityExpression.\n\texitEqualityExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#impliesExpression.\n\tenterImpliesExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#impliesExpression.\n\texitImpliesExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#termExpression.\n\tenterTermExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#termExpression.\n\texitTermExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#typeExpression.\n\tenterTypeExpression(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#typeExpression.\n\texitTypeExpression(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#invocationTerm.\n\tenterInvocationTerm(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#invocationTerm.\n\texitInvocationTerm(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#literalTerm.\n\tenterLiteralTerm(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#literalTerm.\n\texitLiteralTerm(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#externalConstantTerm.\n\tenterExternalConstantTerm(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#externalConstantTerm.\n\texitExternalConstantTerm(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#parenthesizedTerm.\n\tenterParenthesizedTerm(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#parenthesizedTerm.\n\texitParenthesizedTerm(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#nullLiteral.\n\tenterNullLiteral(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#nullLiteral.\n\texitNullLiteral(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#booleanLiteral.\n\tenterBooleanLiteral(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#booleanLiteral.\n\texitBooleanLiteral(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#stringLiteral.\n\tenterStringLiteral(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#stringLiteral.\n\texitStringLiteral(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#numberLiteral.\n\tenterNumberLiteral(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#numberLiteral.\n\texitNumberLiteral(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#dateTimeLiteral.\n\tenterDateTimeLiteral(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#dateTimeLiteral.\n\texitDateTimeLiteral(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#timeLiteral.\n\tenterTimeLiteral(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#timeLiteral.\n\texitTimeLiteral(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#quantityLiteral.\n\tenterQuantityLiteral(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#quantityLiteral.\n\texitQuantityLiteral(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#externalConstant.\n\tenterExternalConstant(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#externalConstant.\n\texitExternalConstant(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#memberInvocation.\n\tenterMemberInvocation(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#memberInvocation.\n\texitMemberInvocation(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#functionInvocation.\n\tenterFunctionInvocation(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#functionInvocation.\n\texitFunctionInvocation(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#thisInvocation.\n\tenterThisInvocation(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#thisInvocation.\n\texitThisInvocation(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#indexInvocation.\n\tenterIndexInvocation(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#indexInvocation.\n\texitIndexInvocation(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#totalInvocation.\n\tenterTotalInvocation(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#totalInvocation.\n\texitTotalInvocation(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#functn.\n\tenterFunctn(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#functn.\n\texitFunctn(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#paramList.\n\tenterParamList(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#paramList.\n\texitParamList(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#quantity.\n\tenterQuantity(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#quantity.\n\texitQuantity(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#unit.\n\tenterUnit(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#unit.\n\texitUnit(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#dateTimePrecision.\n\tenterDateTimePrecision(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#dateTimePrecision.\n\texitDateTimePrecision(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#pluralDateTimePrecision.\n\tenterPluralDateTimePrecision(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#pluralDateTimePrecision.\n\texitPluralDateTimePrecision(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#typeSpecifier.\n\tenterTypeSpecifier(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#typeSpecifier.\n\texitTypeSpecifier(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#qualifiedIdentifier.\n\tenterQualifiedIdentifier(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#qualifiedIdentifier.\n\texitQualifiedIdentifier(ctx) {\n\t}\n\n\n\t// Enter a parse tree produced by FHIRPathParser#identifier.\n\tenterIdentifier(ctx) {\n\t}\n\n\t// Exit a parse tree produced by FHIRPathParser#identifier.\n\texitIdentifier(ctx) {\n\t}\n\n\n\n}\nmodule.exports = FHIRPathListener;","// Generated from FHIRPath.g4 by ANTLR 4.9.3\n// jshint ignore: start\nconst antlr4 = require('../antlr4-index');\nconst FHIRPathListener = require('./FHIRPathListener');\n\nconst serializedATN = [\"\\u0003\\u608b\\ua72a\\u8133\\ub9ed\\u417c\\u3be7\\u7786\",\n    \"\\u5964\\u0003A\\u009c\\u0004\\u0002\\t\\u0002\\u0004\\u0003\\t\\u0003\\u0004\\u0004\",\n    \"\\t\\u0004\\u0004\\u0005\\t\\u0005\\u0004\\u0006\\t\\u0006\\u0004\\u0007\\t\\u0007\",\n    \"\\u0004\\b\\t\\b\\u0004\\t\\t\\t\\u0004\\n\\t\\n\\u0004\\u000b\\t\\u000b\\u0004\\f\\t\\f\",\n    \"\\u0004\\r\\t\\r\\u0004\\u000e\\t\\u000e\\u0004\\u000f\\t\\u000f\\u0004\\u0010\\t\\u0010\",\n    \"\\u0003\\u0002\\u0003\\u0002\\u0003\\u0002\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\",\n    \"\\u0003\\u0003\\u0005\\u0003(\\n\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\",\n    \"\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\",\n    \"\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\",\n    \"\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\",\n    \"\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\",\n    \"\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\",\n    \"\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0007\\u0003\",\n    \"P\\n\\u0003\\f\\u0003\\u000e\\u0003S\\u000b\\u0003\\u0003\\u0004\\u0003\\u0004\\u0003\",\n    \"\\u0004\\u0003\\u0004\\u0003\\u0004\\u0003\\u0004\\u0003\\u0004\\u0005\\u0004\\\\\",\n    \"\\n\\u0004\\u0003\\u0005\\u0003\\u0005\\u0003\\u0005\\u0003\\u0005\\u0003\\u0005\",\n    \"\\u0003\\u0005\\u0003\\u0005\\u0003\\u0005\\u0005\\u0005f\\n\\u0005\\u0003\\u0006\",\n    \"\\u0003\\u0006\\u0003\\u0006\\u0005\\u0006k\\n\\u0006\\u0003\\u0007\\u0003\\u0007\",\n    \"\\u0003\\u0007\\u0003\\u0007\\u0003\\u0007\\u0005\\u0007r\\n\\u0007\\u0003\\b\\u0003\",\n    \"\\b\\u0003\\b\\u0005\\bw\\n\\b\\u0003\\b\\u0003\\b\\u0003\\t\\u0003\\t\\u0003\\t\\u0007\",\n    \"\\t~\\n\\t\\f\\t\\u000e\\t\\u0081\\u000b\\t\\u0003\\n\\u0003\\n\\u0005\\n\\u0085\\n\\n\",\n    \"\\u0003\\u000b\\u0003\\u000b\\u0003\\u000b\\u0005\\u000b\\u008a\\n\\u000b\\u0003\",\n    \"\\f\\u0003\\f\\u0003\\r\\u0003\\r\\u0003\\u000e\\u0003\\u000e\\u0003\\u000f\\u0003\",\n    \"\\u000f\\u0003\\u000f\\u0007\\u000f\\u0095\\n\\u000f\\f\\u000f\\u000e\\u000f\\u0098\",\n    \"\\u000b\\u000f\\u0003\\u0010\\u0003\\u0010\\u0003\\u0010\\u0002\\u0003\\u0004\\u0011\",\n    \"\\u0002\\u0004\\u0006\\b\\n\\f\\u000e\\u0010\\u0012\\u0014\\u0016\\u0018\\u001a\\u001c\",\n    \"\\u001e\\u0002\\u000e\\u0003\\u0002\\u0006\\u0007\\u0003\\u0002\\b\\u000b\\u0004\",\n    \"\\u0002\\u0006\\u0007\\f\\f\\u0003\\u0002\\u000e\\u0011\\u0003\\u0002\\u0014\\u0017\",\n    \"\\u0003\\u0002\\u0018\\u0019\\u0003\\u0002\\u001b\\u001c\\u0003\\u0002\\u0012\\u0013\",\n    \"\\u0003\\u0002\\\"#\\u0003\\u0002)0\\u0003\\u000218\\u0005\\u0002\\u0012\\u0013\",\n    \"\\u0018\\u0019;<\\u0002\\u00ad\\u0002 \\u0003\\u0002\\u0002\\u0002\\u0004\\'\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0006[\\u0003\\u0002\\u0002\\u0002\\be\\u0003\\u0002\\u0002\",\n    \"\\u0002\\ng\\u0003\\u0002\\u0002\\u0002\\fq\\u0003\\u0002\\u0002\\u0002\\u000es\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0010z\\u0003\\u0002\\u0002\\u0002\\u0012\\u0082\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0014\\u0089\\u0003\\u0002\\u0002\\u0002\\u0016\\u008b\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0018\\u008d\\u0003\\u0002\\u0002\\u0002\\u001a\\u008f\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u001c\\u0091\\u0003\\u0002\\u0002\\u0002\\u001e\\u0099\",\n    \"\\u0003\\u0002\\u0002\\u0002 !\\u0005\\u0004\\u0003\\u0002!\\\"\\u0007\\u0002\\u0002\",\n    \"\\u0003\\\"\\u0003\\u0003\\u0002\\u0002\\u0002#$\\b\\u0003\\u0001\\u0002$(\\u0005\",\n    \"\\u0006\\u0004\\u0002%&\\t\\u0002\\u0002\\u0002&(\\u0005\\u0004\\u0003\\r\\'#\\u0003\",\n    \"\\u0002\\u0002\\u0002\\'%\\u0003\\u0002\\u0002\\u0002(Q\\u0003\\u0002\\u0002\\u0002\",\n    \")*\\f\\f\\u0002\\u0002*+\\t\\u0003\\u0002\\u0002+P\\u0005\\u0004\\u0003\\r,-\\f\\u000b\",\n    \"\\u0002\\u0002-.\\t\\u0004\\u0002\\u0002.P\\u0005\\u0004\\u0003\\f/0\\f\\n\\u0002\",\n    \"\\u000201\\u0007\\r\\u0002\\u00021P\\u0005\\u0004\\u0003\\u000b23\\f\\t\\u0002\\u0002\",\n    \"34\\t\\u0005\\u0002\\u00024P\\u0005\\u0004\\u0003\\n56\\f\\u0007\\u0002\\u00026\",\n    \"7\\t\\u0006\\u0002\\u00027P\\u0005\\u0004\\u0003\\b89\\f\\u0006\\u0002\\u00029:\",\n    \"\\t\\u0007\\u0002\\u0002:P\\u0005\\u0004\\u0003\\u0007;<\\f\\u0005\\u0002\\u0002\",\n    \"<=\\u0007\\u001a\\u0002\\u0002=P\\u0005\\u0004\\u0003\\u0006>?\\f\\u0004\\u0002\",\n    \"\\u0002?@\\t\\b\\u0002\\u0002@P\\u0005\\u0004\\u0003\\u0005AB\\f\\u0003\\u0002\\u0002\",\n    \"BC\\u0007\\u001d\\u0002\\u0002CP\\u0005\\u0004\\u0003\\u0004DE\\f\\u000f\\u0002\",\n    \"\\u0002EF\\u0007\\u0003\\u0002\\u0002FP\\u0005\\f\\u0007\\u0002GH\\f\\u000e\\u0002\",\n    \"\\u0002HI\\u0007\\u0004\\u0002\\u0002IJ\\u0005\\u0004\\u0003\\u0002JK\\u0007\\u0005\",\n    \"\\u0002\\u0002KP\\u0003\\u0002\\u0002\\u0002LM\\f\\b\\u0002\\u0002MN\\t\\t\\u0002\",\n    \"\\u0002NP\\u0005\\u001a\\u000e\\u0002O)\\u0003\\u0002\\u0002\\u0002O,\\u0003\\u0002\",\n    \"\\u0002\\u0002O/\\u0003\\u0002\\u0002\\u0002O2\\u0003\\u0002\\u0002\\u0002O5\\u0003\",\n    \"\\u0002\\u0002\\u0002O8\\u0003\\u0002\\u0002\\u0002O;\\u0003\\u0002\\u0002\\u0002\",\n    \"O>\\u0003\\u0002\\u0002\\u0002OA\\u0003\\u0002\\u0002\\u0002OD\\u0003\\u0002\\u0002\",\n    \"\\u0002OG\\u0003\\u0002\\u0002\\u0002OL\\u0003\\u0002\\u0002\\u0002PS\\u0003\\u0002\",\n    \"\\u0002\\u0002QO\\u0003\\u0002\\u0002\\u0002QR\\u0003\\u0002\\u0002\\u0002R\\u0005\",\n    \"\\u0003\\u0002\\u0002\\u0002SQ\\u0003\\u0002\\u0002\\u0002T\\\\\\u0005\\f\\u0007\",\n    \"\\u0002U\\\\\\u0005\\b\\u0005\\u0002V\\\\\\u0005\\n\\u0006\\u0002WX\\u0007\\u001e\\u0002\",\n    \"\\u0002XY\\u0005\\u0004\\u0003\\u0002YZ\\u0007\\u001f\\u0002\\u0002Z\\\\\\u0003\",\n    \"\\u0002\\u0002\\u0002[T\\u0003\\u0002\\u0002\\u0002[U\\u0003\\u0002\\u0002\\u0002\",\n    \"[V\\u0003\\u0002\\u0002\\u0002[W\\u0003\\u0002\\u0002\\u0002\\\\\\u0007\\u0003\\u0002\",\n    \"\\u0002\\u0002]^\\u0007 \\u0002\\u0002^f\\u0007!\\u0002\\u0002_f\\t\\n\\u0002\\u0002\",\n    \"`f\\u0007=\\u0002\\u0002af\\u0007>\\u0002\\u0002bf\\u00079\\u0002\\u0002cf\\u0007\",\n    \":\\u0002\\u0002df\\u0005\\u0012\\n\\u0002e]\\u0003\\u0002\\u0002\\u0002e_\\u0003\",\n    \"\\u0002\\u0002\\u0002e`\\u0003\\u0002\\u0002\\u0002ea\\u0003\\u0002\\u0002\\u0002\",\n    \"eb\\u0003\\u0002\\u0002\\u0002ec\\u0003\\u0002\\u0002\\u0002ed\\u0003\\u0002\\u0002\",\n    \"\\u0002f\\t\\u0003\\u0002\\u0002\\u0002gj\\u0007$\\u0002\\u0002hk\\u0005\\u001e\",\n    \"\\u0010\\u0002ik\\u0007=\\u0002\\u0002jh\\u0003\\u0002\\u0002\\u0002ji\\u0003\",\n    \"\\u0002\\u0002\\u0002k\\u000b\\u0003\\u0002\\u0002\\u0002lr\\u0005\\u001e\\u0010\",\n    \"\\u0002mr\\u0005\\u000e\\b\\u0002nr\\u0007%\\u0002\\u0002or\\u0007&\\u0002\\u0002\",\n    \"pr\\u0007\\'\\u0002\\u0002ql\\u0003\\u0002\\u0002\\u0002qm\\u0003\\u0002\\u0002\",\n    \"\\u0002qn\\u0003\\u0002\\u0002\\u0002qo\\u0003\\u0002\\u0002\\u0002qp\\u0003\\u0002\",\n    \"\\u0002\\u0002r\\r\\u0003\\u0002\\u0002\\u0002st\\u0005\\u001e\\u0010\\u0002tv\",\n    \"\\u0007\\u001e\\u0002\\u0002uw\\u0005\\u0010\\t\\u0002vu\\u0003\\u0002\\u0002\\u0002\",\n    \"vw\\u0003\\u0002\\u0002\\u0002wx\\u0003\\u0002\\u0002\\u0002xy\\u0007\\u001f\\u0002\",\n    \"\\u0002y\\u000f\\u0003\\u0002\\u0002\\u0002z\\u007f\\u0005\\u0004\\u0003\\u0002\",\n    \"{|\\u0007(\\u0002\\u0002|~\\u0005\\u0004\\u0003\\u0002}{\\u0003\\u0002\\u0002\",\n    \"\\u0002~\\u0081\\u0003\\u0002\\u0002\\u0002\\u007f}\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u007f\\u0080\\u0003\\u0002\\u0002\\u0002\\u0080\\u0011\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0081\\u007f\\u0003\\u0002\\u0002\\u0002\\u0082\\u0084\\u0007>\\u0002\\u0002\",\n    \"\\u0083\\u0085\\u0005\\u0014\\u000b\\u0002\\u0084\\u0083\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0084\\u0085\\u0003\\u0002\\u0002\\u0002\\u0085\\u0013\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0086\\u008a\\u0005\\u0016\\f\\u0002\\u0087\\u008a\\u0005\\u0018\\r\\u0002\\u0088\",\n    \"\\u008a\\u0007=\\u0002\\u0002\\u0089\\u0086\\u0003\\u0002\\u0002\\u0002\\u0089\",\n    \"\\u0087\\u0003\\u0002\\u0002\\u0002\\u0089\\u0088\\u0003\\u0002\\u0002\\u0002\\u008a\",\n    \"\\u0015\\u0003\\u0002\\u0002\\u0002\\u008b\\u008c\\t\\u000b\\u0002\\u0002\\u008c\",\n    \"\\u0017\\u0003\\u0002\\u0002\\u0002\\u008d\\u008e\\t\\f\\u0002\\u0002\\u008e\\u0019\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u008f\\u0090\\u0005\\u001c\\u000f\\u0002\\u0090\\u001b\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0091\\u0096\\u0005\\u001e\\u0010\\u0002\\u0092\\u0093\",\n    \"\\u0007\\u0003\\u0002\\u0002\\u0093\\u0095\\u0005\\u001e\\u0010\\u0002\\u0094\\u0092\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0095\\u0098\\u0003\\u0002\\u0002\\u0002\\u0096\\u0094\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0096\\u0097\\u0003\\u0002\\u0002\\u0002\\u0097\\u001d\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0098\\u0096\\u0003\\u0002\\u0002\\u0002\\u0099\\u009a\",\n    \"\\t\\r\\u0002\\u0002\\u009a\\u001f\\u0003\\u0002\\u0002\\u0002\\u000e\\'OQ[ejqv\",\n    \"\\u007f\\u0084\\u0089\\u0096\"].join(\"\");\n\n\nconst atn = new antlr4.atn.ATNDeserializer().deserialize(serializedATN);\n\nconst decisionsToDFA = atn.decisionToState.map( (ds, index) => new antlr4.dfa.DFA(ds, index) );\n\nconst sharedContextCache = new antlr4.PredictionContextCache();\n\nclass FHIRPathParser extends antlr4.Parser {\n\n    static grammarFileName = \"FHIRPath.g4\";\n    static literalNames = [ null, \"'.'\", \"'['\", \"']'\", \"'+'\", \"'-'\", \"'*'\", \n                            \"'/'\", \"'div'\", \"'mod'\", \"'&'\", \"'|'\", \"'<='\", \n                            \"'<'\", \"'>'\", \"'>='\", \"'is'\", \"'as'\", \"'='\", \n                            \"'~'\", \"'!='\", \"'!~'\", \"'in'\", \"'contains'\", \n                            \"'and'\", \"'or'\", \"'xor'\", \"'implies'\", \"'('\", \n                            \"')'\", \"'{'\", \"'}'\", \"'true'\", \"'false'\", \"'%'\", \n                            \"'$this'\", \"'$index'\", \"'$total'\", \"','\", \"'year'\", \n                            \"'month'\", \"'week'\", \"'day'\", \"'hour'\", \"'minute'\", \n                            \"'second'\", \"'millisecond'\", \"'years'\", \"'months'\", \n                            \"'weeks'\", \"'days'\", \"'hours'\", \"'minutes'\", \n                            \"'seconds'\", \"'milliseconds'\" ];\n    static symbolicNames = [ null, null, null, null, null, null, null, null, \n                             null, null, null, null, null, null, null, null, \n                             null, null, null, null, null, null, null, null, \n                             null, null, null, null, null, null, null, null, \n                             null, null, null, null, null, null, null, null, \n                             null, null, null, null, null, null, null, null, \n                             null, null, null, null, null, null, null, \"DATETIME\", \n                             \"TIME\", \"IDENTIFIER\", \"DELIMITEDIDENTIFIER\", \n                             \"STRING\", \"NUMBER\", \"WS\", \"COMMENT\", \"LINE_COMMENT\" ];\n    static ruleNames = [ \"entireExpression\", \"expression\", \"term\", \"literal\", \n                         \"externalConstant\", \"invocation\", \"functn\", \"paramList\", \n                         \"quantity\", \"unit\", \"dateTimePrecision\", \"pluralDateTimePrecision\", \n                         \"typeSpecifier\", \"qualifiedIdentifier\", \"identifier\" ];\n\n    constructor(input) {\n        super(input);\n        this._interp = new antlr4.atn.ParserATNSimulator(this, atn, decisionsToDFA, sharedContextCache);\n        this.ruleNames = FHIRPathParser.ruleNames;\n        this.literalNames = FHIRPathParser.literalNames;\n        this.symbolicNames = FHIRPathParser.symbolicNames;\n    }\n\n    get atn() {\n        return atn;\n    }\n\n    sempred(localctx, ruleIndex, predIndex) {\n    \tswitch(ruleIndex) {\n    \tcase 1:\n    \t    \t\treturn this.expression_sempred(localctx, predIndex);\n        default:\n            throw \"No predicate with index:\" + ruleIndex;\n       }\n    }\n\n    expression_sempred(localctx, predIndex) {\n    \tswitch(predIndex) {\n    \t\tcase 0:\n    \t\t\treturn this.precpred(this._ctx, 10);\n    \t\tcase 1:\n    \t\t\treturn this.precpred(this._ctx, 9);\n    \t\tcase 2:\n    \t\t\treturn this.precpred(this._ctx, 8);\n    \t\tcase 3:\n    \t\t\treturn this.precpred(this._ctx, 7);\n    \t\tcase 4:\n    \t\t\treturn this.precpred(this._ctx, 5);\n    \t\tcase 5:\n    \t\t\treturn this.precpred(this._ctx, 4);\n    \t\tcase 6:\n    \t\t\treturn this.precpred(this._ctx, 3);\n    \t\tcase 7:\n    \t\t\treturn this.precpred(this._ctx, 2);\n    \t\tcase 8:\n    \t\t\treturn this.precpred(this._ctx, 1);\n    \t\tcase 9:\n    \t\t\treturn this.precpred(this._ctx, 13);\n    \t\tcase 10:\n    \t\t\treturn this.precpred(this._ctx, 12);\n    \t\tcase 11:\n    \t\t\treturn this.precpred(this._ctx, 6);\n    \t\tdefault:\n    \t\t\tthrow \"No predicate with index:\" + predIndex;\n    \t}\n    };\n\n\n\n\n\tentireExpression() {\n\t    let localctx = new EntireExpressionContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 0, FHIRPathParser.RULE_entireExpression);\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 30;\n\t        this.expression(0);\n\t        this.state = 31;\n\t        this.match(FHIRPathParser.EOF);\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\texpression(_p) {\n\t\tif(_p===undefined) {\n\t\t    _p = 0;\n\t\t}\n\t    const _parentctx = this._ctx;\n\t    const _parentState = this.state;\n\t    let localctx = new ExpressionContext(this, this._ctx, _parentState);\n\t    let _prevctx = localctx;\n\t    const _startState = 2;\n\t    this.enterRecursionRule(localctx, 2, FHIRPathParser.RULE_expression, _p);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 37;\n\t        this._errHandler.sync(this);\n\t        switch(this._input.LA(1)) {\n\t        case FHIRPathParser.T__15:\n\t        case FHIRPathParser.T__16:\n\t        case FHIRPathParser.T__21:\n\t        case FHIRPathParser.T__22:\n\t        case FHIRPathParser.T__27:\n\t        case FHIRPathParser.T__29:\n\t        case FHIRPathParser.T__31:\n\t        case FHIRPathParser.T__32:\n\t        case FHIRPathParser.T__33:\n\t        case FHIRPathParser.T__34:\n\t        case FHIRPathParser.T__35:\n\t        case FHIRPathParser.T__36:\n\t        case FHIRPathParser.DATETIME:\n\t        case FHIRPathParser.TIME:\n\t        case FHIRPathParser.IDENTIFIER:\n\t        case FHIRPathParser.DELIMITEDIDENTIFIER:\n\t        case FHIRPathParser.STRING:\n\t        case FHIRPathParser.NUMBER:\n\t            localctx = new TermExpressionContext(this, localctx);\n\t            this._ctx = localctx;\n\t            _prevctx = localctx;\n\n\t            this.state = 34;\n\t            this.term();\n\t            break;\n\t        case FHIRPathParser.T__3:\n\t        case FHIRPathParser.T__4:\n\t            localctx = new PolarityExpressionContext(this, localctx);\n\t            this._ctx = localctx;\n\t            _prevctx = localctx;\n\t            this.state = 35;\n\t            _la = this._input.LA(1);\n\t            if(!(_la===FHIRPathParser.T__3 || _la===FHIRPathParser.T__4)) {\n\t            this._errHandler.recoverInline(this);\n\t            }\n\t            else {\n\t            \tthis._errHandler.reportMatch(this);\n\t                this.consume();\n\t            }\n\t            this.state = 36;\n\t            this.expression(11);\n\t            break;\n\t        default:\n\t            throw new antlr4.error.NoViableAltException(this);\n\t        }\n\t        this._ctx.stop = this._input.LT(-1);\n\t        this.state = 79;\n\t        this._errHandler.sync(this);\n\t        var _alt = this._interp.adaptivePredict(this._input,2,this._ctx)\n\t        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {\n\t            if(_alt===1) {\n\t                if(this._parseListeners!==null) {\n\t                    this.triggerExitRuleEvent();\n\t                }\n\t                _prevctx = localctx;\n\t                this.state = 77;\n\t                this._errHandler.sync(this);\n\t                var la_ = this._interp.adaptivePredict(this._input,1,this._ctx);\n\t                switch(la_) {\n\t                case 1:\n\t                    localctx = new MultiplicativeExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n\t                    this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n\t                    this.state = 39;\n\t                    if (!( this.precpred(this._ctx, 10))) {\n\t                        throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 10)\");\n\t                    }\n\t                    this.state = 40;\n\t                    _la = this._input.LA(1);\n\t                    if(!((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << FHIRPathParser.T__5) | (1 << FHIRPathParser.T__6) | (1 << FHIRPathParser.T__7) | (1 << FHIRPathParser.T__8))) !== 0))) {\n\t                    this._errHandler.recoverInline(this);\n\t                    }\n\t                    else {\n\t                    \tthis._errHandler.reportMatch(this);\n\t                        this.consume();\n\t                    }\n\t                    this.state = 41;\n\t                    this.expression(11);\n\t                    break;\n\n\t                case 2:\n\t                    localctx = new AdditiveExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n\t                    this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n\t                    this.state = 42;\n\t                    if (!( this.precpred(this._ctx, 9))) {\n\t                        throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 9)\");\n\t                    }\n\t                    this.state = 43;\n\t                    _la = this._input.LA(1);\n\t                    if(!((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << FHIRPathParser.T__3) | (1 << FHIRPathParser.T__4) | (1 << FHIRPathParser.T__9))) !== 0))) {\n\t                    this._errHandler.recoverInline(this);\n\t                    }\n\t                    else {\n\t                    \tthis._errHandler.reportMatch(this);\n\t                        this.consume();\n\t                    }\n\t                    this.state = 44;\n\t                    this.expression(10);\n\t                    break;\n\n\t                case 3:\n\t                    localctx = new UnionExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n\t                    this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n\t                    this.state = 45;\n\t                    if (!( this.precpred(this._ctx, 8))) {\n\t                        throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 8)\");\n\t                    }\n\t                    this.state = 46;\n\t                    this.match(FHIRPathParser.T__10);\n\t                    this.state = 47;\n\t                    this.expression(9);\n\t                    break;\n\n\t                case 4:\n\t                    localctx = new InequalityExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n\t                    this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n\t                    this.state = 48;\n\t                    if (!( this.precpred(this._ctx, 7))) {\n\t                        throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 7)\");\n\t                    }\n\t                    this.state = 49;\n\t                    _la = this._input.LA(1);\n\t                    if(!((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << FHIRPathParser.T__11) | (1 << FHIRPathParser.T__12) | (1 << FHIRPathParser.T__13) | (1 << FHIRPathParser.T__14))) !== 0))) {\n\t                    this._errHandler.recoverInline(this);\n\t                    }\n\t                    else {\n\t                    \tthis._errHandler.reportMatch(this);\n\t                        this.consume();\n\t                    }\n\t                    this.state = 50;\n\t                    this.expression(8);\n\t                    break;\n\n\t                case 5:\n\t                    localctx = new EqualityExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n\t                    this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n\t                    this.state = 51;\n\t                    if (!( this.precpred(this._ctx, 5))) {\n\t                        throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 5)\");\n\t                    }\n\t                    this.state = 52;\n\t                    _la = this._input.LA(1);\n\t                    if(!((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << FHIRPathParser.T__17) | (1 << FHIRPathParser.T__18) | (1 << FHIRPathParser.T__19) | (1 << FHIRPathParser.T__20))) !== 0))) {\n\t                    this._errHandler.recoverInline(this);\n\t                    }\n\t                    else {\n\t                    \tthis._errHandler.reportMatch(this);\n\t                        this.consume();\n\t                    }\n\t                    this.state = 53;\n\t                    this.expression(6);\n\t                    break;\n\n\t                case 6:\n\t                    localctx = new MembershipExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n\t                    this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n\t                    this.state = 54;\n\t                    if (!( this.precpred(this._ctx, 4))) {\n\t                        throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 4)\");\n\t                    }\n\t                    this.state = 55;\n\t                    _la = this._input.LA(1);\n\t                    if(!(_la===FHIRPathParser.T__21 || _la===FHIRPathParser.T__22)) {\n\t                    this._errHandler.recoverInline(this);\n\t                    }\n\t                    else {\n\t                    \tthis._errHandler.reportMatch(this);\n\t                        this.consume();\n\t                    }\n\t                    this.state = 56;\n\t                    this.expression(5);\n\t                    break;\n\n\t                case 7:\n\t                    localctx = new AndExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n\t                    this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n\t                    this.state = 57;\n\t                    if (!( this.precpred(this._ctx, 3))) {\n\t                        throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 3)\");\n\t                    }\n\t                    this.state = 58;\n\t                    this.match(FHIRPathParser.T__23);\n\t                    this.state = 59;\n\t                    this.expression(4);\n\t                    break;\n\n\t                case 8:\n\t                    localctx = new OrExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n\t                    this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n\t                    this.state = 60;\n\t                    if (!( this.precpred(this._ctx, 2))) {\n\t                        throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 2)\");\n\t                    }\n\t                    this.state = 61;\n\t                    _la = this._input.LA(1);\n\t                    if(!(_la===FHIRPathParser.T__24 || _la===FHIRPathParser.T__25)) {\n\t                    this._errHandler.recoverInline(this);\n\t                    }\n\t                    else {\n\t                    \tthis._errHandler.reportMatch(this);\n\t                        this.consume();\n\t                    }\n\t                    this.state = 62;\n\t                    this.expression(3);\n\t                    break;\n\n\t                case 9:\n\t                    localctx = new ImpliesExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n\t                    this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n\t                    this.state = 63;\n\t                    if (!( this.precpred(this._ctx, 1))) {\n\t                        throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 1)\");\n\t                    }\n\t                    this.state = 64;\n\t                    this.match(FHIRPathParser.T__26);\n\t                    this.state = 65;\n\t                    this.expression(2);\n\t                    break;\n\n\t                case 10:\n\t                    localctx = new InvocationExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n\t                    this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n\t                    this.state = 66;\n\t                    if (!( this.precpred(this._ctx, 13))) {\n\t                        throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 13)\");\n\t                    }\n\t                    this.state = 67;\n\t                    this.match(FHIRPathParser.T__0);\n\t                    this.state = 68;\n\t                    this.invocation();\n\t                    break;\n\n\t                case 11:\n\t                    localctx = new IndexerExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n\t                    this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n\t                    this.state = 69;\n\t                    if (!( this.precpred(this._ctx, 12))) {\n\t                        throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 12)\");\n\t                    }\n\t                    this.state = 70;\n\t                    this.match(FHIRPathParser.T__1);\n\t                    this.state = 71;\n\t                    this.expression(0);\n\t                    this.state = 72;\n\t                    this.match(FHIRPathParser.T__2);\n\t                    break;\n\n\t                case 12:\n\t                    localctx = new TypeExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n\t                    this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n\t                    this.state = 74;\n\t                    if (!( this.precpred(this._ctx, 6))) {\n\t                        throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 6)\");\n\t                    }\n\t                    this.state = 75;\n\t                    _la = this._input.LA(1);\n\t                    if(!(_la===FHIRPathParser.T__15 || _la===FHIRPathParser.T__16)) {\n\t                    this._errHandler.recoverInline(this);\n\t                    }\n\t                    else {\n\t                    \tthis._errHandler.reportMatch(this);\n\t                        this.consume();\n\t                    }\n\t                    this.state = 76;\n\t                    this.typeSpecifier();\n\t                    break;\n\n\t                } \n\t            }\n\t            this.state = 81;\n\t            this._errHandler.sync(this);\n\t            _alt = this._interp.adaptivePredict(this._input,2,this._ctx);\n\t        }\n\n\t    } catch( error) {\n\t        if(error instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = error;\n\t\t        this._errHandler.reportError(this, error);\n\t\t        this._errHandler.recover(this, error);\n\t\t    } else {\n\t\t    \tthrow error;\n\t\t    }\n\t    } finally {\n\t        this.unrollRecursionContexts(_parentctx)\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tterm() {\n\t    let localctx = new TermContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 4, FHIRPathParser.RULE_term);\n\t    try {\n\t        this.state = 89;\n\t        this._errHandler.sync(this);\n\t        switch(this._input.LA(1)) {\n\t        case FHIRPathParser.T__15:\n\t        case FHIRPathParser.T__16:\n\t        case FHIRPathParser.T__21:\n\t        case FHIRPathParser.T__22:\n\t        case FHIRPathParser.T__34:\n\t        case FHIRPathParser.T__35:\n\t        case FHIRPathParser.T__36:\n\t        case FHIRPathParser.IDENTIFIER:\n\t        case FHIRPathParser.DELIMITEDIDENTIFIER:\n\t            localctx = new InvocationTermContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 1);\n\t            this.state = 82;\n\t            this.invocation();\n\t            break;\n\t        case FHIRPathParser.T__29:\n\t        case FHIRPathParser.T__31:\n\t        case FHIRPathParser.T__32:\n\t        case FHIRPathParser.DATETIME:\n\t        case FHIRPathParser.TIME:\n\t        case FHIRPathParser.STRING:\n\t        case FHIRPathParser.NUMBER:\n\t            localctx = new LiteralTermContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 2);\n\t            this.state = 83;\n\t            this.literal();\n\t            break;\n\t        case FHIRPathParser.T__33:\n\t            localctx = new ExternalConstantTermContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 3);\n\t            this.state = 84;\n\t            this.externalConstant();\n\t            break;\n\t        case FHIRPathParser.T__27:\n\t            localctx = new ParenthesizedTermContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 4);\n\t            this.state = 85;\n\t            this.match(FHIRPathParser.T__27);\n\t            this.state = 86;\n\t            this.expression(0);\n\t            this.state = 87;\n\t            this.match(FHIRPathParser.T__28);\n\t            break;\n\t        default:\n\t            throw new antlr4.error.NoViableAltException(this);\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tliteral() {\n\t    let localctx = new LiteralContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 6, FHIRPathParser.RULE_literal);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.state = 99;\n\t        this._errHandler.sync(this);\n\t        var la_ = this._interp.adaptivePredict(this._input,4,this._ctx);\n\t        switch(la_) {\n\t        case 1:\n\t            localctx = new NullLiteralContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 1);\n\t            this.state = 91;\n\t            this.match(FHIRPathParser.T__29);\n\t            this.state = 92;\n\t            this.match(FHIRPathParser.T__30);\n\t            break;\n\n\t        case 2:\n\t            localctx = new BooleanLiteralContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 2);\n\t            this.state = 93;\n\t            _la = this._input.LA(1);\n\t            if(!(_la===FHIRPathParser.T__31 || _la===FHIRPathParser.T__32)) {\n\t            this._errHandler.recoverInline(this);\n\t            }\n\t            else {\n\t            \tthis._errHandler.reportMatch(this);\n\t                this.consume();\n\t            }\n\t            break;\n\n\t        case 3:\n\t            localctx = new StringLiteralContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 3);\n\t            this.state = 94;\n\t            this.match(FHIRPathParser.STRING);\n\t            break;\n\n\t        case 4:\n\t            localctx = new NumberLiteralContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 4);\n\t            this.state = 95;\n\t            this.match(FHIRPathParser.NUMBER);\n\t            break;\n\n\t        case 5:\n\t            localctx = new DateTimeLiteralContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 5);\n\t            this.state = 96;\n\t            this.match(FHIRPathParser.DATETIME);\n\t            break;\n\n\t        case 6:\n\t            localctx = new TimeLiteralContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 6);\n\t            this.state = 97;\n\t            this.match(FHIRPathParser.TIME);\n\t            break;\n\n\t        case 7:\n\t            localctx = new QuantityLiteralContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 7);\n\t            this.state = 98;\n\t            this.quantity();\n\t            break;\n\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\texternalConstant() {\n\t    let localctx = new ExternalConstantContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 8, FHIRPathParser.RULE_externalConstant);\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 101;\n\t        this.match(FHIRPathParser.T__33);\n\t        this.state = 104;\n\t        this._errHandler.sync(this);\n\t        switch(this._input.LA(1)) {\n\t        case FHIRPathParser.T__15:\n\t        case FHIRPathParser.T__16:\n\t        case FHIRPathParser.T__21:\n\t        case FHIRPathParser.T__22:\n\t        case FHIRPathParser.IDENTIFIER:\n\t        case FHIRPathParser.DELIMITEDIDENTIFIER:\n\t            this.state = 102;\n\t            this.identifier();\n\t            break;\n\t        case FHIRPathParser.STRING:\n\t            this.state = 103;\n\t            this.match(FHIRPathParser.STRING);\n\t            break;\n\t        default:\n\t            throw new antlr4.error.NoViableAltException(this);\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tinvocation() {\n\t    let localctx = new InvocationContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 10, FHIRPathParser.RULE_invocation);\n\t    try {\n\t        this.state = 111;\n\t        this._errHandler.sync(this);\n\t        var la_ = this._interp.adaptivePredict(this._input,6,this._ctx);\n\t        switch(la_) {\n\t        case 1:\n\t            localctx = new MemberInvocationContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 1);\n\t            this.state = 106;\n\t            this.identifier();\n\t            break;\n\n\t        case 2:\n\t            localctx = new FunctionInvocationContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 2);\n\t            this.state = 107;\n\t            this.functn();\n\t            break;\n\n\t        case 3:\n\t            localctx = new ThisInvocationContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 3);\n\t            this.state = 108;\n\t            this.match(FHIRPathParser.T__34);\n\t            break;\n\n\t        case 4:\n\t            localctx = new IndexInvocationContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 4);\n\t            this.state = 109;\n\t            this.match(FHIRPathParser.T__35);\n\t            break;\n\n\t        case 5:\n\t            localctx = new TotalInvocationContext(this, localctx);\n\t            this.enterOuterAlt(localctx, 5);\n\t            this.state = 110;\n\t            this.match(FHIRPathParser.T__36);\n\t            break;\n\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tfunctn() {\n\t    let localctx = new FunctnContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 12, FHIRPathParser.RULE_functn);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 113;\n\t        this.identifier();\n\t        this.state = 114;\n\t        this.match(FHIRPathParser.T__27);\n\t        this.state = 116;\n\t        this._errHandler.sync(this);\n\t        _la = this._input.LA(1);\n\t        if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << FHIRPathParser.T__3) | (1 << FHIRPathParser.T__4) | (1 << FHIRPathParser.T__15) | (1 << FHIRPathParser.T__16) | (1 << FHIRPathParser.T__21) | (1 << FHIRPathParser.T__22) | (1 << FHIRPathParser.T__27) | (1 << FHIRPathParser.T__29))) !== 0) || ((((_la - 32)) & ~0x1f) == 0 && ((1 << (_la - 32)) & ((1 << (FHIRPathParser.T__31 - 32)) | (1 << (FHIRPathParser.T__32 - 32)) | (1 << (FHIRPathParser.T__33 - 32)) | (1 << (FHIRPathParser.T__34 - 32)) | (1 << (FHIRPathParser.T__35 - 32)) | (1 << (FHIRPathParser.T__36 - 32)) | (1 << (FHIRPathParser.DATETIME - 32)) | (1 << (FHIRPathParser.TIME - 32)) | (1 << (FHIRPathParser.IDENTIFIER - 32)) | (1 << (FHIRPathParser.DELIMITEDIDENTIFIER - 32)) | (1 << (FHIRPathParser.STRING - 32)) | (1 << (FHIRPathParser.NUMBER - 32)))) !== 0)) {\n\t            this.state = 115;\n\t            this.paramList();\n\t        }\n\n\t        this.state = 118;\n\t        this.match(FHIRPathParser.T__28);\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tparamList() {\n\t    let localctx = new ParamListContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 14, FHIRPathParser.RULE_paramList);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 120;\n\t        this.expression(0);\n\t        this.state = 125;\n\t        this._errHandler.sync(this);\n\t        _la = this._input.LA(1);\n\t        while(_la===FHIRPathParser.T__37) {\n\t            this.state = 121;\n\t            this.match(FHIRPathParser.T__37);\n\t            this.state = 122;\n\t            this.expression(0);\n\t            this.state = 127;\n\t            this._errHandler.sync(this);\n\t            _la = this._input.LA(1);\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tquantity() {\n\t    let localctx = new QuantityContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 16, FHIRPathParser.RULE_quantity);\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 128;\n\t        this.match(FHIRPathParser.NUMBER);\n\t        this.state = 130;\n\t        this._errHandler.sync(this);\n\t        var la_ = this._interp.adaptivePredict(this._input,9,this._ctx);\n\t        if(la_===1) {\n\t            this.state = 129;\n\t            this.unit();\n\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tunit() {\n\t    let localctx = new UnitContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 18, FHIRPathParser.RULE_unit);\n\t    try {\n\t        this.state = 135;\n\t        this._errHandler.sync(this);\n\t        switch(this._input.LA(1)) {\n\t        case FHIRPathParser.T__38:\n\t        case FHIRPathParser.T__39:\n\t        case FHIRPathParser.T__40:\n\t        case FHIRPathParser.T__41:\n\t        case FHIRPathParser.T__42:\n\t        case FHIRPathParser.T__43:\n\t        case FHIRPathParser.T__44:\n\t        case FHIRPathParser.T__45:\n\t            this.enterOuterAlt(localctx, 1);\n\t            this.state = 132;\n\t            this.dateTimePrecision();\n\t            break;\n\t        case FHIRPathParser.T__46:\n\t        case FHIRPathParser.T__47:\n\t        case FHIRPathParser.T__48:\n\t        case FHIRPathParser.T__49:\n\t        case FHIRPathParser.T__50:\n\t        case FHIRPathParser.T__51:\n\t        case FHIRPathParser.T__52:\n\t        case FHIRPathParser.T__53:\n\t            this.enterOuterAlt(localctx, 2);\n\t            this.state = 133;\n\t            this.pluralDateTimePrecision();\n\t            break;\n\t        case FHIRPathParser.STRING:\n\t            this.enterOuterAlt(localctx, 3);\n\t            this.state = 134;\n\t            this.match(FHIRPathParser.STRING);\n\t            break;\n\t        default:\n\t            throw new antlr4.error.NoViableAltException(this);\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tdateTimePrecision() {\n\t    let localctx = new DateTimePrecisionContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 20, FHIRPathParser.RULE_dateTimePrecision);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 137;\n\t        _la = this._input.LA(1);\n\t        if(!(((((_la - 39)) & ~0x1f) == 0 && ((1 << (_la - 39)) & ((1 << (FHIRPathParser.T__38 - 39)) | (1 << (FHIRPathParser.T__39 - 39)) | (1 << (FHIRPathParser.T__40 - 39)) | (1 << (FHIRPathParser.T__41 - 39)) | (1 << (FHIRPathParser.T__42 - 39)) | (1 << (FHIRPathParser.T__43 - 39)) | (1 << (FHIRPathParser.T__44 - 39)) | (1 << (FHIRPathParser.T__45 - 39)))) !== 0))) {\n\t        this._errHandler.recoverInline(this);\n\t        }\n\t        else {\n\t        \tthis._errHandler.reportMatch(this);\n\t            this.consume();\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tpluralDateTimePrecision() {\n\t    let localctx = new PluralDateTimePrecisionContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 22, FHIRPathParser.RULE_pluralDateTimePrecision);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 139;\n\t        _la = this._input.LA(1);\n\t        if(!(((((_la - 47)) & ~0x1f) == 0 && ((1 << (_la - 47)) & ((1 << (FHIRPathParser.T__46 - 47)) | (1 << (FHIRPathParser.T__47 - 47)) | (1 << (FHIRPathParser.T__48 - 47)) | (1 << (FHIRPathParser.T__49 - 47)) | (1 << (FHIRPathParser.T__50 - 47)) | (1 << (FHIRPathParser.T__51 - 47)) | (1 << (FHIRPathParser.T__52 - 47)) | (1 << (FHIRPathParser.T__53 - 47)))) !== 0))) {\n\t        this._errHandler.recoverInline(this);\n\t        }\n\t        else {\n\t        \tthis._errHandler.reportMatch(this);\n\t            this.consume();\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\ttypeSpecifier() {\n\t    let localctx = new TypeSpecifierContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 24, FHIRPathParser.RULE_typeSpecifier);\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 141;\n\t        this.qualifiedIdentifier();\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tqualifiedIdentifier() {\n\t    let localctx = new QualifiedIdentifierContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 26, FHIRPathParser.RULE_qualifiedIdentifier);\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 143;\n\t        this.identifier();\n\t        this.state = 148;\n\t        this._errHandler.sync(this);\n\t        var _alt = this._interp.adaptivePredict(this._input,11,this._ctx)\n\t        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {\n\t            if(_alt===1) {\n\t                this.state = 144;\n\t                this.match(FHIRPathParser.T__0);\n\t                this.state = 145;\n\t                this.identifier(); \n\t            }\n\t            this.state = 150;\n\t            this._errHandler.sync(this);\n\t            _alt = this._interp.adaptivePredict(this._input,11,this._ctx);\n\t        }\n\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tidentifier() {\n\t    let localctx = new IdentifierContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 28, FHIRPathParser.RULE_identifier);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 151;\n\t        _la = this._input.LA(1);\n\t        if(!((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << FHIRPathParser.T__15) | (1 << FHIRPathParser.T__16) | (1 << FHIRPathParser.T__21) | (1 << FHIRPathParser.T__22))) !== 0) || _la===FHIRPathParser.IDENTIFIER || _la===FHIRPathParser.DELIMITEDIDENTIFIER)) {\n\t        this._errHandler.recoverInline(this);\n\t        }\n\t        else {\n\t        \tthis._errHandler.reportMatch(this);\n\t            this.consume();\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n}\n\nFHIRPathParser.EOF = antlr4.Token.EOF;\nFHIRPathParser.T__0 = 1;\nFHIRPathParser.T__1 = 2;\nFHIRPathParser.T__2 = 3;\nFHIRPathParser.T__3 = 4;\nFHIRPathParser.T__4 = 5;\nFHIRPathParser.T__5 = 6;\nFHIRPathParser.T__6 = 7;\nFHIRPathParser.T__7 = 8;\nFHIRPathParser.T__8 = 9;\nFHIRPathParser.T__9 = 10;\nFHIRPathParser.T__10 = 11;\nFHIRPathParser.T__11 = 12;\nFHIRPathParser.T__12 = 13;\nFHIRPathParser.T__13 = 14;\nFHIRPathParser.T__14 = 15;\nFHIRPathParser.T__15 = 16;\nFHIRPathParser.T__16 = 17;\nFHIRPathParser.T__17 = 18;\nFHIRPathParser.T__18 = 19;\nFHIRPathParser.T__19 = 20;\nFHIRPathParser.T__20 = 21;\nFHIRPathParser.T__21 = 22;\nFHIRPathParser.T__22 = 23;\nFHIRPathParser.T__23 = 24;\nFHIRPathParser.T__24 = 25;\nFHIRPathParser.T__25 = 26;\nFHIRPathParser.T__26 = 27;\nFHIRPathParser.T__27 = 28;\nFHIRPathParser.T__28 = 29;\nFHIRPathParser.T__29 = 30;\nFHIRPathParser.T__30 = 31;\nFHIRPathParser.T__31 = 32;\nFHIRPathParser.T__32 = 33;\nFHIRPathParser.T__33 = 34;\nFHIRPathParser.T__34 = 35;\nFHIRPathParser.T__35 = 36;\nFHIRPathParser.T__36 = 37;\nFHIRPathParser.T__37 = 38;\nFHIRPathParser.T__38 = 39;\nFHIRPathParser.T__39 = 40;\nFHIRPathParser.T__40 = 41;\nFHIRPathParser.T__41 = 42;\nFHIRPathParser.T__42 = 43;\nFHIRPathParser.T__43 = 44;\nFHIRPathParser.T__44 = 45;\nFHIRPathParser.T__45 = 46;\nFHIRPathParser.T__46 = 47;\nFHIRPathParser.T__47 = 48;\nFHIRPathParser.T__48 = 49;\nFHIRPathParser.T__49 = 50;\nFHIRPathParser.T__50 = 51;\nFHIRPathParser.T__51 = 52;\nFHIRPathParser.T__52 = 53;\nFHIRPathParser.T__53 = 54;\nFHIRPathParser.DATETIME = 55;\nFHIRPathParser.TIME = 56;\nFHIRPathParser.IDENTIFIER = 57;\nFHIRPathParser.DELIMITEDIDENTIFIER = 58;\nFHIRPathParser.STRING = 59;\nFHIRPathParser.NUMBER = 60;\nFHIRPathParser.WS = 61;\nFHIRPathParser.COMMENT = 62;\nFHIRPathParser.LINE_COMMENT = 63;\n\nFHIRPathParser.RULE_entireExpression = 0;\nFHIRPathParser.RULE_expression = 1;\nFHIRPathParser.RULE_term = 2;\nFHIRPathParser.RULE_literal = 3;\nFHIRPathParser.RULE_externalConstant = 4;\nFHIRPathParser.RULE_invocation = 5;\nFHIRPathParser.RULE_functn = 6;\nFHIRPathParser.RULE_paramList = 7;\nFHIRPathParser.RULE_quantity = 8;\nFHIRPathParser.RULE_unit = 9;\nFHIRPathParser.RULE_dateTimePrecision = 10;\nFHIRPathParser.RULE_pluralDateTimePrecision = 11;\nFHIRPathParser.RULE_typeSpecifier = 12;\nFHIRPathParser.RULE_qualifiedIdentifier = 13;\nFHIRPathParser.RULE_identifier = 14;\n\nclass EntireExpressionContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_entireExpression;\n    }\n\n\texpression() {\n\t    return this.getTypedRuleContext(ExpressionContext,0);\n\t};\n\n\tEOF() {\n\t    return this.getToken(FHIRPathParser.EOF, 0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterEntireExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitEntireExpression(this);\n\t\t}\n\t}\n\n\n}\n\n\n\nclass ExpressionContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_expression;\n    }\n\n\n\t \n\t\tcopyFrom(ctx) {\n\t\t\tsuper.copyFrom(ctx);\n\t\t}\n\n}\n\n\nclass IndexerExpressionContext extends ExpressionContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texpression = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(ExpressionContext);\n\t    } else {\n\t        return this.getTypedRuleContext(ExpressionContext,i);\n\t    }\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterIndexerExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitIndexerExpression(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.IndexerExpressionContext = IndexerExpressionContext;\n\nclass PolarityExpressionContext extends ExpressionContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texpression() {\n\t    return this.getTypedRuleContext(ExpressionContext,0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterPolarityExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitPolarityExpression(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.PolarityExpressionContext = PolarityExpressionContext;\n\nclass AdditiveExpressionContext extends ExpressionContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texpression = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(ExpressionContext);\n\t    } else {\n\t        return this.getTypedRuleContext(ExpressionContext,i);\n\t    }\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterAdditiveExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitAdditiveExpression(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.AdditiveExpressionContext = AdditiveExpressionContext;\n\nclass MultiplicativeExpressionContext extends ExpressionContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texpression = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(ExpressionContext);\n\t    } else {\n\t        return this.getTypedRuleContext(ExpressionContext,i);\n\t    }\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterMultiplicativeExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitMultiplicativeExpression(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.MultiplicativeExpressionContext = MultiplicativeExpressionContext;\n\nclass UnionExpressionContext extends ExpressionContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texpression = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(ExpressionContext);\n\t    } else {\n\t        return this.getTypedRuleContext(ExpressionContext,i);\n\t    }\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterUnionExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitUnionExpression(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.UnionExpressionContext = UnionExpressionContext;\n\nclass OrExpressionContext extends ExpressionContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texpression = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(ExpressionContext);\n\t    } else {\n\t        return this.getTypedRuleContext(ExpressionContext,i);\n\t    }\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterOrExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitOrExpression(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.OrExpressionContext = OrExpressionContext;\n\nclass AndExpressionContext extends ExpressionContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texpression = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(ExpressionContext);\n\t    } else {\n\t        return this.getTypedRuleContext(ExpressionContext,i);\n\t    }\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterAndExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitAndExpression(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.AndExpressionContext = AndExpressionContext;\n\nclass MembershipExpressionContext extends ExpressionContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texpression = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(ExpressionContext);\n\t    } else {\n\t        return this.getTypedRuleContext(ExpressionContext,i);\n\t    }\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterMembershipExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitMembershipExpression(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.MembershipExpressionContext = MembershipExpressionContext;\n\nclass InequalityExpressionContext extends ExpressionContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texpression = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(ExpressionContext);\n\t    } else {\n\t        return this.getTypedRuleContext(ExpressionContext,i);\n\t    }\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterInequalityExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitInequalityExpression(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.InequalityExpressionContext = InequalityExpressionContext;\n\nclass InvocationExpressionContext extends ExpressionContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texpression() {\n\t    return this.getTypedRuleContext(ExpressionContext,0);\n\t};\n\n\tinvocation() {\n\t    return this.getTypedRuleContext(InvocationContext,0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterInvocationExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitInvocationExpression(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.InvocationExpressionContext = InvocationExpressionContext;\n\nclass EqualityExpressionContext extends ExpressionContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texpression = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(ExpressionContext);\n\t    } else {\n\t        return this.getTypedRuleContext(ExpressionContext,i);\n\t    }\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterEqualityExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitEqualityExpression(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.EqualityExpressionContext = EqualityExpressionContext;\n\nclass ImpliesExpressionContext extends ExpressionContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texpression = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(ExpressionContext);\n\t    } else {\n\t        return this.getTypedRuleContext(ExpressionContext,i);\n\t    }\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterImpliesExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitImpliesExpression(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.ImpliesExpressionContext = ImpliesExpressionContext;\n\nclass TermExpressionContext extends ExpressionContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\tterm() {\n\t    return this.getTypedRuleContext(TermContext,0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterTermExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitTermExpression(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.TermExpressionContext = TermExpressionContext;\n\nclass TypeExpressionContext extends ExpressionContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texpression() {\n\t    return this.getTypedRuleContext(ExpressionContext,0);\n\t};\n\n\ttypeSpecifier() {\n\t    return this.getTypedRuleContext(TypeSpecifierContext,0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterTypeExpression(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitTypeExpression(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.TypeExpressionContext = TypeExpressionContext;\n\nclass TermContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_term;\n    }\n\n\n\t \n\t\tcopyFrom(ctx) {\n\t\t\tsuper.copyFrom(ctx);\n\t\t}\n\n}\n\n\nclass ExternalConstantTermContext extends TermContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texternalConstant() {\n\t    return this.getTypedRuleContext(ExternalConstantContext,0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterExternalConstantTerm(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitExternalConstantTerm(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.ExternalConstantTermContext = ExternalConstantTermContext;\n\nclass LiteralTermContext extends TermContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\tliteral() {\n\t    return this.getTypedRuleContext(LiteralContext,0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterLiteralTerm(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitLiteralTerm(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.LiteralTermContext = LiteralTermContext;\n\nclass ParenthesizedTermContext extends TermContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\texpression() {\n\t    return this.getTypedRuleContext(ExpressionContext,0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterParenthesizedTerm(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitParenthesizedTerm(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.ParenthesizedTermContext = ParenthesizedTermContext;\n\nclass InvocationTermContext extends TermContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\tinvocation() {\n\t    return this.getTypedRuleContext(InvocationContext,0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterInvocationTerm(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitInvocationTerm(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.InvocationTermContext = InvocationTermContext;\n\nclass LiteralContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_literal;\n    }\n\n\n\t \n\t\tcopyFrom(ctx) {\n\t\t\tsuper.copyFrom(ctx);\n\t\t}\n\n}\n\n\nclass TimeLiteralContext extends LiteralContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\tTIME() {\n\t    return this.getToken(FHIRPathParser.TIME, 0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterTimeLiteral(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitTimeLiteral(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.TimeLiteralContext = TimeLiteralContext;\n\nclass NullLiteralContext extends LiteralContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterNullLiteral(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitNullLiteral(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.NullLiteralContext = NullLiteralContext;\n\nclass DateTimeLiteralContext extends LiteralContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\tDATETIME() {\n\t    return this.getToken(FHIRPathParser.DATETIME, 0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterDateTimeLiteral(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitDateTimeLiteral(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.DateTimeLiteralContext = DateTimeLiteralContext;\n\nclass StringLiteralContext extends LiteralContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\tSTRING() {\n\t    return this.getToken(FHIRPathParser.STRING, 0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterStringLiteral(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitStringLiteral(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.StringLiteralContext = StringLiteralContext;\n\nclass BooleanLiteralContext extends LiteralContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterBooleanLiteral(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitBooleanLiteral(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.BooleanLiteralContext = BooleanLiteralContext;\n\nclass NumberLiteralContext extends LiteralContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\tNUMBER() {\n\t    return this.getToken(FHIRPathParser.NUMBER, 0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterNumberLiteral(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitNumberLiteral(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.NumberLiteralContext = NumberLiteralContext;\n\nclass QuantityLiteralContext extends LiteralContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\tquantity() {\n\t    return this.getTypedRuleContext(QuantityContext,0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterQuantityLiteral(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitQuantityLiteral(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.QuantityLiteralContext = QuantityLiteralContext;\n\nclass ExternalConstantContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_externalConstant;\n    }\n\n\tidentifier() {\n\t    return this.getTypedRuleContext(IdentifierContext,0);\n\t};\n\n\tSTRING() {\n\t    return this.getToken(FHIRPathParser.STRING, 0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterExternalConstant(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitExternalConstant(this);\n\t\t}\n\t}\n\n\n}\n\n\n\nclass InvocationContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_invocation;\n    }\n\n\n\t \n\t\tcopyFrom(ctx) {\n\t\t\tsuper.copyFrom(ctx);\n\t\t}\n\n}\n\n\nclass TotalInvocationContext extends InvocationContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterTotalInvocation(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitTotalInvocation(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.TotalInvocationContext = TotalInvocationContext;\n\nclass ThisInvocationContext extends InvocationContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterThisInvocation(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitThisInvocation(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.ThisInvocationContext = ThisInvocationContext;\n\nclass IndexInvocationContext extends InvocationContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterIndexInvocation(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitIndexInvocation(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.IndexInvocationContext = IndexInvocationContext;\n\nclass FunctionInvocationContext extends InvocationContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\tfunctn() {\n\t    return this.getTypedRuleContext(FunctnContext,0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterFunctionInvocation(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitFunctionInvocation(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.FunctionInvocationContext = FunctionInvocationContext;\n\nclass MemberInvocationContext extends InvocationContext {\n\n    constructor(parser, ctx) {\n        super(parser);\n        super.copyFrom(ctx);\n    }\n\n\tidentifier() {\n\t    return this.getTypedRuleContext(IdentifierContext,0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterMemberInvocation(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitMemberInvocation(this);\n\t\t}\n\t}\n\n\n}\n\nFHIRPathParser.MemberInvocationContext = MemberInvocationContext;\n\nclass FunctnContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_functn;\n    }\n\n\tidentifier() {\n\t    return this.getTypedRuleContext(IdentifierContext,0);\n\t};\n\n\tparamList() {\n\t    return this.getTypedRuleContext(ParamListContext,0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterFunctn(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitFunctn(this);\n\t\t}\n\t}\n\n\n}\n\n\n\nclass ParamListContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_paramList;\n    }\n\n\texpression = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(ExpressionContext);\n\t    } else {\n\t        return this.getTypedRuleContext(ExpressionContext,i);\n\t    }\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterParamList(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitParamList(this);\n\t\t}\n\t}\n\n\n}\n\n\n\nclass QuantityContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_quantity;\n    }\n\n\tNUMBER() {\n\t    return this.getToken(FHIRPathParser.NUMBER, 0);\n\t};\n\n\tunit() {\n\t    return this.getTypedRuleContext(UnitContext,0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterQuantity(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitQuantity(this);\n\t\t}\n\t}\n\n\n}\n\n\n\nclass UnitContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_unit;\n    }\n\n\tdateTimePrecision() {\n\t    return this.getTypedRuleContext(DateTimePrecisionContext,0);\n\t};\n\n\tpluralDateTimePrecision() {\n\t    return this.getTypedRuleContext(PluralDateTimePrecisionContext,0);\n\t};\n\n\tSTRING() {\n\t    return this.getToken(FHIRPathParser.STRING, 0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterUnit(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitUnit(this);\n\t\t}\n\t}\n\n\n}\n\n\n\nclass DateTimePrecisionContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_dateTimePrecision;\n    }\n\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterDateTimePrecision(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitDateTimePrecision(this);\n\t\t}\n\t}\n\n\n}\n\n\n\nclass PluralDateTimePrecisionContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_pluralDateTimePrecision;\n    }\n\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterPluralDateTimePrecision(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitPluralDateTimePrecision(this);\n\t\t}\n\t}\n\n\n}\n\n\n\nclass TypeSpecifierContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_typeSpecifier;\n    }\n\n\tqualifiedIdentifier() {\n\t    return this.getTypedRuleContext(QualifiedIdentifierContext,0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterTypeSpecifier(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitTypeSpecifier(this);\n\t\t}\n\t}\n\n\n}\n\n\n\nclass QualifiedIdentifierContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_qualifiedIdentifier;\n    }\n\n\tidentifier = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(IdentifierContext);\n\t    } else {\n\t        return this.getTypedRuleContext(IdentifierContext,i);\n\t    }\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterQualifiedIdentifier(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitQualifiedIdentifier(this);\n\t\t}\n\t}\n\n\n}\n\n\n\nclass IdentifierContext extends antlr4.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = FHIRPathParser.RULE_identifier;\n    }\n\n\tIDENTIFIER() {\n\t    return this.getToken(FHIRPathParser.IDENTIFIER, 0);\n\t};\n\n\tDELIMITEDIDENTIFIER() {\n\t    return this.getToken(FHIRPathParser.DELIMITEDIDENTIFIER, 0);\n\t};\n\n\tenterRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.enterIdentifier(this);\n\t\t}\n\t}\n\n\texitRule(listener) {\n\t    if(listener instanceof FHIRPathListener ) {\n\t        listener.exitIdentifier(this);\n\t\t}\n\t}\n\n\n}\n\n\n\n\nFHIRPathParser.EntireExpressionContext = EntireExpressionContext; \nFHIRPathParser.ExpressionContext = ExpressionContext; \nFHIRPathParser.TermContext = TermContext; \nFHIRPathParser.LiteralContext = LiteralContext; \nFHIRPathParser.ExternalConstantContext = ExternalConstantContext; \nFHIRPathParser.InvocationContext = InvocationContext; \nFHIRPathParser.FunctnContext = FunctnContext; \nFHIRPathParser.ParamListContext = ParamListContext; \nFHIRPathParser.QuantityContext = QuantityContext; \nFHIRPathParser.UnitContext = UnitContext; \nFHIRPathParser.DateTimePrecisionContext = DateTimePrecisionContext; \nFHIRPathParser.PluralDateTimePrecisionContext = PluralDateTimePrecisionContext; \nFHIRPathParser.TypeSpecifierContext = TypeSpecifierContext; \nFHIRPathParser.QualifiedIdentifierContext = QualifiedIdentifierContext; \nFHIRPathParser.IdentifierContext = IdentifierContext; \n\nmodule.exports = FHIRPathParser;","const antlr4 = require(\"./antlr4-index\");\nconst Lexer = require(\"./generated/FHIRPathLexer\");\nconst Parser = require(\"./generated/FHIRPathParser\");\nconst Listener = require(\"./generated/FHIRPathListener\");\n\n\nclass ErrorListener extends antlr4.error.ErrorListener {\n  constructor(errors) {\n    super();\n    this.errors = errors;\n  }\n  syntaxError(rec, sym, line, col, msg, e) {\n    this.errors.push([rec, sym, line, col, msg, e]);\n  }\n}\n\nvar parse = function(path){\n  var chars = new antlr4.InputStream(path);\n  var lexer = new Lexer(chars);\n\n  var tokens  = new antlr4.CommonTokenStream(lexer);\n\n\n  var parser = new Parser(tokens);\n  parser.buildParseTrees = true;\n  var errors = [];\n  var listener = new ErrorListener(errors);\n\n  lexer.removeErrorListeners();\n  lexer.addErrorListener(listener);\n  parser.removeErrorListeners();\n  parser.addErrorListener(listener);\n\n  var tree = parser.entireExpression();\n\n  class PathListener extends Listener{\n    constructor() {\n      super();\n    }\n  }\n\n  var ast = {};\n  var node;\n  var parentStack = [ast];\n  for (let p of Object.getOwnPropertyNames(Listener.prototype)) {\n    if (p.startsWith(\"enter\")) {\n      PathListener.prototype[p] = function(ctx) {\n        let parentNode = parentStack[parentStack.length - 1];\n        let nodeType = p.slice(5); // remove \"enter\"\n        node = {type: nodeType};\n        node.text = ctx.getText();\n        if (!parentNode.children)\n          parentNode.children = [];\n        parentNode.children.push(node);\n        parentStack.push(node);\n        // Also collect this node's terminal nodes, if any.  Terminal nodes are\n        // not walked with the rest of the tree, but include things like \"+\" and\n        // \"-\", which we need.\n        node.terminalNodeText = [];\n        for (let c of ctx.children) {\n          // Test for node type \"TerminalNodeImpl\".  Minimized code no longer\n          // has the original function names, so we can't rely on\n          // c.constructor.name.  It appears the TerminalNodeImpl is the only\n          // node with a \"symbol\" property, so test for that.\n          if (c.symbol)\n            node.terminalNodeText.push(c.getText());\n        }\n      };\n    }\n    else if (p.startsWith(\"exit\")) {\n      PathListener.prototype[p] = function() {\n        parentStack.pop();\n      };\n    }\n  }\n\n  var printer = new PathListener();\n  antlr4.tree.ParseTreeWalker.DEFAULT.walk(printer, tree);\n\n  if (errors.length > 0) {\n    let errMsgs = [];\n    for (let i=0, len=errors.length; i<len; ++i) {\n      let err = errors[i];\n      let msg = \"line: \"+err[2]+\"; column: \"+ err[3]+\"; message: \"+err[4];\n      errMsgs.push(msg);\n    }\n    var e = new Error(errMsgs.join(\"\\n\"));\n    e.errors = errors;\n    throw e;\n  }\n  return ast;\n};\n\n\nmodule.exports = {\n  parse: parse\n};\n","// Binding the function Array.prototype.slice.call for convert Array-like objects/collections to a new Array.\nconst slice = Function.prototype.call.bind(Array.prototype.slice);\n\n// isInteger (not in IE)\n// From Mozilla docs\nNumber.isInteger = Number.isInteger || function(value) {\n  return typeof value === 'number' &&\n    isFinite(value) &&\n    Math.floor(value) === value;\n};\n\n\nif (!String.prototype.startsWith) {\n  // From Mozilla docs with little changes\n  Object.defineProperty(String.prototype, 'startsWith', {\n    value: function(searchString, position) {\n      position = position || 0;\n      return this.indexOf(searchString, position) === position;\n    }\n  });\n}\n\nif (!String.prototype.endsWith) {\n  // From Mozilla docs with little changes\n  Object.defineProperty(String.prototype, 'endsWith', {\n    value: function(searchString, position) {\n      var subjectString = this.toString();\n      if (position === undefined || position > subjectString.length) {\n        position = subjectString.length;\n      }\n      position -= searchString.length;\n      var lastIndex = subjectString.indexOf(searchString, position);\n      return lastIndex !== -1 && lastIndex === position;\n    }\n  });\n}\n\nif (!String.prototype.includes) {\n  Object.defineProperty(String.prototype, 'includes', {\n    value: function() {\n      return this.indexOf.apply(this, arguments) !== -1;\n    }\n  });\n}\n\nif (!Object.assign) {\n  // From Mozilla docs with little changes\n  Object.defineProperty(Object, 'assign', {\n    value: function(target) {\n      if (target === undefined || target === null) {\n        throw new TypeError('Cannot convert undefined or null to object');\n      }\n\n      return slice(arguments, 1).reduce(function (to, nextSource) {\n        Object.keys(Object(nextSource)).forEach(function (nextKey) {\n          to[nextKey] = nextSource[nextKey];\n        });\n        return to;\n      },  Object(target));\n    }\n  });\n}","const util = require(\"./utilities\");\nconst misc = require(\"./misc\");\n\nconst engine = {};\n\n// Cache for rewritten RegExp patterns\nconst cachedRegExp = {};\n\n/**\n * Rewrites RegExp pattern to support single-line mode (dotAll) in IE11:\n * To do that we replace \".\" with \"[^]\" in source RegExp pattern,\n * except where \".\" is escaped or is inside unescaped [].\n * Another way to do the same is using package regexpu-core\n * or packages regjsparser/regjsgen.\n * @param {string} pattern - source RegExp pattern\n * @return {string}\n */\nfunction rewritePatternForDotAll(pattern) {\n  if (!cachedRegExp[pattern]) {\n    cachedRegExp[pattern] = pattern.replace(/\\./g, (_, offset, entirePattern) => {\n      // The preceding part of the string\n      const precedingPart = entirePattern.substr(0, offset);\n      // The preceding part of the string without escaped characters: '\\', '[' or ']'\n      const cleanPrecedingPart = precedingPart\n        .replace(/\\\\\\\\/g, '')\n        .replace(/\\\\[\\][]/g, '');\n      // Check if '.' is escaped\n      const escaped = cleanPrecedingPart[cleanPrecedingPart.length - 1] === '\\\\';\n      // The last index of unescaped '['\n      const lastIndexOfOpenBracket = cleanPrecedingPart.lastIndexOf('[');\n      // The last index of unescaped ']'\n      const lastIndexOfCloseBracket = cleanPrecedingPart.lastIndexOf(']');\n      return escaped ||\n      (lastIndexOfOpenBracket > lastIndexOfCloseBracket)\n        ? '.'\n        : '[^]';\n    });\n  }\n\n  return cachedRegExp[pattern];\n}\n\nengine.indexOf = function(coll, substr){\n  const str = misc.singleton(coll, 'String');\n  return util.isEmpty(substr) || util.isEmpty(str) ? [] : str.indexOf(substr);\n};\n\nengine.substring = function(coll, start, length){\n  const str = misc.singleton(coll, 'String');\n  if (util.isEmpty(str) || util.isEmpty(start) || start < 0 || start >= str.length) {\n    return  [];\n  }\n  if (length === undefined || util.isEmpty(length)) {\n    return str.substring(start);\n  }\n  return str.substring(start, start + length);\n};\n\nengine.startsWith = function(coll, prefix){\n  const str = misc.singleton(coll, 'String');\n  return util.isEmpty(prefix) || util.isEmpty(str) ? [] : str.startsWith(prefix);\n};\n\nengine.endsWith = function(coll, postfix) {\n  const str = misc.singleton(coll, 'String');\n  return util.isEmpty(postfix) || util.isEmpty(str) ? [] : str.endsWith(postfix);\n};\n\nengine.containsFn = function(coll, substr){\n  const str = misc.singleton(coll, 'String');\n  return util.isEmpty(substr) || util.isEmpty(str) ? [] : str.includes(substr);\n};\n\nengine.upper = function(coll){\n  const str = misc.singleton(coll, 'String');\n  return util.isEmpty(str) ? [] : str.toUpperCase();\n};\n\n\nengine.lower = function(coll){\n  const str = misc.singleton(coll, 'String');\n  return util.isEmpty(str) ? [] : str.toLowerCase();\n};\n\n// Check if dotAll is supported.\n// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/dotAll for details.\nconst dotAllIsSupported = (new RegExp('')).dotAll === false;\n\nif (dotAllIsSupported) {\n  engine.matches = function(coll, regex) {\n    const str = misc.singleton(coll, 'String');\n    if (util.isEmpty(regex) || util.isEmpty(str)) {\n      return [];\n    }\n    const reg = new RegExp(regex, 's');\n    return reg.test(str);\n  };\n} else {\n  engine.matches = function(coll, regex) {\n    const str = misc.singleton(coll, 'String');\n    if (util.isEmpty(regex) || util.isEmpty(str)) {\n      return [];\n    }\n    const reg = new RegExp(rewritePatternForDotAll(regex));\n    return reg.test(str);\n  };\n}\n\nengine.replace = function(coll, pattern, repl){\n  const str = misc.singleton(coll, 'String');\n  if (util.isEmpty(pattern) || util.isEmpty(repl) || util.isEmpty(str)) {\n    return [];\n  }\n  const reg = new RegExp(util.escapeStringForRegExp(pattern), 'g');\n  return str.replace(reg, repl);\n};\n\nengine.replaceMatches = function(coll, regex, repl){\n  const str = misc.singleton(coll, 'String');\n  if (util.isEmpty(regex) || util.isEmpty(repl) || util.isEmpty(str)) {\n    return [];\n  }\n  const reg = new RegExp(regex, 'g');\n  return str.replace(reg, repl);\n};\n\nengine.length = function(coll){\n  const str = misc.singleton(coll, 'String');\n  return util.isEmpty(str) ? [] : str.length;\n};\n\nengine.toChars = function(coll){\n  const str = misc.singleton(coll, 'String');\n  return util.isEmpty(str) ? [] : str.split('');\n};\n\nmodule.exports = engine;\n","const addMinutes = require('date-fns/add_minutes');\nconst ucumUtils = require('@lhncbc/ucum-lhc').UcumLhcUtils.getInstance();\nconst numbers = require('./numbers');\n\nconst ucumSystemUrl = 'http://unitsofmeasure.org';\nlet timeFormat =\n  '[0-9][0-9](\\\\:[0-9][0-9](\\\\:[0-9][0-9](\\\\.[0-9]+)?)?)?(Z|(\\\\+|-)[0-9][0-9]\\\\:[0-9][0-9])?';\nlet timeRE = new RegExp('^T?'+timeFormat+'$');\nlet dateTimeRE = new RegExp(\n  '^[0-9][0-9][0-9][0-9](-[0-9][0-9](-[0-9][0-9](T'+timeFormat+')?)?)?Z?$');\n// FHIR date/time regular expressions are slightly different.  For now, we will\n// stick with the FHIRPath regular expressions.\n//let fhirTimeRE = /([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\\.[0-9]+)?/;\n//let fhirDateTimeRE =\n///([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\\.[0-9]+)?(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?/;\n\n/**\n *   Class FP_Type is the superclass for FHIRPath types that required special\n *   handling.\n */\nclass FP_Type {\n  /**\n   *  Tests whether this object is equal to another.  Returns either true,\n   *  false, or undefined (where in the FHIRPath specification empty would be\n   *  returned).  The undefined return value indicates that the values were the\n   *  same to the shared precision, but that they had differnent levels of\n   *  precision.\n   */\n  equals(/* otherObj */) {\n    return false;\n  }\n\n  /**\n   *  Tests whether this object is equivalant to another.  Returns either true,\n   *  false, or undefined (where in the FHIRPath specification empty would be\n   *  returned).\n   */\n  equivalentTo(/* otherObj */) {\n    return false;\n  }\n\n  toString() {\n    return this.asStr ? this.asStr : super.toString();\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n\n  /**\n   *  Returns -1, 0, or 1 if this object is less then, equal to, or greater\n   *  than otherObj.\n   */\n  compare(/* otherObj */) {\n    throw 'Not implemented';\n  }\n}\n\n\n/**\n *  A class for Quantities.\n */\nclass FP_Quantity extends FP_Type {\n  constructor(value, unit) {\n    super();\n    this.asStr = value + ' ' + unit;\n    this.value = value;\n    this.unit = unit;\n  }\n\n  equals(otherQuantity) {\n    if (!(otherQuantity instanceof this.constructor)) {\n      return false;\n    }\n\n    if (this.unit === otherQuantity.unit) {\n      return numbers.isEqual(this.value, otherQuantity.value);\n    }\n\n    // Special year/month comparison case: 1 year = 12 month\n    const compareYearsAndMonths = this._compareYearsAndMonths(otherQuantity);\n    if (compareYearsAndMonths) {\n      return compareYearsAndMonths.isEqual;\n    }\n\n    // General comparison case\n    const thisQuantity = FP_Quantity.toUcumQuantity(this.value, this.unit),\n      normalizedOtherQuantity = FP_Quantity.toUcumQuantity(otherQuantity.value, otherQuantity.unit),\n      convResult = ucumUtils.convertUnitTo(normalizedOtherQuantity.unit, normalizedOtherQuantity.value, thisQuantity.unit);\n\n    if (convResult.status !== 'succeeded') {\n      return false;\n    }\n\n    return numbers.isEqual(thisQuantity.value, convResult.toVal);\n  }\n\n  equivalentTo(otherQuantity) {\n    if (!(otherQuantity instanceof this.constructor)) {\n      return false;\n    }\n\n    if (this.unit === otherQuantity.unit) {\n      return numbers.isEquivalent(this.value, otherQuantity.value);\n    }\n\n    const ucumUnitCode = FP_Quantity.getEquivalentUcumUnitCode(this.unit),\n      otherUcumUnitCode = FP_Quantity.getEquivalentUcumUnitCode(otherQuantity.unit),\n      convResult = ucumUtils.convertUnitTo(otherUcumUnitCode, otherQuantity.value, ucumUnitCode);\n\n    if (convResult.status !== 'succeeded') {\n      return false;\n    }\n\n    return numbers.isEquivalent(this.value, convResult.toVal);\n  }\n\n  /**\n   * If both quantities have one of these units: year or month,\n   * then a special case will apply; otherwise returns null.\n   * In the special case of comparison, the fact that 1 year = 12 months is used.\n   *\n   * Just note: in general, for a calendar duration:\n   * 1 year = 365 days\n   * 12 month = 12*30 days = 360 days\n   * so, 1 year != 12 month\n   * That's why this special case is needed\n   *\n   * @param {FP_Quantity} otherQuantity\n   * @return {null|{isEqual: boolean}}\n   * @private\n   */\n  _compareYearsAndMonths(otherQuantity) {\n    const magnitude1 = FP_Quantity._yearMonthConversionFactor[this.unit],\n      magnitude2 = FP_Quantity._yearMonthConversionFactor[otherQuantity.unit];\n\n    if ( magnitude1 && magnitude2) {\n      return {\n        isEqual: numbers.isEqual(this.value*magnitude1, otherQuantity.value*magnitude2)\n      };\n    }\n\n    return null;\n  }\n\n}\n\nconst  surroundingApostrophesRegex = /^'|'$/g;\n/**\n * Converts a FHIR path unit to a UCUM unit code by converting a calendar duration keyword to an equivalent UCUM unit code\n * or removing single quotes for a UCUM unit.\n * @param {string} unit\n * @return {string}\n */\nFP_Quantity.getEquivalentUcumUnitCode = function (unit) {\n  return FP_Quantity.mapTimeUnitsToUCUMCode[unit] || unit.replace(surroundingApostrophesRegex, '');\n};\n\n/**\n * Converts FHIR path value/unit to UCUM value/unit. Usable for comparison.\n * @param {number} value\n * @param {string} unit\n * @returns { {value: number, unit: string} }\n */\nFP_Quantity.toUcumQuantity = function (value, unit) {\n  const magnitude = FP_Quantity._calendarDuration2Seconds[unit];\n  if (magnitude) {\n    return {\n      value: magnitude * value,\n      unit: 's'\n    };\n  }\n\n  return {\n    value,\n    unit: unit.replace(surroundingApostrophesRegex, '')\n  };\n};\n\n\n/**\n * Converts FHIRPath value/unit to other FHIRPath value/unit.\n * @param {string} fromUnit\n * @param {number} value\n * @param {string} toUnit\n * @return {FP_Quantity|null}\n */\nFP_Quantity.convUnitTo = function (fromUnit, value, toUnit) {\n  // 1 Year <-> 12 Months\n  const fromYearMonthMagnitude = FP_Quantity._yearMonthConversionFactor[fromUnit],\n    toYearMonthMagnitude = FP_Quantity._yearMonthConversionFactor[toUnit];\n  if (fromYearMonthMagnitude && toYearMonthMagnitude) {\n    return new FP_Quantity( fromYearMonthMagnitude*value/toYearMonthMagnitude, toUnit);\n  }\n\n  const fromMagnitude = FP_Quantity._calendarDuration2Seconds[fromUnit],\n    toMagnitude = FP_Quantity._calendarDuration2Seconds[toUnit];\n\n  // To FHIR path calendar duration\n  if (toMagnitude) {\n    if (fromMagnitude) {\n      return new FP_Quantity( fromMagnitude*value/toMagnitude, toUnit);\n    } else {\n      const convResult = ucumUtils.convertUnitTo(fromUnit.replace(/^'|'$/g, ''), value, 's');\n\n      if (convResult.status === 'succeeded') {\n        return new FP_Quantity(convResult.toVal/toMagnitude, toUnit);\n      }\n    }\n  // To Ucum unit\n  } else {\n    const convResult = fromMagnitude ? ucumUtils.convertUnitTo('s', fromMagnitude*value, toUnit.replace(/^'|'$/g, ''))\n      : ucumUtils.convertUnitTo(fromUnit.replace(/^'|'$/g, ''), value, toUnit.replace(/^'|'$/g, ''));\n\n    if(convResult.status === 'succeeded') {\n      return new FP_Quantity(convResult.toVal, toUnit);\n    }\n  }\n\n  return null;\n};\n\n\n// Defines conversion factors for calendar durations\nFP_Quantity._calendarDuration2Seconds = {\n  'years': 365*24*60*60,\n  'months': 30*24*60*60,\n  'weeks': 7*24*60*60,\n  'days': 24*60*60,\n  'hours': 60*60,\n  'minutes': 60,\n  'seconds': 1,\n  'milliseconds': .001,\n  'year': 365*24*60*60,\n  'month': 30*24*60*60,\n  'week': 7*24*60*60,\n  'day': 24*60*60,\n  'hour': 60*60,\n  'minute': 60,\n  'second': 1,\n  'millisecond': .001\n};\n\n// Defines special case to compare years with months for calendar durations\nFP_Quantity._yearMonthConversionFactor = {\n  'years': 12,\n  'months': 1,\n  'year': 12,\n  'month': 1\n};\n\n/**\n *  Defines a map from time units that are supported for arithmetic (including\n *  some UCUM time based units) to FHIRPath time units.\n */\nFP_Quantity.arithmeticDurationUnits = {\n  'years': \"year\",\n  'months': \"month\",\n  'weeks': \"week\",\n  'days': \"day\",\n  'hours': \"hour\",\n  'minutes': \"minute\",\n  'seconds': \"second\",\n  'milliseconds': \"millisecond\",\n  'year': \"year\",\n  'month': \"month\",\n  'week': \"week\",\n  'day': \"day\",\n  'hour': \"hour\",\n  'minute': \"minute\",\n  'second': \"second\",\n  'millisecond': \"millisecond\",\n  \"'wk'\": \"week\",\n  \"'d'\": \"day\",\n  \"'h'\": \"hour\",\n  \"'min'\": \"minute\",\n  \"'s'\": \"second\",\n  \"'ms'\": \"millisecond\"\n};\n\n/**\n *  Defines a map from UCUM code to FHIRPath time units.\n */\nFP_Quantity.mapUCUMCodeToTimeUnits = {\n  'a': \"year\",\n  'mo': \"month\",\n  'wk': \"week\",\n  'd': \"day\",\n  'h': \"hour\",\n  'min': \"minute\",\n  's': \"second\",\n  'ms': \"millisecond\",\n};\n\n/**\n *  Defines a map from FHIRPath time units to UCUM code.\n */\nFP_Quantity.mapTimeUnitsToUCUMCode = Object.keys(FP_Quantity.mapUCUMCodeToTimeUnits)\n  .reduce(function (res, key) {\n    res[FP_Quantity.mapUCUMCodeToTimeUnits[key]] = key;\n    res[FP_Quantity.mapUCUMCodeToTimeUnits[key]+'s'] = key;\n    return res;\n  }, {});\n\nclass FP_TimeBase extends FP_Type {\n  constructor(timeStr) {\n    super();\n    this.asStr = timeStr;\n  }\n\n  /**\n   *  Adds a time-based quantity to this date/time.\n   * @param timeQuantity a quantity to be added to this date/time.  See the\n   *  FHIRPath specification for supported units.\n   */\n  plus(timeQuantity) {\n    const unit = timeQuantity.unit;\n    let timeUnit = FP_Quantity.arithmeticDurationUnits[unit];\n    if (!timeUnit) {\n      throw new Error('For date/time arithmetic, the unit of the quantity ' +\n        'must be one of the following time-based units: ' +\n        Object.keys(FP_Quantity.arithmeticDurationUnits));\n    }\n    const cls = this.constructor;\n    const unitPrecision = cls._timeUnitToDatePrecision[timeUnit];\n    if (unitPrecision === undefined) {\n      throw new Error('Unsupported unit for +.  The unit should be one of ' +\n        Object.keys(cls._timeUnitToDatePrecision).join(', ') + '.');\n    }\n    let qVal = timeQuantity.value;\n    const isTime = (cls === FP_Time);\n\n    // From the FHIRPath specification: \"For precisions above seconds, the\n    // decimal portion of the time-valued quantity is ignored, since date/time\n    // arithmetic above seconds is performed with calendar duration semantics.\"\n    if (isTime ? unitPrecision < 2 : unitPrecision < 5) {\n      qVal = Math.trunc(qVal);\n    }\n\n    // If the precision of the time quantity is higher than the precision of the\n    // date, we need to convert the time quantity to the precision of the date.\n    if (this._getPrecision() < unitPrecision) {\n      const neededUnit = cls._datePrecisionToTimeUnit[\n        this._getPrecision()];\n      if (neededUnit !== 'second') {\n        const newQuantity = FP_Quantity.convUnitTo(timeUnit, qVal, neededUnit);\n        timeUnit = newQuantity.unit;\n        qVal = Math.trunc(newQuantity.value);\n      }\n    }\n    const newDate = FP_TimeBase.timeUnitToAddFn[timeUnit](this._getDateObj(), qVal);\n    // newDate is a Date.  We need to make a string with the correct precision.\n    let precision = this._getPrecision();\n    if (isTime)\n      precision += 3; // based on dateTimeRE, not timeRE\n    let newDateStr = FP_DateTime.isoDateTime(newDate, precision);\n    if (isTime) {\n      // FP_Time just needs the time part of the string\n      newDateStr = newDateStr.slice(newDateStr.indexOf('T') + 1);\n    }\n\n    return new cls(newDateStr);\n  }\n\n\n  /**\n   *  Tests whether this object is equal to another.  Returns either true,\n   *  false, or undefined (where in the FHIRPath specification empty would be\n   *  returned).  The undefined return value indicates that the values were the\n   *  same to the shared precision, but that they had differnent levels of\n   *  precision.\n   * @param otherDateTime any sub-type of FP_TimeBase, but it should be the same\n   *  as the type of \"this\".\n   */\n  equals(otherDateTime) {\n    // From the 2019May ballot:\n    // For Date, DateTime and Time equality, the comparison is performed by\n    // considering each precision in order, beginning with years (or hours for\n    // time values), and respecting timezone offsets. If the values are the\n    // same, comparison proceeds to the next precision; if the values are\n    // different, the comparison stops and the result is false. If one input has\n    // a value for the precision and the other does not, the comparison stops\n    // and the result is empty ({ }); if neither input has a value for the\n    // precision, or the last precision has been reached, the comparison stops\n    // and the result is true.\n    // Note:  Per the spec above\n    //   2012-01 = 2012 //  empty\n    //   2012-01 = 2011 //  false\n    //   2012-01 ~ 2012 //  false\n    var rtn;\n    if (!(otherDateTime instanceof this.constructor))\n      rtn = false;\n    else {\n      var thisPrec  = this._getPrecision();\n      var otherPrec = otherDateTime._getPrecision();\n\n      if (thisPrec == otherPrec) {\n        rtn = this._getDateObj().getTime() == otherDateTime._getDateObj().getTime();\n      }\n      else {\n        // The dates are not equal, but decide whether to return empty or false.\n        var commonPrec  = thisPrec <= otherPrec ? thisPrec : otherPrec;\n        // Adjust for timezone offsets, if any, so they are at a common timezone\n        var thisUTCStr  = this._getDateObj().toISOString();\n        var otherUTCStr = otherDateTime._getDateObj().toISOString();\n\n        if (this.constructor === FP_Time) {\n          commonPrec += 3; // because we now have year, month, and day\n          thisPrec += 3;\n          otherPrec += 3;\n        }\n\n        // Now parse the strings and compare the adjusted time parts.\n        // Dates without time specify no timezone and should be treated as already normalized to UTC. So we do not adjust the timezone, as this would change the date\n        var thisAdj  = thisPrec > 2 ? (new FP_DateTime(thisUTCStr))._getTimeParts() : this._getTimeParts();\n        var otherAdj = otherPrec > 2 ? (new FP_DateTime(otherUTCStr))._getTimeParts() : otherDateTime._getTimeParts();\n\n        for (var i = 0; i <= commonPrec && rtn !== false; ++i) {\n          rtn = thisAdj[i] == otherAdj[i];\n        }\n        // if rtn is still true, then return empty to indicate the difference in\n        // precision.\n        if (rtn)\n          rtn = undefined;\n      }\n    }\n    // else return undefined (empty)\n    return rtn;\n  }\n\n\n  /**\n   *  Tests whether this object is equivalant to another.  Returns either true\n   *  or false.\n   */\n  equivalentTo(otherDateTime) {\n    var rtn = otherDateTime instanceof this.constructor;\n    if (rtn) {\n      var thisPrec = this._getPrecision();\n      var otherPrec = otherDateTime._getPrecision();\n      rtn = thisPrec == otherPrec;\n      if (rtn) {\n        rtn = this._getDateObj().getTime() ==\n          otherDateTime._getDateObj().getTime();\n      }\n    }\n    return rtn;\n  }\n\n\n  /**\n   *  Returns a number less than 0, equal to 0 or greater than 0\n   *  if this (date) time is less than, equal to, or greater than otherTime.\n   *  Comparisons are made at the lesser of the two time precisions.\n   *  @param {FP_TimeBase} otherTime\n   *  @return {number}\n   */\n  compare(otherTime) {\n    var thisPrecision = this._getPrecision();\n    var otherPrecision = otherTime._getPrecision();\n    var thisTimeInt = thisPrecision <= otherPrecision ?\n      this._getDateObj().getTime(): this._dateAtPrecision(otherPrecision).getTime();\n    var otherTimeInt = otherPrecision <= thisPrecision ?\n      otherTime._getDateObj().getTime(): otherTime._dateAtPrecision(thisPrecision).getTime();\n    if (thisPrecision !== otherPrecision && thisTimeInt === otherTimeInt) {\n      return null;\n    }\n    return thisTimeInt - otherTimeInt;\n  }\n\n\n  /**\n   *  Returns a number representing the precision of the time string given to\n   *  the constructor.  (Higher means more precise).  The number is the number\n   *  of components of the time string (ignoring the time zone) produced by\n   *  matching against the time regular expression, except that milliseconds\n   *  and seconds are counted together as a single of level of precision.\n   *  @return {number}\n   */\n  _getPrecision() {\n    if (this.precision === undefined)\n      this._getMatchData();\n    return this.precision;\n  }\n\n  /**\n   *  Returns the match data from matching the given RegExp against the\n   *  date/time string given to the constructor.\n   *  Also sets this.precision.\n   * @param regEx The regular expression to match against the date/time string.\n   * @param maxPrecision the maximum precision possible for the type\n   */\n  _getMatchData(regEx, maxPrecision) {\n    if (this.timeMatchData === undefined) {\n      this.timeMatchData = this.asStr.match(regEx);\n      if (this.timeMatchData) {\n        for (let i=maxPrecision; i>=0 && this.precision === undefined; --i) {\n          if (this.timeMatchData[i])\n            this.precision = i;\n        }\n      }\n    }\n    return this.timeMatchData;\n  }\n\n  /**\n   *  Returns an array of the pieces of the given time string, for use in\n   *  constructing lower precision versions of the time. The returned array will\n   *  contain separate elements for the hour, minutes, seconds, and milliseconds\n   *  (or as many of those are as present).  The length of the returned array\n   *  will therefore be an indication of the precision.\n   *  It will not include the timezone.\n   * @timeMatchData the result of matching the time portion of the string passed\n   *  into the constructor against the \"timeRE\" regular expression.\n   */\n  _getTimeParts(timeMatchData) {\n    var timeParts = [];\n    // Finish parsing the data into pieces, for later use in building\n    // lower-precision versions of the date if needed.\n    timeParts = [timeMatchData[0]];\n    var timeZone = timeMatchData[4];\n    if (timeZone) { // remove time zone from hours\n      let hours = timeParts[0];\n      timeParts[0] = hours.slice(0, hours.length-timeZone.length);\n    }\n    var min = timeMatchData[1];\n    if (min) { // remove minutes from hours\n      let hours = timeParts[0];\n      timeParts[0] = hours.slice(0, hours.length-min.length);\n      timeParts[1] = min;\n      var sec = timeMatchData[2];\n      if (sec) { // remove seconds from minutes\n        timeParts[1] = min.slice(0, min.length-sec.length);\n        timeParts[2] = sec;\n        var ms = timeMatchData[3];\n        if (ms) { // remove milliseconds from seconds\n          timeParts[2] = sec.slice(0, sec.length-ms.length);\n          timeParts[3] = ms;\n        }\n      }\n    }\n    return timeParts;\n  }\n\n\n  /**\n   *  Returns a date object representing this time on a certain date.\n   */\n  _getDateObj() {\n    if (!this.dateObj) {\n      var precision = this._getPrecision();\n      // We cannot directly pass the string into the date constructor because\n      // (1) we don't want to introduce a time-dependent system date and (2) the\n      // time string might not have contained minutes, which are required by the\n      // Date constructor.\n      this.dateObj = this._dateAtPrecision(precision);\n    }\n    return this.dateObj;\n  }\n\n\n  /**\n   *  Creates a date object for the given timezone.  The returned date object\n   *  will have the specified date and time in the specified timezone.\n   * @param year...ms Just as in the Date constructor.\n   * @param timezoneOffset (optional) a string in the format (+-)HH:mm or Z, representing the\n   *  timezone offset.  If not provided, the local timzone will be assumed (as the\n   *  Date constructor does).\n   */\n  _createDate(year, month, day, hour, minutes, seconds, ms, timezoneOffset) {\n    var d = new Date(year, month, day, hour, minutes, seconds, ms);\n    if (timezoneOffset) {\n      // d is in local time.  Adjust for the timezone offset.\n      // First adjust the date by the timezone offset before reducing its\n      // precision.  Otherwise,\n      // @2018-11-01T-04:00 < @2018T-05:00\n      var localTimezoneMinutes = d.getTimezoneOffset();\n      var timezoneMinutes = 0; // if Z\n      if (timezoneOffset != 'Z') {\n        var timezoneParts = timezoneOffset.split(':'); // (+-)hours:minutes\n        var hours = parseInt(timezoneParts[0]);\n        timezoneMinutes = parseInt(timezoneParts[1]);\n        if (hours < 0)\n          timezoneMinutes = -timezoneMinutes;\n        timezoneMinutes += 60*hours;\n      }\n      // localTimezoneMinutes has the inverse sign of its timezone offset\n      d = addMinutes(d, -localTimezoneMinutes-timezoneMinutes);\n    }\n    return d;\n  }\n}\n\n/**\n *  A map from a FHIRPath time units to a function used to add that\n *  quantity to a date/time.\n */\nFP_TimeBase.timeUnitToAddFn = {\n  \"year\": require('date-fns/add_years'),\n  \"month\": require('date-fns/add_months'),\n  \"week\": require('date-fns/add_weeks'),\n  \"day\": require('date-fns/add_days'),\n  \"hour\": require('date-fns/add_hours'),\n  \"minute\": require('date-fns/add_minutes'),\n  \"second\": require('date-fns/add_seconds'),\n  \"millisecond\": require('date-fns/add_milliseconds')\n};\n\n\nclass FP_DateTime extends FP_TimeBase {\n  /**\n   *  Constructs an FP_DateTime, assuming dateStr is valid.  If you don't know\n   *  whether a string is a valid DateTime, use FP_DateTime.checkString instead.\n   */\n  constructor(dateStr) {\n    super(dateStr);\n  }\n\n\n  /**\n   *  Returns -1, 0, or 1 if this date time is less then, equal to, or greater\n   *  than otherDateTime.  Comparisons are made at the lesser of the two date time\n   *  precisions.\n   */\n  compare(otherDateTime) {\n    if (!(otherDateTime instanceof FP_DateTime))\n      throw 'Invalid comparison of a DateTime with something else';\n    return super.compare(otherDateTime);\n  }\n\n\n  /**\n   *  Returns the match data from matching dateTimeRE against the datetime string.\n   *  Also sets this.precision.\n   */\n  _getMatchData() {\n    return super._getMatchData(dateTimeRE, 5);\n  }\n\n  /**\n   *  Returns an array of the pieces of the date time string passed into the\n   *  constructor, for use in constructing lower precision versions of the\n   *  date time. The returned array will contain separate elements for the year,\n   *  month, day, hour, minutes, seconds, and milliseconds (or as many of those\n   *  are as present).  The length of the returned array will therefore be an\n   *  indication of the precision.  It will not include the timezone.\n   */\n  _getTimeParts() {\n    if (!this.timeParts) {\n      let timeMatchData =  this._getMatchData();\n      let year = timeMatchData[0];\n      this.timeParts = [year];\n      var month = timeMatchData[1];\n      if (month) { // Remove other information from year\n        this.timeParts[0] = year.slice(0, year.length-month.length);\n        this.timeParts[1] = month;\n        let day = timeMatchData[2];\n        if (day) { // Remove day information from month\n          this.timeParts[1] = month.slice(0, month.length-day.length);\n          this.timeParts[2] = day;\n          let time = timeMatchData[3];\n          if (time) { // Remove time from day\n            this.timeParts[2] = day.slice(0, day.length-time.length);\n            if (time[0] === 'T') // remove T from hour\n              timeMatchData[3] = time.slice(1);\n            this.timeParts = this.timeParts.concat(\n              super._getTimeParts(timeMatchData.slice(3)));\n          }\n        }\n      }\n    }\n    return this.timeParts;\n  }\n\n\n  /**\n   *  Returns a new Date object for a time equal to what this time would be if\n   *  the string passed into the constructor had the given precision.\n   * @param precision the new precision, which is assumed to be less than\n   *  or equal to the current precision.\n   */\n  _dateAtPrecision(precision) {\n    var timeParts = this._getTimeParts();\n    var timezoneOffset = this._getMatchData()[7];\n    // Get the date object first at the current precision.\n    var thisPrecision = this._getPrecision();\n    var year = parseInt(timeParts[0]);\n    var month = thisPrecision > 0 ? parseInt(timeParts[1].slice(1)) - 1 : 0;\n    var day = thisPrecision > 1 ? parseInt(timeParts[2].slice(1)) : 1;\n    var hour = thisPrecision > 2 ? parseInt(timeParts[3]) : 0;\n    var minutes = thisPrecision > 3 ? parseInt(timeParts[4].slice(1)): 0;\n    var seconds = thisPrecision > 4 ? parseInt(timeParts[5].slice(1)): 0;\n    var ms = timeParts.length > 6 ? parseInt(timeParts[6].slice(1)): 0;\n    var d = this._createDate(year, month, day, hour, minutes, seconds, ms,\n      timezoneOffset);\n    if (precision < thisPrecision) {\n      // Adjust the precision\n      year = d.getFullYear();\n      month = precision > 0 ? d.getMonth() : 0;\n      day = precision > 1 ? d.getDate() : 1;\n      hour = precision > 2 ? d.getHours() : 0;\n      minutes = precision > 3 ? d.getMinutes(): 0;\n      // Here the precision will always be less than the maximum\n      // due to the condition in the if statement: \"precision < thisPrecision\"\n      d = new Date(year, month, day, hour, minutes);\n    }\n    return d;\n  }\n}\n\n/**\n *  Tests str to see if it is convertible to a DateTime.\n * @return If str is convertible to a DateTime, returns an FP_DateTime;\n *  otherwise returns null.\n */\nFP_DateTime.checkString = function(str) {\n  let d = new FP_DateTime(str);\n  if (!d._getMatchData())\n    d = null;\n  return d;\n};\n\n/**\n *  A map from FHIRPath time units to the internal DateTime \"precision\" number.\n */\nFP_DateTime._timeUnitToDatePrecision = {\n  \"year\": 0,\n  \"month\": 1,\n  \"week\": 2, // wk is just 7*d\n  \"day\": 2,\n  \"hour\": 3,\n  \"minute\": 4,\n  \"second\": 5,\n  \"millisecond\": 6\n};\n\n/**\n *  The inverse of _timeUnitToDatePrecision.\n */\nFP_DateTime._datePrecisionToTimeUnit = [\n  \"year\", \"month\", \"day\", \"hour\", \"minute\", \"second\", \"millisecond\"\n];\n\n\n\nclass FP_Time extends FP_TimeBase {\n  /**\n   *  Constructs an FP_Time, assuming dateStr is valid.  If you don't know\n   *  whether a string is a valid DateTime, use FP_Time.checkString instead.\n   */\n  constructor(timeStr) {\n    if (timeStr[0] == 'T')\n      timeStr = timeStr.slice(1);\n    super(timeStr);\n  }\n\n\n  /**\n   *  Returns -1, 0, or 1 if this time is less then, equal to, or greater\n   *  than otherTime.  Comparisons are made at the lesser of the two time\n   *  precisions.\n   */\n  compare(otherTime) {\n    if (!(otherTime instanceof FP_Time))\n      throw 'Invalid comparison of a time with something else';\n    return super.compare(otherTime);\n  }\n\n\n  /**\n   *  Returns a new Date object for a time equal to what this time would be if\n   *  the string passed into the constructor had the given precision.\n   *  The \"date\" portion of the returned Date object is not meaningful, and\n   *  should be ignored.\n   * @param precision the new precision, which is assumed to be less than the\n   *  or equal to the current precision.  A precision of 0 means the hour.\n   */\n  _dateAtPrecision(precision) {\n    var timeParts = this._getTimeParts();\n    var timezoneOffset = this._getMatchData()[4];\n    // Get the date object first at the current precision.\n    var thisPrecision = this._getPrecision();\n    var year = 2010; // Have to pick some year for the date object\n    var month = 0;\n    var day = 1;\n    var hour = parseInt(timeParts[0]);\n    var minutes = thisPrecision > 0 ? parseInt(timeParts[1].slice(1)): 0;\n    var seconds = thisPrecision > 1 ? parseInt(timeParts[2].slice(1)): 0;\n    var ms = timeParts.length > 3 ? parseInt(timeParts[3].slice(1)): 0;\n    var d = this._createDate(year, month, day, hour, minutes, seconds, ms,\n      timezoneOffset);\n    if (timezoneOffset) {\n      // Keep the date the same (in the local timezone), so it is not a relevant\n      // factor when comparing different times.\n      d.setYear(year);\n      d.setMonth(month);\n      d.setDate(day);\n    }\n    if (precision < thisPrecision) {\n      // Adjust the precision\n      hour = d.getHours();\n      minutes = precision > 0 ? d.getMinutes(): 0;\n      // Here the precision will always be less than the maximum\n      // due to the condition in the if statement: \"precision < thisPrecision\"\n      d = new Date(year, month, day, hour, minutes);\n    }\n    return d;\n  }\n\n\n  /**\n   *  Returns the match data from matching timeRE against the time string.\n   *  Also sets this.precision.\n   */\n  _getMatchData() {\n    return super._getMatchData(timeRE, 2);\n  }\n\n  /**\n   *  Returns an array of the pieces of the time string passed into the\n   *  constructor, for use in constructing lower precision versions of the\n   *  time. The returned array will contain separate elements for the hour,\n   *  minutes, seconds, and milliseconds (or as many of those are as present).\n   *  The length of the returned array will therefore be an indication of the\n   *  precision.  It will not include the timezone.\n   */\n  _getTimeParts() {\n    if (!this.timeParts) {\n      this.timeParts = super._getTimeParts(this._getMatchData());\n    }\n    return this.timeParts;\n  }\n}\n\n/**\n *  Tests str to see if it is convertible to a Time.\n * @return If str is convertible to a Time, returns an FP_Time;\n *  otherwise returns null.\n */\nFP_Time.checkString = function(str) {\n  let d = new FP_Time(str);\n  if (!d._getMatchData())\n    d = null;\n  return d;\n};\n\n/**\n *  A map from FHIRPath time units to the internal DateTime \"precision\" number.\n */\nFP_Time._timeUnitToDatePrecision = {\n  \"hour\": 0,\n  \"minute\": 1,\n  \"second\": 2,\n  \"millisecond\": 3\n};\n\n/**\n *  The inverse of _timeUnitToDatePrecision.\n */\nFP_Time._datePrecisionToTimeUnit = [\"hour\", \"minute\", \"second\", \"millisecond\"];\n\n\n/**\n *  Returns either the given number or a string with the number prefixed by\n *  zeros if the given number is less than the given length.\n * @param num the nubmer to format\n * @param len the number of returned digits.  For now this must either be 2 or\n *  3. (Optional-- default is 2).\n */\nfunction formatNum(num, len) {\n  // Could use String.repeat, but that requires convertin num to an string first\n  // to get its length.  This might be slightly faster given that we only need 2\n  // or three 3 digit return values.\n  var rtn = num;\n  if (len === 3 && num < 100)\n    rtn = '0' + num;\n  if (num < 10)\n    rtn = '0' + rtn;\n  return rtn;\n}\n\n\n/**\n *  Formats the given date object into an ISO8601 datetime string, expressing it\n *  in the local timezone.\n * @date the date to format\n * @precision the precision at which to terminate string string.  (This is\n *  optional). If present, it will be an integer into the matching components of\n *  dateTimeRE.\n * @return a string in ISO8601 format.\n */\nFP_DateTime.isoDateTime = function(date, precision) {\n  if (precision === undefined)\n    precision = 5; // maximum\n  // YYYY-MM-DDTHH:mm:ss.sss[+-]HH:mm\n  // Note:  Date.toISOString sets the timezone at 'Z', which I did not want.\n  // Actually, I wanted to keep the original timezone given in the constructor,\n  // but that is difficult due to daylight savings time changes.  (For instance,\n  // if you add 6 months, the timezone offset could change).\n  var rtn = '' + date.getFullYear();\n  if (precision > 0) {\n    rtn += '-' + formatNum(date.getMonth() + 1);\n    if (precision > 1) {\n      rtn += '-' + formatNum(date.getDate());\n      if (precision > 2) {\n        rtn += 'T' + FP_DateTime.isoTime(date, precision - 3);\n      }\n    }\n  }\n  // FHIRPath STU1 does not allow a timezone offset on a dateTime that does not\n  // have a time part (except that the grammar allows 'Z', which is\n  // inconsistent).\n  if (precision > 2) {\n    // Note:  getTimezoneoffset returns the offset for the local system at the\n    // given date.\n    var tzOffset = date.getTimezoneOffset();\n    // tzOffset is a number of minutes, and is positive for negative timezones,\n    // and negative for positive timezones.\n    var tzSign = tzOffset < 0 ? '+' : '-';\n    tzOffset = Math.abs(tzOffset);\n    var tzMin = tzOffset % 60;\n    var tzHour = (tzOffset - tzMin) / 60;\n    rtn += tzSign + formatNum(tzHour) + ':' + formatNum(tzMin);\n  }\n  return rtn;\n};\n\n\n/**\n *  Returns a date string in ISO format at the given precision level.\n * @date the date to format\n * @precision the precision at which to terminate string.  (This is\n *  optional). If present, it will be an integer into the matching components of\n *  dateTimeRE.\n * @return a string in ISO8601 format.\n */\nFP_DateTime.isoDate = function(date, precision) {\n  if (precision === undefined || precision > 2)\n    precision = 2;\n  return FP_DateTime.isoDateTime(date, precision);\n};\n\n\n/**\n *  Returns a time string in ISO format at the given precision level.\n * @date the date to format\n * @precision the precision at which to terminate string.  (This is\n *  optional). If present, it will be an integer into the matching components of\n *  timeRE.\n * @return a string in ISO 8601 format.\n */\nFP_DateTime.isoTime = function(date, precision) {\n  if (precision === undefined)\n    precision = 2; // maximum\n\n  let rtn = '' + formatNum(date.getHours());\n  if (precision > 0) {\n    rtn += ':' + formatNum(date.getMinutes());\n    if (precision > 1) {\n      rtn += ':' + formatNum(date.getSeconds() );\n      if (date.getMilliseconds())\n        rtn += '.' + formatNum(date.getMilliseconds(), 3);\n    }\n  }\n  return rtn;\n};\n\n\n/**\n *  A class that represents a node in a FHIR resource, with path and possibly type\n *  information.\n */\nclass ResourceNode {\n  /**\n   *  Constructs a instance for the given node (\"data\") of a resource.  If the\n   *  data is the top-level node of a resouce, the path and type parameters will\n   *  be ignored in favor of the resource's resourceType field.\n   * @param data the node's data or value (which might be an object with\n   *  sub-nodes, an array, or FHIR data type)\n   * @param path the node's path in the resource (e.g. Patient.name).  If the\n   *  data's type can be determined from data, that will take precedence over\n   *  this parameter.\n   * @param _data additional data stored in a property named with \"_\" prepended,\n   *  see https://www.hl7.org/fhir/element.html#json for details.\n   */\n  constructor(data, path, _data) {\n    // If data is a resource (maybe a contained resource) reset the path\n    // information to the resource type.\n    if (data?.resourceType)\n      path = data.resourceType;\n    this.path = path;\n    this.data = data;\n    this._data = _data || {};\n  }\n\n  /**\n   * Returns resource node type info.\n   * @return {TypeInfo}\n   */\n  getTypeInfo() {\n    const namespace = TypeInfo.FHIR;\n\n    // TODO: Here we should use property index which we will extract from the specification\n\n    if (this.path.indexOf('.') === -1) {\n      return new TypeInfo({namespace, name: this.path});\n    }\n    return TypeInfo.createByValueInNamespace({namespace, value: this.data});\n  }\n\n  toJSON() {\n    return JSON.stringify(this.data);\n  }\n\n  /**\n   * Converts the data value from FHIR a Quantity to FHIRPath System.Quantity,\n   * when possible, or if not returns the data as is.  Throws an exception if\n   * the data is a Quantity that has a comparator.\n   * The Mapping from FHIR Quantity to FHIRPath System.Quantity is explained here:\n   * https://www.hl7.org/fhir/fhirpath.html#quantity\n   * this.data is not changed, but converted value is returned.\n   * @param {Object|...} data\n   * @param {string} path\n   * @return {FP_Quantity|Object|...}\n   */\n  convertData() {\n    var data = this.data;\n    if (this.path === 'Quantity' && data?.system === ucumSystemUrl) {\n      if (typeof data.value === 'number' && typeof data.code === 'string') {\n        if (data.comparator !== undefined)\n          throw new Error('Cannot convert a FHIR.Quantity that has a comparator');\n        data =\n          new FP_Quantity(data.value, FP_Quantity.mapUCUMCodeToTimeUnits[data.code] || '\\'' + data.code + '\\'');\n      }\n    }\n\n    return data;\n  }\n\n}\n\n\n/**\n *  Returns a ResourceNode for the given data node, checking first to see if the\n *  given node is already a ResourceNode.  Takes the same arguments as the\n *  constructor for ResourceNode.\n */\nResourceNode.makeResNode = function(data, path, _data) {\n  return (data instanceof ResourceNode) ? data : new ResourceNode(data, path, _data);\n};\n\n/**\n * Object class defining type information.\n * Used for minimal type support.\n * (see http://hl7.org/fhirpath/#types-and-reflection)\n */\nclass TypeInfo {\n  constructor({name, namespace}) {\n    this.name = name;\n    this.namespace = namespace;\n  }\n\n  /**\n   * Checks for equality with another TypeInfo object, or that another TypeInfo\n   * object specifies a superclass for the type specified by this object.\n   * @param {TypeInfo} other\n   * @return {boolean}\n   */\n  is(other) {\n    // TODO: Here we should use type hierarchy index which we will extract from the specification\n    return other instanceof TypeInfo && this.name === other.name\n      && (!this.namespace || !other.namespace || this.namespace === other.namespace);\n  }\n}\n\n// Available namespaces:\nTypeInfo.System = 'System';\nTypeInfo.FHIR = 'FHIR';\n\n/**\n * Creates new TypeInfo object for specified namespace and value\n * @param {String} namespace\n * @param {*} value\n * @return {TypeInfo}\n */\nTypeInfo.createByValueInNamespace = function({namespace, value}) {\n  let name = typeof value;\n\n  if (Number.isInteger(value)) {\n    name = 'integer';\n  } else if (name === \"number\") {\n    name = 'decimal';\n  } else if (value instanceof FP_DateTime) {\n    name = 'dateTime';\n  } else if (value instanceof FP_Time) {\n    name = 'time';\n  } else if (value instanceof FP_Quantity) {\n    name = 'Quantity';\n  }\n\n  if (namespace === TypeInfo.System) {\n    name = name.replace(/^\\w/, c => c.toUpperCase());\n  }\n\n  // TODO: currently can return name = 'object\" or \"Object\" which is probably wrong\n  return new TypeInfo({namespace, name}) ;\n};\n\n/**\n * Retrieves TypeInfo by value\n * @param {*} value\n * @return {TypeInfo}\n */\nTypeInfo.fromValue = function (value) {\n  return value instanceof ResourceNode\n    ? value.getTypeInfo()\n    : TypeInfo.createByValueInNamespace({namespace: TypeInfo.System, value});\n};\n\n/**\n * Basic \"type()\" function implementation\n * (see http://hl7.org/fhirpath/#reflection)\n * @param {Array<*>} coll - input collection\n * @return {Array<*>}\n */\nfunction typeFn(coll) {\n  return coll.map(value => {\n    return TypeInfo.fromValue(value);\n  });\n}\n\n/**\n * Implementation of function \"is(type : type specifier)\" and operator \"is\"\n * (see http://hl7.org/fhirpath/#is-type-specifier)\n * @param {Array<*>} coll - input collection\n * @param {TypeInfo} typeInfo\n * @return {boolean|[]}\n */\nfunction isFn(coll, typeInfo) {\n  if(coll.length === 0) {\n    return [];\n  }\n\n  if(coll.length > 1) {\n    throw new Error(\"Expected singleton on left side of is, got \" + JSON.stringify(coll));\n  }\n\n  return TypeInfo.fromValue(coll[0]).is(typeInfo);\n}\n\nmodule.exports = {\n  FP_Type: FP_Type,\n  FP_TimeBase: FP_TimeBase,\n  FP_DateTime: FP_DateTime,\n  FP_Time: FP_Time,\n  FP_Quantity: FP_Quantity,\n  timeRE: timeRE,\n  dateTimeRE: dateTimeRE,\n  ResourceNode: ResourceNode,\n  TypeInfo: TypeInfo,\n  typeFn,\n  isFn\n};\n","// This file holds utility functions used in implementing the public functions.\n\nconst util =  {};\nconst types = require('./types');\nlet {ResourceNode} = types;\n\n/**\n *  Reports and error to the calling environment and stops processing.\n * @param message the error message\n * @param fnName the name of the function raising the error (optional)\n */\nutil.raiseError = function(message, fnName) {\n  fnName = fnName ? fnName + \": \" : \"\";\n  throw fnName + message;\n};\n\n/**\n *  Throws an exception if the collection contains more than one value.\n * @param collection the collection to be checked.\n * @param errorMsgPrefix An optional prefix for the error message to assist in\n *  debugging.\n */\nutil.assertAtMostOne = function (collection, errorMsgPrefix) {\n  if (collection.length > 1) {\n    util.raiseError(\"Was expecting no more than one element but got \" +\n      JSON.stringify(collection), errorMsgPrefix);\n  }\n};\n\n/**\n *  Throws an exception if the data is not one of the expected types.\n * @param data the value to be checked.  This may be a ResourceNode.\n * @param types an array of the permitted types\n * @param errorMsgPrefix An optional prefix for the error message to assist in\n *  debugging.\n * @return the value that was checked.  If \"data\" was a ResourceNode, this will\n *  be the ReourceNode's data.\n */\nutil.assertType = function(data, types, errorMsgPrefix) {\n  let val = this.valData(data);\n  if (types.indexOf(typeof val) < 0) {\n    let typeList = types.length > 1 ? \"one of \"+types.join(\", \") : types[0];\n    util.raiseError(\"Found type '\"+(typeof data)+\"' but was expecting \" +\n      typeList, errorMsgPrefix);\n  }\n  return val;\n};\n\nutil.isEmpty = function(x){\n  return Array.isArray(x) && x.length == 0;\n};\n\nutil.isSome = function(x){\n  return x !== null && x !== undefined && !util.isEmpty(x);\n};\n\nutil.isTrue = function(x){\n  return x !== null && x !== undefined && (x === true || (x.length == 1 && x[0] === true));\n};\n\nutil.isFalse = function(x){\n  return x !== null && x !== undefined && (x === false || (x.length == 1 && x[0] === false));\n};\n\nutil.isCapitalized = function(x){\n  return x && (x[0] === x[0].toUpperCase());\n};\n\nutil.flatten = function(x){\n  return x.reduce(function(acc, x) {\n    if(Array.isArray(x)){\n      // todo replace with array modification\n      acc = acc.concat(x);\n    } else {\n      acc.push(x);\n    }\n    return acc;\n  }, []);\n};\n\nutil.arraify = function(x){\n  if(Array.isArray(x)){ return x; }\n  if(util.isSome(x)){ return [x]; }\n  return [];\n};\n\n/**\n *  Returns the data value of the given parameter, which might be a ResourceNode.\n *  Otherwise, it returns the value that was passed in.\n */\nutil.valData = function(val) {\n  return (val instanceof ResourceNode) ? val.data : val;\n};\n\n/**\n *  Returns the data value of the given parameter, which might be a ResourceNode.\n *  Otherwise, it returns the value that was passed in.  In the case of a\n *  ResourceNode that is a Quantity, the returned value will have been converted\n *  to an FP_Quantity.\n */\nutil.valDataConverted = function(val) {\n  if (val instanceof ResourceNode) {\n    val = val.convertData();\n  }\n  return val;\n};\n\n/**\n * Prepares a string for insertion into a regular expression\n * @param {string} str\n * @return {string}\n */\nutil.escapeStringForRegExp = function (str) {\n  return str.replace(/[-[\\]{}()*+?.,\\\\/^$|#\\s]/g, '\\\\$&');\n};\n\nmodule.exports = util;\n","'use strict';\n\nvar isCallable = require('is-callable');\n\nvar toStr = Object.prototype.toString;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar forEachArray = function forEachArray(array, iterator, receiver) {\n    for (var i = 0, len = array.length; i < len; i++) {\n        if (hasOwnProperty.call(array, i)) {\n            if (receiver == null) {\n                iterator(array[i], i, array);\n            } else {\n                iterator.call(receiver, array[i], i, array);\n            }\n        }\n    }\n};\n\nvar forEachString = function forEachString(string, iterator, receiver) {\n    for (var i = 0, len = string.length; i < len; i++) {\n        // no such thing as a sparse string.\n        if (receiver == null) {\n            iterator(string.charAt(i), i, string);\n        } else {\n            iterator.call(receiver, string.charAt(i), i, string);\n        }\n    }\n};\n\nvar forEachObject = function forEachObject(object, iterator, receiver) {\n    for (var k in object) {\n        if (hasOwnProperty.call(object, k)) {\n            if (receiver == null) {\n                iterator(object[k], k, object);\n            } else {\n                iterator.call(receiver, object[k], k, object);\n            }\n        }\n    }\n};\n\nvar forEach = function forEach(list, iterator, thisArg) {\n    if (!isCallable(iterator)) {\n        throw new TypeError('iterator must be a function');\n    }\n\n    var receiver;\n    if (arguments.length >= 3) {\n        receiver = thisArg;\n    }\n\n    if (toStr.call(list) === '[object Array]') {\n        forEachArray(list, iterator, receiver);\n    } else if (typeof list === 'string') {\n        forEachString(list, iterator, receiver);\n    } else {\n        forEachObject(list, iterator, receiver);\n    }\n};\n\nmodule.exports = forEach;\n","'use strict';\n\n/* eslint no-invalid-this: 1 */\n\nvar ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';\nvar slice = Array.prototype.slice;\nvar toStr = Object.prototype.toString;\nvar funcType = '[object Function]';\n\nmodule.exports = function bind(that) {\n    var target = this;\n    if (typeof target !== 'function' || toStr.call(target) !== funcType) {\n        throw new TypeError(ERROR_MESSAGE + target);\n    }\n    var args = slice.call(arguments, 1);\n\n    var bound;\n    var binder = function () {\n        if (this instanceof bound) {\n            var result = target.apply(\n                this,\n                args.concat(slice.call(arguments))\n            );\n            if (Object(result) === result) {\n                return result;\n            }\n            return this;\n        } else {\n            return target.apply(\n                that,\n                args.concat(slice.call(arguments))\n            );\n        }\n    };\n\n    var boundLength = Math.max(0, target.length - args.length);\n    var boundArgs = [];\n    for (var i = 0; i < boundLength; i++) {\n        boundArgs.push('$' + i);\n    }\n\n    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);\n\n    if (target.prototype) {\n        var Empty = function Empty() {};\n        Empty.prototype = target.prototype;\n        bound.prototype = new Empty();\n        Empty.prototype = null;\n    }\n\n    return bound;\n};\n","'use strict';\n\nvar implementation = require('./implementation');\n\nmodule.exports = Function.prototype.bind || implementation;\n","'use strict';\n\nvar functionsHaveNames = function functionsHaveNames() {\n\treturn typeof function f() {}.name === 'string';\n};\n\nvar gOPD = Object.getOwnPropertyDescriptor;\nif (gOPD) {\n\ttry {\n\t\tgOPD([], 'length');\n\t} catch (e) {\n\t\t// IE 8 has a broken gOPD\n\t\tgOPD = null;\n\t}\n}\n\nfunctionsHaveNames.functionsHaveConfigurableNames = function functionsHaveConfigurableNames() {\n\tif (!functionsHaveNames() || !gOPD) {\n\t\treturn false;\n\t}\n\tvar desc = gOPD(function () {}, 'name');\n\treturn !!desc && !!desc.configurable;\n};\n\nvar $bind = Function.prototype.bind;\n\nfunctionsHaveNames.boundFunctionsHaveNames = function boundFunctionsHaveNames() {\n\treturn functionsHaveNames() && typeof $bind === 'function' && function f() {}.bind().name !== '';\n};\n\nmodule.exports = functionsHaveNames;\n","'use strict';\n\nvar undefined;\n\nvar $SyntaxError = SyntaxError;\nvar $Function = Function;\nvar $TypeError = TypeError;\n\n// eslint-disable-next-line consistent-return\nvar getEvalledConstructor = function (expressionSyntax) {\n\ttry {\n\t\treturn $Function('\"use strict\"; return (' + expressionSyntax + ').constructor;')();\n\t} catch (e) {}\n};\n\nvar $gOPD = Object.getOwnPropertyDescriptor;\nif ($gOPD) {\n\ttry {\n\t\t$gOPD({}, '');\n\t} catch (e) {\n\t\t$gOPD = null; // this is IE 8, which has a broken gOPD\n\t}\n}\n\nvar throwTypeError = function () {\n\tthrow new $TypeError();\n};\nvar ThrowTypeError = $gOPD\n\t? (function () {\n\t\ttry {\n\t\t\t// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties\n\t\t\targuments.callee; // IE 8 does not throw here\n\t\t\treturn throwTypeError;\n\t\t} catch (calleeThrows) {\n\t\t\ttry {\n\t\t\t\t// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')\n\t\t\t\treturn $gOPD(arguments, 'callee').get;\n\t\t\t} catch (gOPDthrows) {\n\t\t\t\treturn throwTypeError;\n\t\t\t}\n\t\t}\n\t}())\n\t: throwTypeError;\n\nvar hasSymbols = require('has-symbols')();\n\nvar getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto\n\nvar needsEval = {};\n\nvar TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);\n\nvar INTRINSICS = {\n\t'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,\n\t'%Array%': Array,\n\t'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,\n\t'%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,\n\t'%AsyncFromSyncIteratorPrototype%': undefined,\n\t'%AsyncFunction%': needsEval,\n\t'%AsyncGenerator%': needsEval,\n\t'%AsyncGeneratorFunction%': needsEval,\n\t'%AsyncIteratorPrototype%': needsEval,\n\t'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,\n\t'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,\n\t'%Boolean%': Boolean,\n\t'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,\n\t'%Date%': Date,\n\t'%decodeURI%': decodeURI,\n\t'%decodeURIComponent%': decodeURIComponent,\n\t'%encodeURI%': encodeURI,\n\t'%encodeURIComponent%': encodeURIComponent,\n\t'%Error%': Error,\n\t'%eval%': eval, // eslint-disable-line no-eval\n\t'%EvalError%': EvalError,\n\t'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,\n\t'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,\n\t'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,\n\t'%Function%': $Function,\n\t'%GeneratorFunction%': needsEval,\n\t'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,\n\t'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,\n\t'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,\n\t'%isFinite%': isFinite,\n\t'%isNaN%': isNaN,\n\t'%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,\n\t'%JSON%': typeof JSON === 'object' ? JSON : undefined,\n\t'%Map%': typeof Map === 'undefined' ? undefined : Map,\n\t'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),\n\t'%Math%': Math,\n\t'%Number%': Number,\n\t'%Object%': Object,\n\t'%parseFloat%': parseFloat,\n\t'%parseInt%': parseInt,\n\t'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,\n\t'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,\n\t'%RangeError%': RangeError,\n\t'%ReferenceError%': ReferenceError,\n\t'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,\n\t'%RegExp%': RegExp,\n\t'%Set%': typeof Set === 'undefined' ? undefined : Set,\n\t'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),\n\t'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,\n\t'%String%': String,\n\t'%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,\n\t'%Symbol%': hasSymbols ? Symbol : undefined,\n\t'%SyntaxError%': $SyntaxError,\n\t'%ThrowTypeError%': ThrowTypeError,\n\t'%TypedArray%': TypedArray,\n\t'%TypeError%': $TypeError,\n\t'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,\n\t'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,\n\t'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,\n\t'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,\n\t'%URIError%': URIError,\n\t'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,\n\t'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,\n\t'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet\n};\n\nvar doEval = function doEval(name) {\n\tvar value;\n\tif (name === '%AsyncFunction%') {\n\t\tvalue = getEvalledConstructor('async function () {}');\n\t} else if (name === '%GeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('function* () {}');\n\t} else if (name === '%AsyncGeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('async function* () {}');\n\t} else if (name === '%AsyncGenerator%') {\n\t\tvar fn = doEval('%AsyncGeneratorFunction%');\n\t\tif (fn) {\n\t\t\tvalue = fn.prototype;\n\t\t}\n\t} else if (name === '%AsyncIteratorPrototype%') {\n\t\tvar gen = doEval('%AsyncGenerator%');\n\t\tif (gen) {\n\t\t\tvalue = getProto(gen.prototype);\n\t\t}\n\t}\n\n\tINTRINSICS[name] = value;\n\n\treturn value;\n};\n\nvar LEGACY_ALIASES = {\n\t'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],\n\t'%ArrayPrototype%': ['Array', 'prototype'],\n\t'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],\n\t'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],\n\t'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],\n\t'%ArrayProto_values%': ['Array', 'prototype', 'values'],\n\t'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],\n\t'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],\n\t'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],\n\t'%BooleanPrototype%': ['Boolean', 'prototype'],\n\t'%DataViewPrototype%': ['DataView', 'prototype'],\n\t'%DatePrototype%': ['Date', 'prototype'],\n\t'%ErrorPrototype%': ['Error', 'prototype'],\n\t'%EvalErrorPrototype%': ['EvalError', 'prototype'],\n\t'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],\n\t'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],\n\t'%FunctionPrototype%': ['Function', 'prototype'],\n\t'%Generator%': ['GeneratorFunction', 'prototype'],\n\t'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],\n\t'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],\n\t'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],\n\t'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],\n\t'%JSONParse%': ['JSON', 'parse'],\n\t'%JSONStringify%': ['JSON', 'stringify'],\n\t'%MapPrototype%': ['Map', 'prototype'],\n\t'%NumberPrototype%': ['Number', 'prototype'],\n\t'%ObjectPrototype%': ['Object', 'prototype'],\n\t'%ObjProto_toString%': ['Object', 'prototype', 'toString'],\n\t'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],\n\t'%PromisePrototype%': ['Promise', 'prototype'],\n\t'%PromiseProto_then%': ['Promise', 'prototype', 'then'],\n\t'%Promise_all%': ['Promise', 'all'],\n\t'%Promise_reject%': ['Promise', 'reject'],\n\t'%Promise_resolve%': ['Promise', 'resolve'],\n\t'%RangeErrorPrototype%': ['RangeError', 'prototype'],\n\t'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],\n\t'%RegExpPrototype%': ['RegExp', 'prototype'],\n\t'%SetPrototype%': ['Set', 'prototype'],\n\t'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],\n\t'%StringPrototype%': ['String', 'prototype'],\n\t'%SymbolPrototype%': ['Symbol', 'prototype'],\n\t'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],\n\t'%TypedArrayPrototype%': ['TypedArray', 'prototype'],\n\t'%TypeErrorPrototype%': ['TypeError', 'prototype'],\n\t'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],\n\t'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],\n\t'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],\n\t'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],\n\t'%URIErrorPrototype%': ['URIError', 'prototype'],\n\t'%WeakMapPrototype%': ['WeakMap', 'prototype'],\n\t'%WeakSetPrototype%': ['WeakSet', 'prototype']\n};\n\nvar bind = require('function-bind');\nvar hasOwn = require('has');\nvar $concat = bind.call(Function.call, Array.prototype.concat);\nvar $spliceApply = bind.call(Function.apply, Array.prototype.splice);\nvar $replace = bind.call(Function.call, String.prototype.replace);\nvar $strSlice = bind.call(Function.call, String.prototype.slice);\nvar $exec = bind.call(Function.call, RegExp.prototype.exec);\n\n/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */\nvar rePropName = /[^%.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|%$))/g;\nvar reEscapeChar = /\\\\(\\\\)?/g; /** Used to match backslashes in property paths. */\nvar stringToPath = function stringToPath(string) {\n\tvar first = $strSlice(string, 0, 1);\n\tvar last = $strSlice(string, -1);\n\tif (first === '%' && last !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected closing `%`');\n\t} else if (last === '%' && first !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected opening `%`');\n\t}\n\tvar result = [];\n\t$replace(string, rePropName, function (match, number, quote, subString) {\n\t\tresult[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;\n\t});\n\treturn result;\n};\n/* end adaptation */\n\nvar getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {\n\tvar intrinsicName = name;\n\tvar alias;\n\tif (hasOwn(LEGACY_ALIASES, intrinsicName)) {\n\t\talias = LEGACY_ALIASES[intrinsicName];\n\t\tintrinsicName = '%' + alias[0] + '%';\n\t}\n\n\tif (hasOwn(INTRINSICS, intrinsicName)) {\n\t\tvar value = INTRINSICS[intrinsicName];\n\t\tif (value === needsEval) {\n\t\t\tvalue = doEval(intrinsicName);\n\t\t}\n\t\tif (typeof value === 'undefined' && !allowMissing) {\n\t\t\tthrow new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');\n\t\t}\n\n\t\treturn {\n\t\t\talias: alias,\n\t\t\tname: intrinsicName,\n\t\t\tvalue: value\n\t\t};\n\t}\n\n\tthrow new $SyntaxError('intrinsic ' + name + ' does not exist!');\n};\n\nmodule.exports = function GetIntrinsic(name, allowMissing) {\n\tif (typeof name !== 'string' || name.length === 0) {\n\t\tthrow new $TypeError('intrinsic name must be a non-empty string');\n\t}\n\tif (arguments.length > 1 && typeof allowMissing !== 'boolean') {\n\t\tthrow new $TypeError('\"allowMissing\" argument must be a boolean');\n\t}\n\n\tif ($exec(/^%?[^%]*%?$/, name) === null) {\n\t\tthrow new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');\n\t}\n\tvar parts = stringToPath(name);\n\tvar intrinsicBaseName = parts.length > 0 ? parts[0] : '';\n\n\tvar intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);\n\tvar intrinsicRealName = intrinsic.name;\n\tvar value = intrinsic.value;\n\tvar skipFurtherCaching = false;\n\n\tvar alias = intrinsic.alias;\n\tif (alias) {\n\t\tintrinsicBaseName = alias[0];\n\t\t$spliceApply(parts, $concat([0, 1], alias));\n\t}\n\n\tfor (var i = 1, isOwn = true; i < parts.length; i += 1) {\n\t\tvar part = parts[i];\n\t\tvar first = $strSlice(part, 0, 1);\n\t\tvar last = $strSlice(part, -1);\n\t\tif (\n\t\t\t(\n\t\t\t\t(first === '\"' || first === \"'\" || first === '`')\n\t\t\t\t|| (last === '\"' || last === \"'\" || last === '`')\n\t\t\t)\n\t\t\t&& first !== last\n\t\t) {\n\t\t\tthrow new $SyntaxError('property names with quotes must have matching quotes');\n\t\t}\n\t\tif (part === 'constructor' || !isOwn) {\n\t\t\tskipFurtherCaching = true;\n\t\t}\n\n\t\tintrinsicBaseName += '.' + part;\n\t\tintrinsicRealName = '%' + intrinsicBaseName + '%';\n\n\t\tif (hasOwn(INTRINSICS, intrinsicRealName)) {\n\t\t\tvalue = INTRINSICS[intrinsicRealName];\n\t\t} else if (value != null) {\n\t\t\tif (!(part in value)) {\n\t\t\t\tif (!allowMissing) {\n\t\t\t\t\tthrow new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');\n\t\t\t\t}\n\t\t\t\treturn void undefined;\n\t\t\t}\n\t\t\tif ($gOPD && (i + 1) >= parts.length) {\n\t\t\t\tvar desc = $gOPD(value, part);\n\t\t\t\tisOwn = !!desc;\n\n\t\t\t\t// By convention, when a data property is converted to an accessor\n\t\t\t\t// property to emulate a data property that does not suffer from\n\t\t\t\t// the override mistake, that accessor's getter is marked with\n\t\t\t\t// an `originalValue` property. Here, when we detect this, we\n\t\t\t\t// uphold the illusion by pretending to see that original data\n\t\t\t\t// property, i.e., returning the value rather than the getter\n\t\t\t\t// itself.\n\t\t\t\tif (isOwn && 'get' in desc && !('originalValue' in desc.get)) {\n\t\t\t\t\tvalue = desc.get;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = value[part];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tisOwn = hasOwn(value, part);\n\t\t\t\tvalue = value[part];\n\t\t\t}\n\n\t\t\tif (isOwn && !skipFurtherCaching) {\n\t\t\t\tINTRINSICS[intrinsicRealName] = value;\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n};\n","'use strict';\n\nvar $BigInt = typeof BigInt !== 'undefined' && BigInt;\n\nmodule.exports = function hasNativeBigInts() {\n\treturn typeof $BigInt === 'function'\n\t\t&& typeof BigInt === 'function'\n\t\t&& typeof $BigInt(42) === 'bigint' // eslint-disable-line no-magic-numbers\n\t\t&& typeof BigInt(42) === 'bigint'; // eslint-disable-line no-magic-numbers\n};\n","'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\n\nvar $defineProperty = GetIntrinsic('%Object.defineProperty%', true);\n\nvar hasPropertyDescriptors = function hasPropertyDescriptors() {\n\tif ($defineProperty) {\n\t\ttry {\n\t\t\t$defineProperty({}, 'a', { value: 1 });\n\t\t\treturn true;\n\t\t} catch (e) {\n\t\t\t// IE 8 has a broken defineProperty\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn false;\n};\n\nhasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {\n\t// node v0.6 has a bug where array lengths can be Set but not Defined\n\tif (!hasPropertyDescriptors()) {\n\t\treturn null;\n\t}\n\ttry {\n\t\treturn $defineProperty([], 'length', { value: 1 }).length !== 1;\n\t} catch (e) {\n\t\t// In Firefox 4-22, defining length on an array throws an exception.\n\t\treturn true;\n\t}\n};\n\nmodule.exports = hasPropertyDescriptors;\n","'use strict';\n\nvar origSymbol = typeof Symbol !== 'undefined' && Symbol;\nvar hasSymbolSham = require('./shams');\n\nmodule.exports = function hasNativeSymbols() {\n\tif (typeof origSymbol !== 'function') { return false; }\n\tif (typeof Symbol !== 'function') { return false; }\n\tif (typeof origSymbol('foo') !== 'symbol') { return false; }\n\tif (typeof Symbol('bar') !== 'symbol') { return false; }\n\n\treturn hasSymbolSham();\n};\n","'use strict';\n\n/* eslint complexity: [2, 18], max-statements: [2, 33] */\nmodule.exports = function hasSymbols() {\n\tif (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }\n\tif (typeof Symbol.iterator === 'symbol') { return true; }\n\n\tvar obj = {};\n\tvar sym = Symbol('test');\n\tvar symObj = Object(sym);\n\tif (typeof sym === 'string') { return false; }\n\n\tif (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }\n\tif (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }\n\n\t// temp disabled per https://github.com/ljharb/object.assign/issues/17\n\t// if (sym instanceof Symbol) { return false; }\n\t// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4\n\t// if (!(symObj instanceof Symbol)) { return false; }\n\n\t// if (typeof Symbol.prototype.toString !== 'function') { return false; }\n\t// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }\n\n\tvar symVal = 42;\n\tobj[sym] = symVal;\n\tfor (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop\n\tif (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }\n\n\tif (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }\n\n\tvar syms = Object.getOwnPropertySymbols(obj);\n\tif (syms.length !== 1 || syms[0] !== sym) { return false; }\n\n\tif (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }\n\n\tif (typeof Object.getOwnPropertyDescriptor === 'function') {\n\t\tvar descriptor = Object.getOwnPropertyDescriptor(obj, sym);\n\t\tif (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }\n\t}\n\n\treturn true;\n};\n","'use strict';\n\nvar hasSymbols = require('has-symbols/shams');\n\nmodule.exports = function hasToStringTagShams() {\n\treturn hasSymbols() && !!Symbol.toStringTag;\n};\n","'use strict';\n\nvar bind = require('function-bind');\n\nmodule.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);\n","'use strict';\n\nvar hasToStringTag = require('has-tostringtag/shams')();\nvar callBound = require('call-bind/callBound');\n\nvar $toString = callBound('Object.prototype.toString');\n\nvar isStandardArguments = function isArguments(value) {\n\tif (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {\n\t\treturn false;\n\t}\n\treturn $toString(value) === '[object Arguments]';\n};\n\nvar isLegacyArguments = function isArguments(value) {\n\tif (isStandardArguments(value)) {\n\t\treturn true;\n\t}\n\treturn value !== null &&\n\t\ttypeof value === 'object' &&\n\t\ttypeof value.length === 'number' &&\n\t\tvalue.length >= 0 &&\n\t\t$toString(value) !== '[object Array]' &&\n\t\t$toString(value.callee) === '[object Function]';\n};\n\nvar supportsStandardArguments = (function () {\n\treturn isStandardArguments(arguments);\n}());\n\nisStandardArguments.isLegacyArguments = isLegacyArguments; // for tests\n\nmodule.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;\n","'use strict';\n\nvar hasBigInts = require('has-bigints')();\n\nif (hasBigInts) {\n\tvar bigIntValueOf = BigInt.prototype.valueOf;\n\tvar tryBigInt = function tryBigIntObject(value) {\n\t\ttry {\n\t\t\tbigIntValueOf.call(value);\n\t\t\treturn true;\n\t\t} catch (e) {\n\t\t}\n\t\treturn false;\n\t};\n\n\tmodule.exports = function isBigInt(value) {\n\t\tif (\n\t\t\tvalue === null\n\t\t\t|| typeof value === 'undefined'\n\t\t\t|| typeof value === 'boolean'\n\t\t\t|| typeof value === 'string'\n\t\t\t|| typeof value === 'number'\n\t\t\t|| typeof value === 'symbol'\n\t\t\t|| typeof value === 'function'\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\t\tif (typeof value === 'bigint') {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn tryBigInt(value);\n\t};\n} else {\n\tmodule.exports = function isBigInt(value) {\n\t\treturn false && value;\n\t};\n}\n","'use strict';\n\nvar callBound = require('call-bind/callBound');\nvar $boolToStr = callBound('Boolean.prototype.toString');\nvar $toString = callBound('Object.prototype.toString');\n\nvar tryBooleanObject = function booleanBrandCheck(value) {\n\ttry {\n\t\t$boolToStr(value);\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t}\n};\nvar boolClass = '[object Boolean]';\nvar hasToStringTag = require('has-tostringtag/shams')();\n\nmodule.exports = function isBoolean(value) {\n\tif (typeof value === 'boolean') {\n\t\treturn true;\n\t}\n\tif (value === null || typeof value !== 'object') {\n\t\treturn false;\n\t}\n\treturn hasToStringTag && Symbol.toStringTag in value ? tryBooleanObject(value) : $toString(value) === boolClass;\n};\n","'use strict';\n\nvar fnToStr = Function.prototype.toString;\nvar reflectApply = typeof Reflect === 'object' && Reflect !== null && Reflect.apply;\nvar badArrayLike;\nvar isCallableMarker;\nif (typeof reflectApply === 'function' && typeof Object.defineProperty === 'function') {\n\ttry {\n\t\tbadArrayLike = Object.defineProperty({}, 'length', {\n\t\t\tget: function () {\n\t\t\t\tthrow isCallableMarker;\n\t\t\t}\n\t\t});\n\t\tisCallableMarker = {};\n\t\t// eslint-disable-next-line no-throw-literal\n\t\treflectApply(function () { throw 42; }, null, badArrayLike);\n\t} catch (_) {\n\t\tif (_ !== isCallableMarker) {\n\t\t\treflectApply = null;\n\t\t}\n\t}\n} else {\n\treflectApply = null;\n}\n\nvar constructorRegex = /^\\s*class\\b/;\nvar isES6ClassFn = function isES6ClassFunction(value) {\n\ttry {\n\t\tvar fnStr = fnToStr.call(value);\n\t\treturn constructorRegex.test(fnStr);\n\t} catch (e) {\n\t\treturn false; // not a function\n\t}\n};\n\nvar tryFunctionObject = function tryFunctionToStr(value) {\n\ttry {\n\t\tif (isES6ClassFn(value)) { return false; }\n\t\tfnToStr.call(value);\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t}\n};\nvar toStr = Object.prototype.toString;\nvar fnClass = '[object Function]';\nvar genClass = '[object GeneratorFunction]';\nvar hasToStringTag = typeof Symbol === 'function' && !!Symbol.toStringTag; // better: use `has-tostringtag`\nvar isDDA = typeof document === 'object' ? function isDocumentDotAll(value) {\n\t/* globals document: false */\n\t// in IE 8, typeof document.all is \"object\"\n\tif (typeof value === 'undefined' || typeof value === 'object') {\n\t\ttry {\n\t\t\treturn value('') === null;\n\t\t} catch (e) { /**/ }\n\t}\n\treturn false;\n} : function () { return false; };\n\nmodule.exports = reflectApply\n\t? function isCallable(value) {\n\t\tif (isDDA(value)) { return true; }\n\t\tif (!value) { return false; }\n\t\tif (typeof value !== 'function' && typeof value !== 'object') { return false; }\n\t\tif (typeof value === 'function' && !value.prototype) { return true; }\n\t\ttry {\n\t\t\treflectApply(value, null, badArrayLike);\n\t\t} catch (e) {\n\t\t\tif (e !== isCallableMarker) { return false; }\n\t\t}\n\t\treturn !isES6ClassFn(value);\n\t}\n\t: function isCallable(value) {\n\t\tif (isDDA(value)) { return true; }\n\t\tif (!value) { return false; }\n\t\tif (typeof value !== 'function' && typeof value !== 'object') { return false; }\n\t\tif (typeof value === 'function' && !value.prototype) { return true; }\n\t\tif (hasToStringTag) { return tryFunctionObject(value); }\n\t\tif (isES6ClassFn(value)) { return false; }\n\t\tvar strClass = toStr.call(value);\n\t\treturn strClass === fnClass || strClass === genClass || tryFunctionObject(value);\n\t};\n","'use strict';\n\nvar getDay = Date.prototype.getDay;\nvar tryDateObject = function tryDateGetDayCall(value) {\n\ttry {\n\t\tgetDay.call(value);\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t}\n};\n\nvar toStr = Object.prototype.toString;\nvar dateClass = '[object Date]';\nvar hasToStringTag = require('has-tostringtag/shams')();\n\nmodule.exports = function isDateObject(value) {\n\tif (typeof value !== 'object' || value === null) {\n\t\treturn false;\n\t}\n\treturn hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;\n};\n","'use strict';\n\nvar $Map = typeof Map === 'function' && Map.prototype ? Map : null;\nvar $Set = typeof Set === 'function' && Set.prototype ? Set : null;\n\nvar exported;\n\nif (!$Map) {\n\t// eslint-disable-next-line no-unused-vars\n\texported = function isMap(x) {\n\t\t// `Map` is not present in this environment.\n\t\treturn false;\n\t};\n}\n\nvar $mapHas = $Map ? Map.prototype.has : null;\nvar $setHas = $Set ? Set.prototype.has : null;\nif (!exported && !$mapHas) {\n\t// eslint-disable-next-line no-unused-vars\n\texported = function isMap(x) {\n\t\t// `Map` does not have a `has` method\n\t\treturn false;\n\t};\n}\n\nmodule.exports = exported || function isMap(x) {\n\tif (!x || typeof x !== 'object') {\n\t\treturn false;\n\t}\n\ttry {\n\t\t$mapHas.call(x);\n\t\tif ($setHas) {\n\t\t\ttry {\n\t\t\t\t$setHas.call(x);\n\t\t\t} catch (e) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn x instanceof $Map; // core-js workaround, pre-v2.5.0\n\t} catch (e) {}\n\treturn false;\n};\n","'use strict';\n\nvar numToStr = Number.prototype.toString;\nvar tryNumberObject = function tryNumberObject(value) {\n\ttry {\n\t\tnumToStr.call(value);\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t}\n};\nvar toStr = Object.prototype.toString;\nvar numClass = '[object Number]';\nvar hasToStringTag = require('has-tostringtag/shams')();\n\nmodule.exports = function isNumberObject(value) {\n\tif (typeof value === 'number') {\n\t\treturn true;\n\t}\n\tif (typeof value !== 'object') {\n\t\treturn false;\n\t}\n\treturn hasToStringTag ? tryNumberObject(value) : toStr.call(value) === numClass;\n};\n","'use strict';\n\nvar callBound = require('call-bind/callBound');\nvar hasToStringTag = require('has-tostringtag/shams')();\nvar has;\nvar $exec;\nvar isRegexMarker;\nvar badStringifier;\n\nif (hasToStringTag) {\n\thas = callBound('Object.prototype.hasOwnProperty');\n\t$exec = callBound('RegExp.prototype.exec');\n\tisRegexMarker = {};\n\n\tvar throwRegexMarker = function () {\n\t\tthrow isRegexMarker;\n\t};\n\tbadStringifier = {\n\t\ttoString: throwRegexMarker,\n\t\tvalueOf: throwRegexMarker\n\t};\n\n\tif (typeof Symbol.toPrimitive === 'symbol') {\n\t\tbadStringifier[Symbol.toPrimitive] = throwRegexMarker;\n\t}\n}\n\nvar $toString = callBound('Object.prototype.toString');\nvar gOPD = Object.getOwnPropertyDescriptor;\nvar regexClass = '[object RegExp]';\n\nmodule.exports = hasToStringTag\n\t// eslint-disable-next-line consistent-return\n\t? function isRegex(value) {\n\t\tif (!value || typeof value !== 'object') {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar descriptor = gOPD(value, 'lastIndex');\n\t\tvar hasLastIndexDataProperty = descriptor && has(descriptor, 'value');\n\t\tif (!hasLastIndexDataProperty) {\n\t\t\treturn false;\n\t\t}\n\n\t\ttry {\n\t\t\t$exec(value, badStringifier);\n\t\t} catch (e) {\n\t\t\treturn e === isRegexMarker;\n\t\t}\n\t}\n\t: function isRegex(value) {\n\t\t// In older browsers, typeof regex incorrectly returns 'function'\n\t\tif (!value || (typeof value !== 'object' && typeof value !== 'function')) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn $toString(value) === regexClass;\n\t};\n","'use strict';\n\nvar $Map = typeof Map === 'function' && Map.prototype ? Map : null;\nvar $Set = typeof Set === 'function' && Set.prototype ? Set : null;\n\nvar exported;\n\nif (!$Set) {\n\t// eslint-disable-next-line no-unused-vars\n\texported = function isSet(x) {\n\t\t// `Set` is not present in this environment.\n\t\treturn false;\n\t};\n}\n\nvar $mapHas = $Map ? Map.prototype.has : null;\nvar $setHas = $Set ? Set.prototype.has : null;\nif (!exported && !$setHas) {\n\t// eslint-disable-next-line no-unused-vars\n\texported = function isSet(x) {\n\t\t// `Set` does not have a `has` method\n\t\treturn false;\n\t};\n}\n\nmodule.exports = exported || function isSet(x) {\n\tif (!x || typeof x !== 'object') {\n\t\treturn false;\n\t}\n\ttry {\n\t\t$setHas.call(x);\n\t\tif ($mapHas) {\n\t\t\ttry {\n\t\t\t\t$mapHas.call(x);\n\t\t\t} catch (e) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn x instanceof $Set; // core-js workaround, pre-v2.5.0\n\t} catch (e) {}\n\treturn false;\n};\n","'use strict';\n\nvar strValue = String.prototype.valueOf;\nvar tryStringObject = function tryStringObject(value) {\n\ttry {\n\t\tstrValue.call(value);\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t}\n};\nvar toStr = Object.prototype.toString;\nvar strClass = '[object String]';\nvar hasToStringTag = require('has-tostringtag/shams')();\n\nmodule.exports = function isString(value) {\n\tif (typeof value === 'string') {\n\t\treturn true;\n\t}\n\tif (typeof value !== 'object') {\n\t\treturn false;\n\t}\n\treturn hasToStringTag ? tryStringObject(value) : toStr.call(value) === strClass;\n};\n","'use strict';\n\nvar toStr = Object.prototype.toString;\nvar hasSymbols = require('has-symbols')();\n\nif (hasSymbols) {\n\tvar symToStr = Symbol.prototype.toString;\n\tvar symStringRegex = /^Symbol\\(.*\\)$/;\n\tvar isSymbolObject = function isRealSymbolObject(value) {\n\t\tif (typeof value.valueOf() !== 'symbol') {\n\t\t\treturn false;\n\t\t}\n\t\treturn symStringRegex.test(symToStr.call(value));\n\t};\n\n\tmodule.exports = function isSymbol(value) {\n\t\tif (typeof value === 'symbol') {\n\t\t\treturn true;\n\t\t}\n\t\tif (toStr.call(value) !== '[object Symbol]') {\n\t\t\treturn false;\n\t\t}\n\t\ttry {\n\t\t\treturn isSymbolObject(value);\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t};\n} else {\n\n\tmodule.exports = function isSymbol(value) {\n\t\t// this environment does not support Symbols.\n\t\treturn false && value;\n\t};\n}\n","'use strict';\n\nvar forEach = require('for-each');\nvar availableTypedArrays = require('available-typed-arrays');\nvar callBound = require('call-bind/callBound');\n\nvar $toString = callBound('Object.prototype.toString');\nvar hasToStringTag = require('has-tostringtag/shams')();\n\nvar g = typeof globalThis === 'undefined' ? global : globalThis;\nvar typedArrays = availableTypedArrays();\n\nvar $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {\n\tfor (var i = 0; i < array.length; i += 1) {\n\t\tif (array[i] === value) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n};\nvar $slice = callBound('String.prototype.slice');\nvar toStrTags = {};\nvar gOPD = require('es-abstract/helpers/getOwnPropertyDescriptor');\nvar getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');\nif (hasToStringTag && gOPD && getPrototypeOf) {\n\tforEach(typedArrays, function (typedArray) {\n\t\tvar arr = new g[typedArray]();\n\t\tif (Symbol.toStringTag in arr) {\n\t\t\tvar proto = getPrototypeOf(arr);\n\t\t\tvar descriptor = gOPD(proto, Symbol.toStringTag);\n\t\t\tif (!descriptor) {\n\t\t\t\tvar superProto = getPrototypeOf(proto);\n\t\t\t\tdescriptor = gOPD(superProto, Symbol.toStringTag);\n\t\t\t}\n\t\t\ttoStrTags[typedArray] = descriptor.get;\n\t\t}\n\t});\n}\n\nvar tryTypedArrays = function tryAllTypedArrays(value) {\n\tvar anyTrue = false;\n\tforEach(toStrTags, function (getter, typedArray) {\n\t\tif (!anyTrue) {\n\t\t\ttry {\n\t\t\t\tanyTrue = getter.call(value) === typedArray;\n\t\t\t} catch (e) { /**/ }\n\t\t}\n\t});\n\treturn anyTrue;\n};\n\nmodule.exports = function isTypedArray(value) {\n\tif (!value || typeof value !== 'object') { return false; }\n\tif (!hasToStringTag || !(Symbol.toStringTag in value)) {\n\t\tvar tag = $slice($toString(value), 8, -1);\n\t\treturn $indexOf(typedArrays, tag) > -1;\n\t}\n\tif (!gOPD) { return false; }\n\treturn tryTypedArrays(value);\n};\n","'use strict';\n\nvar $WeakMap = typeof WeakMap === 'function' && WeakMap.prototype ? WeakMap : null;\nvar $WeakSet = typeof WeakSet === 'function' && WeakSet.prototype ? WeakSet : null;\n\nvar exported;\n\nif (!$WeakMap) {\n\t// eslint-disable-next-line no-unused-vars\n\texported = function isWeakMap(x) {\n\t\t// `WeakMap` is not present in this environment.\n\t\treturn false;\n\t};\n}\n\nvar $mapHas = $WeakMap ? $WeakMap.prototype.has : null;\nvar $setHas = $WeakSet ? $WeakSet.prototype.has : null;\nif (!exported && !$mapHas) {\n\t// eslint-disable-next-line no-unused-vars\n\texported = function isWeakMap(x) {\n\t\t// `WeakMap` does not have a `has` method\n\t\treturn false;\n\t};\n}\n\nmodule.exports = exported || function isWeakMap(x) {\n\tif (!x || typeof x !== 'object') {\n\t\treturn false;\n\t}\n\ttry {\n\t\t$mapHas.call(x, $mapHas);\n\t\tif ($setHas) {\n\t\t\ttry {\n\t\t\t\t$setHas.call(x, $setHas);\n\t\t\t} catch (e) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn x instanceof $WeakMap; // core-js workaround, pre-v3\n\t} catch (e) {}\n\treturn false;\n};\n","'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\nvar callBound = require('call-bind/callBound');\n\nvar $WeakSet = GetIntrinsic('%WeakSet%', true);\n\nvar $setHas = callBound('WeakSet.prototype.has', true);\n\nif ($setHas) {\n\tvar $mapHas = callBound('WeakMap.prototype.has', true);\n\n\tmodule.exports = function isWeakSet(x) {\n\t\tif (!x || typeof x !== 'object') {\n\t\t\treturn false;\n\t\t}\n\t\ttry {\n\t\t\t$setHas(x, $setHas);\n\t\t\tif ($mapHas) {\n\t\t\t\ttry {\n\t\t\t\t\t$mapHas(x, $mapHas);\n\t\t\t\t} catch (e) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn x instanceof $WeakSet; // core-js workaround, pre-v3\n\t\t} catch (e) {}\n\t\treturn false;\n\t};\n} else {\n\t// eslint-disable-next-line no-unused-vars\n\tmodule.exports = function isWeakSet(x) {\n\t\t// `WeakSet` does not exist, or does not have a `has` method\n\t\treturn false;\n\t};\n}\n","var hasMap = typeof Map === 'function' && Map.prototype;\nvar mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;\nvar mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;\nvar mapForEach = hasMap && Map.prototype.forEach;\nvar hasSet = typeof Set === 'function' && Set.prototype;\nvar setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;\nvar setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;\nvar setForEach = hasSet && Set.prototype.forEach;\nvar hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;\nvar weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;\nvar hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;\nvar weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;\nvar hasWeakRef = typeof WeakRef === 'function' && WeakRef.prototype;\nvar weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;\nvar booleanValueOf = Boolean.prototype.valueOf;\nvar objectToString = Object.prototype.toString;\nvar functionToString = Function.prototype.toString;\nvar $match = String.prototype.match;\nvar $slice = String.prototype.slice;\nvar $replace = String.prototype.replace;\nvar $toUpperCase = String.prototype.toUpperCase;\nvar $toLowerCase = String.prototype.toLowerCase;\nvar $test = RegExp.prototype.test;\nvar $concat = Array.prototype.concat;\nvar $join = Array.prototype.join;\nvar $arrSlice = Array.prototype.slice;\nvar $floor = Math.floor;\nvar bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;\nvar gOPS = Object.getOwnPropertySymbols;\nvar symToString = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol.prototype.toString : null;\nvar hasShammedSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'object';\n// ie, `has-tostringtag/shams\nvar toStringTag = typeof Symbol === 'function' && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? 'object' : 'symbol')\n    ? Symbol.toStringTag\n    : null;\nvar isEnumerable = Object.prototype.propertyIsEnumerable;\n\nvar gPO = (typeof Reflect === 'function' ? Reflect.getPrototypeOf : Object.getPrototypeOf) || (\n    [].__proto__ === Array.prototype // eslint-disable-line no-proto\n        ? function (O) {\n            return O.__proto__; // eslint-disable-line no-proto\n        }\n        : null\n);\n\nfunction addNumericSeparator(num, str) {\n    if (\n        num === Infinity\n        || num === -Infinity\n        || num !== num\n        || (num && num > -1000 && num < 1000)\n        || $test.call(/e/, str)\n    ) {\n        return str;\n    }\n    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;\n    if (typeof num === 'number') {\n        var int = num < 0 ? -$floor(-num) : $floor(num); // trunc(num)\n        if (int !== num) {\n            var intStr = String(int);\n            var dec = $slice.call(str, intStr.length + 1);\n            return $replace.call(intStr, sepRegex, '$&_') + '.' + $replace.call($replace.call(dec, /([0-9]{3})/g, '$&_'), /_$/, '');\n        }\n    }\n    return $replace.call(str, sepRegex, '$&_');\n}\n\nvar utilInspect = require('./util.inspect');\nvar inspectCustom = utilInspect.custom;\nvar inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;\n\nmodule.exports = function inspect_(obj, options, depth, seen) {\n    var opts = options || {};\n\n    if (has(opts, 'quoteStyle') && (opts.quoteStyle !== 'single' && opts.quoteStyle !== 'double')) {\n        throw new TypeError('option \"quoteStyle\" must be \"single\" or \"double\"');\n    }\n    if (\n        has(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number'\n            ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity\n            : opts.maxStringLength !== null\n        )\n    ) {\n        throw new TypeError('option \"maxStringLength\", if provided, must be a positive integer, Infinity, or `null`');\n    }\n    var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;\n    if (typeof customInspect !== 'boolean' && customInspect !== 'symbol') {\n        throw new TypeError('option \"customInspect\", if provided, must be `true`, `false`, or `\\'symbol\\'`');\n    }\n\n    if (\n        has(opts, 'indent')\n        && opts.indent !== null\n        && opts.indent !== '\\t'\n        && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)\n    ) {\n        throw new TypeError('option \"indent\" must be \"\\\\t\", an integer > 0, or `null`');\n    }\n    if (has(opts, 'numericSeparator') && typeof opts.numericSeparator !== 'boolean') {\n        throw new TypeError('option \"numericSeparator\", if provided, must be `true` or `false`');\n    }\n    var numericSeparator = opts.numericSeparator;\n\n    if (typeof obj === 'undefined') {\n        return 'undefined';\n    }\n    if (obj === null) {\n        return 'null';\n    }\n    if (typeof obj === 'boolean') {\n        return obj ? 'true' : 'false';\n    }\n\n    if (typeof obj === 'string') {\n        return inspectString(obj, opts);\n    }\n    if (typeof obj === 'number') {\n        if (obj === 0) {\n            return Infinity / obj > 0 ? '0' : '-0';\n        }\n        var str = String(obj);\n        return numericSeparator ? addNumericSeparator(obj, str) : str;\n    }\n    if (typeof obj === 'bigint') {\n        var bigIntStr = String(obj) + 'n';\n        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;\n    }\n\n    var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;\n    if (typeof depth === 'undefined') { depth = 0; }\n    if (depth >= maxDepth && maxDepth > 0 && typeof obj === 'object') {\n        return isArray(obj) ? '[Array]' : '[Object]';\n    }\n\n    var indent = getIndent(opts, depth);\n\n    if (typeof seen === 'undefined') {\n        seen = [];\n    } else if (indexOf(seen, obj) >= 0) {\n        return '[Circular]';\n    }\n\n    function inspect(value, from, noIndent) {\n        if (from) {\n            seen = $arrSlice.call(seen);\n            seen.push(from);\n        }\n        if (noIndent) {\n            var newOpts = {\n                depth: opts.depth\n            };\n            if (has(opts, 'quoteStyle')) {\n                newOpts.quoteStyle = opts.quoteStyle;\n            }\n            return inspect_(value, newOpts, depth + 1, seen);\n        }\n        return inspect_(value, opts, depth + 1, seen);\n    }\n\n    if (typeof obj === 'function' && !isRegExp(obj)) { // in older engines, regexes are callable\n        var name = nameOf(obj);\n        var keys = arrObjKeys(obj, inspect);\n        return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + $join.call(keys, ', ') + ' }' : '');\n    }\n    if (isSymbol(obj)) {\n        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\\(.*\\))_[^)]*$/, '$1') : symToString.call(obj);\n        return typeof obj === 'object' && !hasShammedSymbols ? markBoxed(symString) : symString;\n    }\n    if (isElement(obj)) {\n        var s = '<' + $toLowerCase.call(String(obj.nodeName));\n        var attrs = obj.attributes || [];\n        for (var i = 0; i < attrs.length; i++) {\n            s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);\n        }\n        s += '>';\n        if (obj.childNodes && obj.childNodes.length) { s += '...'; }\n        s += '</' + $toLowerCase.call(String(obj.nodeName)) + '>';\n        return s;\n    }\n    if (isArray(obj)) {\n        if (obj.length === 0) { return '[]'; }\n        var xs = arrObjKeys(obj, inspect);\n        if (indent && !singleLineValues(xs)) {\n            return '[' + indentedJoin(xs, indent) + ']';\n        }\n        return '[ ' + $join.call(xs, ', ') + ' ]';\n    }\n    if (isError(obj)) {\n        var parts = arrObjKeys(obj, inspect);\n        if (!('cause' in Error.prototype) && 'cause' in obj && !isEnumerable.call(obj, 'cause')) {\n            return '{ [' + String(obj) + '] ' + $join.call($concat.call('[cause]: ' + inspect(obj.cause), parts), ', ') + ' }';\n        }\n        if (parts.length === 0) { return '[' + String(obj) + ']'; }\n        return '{ [' + String(obj) + '] ' + $join.call(parts, ', ') + ' }';\n    }\n    if (typeof obj === 'object' && customInspect) {\n        if (inspectSymbol && typeof obj[inspectSymbol] === 'function' && utilInspect) {\n            return utilInspect(obj, { depth: maxDepth - depth });\n        } else if (customInspect !== 'symbol' && typeof obj.inspect === 'function') {\n            return obj.inspect();\n        }\n    }\n    if (isMap(obj)) {\n        var mapParts = [];\n        mapForEach.call(obj, function (value, key) {\n            mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));\n        });\n        return collectionOf('Map', mapSize.call(obj), mapParts, indent);\n    }\n    if (isSet(obj)) {\n        var setParts = [];\n        setForEach.call(obj, function (value) {\n            setParts.push(inspect(value, obj));\n        });\n        return collectionOf('Set', setSize.call(obj), setParts, indent);\n    }\n    if (isWeakMap(obj)) {\n        return weakCollectionOf('WeakMap');\n    }\n    if (isWeakSet(obj)) {\n        return weakCollectionOf('WeakSet');\n    }\n    if (isWeakRef(obj)) {\n        return weakCollectionOf('WeakRef');\n    }\n    if (isNumber(obj)) {\n        return markBoxed(inspect(Number(obj)));\n    }\n    if (isBigInt(obj)) {\n        return markBoxed(inspect(bigIntValueOf.call(obj)));\n    }\n    if (isBoolean(obj)) {\n        return markBoxed(booleanValueOf.call(obj));\n    }\n    if (isString(obj)) {\n        return markBoxed(inspect(String(obj)));\n    }\n    if (!isDate(obj) && !isRegExp(obj)) {\n        var ys = arrObjKeys(obj, inspect);\n        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;\n        var protoTag = obj instanceof Object ? '' : 'null prototype';\n        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? 'Object' : '';\n        var constructorTag = isPlainObject || typeof obj.constructor !== 'function' ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';\n        var tag = constructorTag + (stringTag || protoTag ? '[' + $join.call($concat.call([], stringTag || [], protoTag || []), ': ') + '] ' : '');\n        if (ys.length === 0) { return tag + '{}'; }\n        if (indent) {\n            return tag + '{' + indentedJoin(ys, indent) + '}';\n        }\n        return tag + '{ ' + $join.call(ys, ', ') + ' }';\n    }\n    return String(obj);\n};\n\nfunction wrapQuotes(s, defaultStyle, opts) {\n    var quoteChar = (opts.quoteStyle || defaultStyle) === 'double' ? '\"' : \"'\";\n    return quoteChar + s + quoteChar;\n}\n\nfunction quote(s) {\n    return $replace.call(String(s), /\"/g, '&quot;');\n}\n\nfunction isArray(obj) { return toStr(obj) === '[object Array]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }\nfunction isDate(obj) { return toStr(obj) === '[object Date]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }\nfunction isRegExp(obj) { return toStr(obj) === '[object RegExp]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }\nfunction isError(obj) { return toStr(obj) === '[object Error]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }\nfunction isString(obj) { return toStr(obj) === '[object String]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }\nfunction isNumber(obj) { return toStr(obj) === '[object Number]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }\nfunction isBoolean(obj) { return toStr(obj) === '[object Boolean]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }\n\n// Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives\nfunction isSymbol(obj) {\n    if (hasShammedSymbols) {\n        return obj && typeof obj === 'object' && obj instanceof Symbol;\n    }\n    if (typeof obj === 'symbol') {\n        return true;\n    }\n    if (!obj || typeof obj !== 'object' || !symToString) {\n        return false;\n    }\n    try {\n        symToString.call(obj);\n        return true;\n    } catch (e) {}\n    return false;\n}\n\nfunction isBigInt(obj) {\n    if (!obj || typeof obj !== 'object' || !bigIntValueOf) {\n        return false;\n    }\n    try {\n        bigIntValueOf.call(obj);\n        return true;\n    } catch (e) {}\n    return false;\n}\n\nvar hasOwn = Object.prototype.hasOwnProperty || function (key) { return key in this; };\nfunction has(obj, key) {\n    return hasOwn.call(obj, key);\n}\n\nfunction toStr(obj) {\n    return objectToString.call(obj);\n}\n\nfunction nameOf(f) {\n    if (f.name) { return f.name; }\n    var m = $match.call(functionToString.call(f), /^function\\s*([\\w$]+)/);\n    if (m) { return m[1]; }\n    return null;\n}\n\nfunction indexOf(xs, x) {\n    if (xs.indexOf) { return xs.indexOf(x); }\n    for (var i = 0, l = xs.length; i < l; i++) {\n        if (xs[i] === x) { return i; }\n    }\n    return -1;\n}\n\nfunction isMap(x) {\n    if (!mapSize || !x || typeof x !== 'object') {\n        return false;\n    }\n    try {\n        mapSize.call(x);\n        try {\n            setSize.call(x);\n        } catch (s) {\n            return true;\n        }\n        return x instanceof Map; // core-js workaround, pre-v2.5.0\n    } catch (e) {}\n    return false;\n}\n\nfunction isWeakMap(x) {\n    if (!weakMapHas || !x || typeof x !== 'object') {\n        return false;\n    }\n    try {\n        weakMapHas.call(x, weakMapHas);\n        try {\n            weakSetHas.call(x, weakSetHas);\n        } catch (s) {\n            return true;\n        }\n        return x instanceof WeakMap; // core-js workaround, pre-v2.5.0\n    } catch (e) {}\n    return false;\n}\n\nfunction isWeakRef(x) {\n    if (!weakRefDeref || !x || typeof x !== 'object') {\n        return false;\n    }\n    try {\n        weakRefDeref.call(x);\n        return true;\n    } catch (e) {}\n    return false;\n}\n\nfunction isSet(x) {\n    if (!setSize || !x || typeof x !== 'object') {\n        return false;\n    }\n    try {\n        setSize.call(x);\n        try {\n            mapSize.call(x);\n        } catch (m) {\n            return true;\n        }\n        return x instanceof Set; // core-js workaround, pre-v2.5.0\n    } catch (e) {}\n    return false;\n}\n\nfunction isWeakSet(x) {\n    if (!weakSetHas || !x || typeof x !== 'object') {\n        return false;\n    }\n    try {\n        weakSetHas.call(x, weakSetHas);\n        try {\n            weakMapHas.call(x, weakMapHas);\n        } catch (s) {\n            return true;\n        }\n        return x instanceof WeakSet; // core-js workaround, pre-v2.5.0\n    } catch (e) {}\n    return false;\n}\n\nfunction isElement(x) {\n    if (!x || typeof x !== 'object') { return false; }\n    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {\n        return true;\n    }\n    return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';\n}\n\nfunction inspectString(str, opts) {\n    if (str.length > opts.maxStringLength) {\n        var remaining = str.length - opts.maxStringLength;\n        var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');\n        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;\n    }\n    // eslint-disable-next-line no-control-regex\n    var s = $replace.call($replace.call(str, /(['\\\\])/g, '\\\\$1'), /[\\x00-\\x1f]/g, lowbyte);\n    return wrapQuotes(s, 'single', opts);\n}\n\nfunction lowbyte(c) {\n    var n = c.charCodeAt(0);\n    var x = {\n        8: 'b',\n        9: 't',\n        10: 'n',\n        12: 'f',\n        13: 'r'\n    }[n];\n    if (x) { return '\\\\' + x; }\n    return '\\\\x' + (n < 0x10 ? '0' : '') + $toUpperCase.call(n.toString(16));\n}\n\nfunction markBoxed(str) {\n    return 'Object(' + str + ')';\n}\n\nfunction weakCollectionOf(type) {\n    return type + ' { ? }';\n}\n\nfunction collectionOf(type, size, entries, indent) {\n    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ', ');\n    return type + ' (' + size + ') {' + joinedEntries + '}';\n}\n\nfunction singleLineValues(xs) {\n    for (var i = 0; i < xs.length; i++) {\n        if (indexOf(xs[i], '\\n') >= 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction getIndent(opts, depth) {\n    var baseIndent;\n    if (opts.indent === '\\t') {\n        baseIndent = '\\t';\n    } else if (typeof opts.indent === 'number' && opts.indent > 0) {\n        baseIndent = $join.call(Array(opts.indent + 1), ' ');\n    } else {\n        return null;\n    }\n    return {\n        base: baseIndent,\n        prev: $join.call(Array(depth + 1), baseIndent)\n    };\n}\n\nfunction indentedJoin(xs, indent) {\n    if (xs.length === 0) { return ''; }\n    var lineJoiner = '\\n' + indent.prev + indent.base;\n    return lineJoiner + $join.call(xs, ',' + lineJoiner) + '\\n' + indent.prev;\n}\n\nfunction arrObjKeys(obj, inspect) {\n    var isArr = isArray(obj);\n    var xs = [];\n    if (isArr) {\n        xs.length = obj.length;\n        for (var i = 0; i < obj.length; i++) {\n            xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';\n        }\n    }\n    var syms = typeof gOPS === 'function' ? gOPS(obj) : [];\n    var symMap;\n    if (hasShammedSymbols) {\n        symMap = {};\n        for (var k = 0; k < syms.length; k++) {\n            symMap['$' + syms[k]] = syms[k];\n        }\n    }\n\n    for (var key in obj) { // eslint-disable-line no-restricted-syntax\n        if (!has(obj, key)) { continue; } // eslint-disable-line no-restricted-syntax, no-continue\n        if (isArr && String(Number(key)) === key && key < obj.length) { continue; } // eslint-disable-line no-restricted-syntax, no-continue\n        if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) {\n            // this is to prevent shammed Symbols, which are stored as strings, from being included in the string key section\n            continue; // eslint-disable-line no-restricted-syntax, no-continue\n        } else if ($test.call(/[^\\w$]/, key)) {\n            xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));\n        } else {\n            xs.push(key + ': ' + inspect(obj[key], obj));\n        }\n    }\n    if (typeof gOPS === 'function') {\n        for (var j = 0; j < syms.length; j++) {\n            if (isEnumerable.call(obj, syms[j])) {\n                xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));\n            }\n        }\n    }\n    return xs;\n}\n","'use strict';\n\nvar numberIsNaN = function (value) {\n\treturn value !== value;\n};\n\nmodule.exports = function is(a, b) {\n\tif (a === 0 && b === 0) {\n\t\treturn 1 / a === 1 / b;\n\t}\n\tif (a === b) {\n\t\treturn true;\n\t}\n\tif (numberIsNaN(a) && numberIsNaN(b)) {\n\t\treturn true;\n\t}\n\treturn false;\n};\n\n","'use strict';\n\nvar define = require('define-properties');\nvar callBind = require('call-bind');\n\nvar implementation = require('./implementation');\nvar getPolyfill = require('./polyfill');\nvar shim = require('./shim');\n\nvar polyfill = callBind(getPolyfill(), Object);\n\ndefine(polyfill, {\n\tgetPolyfill: getPolyfill,\n\timplementation: implementation,\n\tshim: shim\n});\n\nmodule.exports = polyfill;\n","'use strict';\n\nvar implementation = require('./implementation');\n\nmodule.exports = function getPolyfill() {\n\treturn typeof Object.is === 'function' ? Object.is : implementation;\n};\n","'use strict';\n\nvar getPolyfill = require('./polyfill');\nvar define = require('define-properties');\n\nmodule.exports = function shimObjectIs() {\n\tvar polyfill = getPolyfill();\n\tdefine(Object, { is: polyfill }, {\n\t\tis: function testObjectIs() {\n\t\t\treturn Object.is !== polyfill;\n\t\t}\n\t});\n\treturn polyfill;\n};\n","'use strict';\n\nvar keysShim;\nif (!Object.keys) {\n\t// modified from https://github.com/es-shims/es5-shim\n\tvar has = Object.prototype.hasOwnProperty;\n\tvar toStr = Object.prototype.toString;\n\tvar isArgs = require('./isArguments'); // eslint-disable-line global-require\n\tvar isEnumerable = Object.prototype.propertyIsEnumerable;\n\tvar hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');\n\tvar hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');\n\tvar dontEnums = [\n\t\t'toString',\n\t\t'toLocaleString',\n\t\t'valueOf',\n\t\t'hasOwnProperty',\n\t\t'isPrototypeOf',\n\t\t'propertyIsEnumerable',\n\t\t'constructor'\n\t];\n\tvar equalsConstructorPrototype = function (o) {\n\t\tvar ctor = o.constructor;\n\t\treturn ctor && ctor.prototype === o;\n\t};\n\tvar excludedKeys = {\n\t\t$applicationCache: true,\n\t\t$console: true,\n\t\t$external: true,\n\t\t$frame: true,\n\t\t$frameElement: true,\n\t\t$frames: true,\n\t\t$innerHeight: true,\n\t\t$innerWidth: true,\n\t\t$onmozfullscreenchange: true,\n\t\t$onmozfullscreenerror: true,\n\t\t$outerHeight: true,\n\t\t$outerWidth: true,\n\t\t$pageXOffset: true,\n\t\t$pageYOffset: true,\n\t\t$parent: true,\n\t\t$scrollLeft: true,\n\t\t$scrollTop: true,\n\t\t$scrollX: true,\n\t\t$scrollY: true,\n\t\t$self: true,\n\t\t$webkitIndexedDB: true,\n\t\t$webkitStorageInfo: true,\n\t\t$window: true\n\t};\n\tvar hasAutomationEqualityBug = (function () {\n\t\t/* global window */\n\t\tif (typeof window === 'undefined') { return false; }\n\t\tfor (var k in window) {\n\t\t\ttry {\n\t\t\t\tif (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tequalsConstructorPrototype(window[k]);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}());\n\tvar equalsConstructorPrototypeIfNotBuggy = function (o) {\n\t\t/* global window */\n\t\tif (typeof window === 'undefined' || !hasAutomationEqualityBug) {\n\t\t\treturn equalsConstructorPrototype(o);\n\t\t}\n\t\ttry {\n\t\t\treturn equalsConstructorPrototype(o);\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t};\n\n\tkeysShim = function keys(object) {\n\t\tvar isObject = object !== null && typeof object === 'object';\n\t\tvar isFunction = toStr.call(object) === '[object Function]';\n\t\tvar isArguments = isArgs(object);\n\t\tvar isString = isObject && toStr.call(object) === '[object String]';\n\t\tvar theKeys = [];\n\n\t\tif (!isObject && !isFunction && !isArguments) {\n\t\t\tthrow new TypeError('Object.keys called on a non-object');\n\t\t}\n\n\t\tvar skipProto = hasProtoEnumBug && isFunction;\n\t\tif (isString && object.length > 0 && !has.call(object, 0)) {\n\t\t\tfor (var i = 0; i < object.length; ++i) {\n\t\t\t\ttheKeys.push(String(i));\n\t\t\t}\n\t\t}\n\n\t\tif (isArguments && object.length > 0) {\n\t\t\tfor (var j = 0; j < object.length; ++j) {\n\t\t\t\ttheKeys.push(String(j));\n\t\t\t}\n\t\t} else {\n\t\t\tfor (var name in object) {\n\t\t\t\tif (!(skipProto && name === 'prototype') && has.call(object, name)) {\n\t\t\t\t\ttheKeys.push(String(name));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (hasDontEnumBug) {\n\t\t\tvar skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);\n\n\t\t\tfor (var k = 0; k < dontEnums.length; ++k) {\n\t\t\t\tif (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {\n\t\t\t\t\ttheKeys.push(dontEnums[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn theKeys;\n\t};\n}\nmodule.exports = keysShim;\n","'use strict';\n\nvar slice = Array.prototype.slice;\nvar isArgs = require('./isArguments');\n\nvar origKeys = Object.keys;\nvar keysShim = origKeys ? function keys(o) { return origKeys(o); } : require('./implementation');\n\nvar originalKeys = Object.keys;\n\nkeysShim.shim = function shimObjectKeys() {\n\tif (Object.keys) {\n\t\tvar keysWorksWithArguments = (function () {\n\t\t\t// Safari 5.0 bug\n\t\t\tvar args = Object.keys(arguments);\n\t\t\treturn args && args.length === arguments.length;\n\t\t}(1, 2));\n\t\tif (!keysWorksWithArguments) {\n\t\t\tObject.keys = function keys(object) { // eslint-disable-line func-name-matching\n\t\t\t\tif (isArgs(object)) {\n\t\t\t\t\treturn originalKeys(slice.call(object));\n\t\t\t\t}\n\t\t\t\treturn originalKeys(object);\n\t\t\t};\n\t\t}\n\t} else {\n\t\tObject.keys = keysShim;\n\t}\n\treturn Object.keys || keysShim;\n};\n\nmodule.exports = keysShim;\n","'use strict';\n\nvar toStr = Object.prototype.toString;\n\nmodule.exports = function isArguments(value) {\n\tvar str = toStr.call(value);\n\tvar isArgs = str === '[object Arguments]';\n\tif (!isArgs) {\n\t\tisArgs = str !== '[object Array]' &&\n\t\t\tvalue !== null &&\n\t\t\ttypeof value === 'object' &&\n\t\t\ttypeof value.length === 'number' &&\n\t\t\tvalue.length >= 0 &&\n\t\t\ttoStr.call(value.callee) === '[object Function]';\n\t}\n\treturn isArgs;\n};\n","'use strict';\n\n// modified from https://github.com/es-shims/es6-shim\nvar objectKeys = require('object-keys');\nvar hasSymbols = require('has-symbols/shams')();\nvar callBound = require('call-bind/callBound');\nvar toObject = Object;\nvar $push = callBound('Array.prototype.push');\nvar $propIsEnumerable = callBound('Object.prototype.propertyIsEnumerable');\nvar originalGetSymbols = hasSymbols ? Object.getOwnPropertySymbols : null;\n\n// eslint-disable-next-line no-unused-vars\nmodule.exports = function assign(target, source1) {\n\tif (target == null) { throw new TypeError('target must be an object'); }\n\tvar to = toObject(target); // step 1\n\tif (arguments.length === 1) {\n\t\treturn to; // step 2\n\t}\n\tfor (var s = 1; s < arguments.length; ++s) {\n\t\tvar from = toObject(arguments[s]); // step 3.a.i\n\n\t\t// step 3.a.ii:\n\t\tvar keys = objectKeys(from);\n\t\tvar getSymbols = hasSymbols && (Object.getOwnPropertySymbols || originalGetSymbols);\n\t\tif (getSymbols) {\n\t\t\tvar syms = getSymbols(from);\n\t\t\tfor (var j = 0; j < syms.length; ++j) {\n\t\t\t\tvar key = syms[j];\n\t\t\t\tif ($propIsEnumerable(from, key)) {\n\t\t\t\t\t$push(keys, key);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// step 3.a.iii:\n\t\tfor (var i = 0; i < keys.length; ++i) {\n\t\t\tvar nextKey = keys[i];\n\t\t\tif ($propIsEnumerable(from, nextKey)) { // step 3.a.iii.2\n\t\t\t\tvar propValue = from[nextKey]; // step 3.a.iii.2.a\n\t\t\t\tto[nextKey] = propValue; // step 3.a.iii.2.b\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to; // step 4\n};\n","'use strict';\n\nvar defineProperties = require('define-properties');\nvar callBind = require('call-bind');\n\nvar implementation = require('./implementation');\nvar getPolyfill = require('./polyfill');\nvar shim = require('./shim');\n\nvar polyfill = callBind.apply(getPolyfill());\n// eslint-disable-next-line no-unused-vars\nvar bound = function assign(target, source1) {\n\treturn polyfill(Object, arguments);\n};\n\ndefineProperties(bound, {\n\tgetPolyfill: getPolyfill,\n\timplementation: implementation,\n\tshim: shim\n});\n\nmodule.exports = bound;\n","'use strict';\n\nvar implementation = require('./implementation');\n\nvar lacksProperEnumerationOrder = function () {\n\tif (!Object.assign) {\n\t\treturn false;\n\t}\n\t/*\n\t * v8, specifically in node 4.x, has a bug with incorrect property enumeration order\n\t * note: this does not detect the bug unless there's 20 characters\n\t */\n\tvar str = 'abcdefghijklmnopqrst';\n\tvar letters = str.split('');\n\tvar map = {};\n\tfor (var i = 0; i < letters.length; ++i) {\n\t\tmap[letters[i]] = letters[i];\n\t}\n\tvar obj = Object.assign({}, map);\n\tvar actual = '';\n\tfor (var k in obj) {\n\t\tactual += k;\n\t}\n\treturn str !== actual;\n};\n\nvar assignHasPendingExceptions = function () {\n\tif (!Object.assign || !Object.preventExtensions) {\n\t\treturn false;\n\t}\n\t/*\n\t * Firefox 37 still has \"pending exception\" logic in its Object.assign implementation,\n\t * which is 72% slower than our shim, and Firefox 40's native implementation.\n\t */\n\tvar thrower = Object.preventExtensions({ 1: 2 });\n\ttry {\n\t\tObject.assign(thrower, 'xy');\n\t} catch (e) {\n\t\treturn thrower[1] === 'y';\n\t}\n\treturn false;\n};\n\nmodule.exports = function getPolyfill() {\n\tif (!Object.assign) {\n\t\treturn implementation;\n\t}\n\tif (lacksProperEnumerationOrder()) {\n\t\treturn implementation;\n\t}\n\tif (assignHasPendingExceptions()) {\n\t\treturn implementation;\n\t}\n\treturn Object.assign;\n};\n","'use strict';\n\nvar define = require('define-properties');\nvar getPolyfill = require('./polyfill');\n\nmodule.exports = function shimAssign() {\n\tvar polyfill = getPolyfill();\n\tdefine(\n\t\tObject,\n\t\t{ assign: polyfill },\n\t\t{ assign: function () { return Object.assign !== polyfill; } }\n\t);\n\treturn polyfill;\n};\n","'use strict';\n\nvar functionsHaveConfigurableNames = require('functions-have-names').functionsHaveConfigurableNames();\n\nvar $Object = Object;\nvar $TypeError = TypeError;\n\nmodule.exports = function flags() {\n\tif (this != null && this !== $Object(this)) {\n\t\tthrow new $TypeError('RegExp.prototype.flags getter called on non-object');\n\t}\n\tvar result = '';\n\tif (this.hasIndices) {\n\t\tresult += 'd';\n\t}\n\tif (this.global) {\n\t\tresult += 'g';\n\t}\n\tif (this.ignoreCase) {\n\t\tresult += 'i';\n\t}\n\tif (this.multiline) {\n\t\tresult += 'm';\n\t}\n\tif (this.dotAll) {\n\t\tresult += 's';\n\t}\n\tif (this.unicode) {\n\t\tresult += 'u';\n\t}\n\tif (this.sticky) {\n\t\tresult += 'y';\n\t}\n\treturn result;\n};\n\nif (functionsHaveConfigurableNames && Object.defineProperty) {\n\tObject.defineProperty(module.exports, 'name', { value: 'get flags' });\n}\n","'use strict';\n\nvar define = require('define-properties');\nvar callBind = require('call-bind');\n\nvar implementation = require('./implementation');\nvar getPolyfill = require('./polyfill');\nvar shim = require('./shim');\n\nvar flagsBound = callBind(getPolyfill());\n\ndefine(flagsBound, {\n\tgetPolyfill: getPolyfill,\n\timplementation: implementation,\n\tshim: shim\n});\n\nmodule.exports = flagsBound;\n","'use strict';\n\nvar implementation = require('./implementation');\n\nvar supportsDescriptors = require('define-properties').supportsDescriptors;\nvar $gOPD = Object.getOwnPropertyDescriptor;\n\nmodule.exports = function getPolyfill() {\n\tif (supportsDescriptors && (/a/mig).flags === 'gim') {\n\t\tvar descriptor = $gOPD(RegExp.prototype, 'flags');\n\t\tif (\n\t\t\tdescriptor\n\t\t\t&& typeof descriptor.get === 'function'\n\t\t\t&& typeof RegExp.prototype.dotAll === 'boolean'\n\t\t\t&& typeof RegExp.prototype.hasIndices === 'boolean'\n\t\t) {\n\t\t\t/* eslint getter-return: 0 */\n\t\t\tvar calls = '';\n\t\t\tvar o = {};\n\t\t\tObject.defineProperty(o, 'hasIndices', {\n\t\t\t\tget: function () {\n\t\t\t\t\tcalls += 'd';\n\t\t\t\t}\n\t\t\t});\n\t\t\tObject.defineProperty(o, 'sticky', {\n\t\t\t\tget: function () {\n\t\t\t\t\tcalls += 'y';\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (calls === 'dy') {\n\t\t\t\treturn descriptor.get;\n\t\t\t}\n\t\t}\n\t}\n\treturn implementation;\n};\n","'use strict';\n\nvar supportsDescriptors = require('define-properties').supportsDescriptors;\nvar getPolyfill = require('./polyfill');\nvar gOPD = Object.getOwnPropertyDescriptor;\nvar defineProperty = Object.defineProperty;\nvar TypeErr = TypeError;\nvar getProto = Object.getPrototypeOf;\nvar regex = /a/;\n\nmodule.exports = function shimFlags() {\n\tif (!supportsDescriptors || !getProto) {\n\t\tthrow new TypeErr('RegExp.prototype.flags requires a true ES5 environment that supports property descriptors');\n\t}\n\tvar polyfill = getPolyfill();\n\tvar proto = getProto(regex);\n\tvar descriptor = gOPD(proto, 'flags');\n\tif (!descriptor || descriptor.get !== polyfill) {\n\t\tdefineProperty(proto, 'flags', {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: false,\n\t\t\tget: polyfill\n\t\t});\n\t}\n\treturn polyfill;\n};\n","'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\nvar callBound = require('call-bind/callBound');\nvar inspect = require('object-inspect');\n\nvar $TypeError = GetIntrinsic('%TypeError%');\nvar $WeakMap = GetIntrinsic('%WeakMap%', true);\nvar $Map = GetIntrinsic('%Map%', true);\n\nvar $weakMapGet = callBound('WeakMap.prototype.get', true);\nvar $weakMapSet = callBound('WeakMap.prototype.set', true);\nvar $weakMapHas = callBound('WeakMap.prototype.has', true);\nvar $mapGet = callBound('Map.prototype.get', true);\nvar $mapSet = callBound('Map.prototype.set', true);\nvar $mapHas = callBound('Map.prototype.has', true);\n\n/*\n * This function traverses the list returning the node corresponding to the\n * given key.\n *\n * That node is also moved to the head of the list, so that if it's accessed\n * again we don't need to traverse the whole list. By doing so, all the recently\n * used nodes can be accessed relatively quickly.\n */\nvar listGetNode = function (list, key) { // eslint-disable-line consistent-return\n\tfor (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {\n\t\tif (curr.key === key) {\n\t\t\tprev.next = curr.next;\n\t\t\tcurr.next = list.next;\n\t\t\tlist.next = curr; // eslint-disable-line no-param-reassign\n\t\t\treturn curr;\n\t\t}\n\t}\n};\n\nvar listGet = function (objects, key) {\n\tvar node = listGetNode(objects, key);\n\treturn node && node.value;\n};\nvar listSet = function (objects, key, value) {\n\tvar node = listGetNode(objects, key);\n\tif (node) {\n\t\tnode.value = value;\n\t} else {\n\t\t// Prepend the new node to the beginning of the list\n\t\tobjects.next = { // eslint-disable-line no-param-reassign\n\t\t\tkey: key,\n\t\t\tnext: objects.next,\n\t\t\tvalue: value\n\t\t};\n\t}\n};\nvar listHas = function (objects, key) {\n\treturn !!listGetNode(objects, key);\n};\n\nmodule.exports = function getSideChannel() {\n\tvar $wm;\n\tvar $m;\n\tvar $o;\n\tvar channel = {\n\t\tassert: function (key) {\n\t\t\tif (!channel.has(key)) {\n\t\t\t\tthrow new $TypeError('Side channel does not contain ' + inspect(key));\n\t\t\t}\n\t\t},\n\t\tget: function (key) { // eslint-disable-line consistent-return\n\t\t\tif ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {\n\t\t\t\tif ($wm) {\n\t\t\t\t\treturn $weakMapGet($wm, key);\n\t\t\t\t}\n\t\t\t} else if ($Map) {\n\t\t\t\tif ($m) {\n\t\t\t\t\treturn $mapGet($m, key);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ($o) { // eslint-disable-line no-lonely-if\n\t\t\t\t\treturn listGet($o, key);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\thas: function (key) {\n\t\t\tif ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {\n\t\t\t\tif ($wm) {\n\t\t\t\t\treturn $weakMapHas($wm, key);\n\t\t\t\t}\n\t\t\t} else if ($Map) {\n\t\t\t\tif ($m) {\n\t\t\t\t\treturn $mapHas($m, key);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ($o) { // eslint-disable-line no-lonely-if\n\t\t\t\t\treturn listHas($o, key);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\tset: function (key, value) {\n\t\t\tif ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {\n\t\t\t\tif (!$wm) {\n\t\t\t\t\t$wm = new $WeakMap();\n\t\t\t\t}\n\t\t\t\t$weakMapSet($wm, key, value);\n\t\t\t} else if ($Map) {\n\t\t\t\tif (!$m) {\n\t\t\t\t\t$m = new $Map();\n\t\t\t\t}\n\t\t\t\t$mapSet($m, key, value);\n\t\t\t} else {\n\t\t\t\tif (!$o) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Initialize the linked list as an empty node, so that we don't have\n\t\t\t\t\t * to special-case handling of the first node: we can always refer to\n\t\t\t\t\t * it as (previous node).next, instead of something like (list).head\n\t\t\t\t\t */\n\t\t\t\t\t$o = { key: {}, next: null };\n\t\t\t\t}\n\t\t\t\tlistSet($o, key, value);\n\t\t\t}\n\t\t}\n\t};\n\treturn channel;\n};\n","'use strict';\n\nvar isString = require('is-string');\nvar isNumber = require('is-number-object');\nvar isBoolean = require('is-boolean-object');\nvar isSymbol = require('is-symbol');\nvar isBigInt = require('is-bigint');\n\n// eslint-disable-next-line consistent-return\nmodule.exports = function whichBoxedPrimitive(value) {\n\t// eslint-disable-next-line eqeqeq\n\tif (value == null || (typeof value !== 'object' && typeof value !== 'function')) {\n\t\treturn null;\n\t}\n\tif (isString(value)) {\n\t\treturn 'String';\n\t}\n\tif (isNumber(value)) {\n\t\treturn 'Number';\n\t}\n\tif (isBoolean(value)) {\n\t\treturn 'Boolean';\n\t}\n\tif (isSymbol(value)) {\n\t\treturn 'Symbol';\n\t}\n\tif (isBigInt(value)) {\n\t\treturn 'BigInt';\n\t}\n};\n","'use strict';\n\nvar forEach = require('for-each');\nvar availableTypedArrays = require('available-typed-arrays');\nvar callBound = require('call-bind/callBound');\n\nvar $toString = callBound('Object.prototype.toString');\nvar hasToStringTag = require('has-tostringtag/shams')();\n\nvar g = typeof globalThis === 'undefined' ? global : globalThis;\nvar typedArrays = availableTypedArrays();\n\nvar $slice = callBound('String.prototype.slice');\nvar toStrTags = {};\nvar gOPD = require('es-abstract/helpers/getOwnPropertyDescriptor');\nvar getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');\nif (hasToStringTag && gOPD && getPrototypeOf) {\n\tforEach(typedArrays, function (typedArray) {\n\t\tif (typeof g[typedArray] === 'function') {\n\t\t\tvar arr = new g[typedArray]();\n\t\t\tif (Symbol.toStringTag in arr) {\n\t\t\t\tvar proto = getPrototypeOf(arr);\n\t\t\t\tvar descriptor = gOPD(proto, Symbol.toStringTag);\n\t\t\t\tif (!descriptor) {\n\t\t\t\t\tvar superProto = getPrototypeOf(proto);\n\t\t\t\t\tdescriptor = gOPD(superProto, Symbol.toStringTag);\n\t\t\t\t}\n\t\t\t\ttoStrTags[typedArray] = descriptor.get;\n\t\t\t}\n\t\t}\n\t});\n}\n\nvar tryTypedArrays = function tryAllTypedArrays(value) {\n\tvar foundName = false;\n\tforEach(toStrTags, function (getter, typedArray) {\n\t\tif (!foundName) {\n\t\t\ttry {\n\t\t\t\tvar name = getter.call(value);\n\t\t\t\tif (name === typedArray) {\n\t\t\t\t\tfoundName = name;\n\t\t\t\t}\n\t\t\t} catch (e) {}\n\t\t}\n\t});\n\treturn foundName;\n};\n\nvar isTypedArray = require('is-typed-array');\n\nmodule.exports = function whichTypedArray(value) {\n\tif (!isTypedArray(value)) { return false; }\n\tif (!hasToStringTag || !(Symbol.toStringTag in value)) { return $slice($toString(value), 8, -1); }\n\treturn tryTypedArrays(value);\n};\n","module.exports = LForms.ucumPkg;","'use strict';\n\nvar possibleNames = [\n\t'BigInt64Array',\n\t'BigUint64Array',\n\t'Float32Array',\n\t'Float64Array',\n\t'Int16Array',\n\t'Int32Array',\n\t'Int8Array',\n\t'Uint16Array',\n\t'Uint32Array',\n\t'Uint8Array',\n\t'Uint8ClampedArray'\n];\n\nvar g = typeof globalThis === 'undefined' ? global : globalThis;\n\nmodule.exports = function availableTypedArrays() {\n\tvar out = [];\n\tfor (var i = 0; i < possibleNames.length; i++) {\n\t\tif (typeof g[possibleNames[i]] === 'function') {\n\t\t\tout[out.length] = possibleNames[i];\n\t\t}\n\t}\n\treturn out;\n};\n","'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\n\nvar $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);\nif ($gOPD) {\n\ttry {\n\t\t$gOPD([], 'length');\n\t} catch (e) {\n\t\t// IE 8 has a broken gOPD\n\t\t$gOPD = null;\n\t}\n}\n\nmodule.exports = $gOPD;\n","'use strict';\n\n/* eslint global-require: 0 */\n// the code is structured this way so that bundlers can\n// alias out `has-symbols` to `() => true` or `() => false` if your target\n// environments' Symbol capabilities are known, and then use\n// dead code elimination on the rest of this module.\n//\n// Similarly, `isarray` can be aliased to `Array.isArray` if\n// available in all target environments.\n\nvar isArguments = require('is-arguments');\n\nif (require('has-symbols')() || require('has-symbols/shams')()) {\n\tvar $iterator = Symbol.iterator;\n\t// Symbol is available natively or shammed\n\t// natively:\n\t//  - Chrome >= 38\n\t//  - Edge 12-14?, Edge >= 15 for sure\n\t//  - FF >= 36\n\t//  - Safari >= 9\n\t//  - node >= 0.12\n\tmodule.exports = function getIterator(iterable) {\n\t\t// alternatively, `iterable[$iterator]?.()`\n\t\tif (iterable != null && typeof iterable[$iterator] !== 'undefined') {\n\t\t\treturn iterable[$iterator]();\n\t\t}\n\t\tif (isArguments(iterable)) {\n\t\t\t// arguments objects lack Symbol.iterator\n\t\t\t// - node 0.12\n\t\t\treturn Array.prototype[$iterator].call(iterable);\n\t\t}\n\t};\n} else {\n\t// Symbol is not available, native or shammed\n\tvar isArray = require('isarray');\n\tvar isString = require('is-string');\n\tvar GetIntrinsic = require('get-intrinsic');\n\tvar $Map = GetIntrinsic('%Map%', true);\n\tvar $Set = GetIntrinsic('%Set%', true);\n\tvar callBound = require('call-bind/callBound');\n\tvar $arrayPush = callBound('Array.prototype.push');\n\tvar $charCodeAt = callBound('String.prototype.charCodeAt');\n\tvar $stringSlice = callBound('String.prototype.slice');\n\n\tvar advanceStringIndex = function advanceStringIndex(S, index) {\n\t\tvar length = S.length;\n\t\tif ((index + 1) >= length) {\n\t\t\treturn index + 1;\n\t\t}\n\n\t\tvar first = $charCodeAt(S, index);\n\t\tif (first < 0xD800 || first > 0xDBFF) {\n\t\t\treturn index + 1;\n\t\t}\n\n\t\tvar second = $charCodeAt(S, index + 1);\n\t\tif (second < 0xDC00 || second > 0xDFFF) {\n\t\t\treturn index + 1;\n\t\t}\n\n\t\treturn index + 2;\n\t};\n\n\tvar getArrayIterator = function getArrayIterator(arraylike) {\n\t\tvar i = 0;\n\t\treturn {\n\t\t\tnext: function next() {\n\t\t\t\tvar done = i >= arraylike.length;\n\t\t\t\tvar value;\n\t\t\t\tif (!done) {\n\t\t\t\t\tvalue = arraylike[i];\n\t\t\t\t\ti += 1;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tdone: done,\n\t\t\t\t\tvalue: value\n\t\t\t\t};\n\t\t\t}\n\t\t};\n\t};\n\n\tvar getNonCollectionIterator = function getNonCollectionIterator(iterable, noPrimordialCollections) {\n\t\tif (isArray(iterable) || isArguments(iterable)) {\n\t\t\treturn getArrayIterator(iterable);\n\t\t}\n\t\tif (isString(iterable)) {\n\t\t\tvar i = 0;\n\t\t\treturn {\n\t\t\t\tnext: function next() {\n\t\t\t\t\tvar nextIndex = advanceStringIndex(iterable, i);\n\t\t\t\t\tvar value = $stringSlice(iterable, i, nextIndex);\n\t\t\t\t\ti = nextIndex;\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdone: nextIndex > iterable.length,\n\t\t\t\t\t\tvalue: value\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\t// es6-shim and es-shims' es-map use a string \"_es6-shim iterator_\" property on different iterables, such as MapIterator.\n\t\tif (noPrimordialCollections && typeof iterable['_es6-shim iterator_'] !== 'undefined') {\n\t\t\treturn iterable['_es6-shim iterator_']();\n\t\t}\n\t};\n\n\tif (!$Map && !$Set) {\n\t\t// the only language iterables are Array, String, arguments\n\t\t// - Safari <= 6.0\n\t\t// - Chrome < 38\n\t\t// - node < 0.12\n\t\t// - FF < 13\n\t\t// - IE < 11\n\t\t// - Edge < 11\n\n\t\tmodule.exports = function getIterator(iterable) {\n\t\t\tif (iterable != null) {\n\t\t\t\treturn getNonCollectionIterator(iterable, true);\n\t\t\t}\n\t\t};\n\t} else {\n\t\t// either Map or Set are available, but Symbol is not\n\t\t// - es6-shim on an ES5 browser\n\t\t// - Safari 6.2 (maybe 6.1?)\n\t\t// - FF v[13, 36)\n\t\t// - IE 11\n\t\t// - Edge 11\n\t\t// - Safari v[6, 9)\n\n\t\tvar isMap = require('is-map');\n\t\tvar isSet = require('is-set');\n\n\t\t// Firefox >= 27, IE 11, Safari 6.2 - 9, Edge 11, es6-shim in older envs, all have forEach\n\t\tvar $mapForEach = callBound('Map.prototype.forEach', true);\n\t\tvar $setForEach = callBound('Set.prototype.forEach', true);\n\t\tif (typeof process === 'undefined' || !process.versions || !process.versions.node) { // \"if is not node\"\n\n\t\t\t// Firefox 17 - 26 has `.iterator()`, whose iterator `.next()` either\n\t\t\t// returns a value, or throws a StopIteration object. These browsers\n\t\t\t// do not have any other mechanism for iteration.\n\t\t\tvar $mapIterator = callBound('Map.prototype.iterator', true);\n\t\t\tvar $setIterator = callBound('Set.prototype.iterator', true);\n\t\t\tvar getStopIterationIterator = function (iterator) {\n\t\t\t\tvar done = false;\n\t\t\t\treturn {\n\t\t\t\t\tnext: function next() {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tdone: done,\n\t\t\t\t\t\t\t\tvalue: done ? undefined : iterator.next()\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tdone = true;\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tdone: true,\n\t\t\t\t\t\t\t\tvalue: undefined\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\t\t}\n\t\t// Firefox 27-35, and some older es6-shim versions, use a string \"@@iterator\" property\n\t\t// this returns a proper iterator object, so we should use it instead of forEach.\n\t\t// newer es6-shim versions use a string \"_es6-shim iterator_\" property.\n\t\tvar $mapAtAtIterator = callBound('Map.prototype.@@iterator', true) || callBound('Map.prototype._es6-shim iterator_', true);\n\t\tvar $setAtAtIterator = callBound('Set.prototype.@@iterator', true) || callBound('Set.prototype._es6-shim iterator_', true);\n\n\t\tvar getCollectionIterator = function getCollectionIterator(iterable) {\n\t\t\tif (isMap(iterable)) {\n\t\t\t\tif ($mapIterator) {\n\t\t\t\t\treturn getStopIterationIterator($mapIterator(iterable));\n\t\t\t\t}\n\t\t\t\tif ($mapAtAtIterator) {\n\t\t\t\t\treturn $mapAtAtIterator(iterable);\n\t\t\t\t}\n\t\t\t\tif ($mapForEach) {\n\t\t\t\t\tvar entries = [];\n\t\t\t\t\t$mapForEach(iterable, function (v, k) {\n\t\t\t\t\t\t$arrayPush(entries, [k, v]);\n\t\t\t\t\t});\n\t\t\t\t\treturn getArrayIterator(entries);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isSet(iterable)) {\n\t\t\t\tif ($setIterator) {\n\t\t\t\t\treturn getStopIterationIterator($setIterator(iterable));\n\t\t\t\t}\n\t\t\t\tif ($setAtAtIterator) {\n\t\t\t\t\treturn $setAtAtIterator(iterable);\n\t\t\t\t}\n\t\t\t\tif ($setForEach) {\n\t\t\t\t\tvar values = [];\n\t\t\t\t\t$setForEach(iterable, function (v) {\n\t\t\t\t\t\t$arrayPush(values, v);\n\t\t\t\t\t});\n\t\t\t\t\treturn getArrayIterator(values);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tmodule.exports = function getIterator(iterable) {\n\t\t\treturn getCollectionIterator(iterable) || getNonCollectionIterator(iterable);\n\t\t};\n\t}\n}\n","'use strict';\n\nvar isMap = require('is-map');\nvar isSet = require('is-set');\nvar isWeakMap = require('is-weakmap');\nvar isWeakSet = require('is-weakset');\n\nmodule.exports = function whichCollection(value) {\n\tif (value && typeof value === 'object') {\n\t\tif (isMap(value)) {\n\t\t\treturn 'Map';\n\t\t}\n\t\tif (isSet(value)) {\n\t\t\treturn 'Set';\n\t\t}\n\t\tif (isWeakMap(value)) {\n\t\t\treturn 'WeakMap';\n\t\t}\n\t\tif (isWeakSet(value)) {\n\t\t\treturn 'WeakSet';\n\t\t}\n\t}\n\treturn false;\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = function(module) {\n\tvar getter = module && module.__esModule ?\n\t\tfunction() { return module['default']; } :\n\t\tfunction() { return module; };\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","/*\n *  Defines import functions that are the same across the different FHIR\n *  versions and that are used by both the SDC and DiagnosticReport imports.\n */\n\n\n/**\n *  Converts a FHIR Quantity to the an an LForms equivalent-- essentially, the\n *  unit object plus 'value' field.\n * @param quantity the quantity to be converted.\n * @return the quantity data with field labels appropriate for LForms.\n */\nexport function importFHIRQuantity(quantity) {\n  const rtn = {_type: 'Quantity',\n    value: quantity.value\n  };\n  const unitOrCode = quantity.unit || quantity.code;\n  if (unitOrCode) {\n    rtn.name = unitOrCode; // in some data 'unit' is undefined\n    if (quantity.code)\n      rtn.code = quantity.code;\n    if (quantity.system)\n      rtn.system = quantity.system;\n  }\n  return rtn;\n}\n\n","import {importFHIRQuantity} from './import-common.js'\n\n/**\n * A package to handle FHIR DiagnosticReport for LForms\n * https://www.hl7.org/fhir/diagnosticreport.html\n *\n * Note that this was written for DSTU2 and has not been updated.\n *\n * It provides the following functions:\n * createDiagnosticReport()\n * -- Convert existing LOINC panels/forms data in LForms format into FHIR DiagnosticReport data\n * mergeDiagnosticReportToLForms()\n * -- Merge FHIR SDC DiagnosticReport data into corresponding LForms data\n */\n\nvar dr = {\n\n  // a prefix for references to Observation resources\n  _OBX_REF_PREFIX: \"Observation/\",\n\n\n  /**\n   * Functions for creating a DiagnosticReport instance from an LFormsData object\n   */\n\n  /** Get date in a standard string format\n   * @param dateObj, a date object\n   * @returns {string} a formatted date string\n   * @private\n   */\n  _getFormattedDate : function (dateObj) {\n    //\"2013-01-27T11:45:33+11:00\",\n    return dateObj ? LForms.Util.dateToDTMString(dateObj) : \"\";\n  },\n\n\n  /**\n   * A recursive function that generates the DiagnosticReport content by\n   * going through the LForms form data structure\n   * @param item an LForms item\n   * @param contained the \"contained\" field in a DiagnosticReport where all the Observation instances are kept.\n   * @returns {{result: Array, resultObj: Array}} the content part of a Diagnostic Report instance\n   * @private\n   */\n  _createDiagnosticReportContent : function (item, contained) {\n    // return the content of \"result\" and \"contained\"\n    var content = {\n      result: [],\n      resultObj: []\n    };\n\n    for(var i=0, iLen=item.items.length; i<iLen; i++) {\n      var subItem = item.items[i];\n      if (subItem) {\n        var obx = this._commonExport._createObservation(subItem, true);\n        if (subItem.items && subItem.items.length>0) {\n          // single obx returned if it is a header item\n          obx[0].related = [];\n          var ret = this._createDiagnosticReportContent(subItem, contained);\n          for(var j=0, jLen=ret.result.length; j<jLen; j++) {\n            var subObxRef = ret.result[j];\n            obx[0].related.push({\n              type: \"has-member\",\n              target: {\n                reference: subObxRef.reference\n              }\n            });\n          }\n        }\n        for (var l=0, lLen=obx.length; l<lLen; l++) {\n          contained.push(obx[l]);\n          content.result.push({\n            reference: \"#\" + obx[l].id\n          });\n          content.resultObj.push(obx[l]);\n        }\n      }\n    }\n    return content;\n  },\n\n\n  /**\n   * Convert a DiagnosticReport resource with contained Observation resources to\n   * a FHIR Bundle resource that includes a DiagnosticReport resource and associated Observation resources\n   * @param dr a DiagnosticReport resource with contained Observation resources\n   * @param bundleType the FHIR Bundle type. Only \"transaction\" and \"collection\" types are allowed.\n   * @returns {{}} a Bundle resource that includes a DiagnosticReport resource and associated Observation resources\n   */\n  _convertFromContainedToBundle: function (dr, bundleType) {\n    var bundleDr = {};\n\n    // default bundleType\n    if (!bundleType) {\n      bundleType = \"transaction\";\n    }\n    if (dr) {\n      switch(bundleType) {\n        case \"transaction\":\n          bundleDr = this._convertContainedToTransactionBundle(dr);\n          break;\n        case \"collection\":\n          bundleDr = this._convertContainedToCollectionBundle(dr);\n          break;\n        default:\n          console.log(\"Bundle type not supported: \" + bundleType);\n      }\n    }\n    return bundleDr;\n  },\n\n\n  /**\n   * Convert a DiagnosticReport resource with contained Observation resources to\n   * a FHIR \"transaction\" typed Bundle resource that includes a DiagnosticReport resource\n   * and associated Observation resources\n   * @param dr a DiagnosticReport resource with contained Observation resources\n   * @returns {{}} a Bundle resource that includes a DiagnosticReport resource and associated Observation resources\n   * @private\n   */\n  _convertContainedToTransactionBundle: function(dr) {\n\n    var bundleDr = {\n      resourceType:\"Bundle\",\n      type: \"transaction\",\n      entry: []\n    };\n\n    var contained = dr.contained;\n    delete dr.contained;\n\n    // update reference to Observation resources\n    for (var i=0, iLen=dr.result.length; i<iLen; i++) {\n      var ref = dr.result[i];\n      ref.reference = this._OBX_REF_PREFIX + ref.reference.slice(1);\n    }\n    // add DiagnosticReport resource into Bundle entry\n    bundleDr.entry.push({\n      resource: dr,\n      request: {\n        method: \"POST\",\n        url: \"DiagnosticReport\"\n      }\n    });\n\n    // add Observation resources into Bundle entry\n    for (var j=0, jLen=contained.length; j<jLen; j++) {\n      var res = contained[j];\n\n      // if it has related Observation resources (as it is a section in LForms)\n      // update values of the references to the related Observation resources\n      if (res.related) {\n        for (var k=0, kLen=res.related.length; k<kLen; k++) {\n          var targetObservation = res.related[k];\n          targetObservation.target.reference = this._OBX_REF_PREFIX + targetObservation.target.reference.slice(1);\n        }\n      }\n\n      // add to the Bundle entry\n      bundleDr.entry.push({\n        resource: res,\n        request: {\n          method: \"POST\",\n          url: \"Observation\"\n        }\n      });\n    }\n\n    return bundleDr;\n  },\n\n\n  /**\n   * Convert a DiagnosticReport resource with contained Observation resources to\n   * a FHIR \"collection\" typed Bundle resource that includes a DiagnosticReport resource\n   * and associated Observation resources\n   * @param dr a DiagnosticReport resource with contained Observation resources\n   * @returns {{}} a Bundle resource that includes a DiagnosticReport resource and associated Observation resources\n   * @private\n   */\n  _convertContainedToCollectionBundle: function(dr) {\n    var bundleDr = {\n      resourceType:\"Bundle\",\n      type: \"collection\",\n      entry: []\n    };\n\n    var contained = dr.contained;\n    delete dr.contained;\n\n    // add DiagnosticReport resource into Bundle entry\n    bundleDr.entry.push({\n      resource: dr\n    });\n\n    // add Observation resources into Bundle entry\n    for (var j=0, jLen=contained.length; j<jLen; j++) {\n      var res = contained[j];\n      // add to the Bundle entry\n      bundleDr.entry.push({\n        resource: res\n      });\n    }\n\n    return bundleDr;\n  },\n\n\n  /**\n   * Generate FHIR DiagnosticReport data from an LForms form data\n   * @param formData an LFormsData object\n   * @param subject optional, A local FHIR resource that is the subject for this\n   *  DiagnoticReport.\n   * @param inBundle optional, a flag that a DiagnosticReport resources and associated Observation resources\n   *        should be placed into a FHIR Bundle. The default is false.\n   * @param bundleType, optional, the FHIR Bundle type if inBundle is true.\n   *        Only \"transaction\" and \"collection\" types are allowed.\n   * @returns {{}} a Diagnostic Report instance\n   */\n  createDiagnosticReport : function(formData, subject, inBundle, bundleType) {\n    var dr = null, contained =[];\n    if (formData) {\n\n      var formAndUserData = formData.getFormData(true,true,true);\n\n      var drContent = this._createDiagnosticReportContent(formAndUserData, contained);\n\n      dr = {\n        resourceType: \"DiagnosticReport\",\n        id: this._commonExport._getUniqueId(formAndUserData.code),\n        status: \"final\",\n        code: {\n          \"coding\": [\n            {\n              \"system\": \"http://loinc.org\",\n              \"code\": formAndUserData.code,\n              \"display\": formAndUserData.name\n            }\n          ],\n          \"text\": formAndUserData.name\n        },\n        result: drContent.result,\n        contained: contained\n      };\n      this._commonExport._addVersionTag(dr);\n\n      if (subject)\n        dr.subject = LForms.Util.createLocalFHIRReference(subject);\n\n      // issued\n      dr[\"issued\"] = this._getFormattedDate(new Date());\n    }\n\n    var ret = inBundle ? this._convertFromContainedToBundle(dr, bundleType) : dr;\n    LForms.Util.pruneNulls(ret);\n    return ret;\n  },\n\n\n  /**\n   * Functions for merging a DiagnosticReport instance into an LFormsData object\n   */\n\n  /**\n   * Find an observation from the \"contained\" list by an observation id\n   * @param refId an observation instance's id\n   * @param contained the \"contained\" field in a DiagnosticReport instance\n   * @returns {{}} an observation instance\n   * @private\n   */\n  _findObxById : function(refId, contained) {\n    var obx = null;\n    if (refId) {\n      var id = refId[0] === \"#\" ? refId.slice(1) : refId;\n      for(var i=0, iLen=contained.length; i<iLen; i++) {\n        if (contained[i].id === id) {\n          obx = contained[i];\n          break;\n        }\n      }\n    }\n    return obx;\n  },\n\n\n  /**\n   * Merge an Observation instance into an item object\n   * @param obx an observation instance\n   * @param item an item in an LForms object\n   * @private\n   */\n  _setupItemValueAndUnit : function(obx, item) {\n    if (item && obx.code.coding[0].code === item.questionCode) {\n      var dataType = item.dataType;\n      // any one has a unit must be a numerical type, let use REAL for now.\n      // dataType conversion should be handled when panel data are added to lforms-service.\n      if ((!dataType || dataType===\"ST\") && item.units && item.units.length>0 ) {\n        dataType = \"REAL\";\n      }\n\n      switch (dataType) {\n        case \"INT\":\n          if (obx.valueInteger) {\n            item.value = obx.valueInteger;\n            break;\n          }\n          // else handle as Quantity\n        case \"REAL\": // handle as Quantity\n        case \"QTY\":\n          let qty = importFHIRQuantity(obx.valueQuantity);\n          item.value = qty.value;\n          delete qty.value;\n          if (qty.name || qty.code || qty.system)\n            item.unit = qty;\n          break;\n        case \"DT\":\n          item.value = LForms.Util.stringToDTDateISO(obx.valueDate);\n          break;\n        case \"DTM\":\n          item.value = LForms.Util.stringToDate(obx.valueDateTime);\n          break;\n        case \"CNE\":\n        case \"CWE\":\n          // get the value from Observation resource.\n          // for multiple-selected answers/values in LForms, each selected answer is exported as\n          // a separated Observation resource\n          var itemValue;\n          if (obx.valueCodeableConcept) {\n            itemValue = {\n              \"code\": obx.valueCodeableConcept.coding[0].code,\n              \"text\": obx.valueCodeableConcept.coding[0].display,\n              \"codeSystem\": obx.valueCodeableConcept.coding[0].system\n            };\n          }\n          else if (obx.valueString) {\n            itemValue = obx.valueString;\n          }\n\n          if (item.answerCardinality &&\n              (item.answerCardinality.max === \"*\" || parseInt(item.answerCardinality.max) > 1)) {\n            if (!item.value) {\n              item.value = [];\n            }\n            item.value.push(itemValue)\n          }\n          else {\n            item.value = itemValue;\n          }\n          break;\n        case \"SECTION\":\n        case \"TITLE\":\n        case \"\":\n          // do nothing\n          break;\n        default:\n          item.value = obx.valueString;\n      }\n    }\n  },\n\n\n  /**\n   * Find the number of the repeating items that have the same code\n   * in the \"contained\" field of a DiagnosticReport instance\n   * @param refIdList a list Observation instance IDs to be checked\n   * @param code an item code\n   * @param contained a list of Observation instances (in the \"contained\")\n   * @returns a structural info object for a repeating item\n   * of the repeating items\n   * @private\n   */\n  _findTotalRepeatingNum : function(refIdList, code, contained) {\n\n    var total = 0;\n    var refIds = [];\n    for (var i=0, iLen=refIdList.length; i<iLen; i++) {\n      var obx = this._findObxById(refIdList[i], contained);\n      if (obx.code.coding[0].code === code) {\n        refIds.push(refIdList[i]);\n        total += 1;\n      }\n    }\n\n    return {\n      total: total,\n      refIds: refIds\n    }\n  },\n\n\n  /**\n   * Get structural info of a DiagnosticReport by going though each level of observations\n   * @param parentObxInfo the structural info of a parent Observation\n   * @param parentRefId the instance ID of a parent Observation\n   * @param diagnosticReport a DiagnosticReport instance\n   * @private\n   */\n  _checkRepeatingItems : function(parentObxInfo, parentRefId, diagnosticReport) {\n\n    var obxInfoList = [];\n    var repeatingItemInfo = {};\n    var obxIdList = [];\n\n    // the report level\n    if (!parentRefId && diagnosticReport.result) {\n      for (var i=0, iLen=diagnosticReport.result.length; i<iLen; i++) {\n        obxIdList.push(diagnosticReport.result[i].reference);\n      }\n    }\n    // obx level\n    else {\n      var parentObx = this._findObxById(parentRefId, diagnosticReport.contained);\n      if (parentObx && parentObx.related) {\n        for (var i=0, iLen=parentObx.related.length; i<iLen; i++) {\n          obxIdList.push(parentObx.related[i].target.reference);\n        }\n      }\n    }\n\n    // go through each observation instance\n    for (var i=0, iLen=obxIdList.length; i<iLen; i++) {\n      var refId = obxIdList[i];\n      var obx = this._findObxById(refId, diagnosticReport.contained);\n      var itemCode =  obx.code.coding[0].code;\n      // first obx that has the same item code, either repeating or non-repeating\n      if (!repeatingItemInfo[itemCode]) {\n        var repeatingInfo = this._findTotalRepeatingNum(obxIdList, itemCode, diagnosticReport.contained);\n        repeatingItemInfo[itemCode] = {\n          total: repeatingInfo.total,\n          refIds: repeatingInfo.refIds\n        };\n      }\n      // create structure info for the obx\n      var repeatingRefIds = repeatingItemInfo[itemCode].refIds;\n      for (var j=0, jLen=repeatingRefIds.length; j<jLen; j++) {\n        if (refId === repeatingRefIds[j]) {\n          var obxInfo = {\n            code: itemCode,\n            refId: refId,\n            index: j,\n            total: repeatingItemInfo[itemCode].total\n          };\n          // check observation instances in the sub level\n          this._checkRepeatingItems(obxInfo, refId, diagnosticReport);\n          obxInfoList.push(obxInfo);\n        }\n      }\n    }\n    parentObxInfo.obxInfoList = obxInfoList;\n  },\n\n\n  /**\n   * Get structure information of a DiagnosticReport instance\n   * @param diagnosticReport a DiagnosticReport instance\n   * @returns {{}} a Diagnostic Report data structure object\n   * @private\n   */\n  _getReportStructure : function(diagnosticReport) {\n    var reportStructure = {\n      obxInfoList: []\n    };\n\n    if (diagnosticReport) {\n      this._checkRepeatingItems(reportStructure, null, diagnosticReport);\n    }\n    return reportStructure;\n  },\n\n\n  /**\n   * Find a matching repeating item\n   * @param parentItem a parent item\n   * @param itemCode code of a repeating (or non-repeating) item\n   * @param index index of the item in the sub item array of the parent item\n   * @returns {{}} a matching item\n   * @private\n   */\n  _findTheMatchingItemByCodeAndIndex : function(parentItem, itemCode, index) {\n    var item = null;\n    var idx = 0;\n    if (parentItem.items) {\n      for(var i=0, iLen=parentItem.items.length; i<iLen; i++) {\n        var subItem = parentItem.items[i];\n        if (itemCode === subItem.questionCode) {\n          if ((subItem.dataType === \"CNE\" || subItem.dataType === \"CWE\") &&\n              subItem.answerCardinality && (subItem.answerCardinality.max ===\"*\" || parseInt(subItem.answerCardinality.max)>1) ) {\n            item = subItem;\n            break;\n\n          }\n          else if (idx === index) {\n            item = subItem;\n            break;\n          }\n          else {\n            idx += 1;\n          }\n        }\n      }\n    }\n    return item;\n  },\n\n\n  /**\n   * Add repeating items\n   * @param parentItem a parent item\n   * @param itemCode code of a repeating item\n   * @param total total number of the repeating item with the same code\n   * @private\n   */\n  _addRepeatingItems : function(parentItem, itemCode, total) {\n    // find the first (and the only one) item\n    var item = null;\n    if (parentItem.items) {\n      for(var i=0, iLen=parentItem.items.length; i<iLen; i++) {\n        if (itemCode === parentItem.items[i].questionCode) {\n          item = parentItem.items[i];\n          break;\n        }\n      }\n      // insert new items unless it is a CNE/CWE and has multiple answers.\n      if (item && !((item.dataType === \"CNE\" || item.dataType ===\"CWE\") &&\n          item.answerCardinality &&\n          (item.answerCardinality.max === \"*\" || parseInt(item.answerCardinality.max) > 1))) {\n        while(total > 1) {\n          var newItem = LForms.Util.deepCopy(item);\n          parentItem.items.splice(i, 0, newItem);\n          total -= 1;\n        }\n      }\n    }\n  },\n\n\n  /**\n   * Merge Observation instances into items on the same level\n   * @param parentObxInfo structural information of a parent item\n   * @param parentItem a parent item\n   * @param diagnosticReport a DiagnosticReport instance\n   * @private\n   */\n  _processObxAndItem : function(parentObxInfo, parentItem, diagnosticReport) {\n    for(var i=0, iLen=parentObxInfo.obxInfoList.length; i<iLen; i++) {\n\n      var obxInfo = parentObxInfo.obxInfoList[i];\n      var obx = this._findObxById(obxInfo.refId, diagnosticReport.contained);\n      if (obx) {\n        // first repeating obx\n        if (obxInfo.total > 1 && obxInfo.index === 0) {\n          // add repeating items in form data\n          this._addRepeatingItems(parentItem, obxInfo.code, obxInfo.total);\n        }\n\n        var item = this._findTheMatchingItemByCodeAndIndex(parentItem, obxInfo.code, obxInfo.index);\n        this._setupItemValueAndUnit(obx, item);\n\n        // process items on sub level\n        if (obxInfo.obxInfoList && obxInfo.obxInfoList.length>0) {\n          this._processObxAndItem(obxInfo, item, diagnosticReport);\n        }\n      }\n    }\n  },\n\n  /**\n   * Convert a FHIR Bundle resource that includes a DiagnosticReport resource and associated Observation resources\n   * to a DiagnosticReport resource with contained Observation resources\n   * @param bundleDr a Bundle that includes a DiagnosticReport resource and associated Observation resources.\n   *        Only \"searchset\" type is allowed.\n   * @returns {{}} a DiagnosticReport resource with contained Observation resources\n   */\n  _convertFromBundleToContained: function (bundleDr) {\n\n    var containedDr;\n    // \"searchset\" is the only supported type at this point.\n    if (bundleDr && bundleDr.type === \"searchset\") {\n      var entry = bundleDr.entry;\n      // find the DiagnosticReport in the bundle\n      for (var i=0, iLen=entry.length; i<iLen; i++) {\n        if (entry[i].resource.resourceType === \"DiagnosticReport\") {\n          containedDr = entry[i].resource;\n          // change reference ids in result\n          for (var j=0, jLen=containedDr.result.length; j<jLen; j++) {\n            var ref = containedDr.result[j];\n            if (ref.reference && ref.reference.match(new RegExp(this._OBX_REF_PREFIX))) {\n              ref.reference = ref.reference.slice(this._OBX_REF_PREFIX.length);\n            }\n          }\n          containedDr.contained =[];\n          break;\n        }\n      }\n      // if DiagnosticReport is found\n      if (containedDr) {\n        // Move all Observation resource into \"contained\" field of the DiagnosticReport resource\n        for (var i=0, iLen=entry.length; i<iLen; i++) {\n          if (entry[i].resource.resourceType === \"Observation\") {\n            var obx = entry[i].resource;\n            // change reference ids in related\n            if (obx.related) {\n              for (var j=0, jLen=obx.related.length; j<jLen; j++) {\n                var related = obx.related[j];\n                if (related.target && related.target.reference &&\n                    related.target.reference.match(new RegExp(this._OBX_REF_PREFIX))) {\n                  related.target.reference = related.target.reference.slice(this._OBX_REF_PREFIX.length);\n                }\n              }\n            }\n            containedDr.contained.push(obx)\n          }\n        }\n      }\n    }\n\n    return containedDr;\n  },\n\n\n  /**\n   * Merge a DiagnosticReport instance into an LForms form definition or LFormsData object\n   * @param formData an LForms form definition or LFormsData object.\n   * @param diagnosticReport a DiagnosticReport resource with contained Observation resources,\n   * or a Bundle that includes a DiagnosticReport resource and associated Observation resources\n   * @param bundleType, optional, the FHIR Bundle type if inBundle is true.\n   * @returns {{}} an updated LForms form definition, with answer data\n   */\n  mergeDiagnosticReportToLForms : function(formData, diagnosticReport) {\n\n    if (!(formData instanceof LForms.LFormsData)) {\n      // get the default settings in case they are missing in the form data\n      // not to set item values by default values for saved forms with user data\n      formData.hasSavedData = true;\n      formData = (new LForms.LFormsData(formData)).getFormData();\n    }\n\n    var inBundle = diagnosticReport && diagnosticReport.resourceType === \"Bundle\";\n\n    // move Observation resources in Bundle to be in \"contained\" in DiagnosticReport resource\n    // as a base data structure for converting\n    var dr = inBundle ? this._convertFromBundleToContained(diagnosticReport) : diagnosticReport;\n\n    var reportStructure = this._getReportStructure(dr);\n\n    this._processObxAndItem(reportStructure, formData, dr);\n\n    return formData;\n  }\n\n};\n\nexport default dr;\n","/* jshint -W097 */ // suppress jshint warning about strict\n/* jshint node: true */ // suppress warning about \"require\"\n\"use strict\";\n\nimport {LOINC_URI} from './fhir-common';\n\nvar _versionTagStr = 'lformsVersion: ';\n\n/**\n *  Defines export functions that are the same across the different FHIR\n *  versions and that are used by both the SDC and DiagnosticReport exports.\n */\nvar self = {\n\n  /**\n   *  Creates Observation resources from an LForms item object\n   * @param item an LForms item object\n   * @param setId (optional) a flag indicating if a unique ID should be set on the Observation resource\n   * @returns {{}} an array of observation resources representing the values\n   *  stored in the item.\n   * @private\n   */\n  _createObservation: function(item, setId) {\n\n    var values = [];\n\n    var dataType = item.dataType;\n    // any item has a unit must be a numerical type, let use REAL for now.\n    if ((!dataType || dataType===\"ST\") && item.units && item.units.length>0 ) {\n      dataType = \"REAL\";\n    }\n    switch (dataType) {\n      case \"INT\":\n        values = [this._createObsIntValue(item)];\n        break;\n      case \"REAL\":\n        // A \"real\" data type should be exported as valueQuantity, because\n        // there is no valueDecimal for Observation (as of R4).\n      case \"QTY\":\n        var valValue = {value: item.value};\n        this._setFHIRQuantityUnit(valValue, item.unit);\n        values = [{\n          key: \"valueQuantity\",\n          val: valValue\n        }];\n        break;\n      case \"DT\":\n        values = [{\n          key:  \"valueDate\",\n          val: item.value\n        }];\n        break;\n      case \"DTM\":\n        values = [{\n          key:  \"valueDateTime\",\n          val: item.value\n        }];\n        break;\n      case \"CNE\":\n      case \"CWE\":\n        var max = item.answerCardinality.max;\n        // multiple values, each value creates a separate Observation resource\n        var itemValues;\n        if (max && (max === \"*\" || parseInt(max) > 1)) {\n          itemValues = item.value;\n        }\n        else {\n          itemValues = [item.value];\n        }\n        for (var j=0,jLen=itemValues.length; j<jLen; j++) {\n          var val = itemValues[j];\n          if (typeof val === \"object\") {\n            var coding = {};\n            if (val.code) coding.code = val.code;\n            if (val.text) coding.display = val.text;\n            var codeSystem = val.system;\n            if (codeSystem) coding.system = LForms.Util.getCodeSystem(codeSystem);\n            values.push(\n                { key: \"valueCodeableConcept\",\n                  val: {\n                    \"coding\" : [coding],\n                    \"text\": coding.display\n                  }\n                }\n            );\n          }\n          else if (typeof val === \"string\") {\n            if (val !== \"\") {\n              values.push(\n                  { key: \"valueString\",\n                    val: val\n                  }\n              );\n            }\n          }\n        }\n        break;\n      case \"attachment\":\n        values = [{\n          key: \"valueAttachment\",\n          val: item.value\n        }];\n        break;\n      case \"BL\":\n        values = [{\n          key: \"valueBoolean\",\n          val: item.value // undefined, null, or '' values should have been skipped before calling this function\n        }];\n        break;\n      default:\n        values = [{\n          key: \"valueString\",\n          val: item.value\n        }];\n    }\n\n    var obxs = [];\n    for(var i=0, iLen=values.length; i<iLen; i++) {\n      var obx = {\n        \"resourceType\": \"Observation\",\n        \"status\": \"final\",\n        \"code\": {\n          \"coding\": item.codeList,\n          \"text\": item.question\n        }\n      };\n      this._addVersionTag(obx);\n      if (setId) {\n        obx.id = this._getUniqueId(item.questionCode);\n      }\n      if (!item.header) {\n        obx[values[i].key] = values[i].val;\n      }\n      obxs.push(obx);\n    }\n    return obxs;\n  },\n\n\n  /**\n   * Generate an almost unique ID for a given Observation code\n   * @param prefix A prefix for the ID (e.g. a code or resource name)\n   * @returns {string} a unique id\n   * @private\n   */\n  _getUniqueId: function(prefix) {\n    this._idCtr || (this._idCtr = 0);\n    return prefix + \"-\" + Date.now() + '-' + ++this._idCtr + '-' +\n      Math.random().toString(16).substr(2);\n  },\n\n\n  /**\n   *  Sets the unit for a Quantity.\n   * @param qty the FHIR Quantity structure whose unit will be set.  This\n   *  function assumes there is no unit information already set.\n   * @param unit An LForms unit object.\n   */\n  _setFHIRQuantityUnit: function(qty, unit) {\n    if (unit) {\n      if (unit.name) qty.unit = unit.name;\n      if (unit.code) qty.code = unit.code;\n      if (unit.system) qty.system = unit.system;\n    }\n  },\n\n\n  /**\n   *  Returns and creates if necessary the tag array object on the resource.  If\n   *  created, the given resource will be modified.\n   * @param res the resource whose tag array is needed.\n   */\n  _resTags: function(res) {\n    var meta = res.meta;\n    if (!meta)\n      meta = (res.meta = {});\n    var tag = meta.tag;\n    if (!tag)\n      tag = (meta.tag = []);\n    return tag;\n  },\n\n\n  /**\n   *  Sets the LForms version tag on a FHIR resource to indicate the LForms version used to\n   *  export it.  This will replace any version tag already present.\n   * @param res the resource object to be tagged.\n   */\n  _setVersionTag: function(res) {\n    var tags = this._resTags(res);\n    // Delete any lformsVersion tag present.  There should be at most one\n    for (var i=0, len=tags.length; i<len; ++i) {\n      var t = tags[i];\n      if (t.code && t.code.indexOf(_versionTagStr)===0) {\n        tags.splice(i, 1);\n        break;\n      }\n    }\n    this._addVersionTag(res);\n  },\n\n\n  /**\n   *  Adds a tag to a FHIR resource to indicate the LForms version used to\n   *  export it.  Assumes the version tag does not already exist.\n   * @param res the resource object to be tagged.\n   */\n  _addVersionTag: function(res) {\n    var tag = this._resTags(res);\n    tag.push({code: _versionTagStr+LForms.lformsVersion});\n  }\n};\n\nexport default self;\n","// R4-specific export code common to DiagnosticReport and SDC.\n\nimport commonExport from '../export-common.js';\n\nlet self = Object.create(commonExport); // copies properties to self.prototype\nObject.assign(self, {\n  /**\n   *  Creates a structure for use by _createObservation() in constructing an\n   *  Observation value for the given integer value.\n   * @param item an LForms item with the integer value to be represented in an Observation.\n   *  It is assumed that the caller has already checked the data type.\n   * @return an object with a \"key\" property that will be the property name for\n   *  the value in the Observation object, and a \"val\" property that holds the\n   *  value (formatted for the Observation).\n   */\n  _createObsIntValue: function(item) {\n    // R4 added valueInteger to Observation, so we use that unless the item has\n    // a unit, in which case we use valueQuantity.\n    // valueQuantity.\n    let rtn;\n    if (item.unit) {\n      let quantity = {value: item.value};\n      this._setFHIRQuantityUnit(quantity, item.unit);\n      rtn = {key: 'valueQuantity', val: quantity};\n    }\n    else\n      rtn = {key: 'valueInteger', val: item.value};\n\n    return rtn;\n  }\n});\n\nexport default self;\n","/**\n * A package to handle FHIR Questionnaire and SDC (STU2) Questionnaire and QuestionnaireResponse for LForms\n *\n * FHIR Questionnaire:\n * https://www.hl7.org/fhir/questionnaire.html\n *\n * R4 Ballot (3.5) for comment:\n * http://hl7.org/fhir/uv/sdc/2018Sep/sdc-questionnaire.html\n * http://hl7.org/fhir/uv/sdc/2018Sep/sdc-questionnaireresponse.html\n *\n * It provides the following functions:\n * convertLFormsToQuestionnaire()\n * -- Convert existing LOINC panels/forms data in LForms format into FHIR (standard or SDC) Questionnaire data\n * convertLFormsToQuestionnaireResponse()\n * -- Generate FHIR (standard or SDC) QuestionnaireResponse data from captured data in LForms\n */\nvar sdcVersion = '2.7';\nvar fhirVersionNum = '4.0';\n\nvar self = {\n\n  SDCVersion: sdcVersion,\n  QProfile: 'http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire|'+sdcVersion,\n  QRProfile: 'http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaireresponse|'+sdcVersion,\n  stdQProfile: 'http://hl7.org/fhir/'+fhirVersionNum+'/StructureDefinition/Questionnaire',\n  stdQRProfile: 'http://hl7.org/fhir/'+fhirVersionNum+'/StructureDefinition/QuestionnaireResponse',\n\n  /**\n   *  Convert LForms captured data to a bundle consisting of a FHIR SDC\n   *  QuestionnaireResponse and any extractable resources. (Currently this means\n   *  any Observations that can be extracted via the observationLinkPeriod\n   *  extension).\n   *\n   * @param lfData a LForms form object\n   * @param noExtensions a flag that a standard FHIR Questionnaire is to be created without any extensions.\n   *  The default is false.\n   * @param subject A local FHIR resource that is the subject of the output resource.\n   *  If provided, a reference to this resource will be added to the output FHIR\n   *  resource when applicable.\n   * @returns an array of QuestionnaireResponse and Observations.  Observations\n   *  will have derivedFrom set to a temporary reference created for the returned\n   *  QuestionnaireResponse (the first element of the array). The caller may\n   *  wish to put all of the returned resources into a transaction Bundle for\n   *  creating them on a FHIR server.\n   */\n  convertLFormsToQRAndExtracFHIRData: function(lfData, noExtensions, subject) {\n    var qr = this.convertLFormsToQuestionnaireResponse(lfData, noExtensions, subject);\n    if (!qr.id) {\n      qr.id = this._commonExport._getUniqueId(\n        qr.identifier && qr.identifier.value || 'QR')\n    }\n\n    var qrRef = 'QuestionnaireResponse/'+qr.id;\n    var rtn = [qr];\n    for (var i=0, len=lfData.itemList.length; i<len; ++i) {\n      var item = lfData.itemList[i];\n      if (self._getExtractValue(item) && self._hasItemValue(item)) {\n        var obs = this._commonExport._createObservation(item);\n        for (var j=0, jLen=obs.length; j<jLen; j++) {\n          // Following\n          // http://hl7.org/fhir/uv/sdc/2019May/extraction.html#observation-based-extraction\n          if (qr.basedOn)\n            obs[j].basedOn = qr.basedOn;\n          if (qr.partOf)\n            obs[j].partOf = qr.partOf;\n          if (qr.subject)\n            obs[j].subject = qr.subject;\n          if (qr.encounter)\n            obs[j].encounter = qr.encounter;\n          if (qr.authored) {\n            obs[j].effectiveDateTime = qr.authored;\n            obs[j].issued = qr.authored;\n          }\n          if (qr.author)\n            obs[j].performer = qr.author;\n          obs[j].derivedFrom = [{reference: qrRef}];\n\n          rtn.push(obs[j]);\n\n        }\n      }\n    }\n    return rtn;\n  },\n\n\n  /**\n   *  Proceses the LForms questionCardinality into FHIR.\n   * @param targetItem an item in Questionnaire\n   * @param item a LForms item\n   */\n  _processQuestionCardinality: function(targetItem, item) {\n    if (item.questionCardinality) {\n      if (item.questionCardinality.max === \"*\") {\n        targetItem.repeats = true;\n      }\n      else if (parseInt(item.questionCardinality.max) > 1) {\n        targetItem.repeats = true;\n        targetItem.extension.push({\n          \"url\": \"http://hl7.org/fhir/StructureDefinition/questionnaire-maxOccurs\",\n          \"valueInteger\": parseInt(item.questionCardinality.max)\n        });\n      }\n    }\n    else {\n      // No default in R4\n      // targetItem.repeats = false;\n    }\n  },\n\n\n  /**\n   * Handle special requirements for 'display' items\n   * @param targetItem an item in Questionnaire\n   * @param item a LForms item\n   * @private\n   */\n  _handleSpecialConstraints: function(targetItem, item) {\n    //Display items cannot have a \"code\" asserted\n    //Required and repeat aren't permitted for display items\n    //Read-only can't be specified for \"display\" items\n    if (targetItem && item.dataType === \"TITLE\") {\n      delete targetItem.code;\n      delete targetItem.required;\n      delete targetItem.repeats;\n      delete targetItem.readOnly;\n    }\n  },\n\n\n  /**\n   * Process various restriction settings\n   * @param targetItem an item in FHIR SDC Questionnaire object\n   * @param item an item in LForms form object\n   * @private\n   */\n  _handleRestrictions: function(targetItem, item) {\n    // http://hl7.org/fhir/StructureDefinition/minLength\n    // http://hl7.org/fhir/StructureDefinition/regex\n    // http://hl7.org/fhir/StructureDefinition/minValue\n    // http://hl7.org/fhir/StructureDefinition/maxValue\n    // http://hl7.org/fhir/StructureDefinition/maxDecimalPlaces, not supported yet\n    // http://hl7.org/fhir/StructureDefinition/maxSize, for attachment, not supported yet\n    // maxLength\n    if (item.restrictions) {\n      for (var key in item.restrictions) {\n        var value = item.restrictions[key];\n        var extValue = null;\n        var dataType = this._getAssumedDataTypeForExport(item);\n        var valueKey = this._getValueKeyByDataType(\"value\", item);\n\n        switch (key) {\n          // http://hl7.org/fhir/StructureDefinition/minValue\n          // { // Must be >= this value\n          //   // from Element: extension\n          //   \"url\" : \"http://hl7.org/fhir/StructureDefinition/minValue\", // R!\n          //   // value[x]: Value of extension. One of these 6:\n          //   \"valueDate\" : \"<date>\" // R! Value of extension\n          //   \"valueDateTime\" : \"<dateTime>\", // R! Value of extension\n          //   \"valueTime\" : \"<time>\", // R! Value of extension\n          //   \"valueInstant\" : \"<instant>\", // R! Value of extension\n          //   \"valueDecimal\" : <decimal>, // R! Value of extension\n          //   \"valueInteger\" : <integer>, // R! Value of extension\n          // }\n          case \"minExclusive\":\n          case \"minInclusive\":\n          // http://hl7.org/fhir/StructureDefinition/maxValue\n          case \"maxExclusive\":\n          case \"maxInclusive\":\n            extValue = this._exportMinMax(dataType, value, valueKey, key);\n            break;\n          // http://hl7.org/fhir/StructureDefinition/minLength\n          case \"minLength\":\n            if (dataType === \"ST\" || dataType === \"TX\" || dataType === \"URL\" ||\n                dataType === \"QTY\") {\n              extValue = {\n                \"url\":\"http://hl7.org/fhir/StructureDefinition/minLength\",\n                \"valueInteger\": parseInt(value)\n              };\n            }\n            break;\n          // maxLength, not an extension, directly on item\n          case \"maxLength\":\n            if (dataType === \"ST\" || dataType === \"TX\" || dataType === \"URL\" ||\n                dataType === \"QTY\") {\n              targetItem.maxLength = parseInt(value);\n            }\n            break;\n          // http://hl7.org/fhir/StructureDefinition/regex\n          case \"pattern\":\n            if (dataType === \"ST\" || dataType === \"TX\" ) {\n              extValue = {\n                \"url\":\"http://hl7.org/fhir/StructureDefinition/regex\",\n                \"valueString\": value\n              };\n            }\n            break\n        }\n        if (extValue) {\n          targetItem.extension.push(extValue);\n        }\n      }\n    }\n  },\n\n\n  /**\n   *  Processes settings for a list field with choices.\n   * @param targetItem an item in FHIR SDC Questionnaire object\n   * @param item an item in the LForms form object\n   * @param noExtensions a flag that a standard FHIR Questionnaire is to be created without any extensions.\n   *        The default is false.\n   */\n  _handleChoiceField: function(targetItem, item, noExtensions) {\n    // an extension for the search url of the auto-complete field.\n    if(item.externallyDefined) {\n      this._handleExternallyDefined(targetItem, item);\n    }\n    // option, for answer list\n    else if (item.answers && !item.answerValueSet) {\n      // Make sure the answers did not come from answerExpression.\n      if (!item._fhirExt || !item._fhirExt[this.fhirExtAnswerExp])\n        targetItem.answerOption = this._handleAnswers(item, noExtensions);\n    }\n    else if (item.answerValueSet)\n      targetItem.answerValueSet = item.answerValueSet;\n  },\n\n\n  /**\n   * Process an item's answer list\n   * @param item an item in the LForms form object\n   * @param noExtensions a flag that a standard FHIR Questionnaire is to be created without any extensions.\n   *        The default is false.\n   * @returns {Array}\n   * @private\n   */\n  _handleAnswers: function(item, noExtensions) {\n    var optionArray = [];\n    for (var i=0, iLen=item.answers.length; i<iLen; i++) {\n      var answer = item.answers[i];\n      var option = {};\n\n      // needs an extension for label\n      if (!noExtensions) {\n        var ext = [];\n        if(answer.label) {\n          ext.push({\n            \"url\" : \"http://hl7.org/fhir/StructureDefinition/questionnaire-optionPrefix\",\n            \"valueString\" : answer.label\n          });\n        }\n\n        if (answer.score !== null && answer.score !== undefined) {\n          ext.push({\n            \"url\" : \"http://hl7.org/fhir/StructureDefinition/ordinalValue\",\n            \"valueDecimal\" : parseFloat(answer.score)\n          });\n        }\n        if(ext.length > 0) {\n          option.extension = ext;\n        }\n      }\n      // option's value supports integer, date, time, string and Coding\n      // for LForms, all answers are Coding\n      option.valueCoding = {};\n      if (answer.code) option.valueCoding.code = answer.code;\n      if (answer.text) option.valueCoding.display = answer.text;\n\n      if (answer.system) {\n        option.valueCoding.system = LForms.Util.getCodeSystem(answer.system);\n      }\n\n      // check default answers, coding only for now\n      if (item.defaultAnswer && (item.dataType === 'CWE' || item.dataType === 'CNE')) {\n        var defaultAnswers = (this._answerRepeats(item) && Array.isArray(item.defaultAnswer)) ?\n        item.defaultAnswer : [item.defaultAnswer];\n    \n        // go through each default value and set the initialSelected on the matching answer item\n        for(var j=0, jLen=defaultAnswers.length; j<jLen; j++ ) {\n          if (LForms.Util.areTwoAnswersSame(defaultAnswers[j], answer, item)) {\n            option.initialSelected = true;\n          }        \n        }\n      }\n\n      optionArray.push(option);\n    }\n    return optionArray;\n  },\n\n\n  /**\n   * Process default values\n   * @param targetItem an item in FHIR SDC Questionnaire object\n   * @param item an item in LForms form object\n   * @private\n   */\n  _handleInitialValues: function(targetItem, item) {\n    if(item.defaultAnswer === null || item.defaultAnswer === undefined || item.defaultAnswer === '') {\n      return;\n    }\n\n    var dataType = this._getAssumedDataTypeForExport(item);\n    // for Coding, the default answer is handled in _handleAnswers(), where\n    // initialSelected is set on the answer items.\n    if (dataType === \"CWE\" || dataType === 'CNE') {\n      return;\n    }\n\n    // item.defaultAnswer could be an array of multiple default values or a single value\n    var defaultAnswers = (this._answerRepeats(item) && Array.isArray(item.defaultAnswer)) ?\n      item.defaultAnswer : [item.defaultAnswer];\n\n    var valueKey = this._getValueKeyByDataType(\"value\", item);\n    var answer = null;\n    targetItem.initial = [];\n\n    // go through each default value and handle it based on the data type.\n    for(var i=0, iLen=defaultAnswers.length; i<iLen; i++ ) {\n      // dataType:\n      // boolean, decimal, integer, date, dateTime, instant, time, string, uri,\n      // Attachment, Coding, Quantity, Reference(Resource)\n\n      // for Quantity,\n      // [{\n      //   // from Element: extension\n      //   \"value\" : <decimal>, // Numerical value (with implicit precision)\n      //   \"comparator\" : \"<code>\", // < | <= | >= | > - how to understand the value\n      //   \"unit\" : \"<string>\", // Unit representation\n      //   \"system\" : \"<uri>\", // Code System that defines coded unit form\n      //   \"code\" : \"<code>\" // Coded form of the unit\n      // }]\n      if (dataType === 'QTY') {  // for now, handling only simple quantities without the comparators.\n        answer = {};\n        answer[valueKey] = this._makeQuantity(defaultAnswers[i], item.units);\n        targetItem.initial.push(answer);\n      }\n      // for boolean, decimal, integer, date, dateTime, instant, time, string, uri\n      else if (dataType === \"INT\" || dataType === \"REAL\" || dataType === \"BL\" ||\n        dataType === \"TM\" || dataType === \"ST\" || dataType === \"TX\" || dataType === \"URL\") {\n        answer = {};\n        answer[valueKey] = defaultAnswers[i];\n        targetItem.initial.push(answer);\n      }\n      else if (dataType === \"DT\" || dataType === \"DTM\") { // transform to FHIR date/datetime format.\n        var dateValue = LForms.Util.stringToDate(defaultAnswers[i]);\n        if(dateValue) {\n          dateValue = dataType === \"DTM\"?\n            LForms.Util.dateToDTMString(dateValue): LForms.Util.dateToDTStringISO(dateValue);\n          targetItem.initial.push({[valueKey]: dateValue});\n        }\n        else { // LForms.Util.stringToDate returns null on invalid string\n          // TODO: should save the errors or emitting events.\n          console.error(defaultAnswers[i] + ': Invalid date/datetime string as defaultAnswer for ' + item.questionCode);\n        }\n      }\n      // no support for reference\n    }\n  },\n\n\n  /**\n   * Process units list\n   * @param targetItem an item in FHIR SDC Questionnaire object\n   * @param item an item in LForms form object\n   * @private\n   */\n  _handleLFormsUnits: function(targetItem, item) {\n\n    if (item.units && item.units.length > 0) {\n      var dataType = this._getAssumedDataTypeForExport(item);\n      if(dataType === \"REAL\" || dataType === \"INT\") {\n\n        targetItem.extension.push({\n          \"url\": this.fhirExtUrlUnit,\n          // Datatype with multiple units is quantity. There is only one unit here.\n          \"valueCoding\" : this._createFhirUnitCoding(item.units[0])\n        });\n      }\n      else if(dataType === 'QTY') {\n        var defUnit = this._getDefaultUnit(item.units);\n        // Skip if units are already set in default answer conversion.\n        if ((defUnit && defUnit.default) && !(targetItem.initial && targetItem.initial.length > 0)) {\n          // Use initial[].valueQuantity.unit to export the default unit.\n          if (!targetItem.initial) {\n            targetItem.initial = [];\n          }\n          var qty = {};\n          self._setUnitAttributesToFhirQuantity(qty, defUnit);\n          targetItem.initial.push({valueQuantity: qty});\n        }\n        for (var i=0, iLen=item.units.length; i<iLen; i++) {\n          var unit = item.units[i];\n          var fhirUnitExt = {\n            \"url\": this.fhirExtUrlUnitOption,\n            \"valueCoding\": self._createFhirUnitCoding(unit)\n          };\n          targetItem.extension.push(fhirUnitExt);\n        }\n      }\n    }\n  },\n\n\n  /**\n   * Process skip logic\n   * @param targetItem an item in FHIR SDC Questionnaire object\n   * @param item an item in LForms form object\n   * @param source a LForms form object\n   * @private\n   */\n  _handleSkipLogic: function(targetItem, item, source) {\n    if (item.skipLogic) {\n      var enableWhen = [];\n      var rangeFound = false;\n\n      // ignore \"ANY\", \"ALL\" on item.skipLogic.logic\n      // ignore \"show\" on item.skipLogic.action\n\n      for (var i=0, iLen=item.skipLogic.conditions.length; i<iLen; i++) {\n        var condition = item.skipLogic.conditions[i];\n        var sourceItem = source._getSkipLogicSourceItem(item,condition.source);\n        let enableWhenRules = self._createEnableWhenRulesForSkipLogicCondition(condition, sourceItem);\n\n        if(enableWhenRules.length > 1) {\n          rangeFound = true;\n        }\n        enableWhen = enableWhen.concat(enableWhenRules);\n      }\n\n      if(rangeFound && item.skipLogic.conditions.length > 1) {\n        // TODO: Multiple skip logic conditons included with range specification is not supported with core FHIR.\n        // Use SDC extensions with fhirpath expressions, but not all fhirpath functionality is\n        // available yet. Revisit after implementation of variables, %resource etc. in fhirpath.\n        throw new Error('Multiple skip logic conditons included with range specification is not supported yet.');\n      }\n\n      targetItem.enableWhen = enableWhen;\n      if(item.skipLogic.logic === 'ALL' || rangeFound) {\n        targetItem.enableBehavior = 'all';\n      }\n      else if(enableWhen.length > 1) {\n        targetItem.enableBehavior = 'any';\n      }\n    }\n  }\n};\n\nexport default self;\n","/**\n *  Defines SDC export functions that are the same across the different FHIR\n *  versions.  The function takes the SDC namespace object defined in the sdc export\n *  code, and adds additional functions to it.\n */\nfunction addCommonSDCExportFns(ns) {\n\"use strict\";\n\n  var self = ns;\n\n  /**\n   * Convert LForms captured data to FHIR SDC QuestionnaireResponse\n   * @param lfData a LForms form object\n   * @param noExtensions a flag that a standard FHIR Questionnaire is to be created without any extensions.\n   *  The default is false.\n   * @param subject A local FHIR resource that is the subject of the output resource.\n   *  If provided, a reference to this resource will be added to the output FHIR\n   *  resource when applicable.\n   * @returns {{}}\n   */\n  self.convertLFormsToQuestionnaireResponse = function(lfData, noExtensions, subject) {\n    var target = {};\n    if (lfData) {\n      var source = lfData.getFormData(true,true,true);\n      this._processRepeatingItemValues(source);\n      this._setResponseFormLevelFields(target, source, noExtensions);\n\n      if (source.items && Array.isArray(source.items)) {\n        var tmp = this._processResponseItem(source, true);\n        if(tmp && tmp.item && tmp.item.length) {\n          target.item = tmp.item;\n        }\n      }\n    }\n    // FHIR doesn't allow null values, strip them out.\n    LForms.Util.pruneNulls(target);\n\n    if (subject)\n      target[\"subject\"] = LForms.Util.createLocalFHIRReference(subject);\n\n    this._commonExport._setVersionTag(target);\n    return target;\n  };\n\n\n  /**\n   * Convert LForms form definition to standard FHIR Questionnaire or FHIR SDC Questionnaire\n   * @param lfData a LForms form object\n   * @param noExtensions a flag that a standard FHIR Questionnaire is to be created without any extensions.\n   *        The default is false.\n   * @returns {{}}\n   */\n  self.convertLFormsToQuestionnaire = function(lfData, noExtensions) {\n    var target = {};\n\n    if (lfData) {\n      var source = LForms.Util.deepCopy(lfData);\n      if(! (source instanceof LForms.LFormsData)) {\n        source = new LForms.LFormsData(source);\n      }\n      this._removeRepeatingItems(source);\n      this._setFormLevelFields(target, lfData, noExtensions);\n\n      if (source.items && Array.isArray(source.items)) {\n        target.item = [];\n        for (var i=0, iLen=source.items.length; i<iLen; i++) {\n          var newItem = this._processItem(source.items[i], source, noExtensions);\n          target.item.push(newItem);\n        }\n      }\n    }\n\n    // FHIR doesn't allow null values, strip them out.\n    LForms.Util.pruneNulls(target);\n    this._commonExport._setVersionTag(target);\n    return target;\n  };\n\n\n  /**\n   * Process an item of the form\n   * @param item an item in LForms form object\n   * @param source a LForms form object\n   * @param noExtensions a flag that a standard FHIR Questionnaire is to be created without any extensions.\n   *        The default is false.\n   * @returns {{}}\n   * @private\n   */\n  self._processItem = function(item, source, noExtensions) {\n    var targetItem = {};\n\n    // type\n    targetItem.type = this._getFhirDataType(item);\n\n    // id (empty for new record)\n\n    // code\n    targetItem.code = item.codeList;\n\n    // extension\n    targetItem.extension = item.extension || []; // later we delete if empty\n\n    // required\n    if (item._answerRequired === true || item._answerRequired === false) {\n      targetItem.required = item._answerRequired;\n    }\n\n    // http://hl7.org/fhir/StructureDefinition/questionnaire-minOccurs\n    if (targetItem.required) {\n      var minOccurInt = parseInt(item.questionCardinality.min);\n      if(minOccurInt > 1) {\n        targetItem.extension.push({\n          \"url\" : \"http://hl7.org/fhir/StructureDefinition/questionnaire-minOccurs\",\n          \"valueInteger\" : minOccurInt\n        });\n      }\n    }\n\n    // question/answer repeats\n    // http://hl7.org/fhir/StructureDefinition/questionnaire-maxOccurs\n    this._processQuestionAndAnswerCardinality(targetItem, item);\n\n    // http://hl7.org/fhir/StructureDefinition/questionnaire-itemControl\n    this._handleItemControl(targetItem, item);\n\n    // check restrictions\n    this._handleRestrictions(targetItem, item);\n\n    // http://hl7.org/fhir/StructureDefinition/entryFormat\n    // looks like tooltip, TBD\n\n    if(item._isHiddenInDef) {\n      targetItem.extension.push({\n        url: \"http://hl7.org/fhir/StructureDefinition/questionnaire-hidden\",\n        valueBoolean: true\n      });\n    }\n\n    // linkId\n    targetItem.linkId = item.linkId;\n\n    // Text & prefix\n    targetItem.text = item.question;\n    if (item.prefix) {\n      targetItem.prefix = item.prefix;\n    }\n    // Copy item extensions\n    for (let extField of ['_prefix', '_text']) {\n      let extFieldData = item['obj'+extField];\n      if (extFieldData)\n        targetItem[extField] = extFieldData;\n    }\n\n    // enableWhen\n    if (item.skipLogic) {\n      this._handleSkipLogic(targetItem, item, source)\n    }\n\n    // repeats, handled above\n    // readonly, (editable)\n    if (item.dataType !== \"SECTION\" && item.dataType !== \"TITLE\" && item.editable === \"0\") {\n      targetItem.readOnly = true;\n    }\n\n    this._handleChoiceField(targetItem, item, noExtensions);\n    this._handleTerminologyServer(targetItem, item);\n\n    // initialValue, for default values\n    this._handleInitialValues(targetItem, item);\n    // add LForms Extension to units list. Process units after handling initial values.\n    if (item.units) {\n      this._handleLFormsUnits(targetItem, item);\n    }\n    // data control\n    this._handleDataControl(targetItem, item);\n\n    if (item.items && Array.isArray(item.items)) {\n      targetItem.item = [];\n      for (var i=0, iLen=item.items.length; i<iLen; i++) {\n        var newItem = this._processItem(item.items[i], source, noExtensions);\n        targetItem.item.push(newItem);\n      }\n    }\n\n    // the coding instruction is a sub item with a \"display\" type, and an item-control value as \"help\"\n    // it is added as a sub item of this item.\n    // http://hl7.org/fhir/StructureDefinition/questionnaire-itemControl, for instructions\n    if (item.codingInstructions) {\n      let helpItem = {\n        \"text\": item.codingInstructionsPlain ? item.codingInstructionsPlain : item.codingInstructions,\n        \"type\": \"display\",\n        \"linkId\": targetItem.linkId + \"-help\",\n        \"extension\": [{\n          \"url\": \"http://hl7.org/fhir/StructureDefinition/questionnaire-itemControl\",\n          \"valueCodeableConcept\": {\n            \"text\": \"Help-Button\",\n            \"coding\": [{\n              \"code\": \"help\",\n              \"display\": \"Help-Button\",\n              \"system\": \"http://hl7.org/fhir/questionnaire-item-control\"\n            }]\n          }\n        }]\n      };\n\n      // format could be 'html' or 'text'\n      if (item.codingInstructionsFormat === 'html') {\n        // add a \"_text\" field to contain the extension for the string value in the 'text' field\n        // see http://hl7.org/fhir/R4/json.html#primitive\n        helpItem._text = {\n          \"extension\": [{\n            \"url\": \"http://hl7.org/fhir/StructureDefinition/rendering-xhtml\",\n            \"valueString\": item.codingInstructions\n          }]\n        }\n      }\n\n      if (Array.isArray(targetItem.item)) {\n        targetItem.item.push(helpItem)\n      }\n      else {\n        targetItem.item = [\n          helpItem\n        ]\n      }\n    }\n\n    if (item.maxAttachmentSize) {\n      var exts = (targetItem.extension || (targetItem.extension = []));\n      exts.push({url: self.fhirExtMaxSize, valueDecimal: item.maxAttachmentSize});\n    }\n\n    if (item.allowedAttachmentTypes) {\n      exts = (targetItem.extension || (targetItem.extension = []));\n      for (let type of item.allowedAttachmentTypes) {\n        exts.push({url: self.fhirExtMimeType, valueCode: type});\n      }\n    }\n\n    // handle special constraints for \"display\" item\n    this._handleSpecialConstraints(targetItem, item);\n\n    // if no extensions are allowed or there is no extension, remove it\n    if (noExtensions || targetItem.extension.length === 0)\n      delete targetItem.extension;\n\n    this.copyFields(item, targetItem, this.itemLevelIgnoredFields);\n    return targetItem\n  };\n\n\n  /**\n   * Process the LForms questionCardinality and answerCardinality into FHIR.\n   * @param targetItem an item in Questionnaire\n   * @param item a LForms item\n   */\n  self._processQuestionAndAnswerCardinality = function(targetItem, item) {\n    var maxOccurs = 0;\n\n    var qCard = item.questionCardinality, aCard = item.answerCardinality;\n    var qCardMax = (qCard && qCard.max !== undefined) ? qCard.max : null;\n    var aCardMax = (aCard && aCard.max !== undefined) ? aCard.max : null;\n\n    // unlimited repeats, no need to set maxOccurs\n    if (qCardMax === \"*\" || aCardMax === \"*\") {\n      if (item.dataType !== \"TITLE\") {\n        targetItem.repeats = true;\n      }\n    }\n    // not unlimited repeats\n    else {\n      var intQCardMax = parseInt(qCardMax), intACardMax = parseInt(aCardMax);\n      // has a maxOcurrs value\n      if(intQCardMax > 1 || intACardMax > 1) {\n        if (item.dataType !== \"TITLE\") {\n          targetItem.repeats = true;\n\n          // get the maxOccurs value\n          if (!isNaN(intQCardMax) && !isNaN(intACardMax)) {\n            maxOccurs = Math.max(intQCardMax, intACardMax);\n          }\n          else if (!isNaN(intQCardMax)) {\n            maxOccurs = intQCardMax;\n          }\n          else if (!isNaN(intACardMax)) {\n            maxOccurs = intACardMax\n          }\n\n          if (maxOccurs > 1) {\n            targetItem.extension.push({\n              \"url\": self.fhirExtUrlCardinalityMax,\n              \"valueInteger\": maxOccurs\n            });\n          }\n        }\n      }\n    }\n\n  };\n\n\n  /**\n   * Process an item's externally defined answer list\n   * @param targetItem an item in FHIR SDC Questionnaire object\n   * @param item an item in the LForms form object\n   * @returns {*}\n   * @private\n   */\n  self._handleExternallyDefined = function(targetItem, item) {\n    if (item.externallyDefined) {\n      targetItem.extension.push({\n        \"url\": self.fhirExtUrlExternallyDefined,\n        \"valueUri\": item.externallyDefined\n      });\n    }\n  };\n\n\n  /**\n   * Process an item's data control\n   * @param targetItem an item in FHIR SDC Questionnaire object\n   * @param item an item in the LForms form object\n   * @returns {*}\n   * @private\n   */\n  self._handleDataControl = function(targetItem, item) {\n    if (item.dataControl) {\n      targetItem.extension.push({\n        \"url\": \"http://lhcforms.nlm.nih.gov/fhirExt/dataControl\",\n        \"valueString\": JSON.stringify(item.dataControl)\n      })\n    }\n  };\n\n\n  /**\n   * Remove repeating items in a form data object\n   * @param source a LForms form data object\n   * @private\n   */\n  self._removeRepeatingItems = function(source) {\n\n    if (source.items && Array.isArray(source.items)) {\n      for (var i= source.items.length-1; i>=0; i--) {\n        // if it is a repeating item, whose _id is not 1\n        if (source.items[i]._id > 1) {\n          source.items.splice(i,1);\n        }\n        else {\n          this._removeRepeatingItems(source.items[i]);\n        }\n      }\n    }\n  };\n\n\n  /**\n   * Set form level attributes\n   * @param target a Questionnaire object\n   * @param source a LForms form object\n   * @param noExtensions  a flag that a standard FHIR Questionnaire is to be created without any extensions.\n   *        The default is false.\n   * @private\n   */\n  self._setFormLevelFields = function(target, source, noExtensions) {\n    this.copyFields(source, target, this.formLevelFields);\n    // Handle title and name.  In LForms, \"name\" is the \"title\", but FHIR\n    // defines both.\n    target.name = source.shortName; // computer friendly\n    target.title = source.name;\n\n    // Handle extensions on title\n    if (source.obj_title)\n      target._title = source.obj_title;\n\n    target.code = source.codeList;\n\n    // resourceType\n    target.resourceType = \"Questionnaire\";\n    target.status = target.status ? target.status : \"draft\";\n\n    // meta\n    var profile = noExtensions ? this.stdQProfile : this.QProfile;\n\n    target.meta = target.meta ? target.meta : {};\n    target.meta.profile = target.meta.profile ? target.meta.profile : [profile];\n  };\n\n\n  /**\n   * Process itemControl based on LForms item's answerLayout and questionLayout\n   * @param targetItem an item in FHIR SDC Questionnaire object\n   * @param item an item in LForms form object\n   * @private\n   */\n  self._handleItemControl = function(targetItem, item) {\n    // http://hl7.org/fhir/StructureDefinition/questionnaire-itemControl\n    var itemControlType = \"\";\n    var itemControlDisplay, answerChoiceOrientation;\n    // Fly-over, Table, Checkbox, Combo-box, Lookup\n    if (!jQuery.isEmptyObject(item.displayControl)) {\n      var dataType = this._getAssumedDataTypeForExport(item);\n      // for answers\n      if (item.displayControl.answerLayout &&\n        (dataType === \"CNE\" || dataType === \"CWE\")) {\n        // search field\n        if (item.externallyDefined || (item.answerValueSet && item.isSearchAutocomplete)) {\n          itemControlType = \"autocomplete\";\n          itemControlDisplay = \"Auto-complete\";\n        }\n        // prefetch list\n        // combo-box\n        else if (item.displayControl.answerLayout.type === \"COMBO_BOX\") {\n          itemControlType = \"drop-down\";\n          itemControlDisplay = \"Drop down\";\n        }\n        // radio or checkbox\n        else if (item.displayControl.answerLayout.type === \"RADIO_CHECKBOX\") {\n          if (item.answerCardinality &&\n            (item.answerCardinality.max === \"*\" || parseInt(item.answerCardinality.max) > 1)) {\n            itemControlType = \"check-box\";\n            itemControlDisplay = \"Check-box\";\n          }\n          else {\n            itemControlType = \"radio-button\";\n            itemControlDisplay = \"Radio Button\";\n          }\n          // answer choice orientation\n          if (item.displayControl.answerLayout.columns === \"0\") {\n            answerChoiceOrientation = \"horizontal\";\n          }\n          else if (item.displayControl.answerLayout.columns === \"1\") {\n            answerChoiceOrientation = \"vertical\";\n          }\n\n        }\n      }\n      // for section item\n      else if (item.displayControl.questionLayout && dataType === \"SECTION\") {\n        if (item.displayControl.questionLayout === \"horizontal\") {\n          itemControlType = \"gtable\"; // Not in STU3, but the binding is extensible, so we can use it\n          itemControlDisplay = \"Group Table\";\n        }\n        else if (item.displayControl.questionLayout === \"matrix\") {\n          itemControlType = \"table\";\n          itemControlDisplay = \"Vertical Answer Table\";\n        }\n        // else {\n        //   itemControlType = \"List\";\n        // }\n      }\n\n      if (itemControlType) {\n        targetItem.extension.push(\n          {\n            \"url\": \"http://hl7.org/fhir/StructureDefinition/questionnaire-itemControl\",\n            \"valueCodeableConcept\": {\n              \"coding\": [{\n                //\"system\" : \"<uri>\", // Identity of the terminology system\n                //\"version\" : \"<string>\", // Version of the system - if relevant\n                //\"code\" : \"<code>\", // Symbol in syntax defined by the system\n                //\"display\" : \"<string>\", // Representation defined by the system\n                //\"userSelected\" : <boolean> // If this coding was chosen directly by the user\n                \"system\": \"http://hl7.org/fhir/questionnaire-item-control\",\n                \"code\": itemControlType,\n                \"display\": itemControlDisplay\n              }],\n              \"text\": itemControlDisplay || itemControlType\n            }\n          });\n        // answer choice orientation\n        if (answerChoiceOrientation) {\n          targetItem.extension.push(\n            {\n              \"url\": \"http://hl7.org/fhir/StructureDefinition/questionnaire-choiceOrientation\",\n              \"valueCode\": answerChoiceOrientation\n            });\n        }\n      }\n    }\n  };\n\n\n  /**\n   * Process an item's terminology server setting.\n   * @param targetItem a QuestionnaireResponse object\n   * @param item an item in the LForms form object\n   * @returns {*}\n   * @private\n   */\n  self._handleTerminologyServer = function(targetItem, item) {\n    if (item.terminologyServer) {\n      targetItem.extension.push({\n        \"url\": self.fhirExtTerminologyServer,\n        \"valueUrl\": item.terminologyServer\n      });\n    }\n  };\n\n\n\n  /**\n   * Convert LForms data type to FHIR SDC data type\n   * @param item an item in the LForms form object\n   * @returns {string}\n   * @private\n   */\n  self._getFhirDataType = function(item) {\n\n    var dataType = this._getAssumedDataTypeForExport(item);\n    var type = this._lformsTypesToFHIRTypes[dataType];\n    // default is string\n    if (!type) {\n      type = 'string';\n    }\n    return type;\n  };\n\n\n  /**\n   * Determine how an item's data type should be for export.\n\n   If number type has multiple units, change it to quantity type. In such a case,\n   multiple units are converted to quesionnaire-unitOption extension and the default unit\n   would go into initial.valueQuantity.unit.\n   For single unit numbers, use the same type, whose unit will be in questionnaire-unit extension.\n\n   * @param item an item in the LForms form object\n   * @returns {string} dataType - Data type in lforms\n   * @private\n   */\n  self._getAssumedDataTypeForExport = function (item) {\n    var dataType = item.dataType;\n    if((item.dataType === 'REAL' || item.dataType === 'INT') && item.units && item.units.length > 1) {\n      dataType = 'QTY';\n    }\n    return dataType;\n  };\n\n\n  /**\n   * Make a FHIR Quantity for the given value and unit info.\n   * @param value optional, must be an integer or decimal\n   * @param itemUnit optional, lform data item.unit (that has a name property)\n   * @param unitSystem optional, overrides any system in itemUnit.\n   * @return a FHIR quantity or null IFF the given value is not a number (parseFloat() returns NaN).\n   * @private\n   */\n  self._makeValueQuantity = function(value, itemUnit, unitSystem) {\n    let fhirQuantity = {};\n    let floatValue = parseFloat(value);\n\n    if(! isNaN(floatValue)) {\n      fhirQuantity.value = floatValue;\n    }\n\n    if(itemUnit) {\n      self._setUnitAttributesToFhirQuantity(fhirQuantity, itemUnit);\n      if(unitSystem) {\n        fhirQuantity.system = unitSystem;\n      }\n    }\n\n    return (Object.keys(fhirQuantity).length > 0) ? fhirQuantity : null;\n  };\n\n\n  /**\n   * Make a FHIR Quantity for the given value and unit info.\n   * @param value required, must be an integer or decimal\n   * @param itemUnits optional, lform data item.units (An array of units)\n   * @param unitSystem optional.\n   * @return a FHIR quantity or null IFF the given value is not a number (parseFloat() returns NaN).\n   * @private\n   */\n  self._makeQuantity = function(value, itemUnits, unitSystem) {\n    var defaultUnit = this._getDefaultUnit(itemUnits);\n    return this._makeValueQuantity(value, defaultUnit, unitSystem);\n  };\n\n\n  /**\n   * Pick a default unit if found, otherwise return first one as default. Will return\n   * null, if passed with empty list.\n   * @param lformsUnits - Array of lforms units i.e with {name, default}\n   * @returns {*} Return lforms unit if found otherwise null.\n   * @private\n   */\n  self._getDefaultUnit = function (lformsUnits) {\n    if(!lformsUnits || lformsUnits.length === 0) {\n      return null;\n    }\n\n    var ret = null;\n    for(var i = 0; i < lformsUnits.length; i++) {\n      if (lformsUnits[i].default) {\n        ret = lformsUnits[i];\n        break;\n      }\n    }\n\n    if(!ret) {\n      ret = lformsUnits[0];\n    }\n\n    return ret;\n  };\n\n\n  /**\n   * Create a key from data type to be used in a hash\n   * @param prefix a prefix to be added to the key\n   * @param item a LForms item\n   * @returns {*}\n   * @private\n   */\n  self._getValueKeyByDataType = function(prefix, item) {\n\n    // prefix could be 'value', 'initial', 'answer'\n    if (!prefix) {\n      prefix = \"value\"\n    }\n\n    var fhirType = this._getFhirDataType(item);\n    var dataType = fhirType === 'quantity' ? 'QTY' : item.dataType;\n    var valueKey = this._lformsTypesToFHIRFields[dataType];\n\n    return prefix + valueKey;\n  };\n\n\n  /**\n   * Convert the minInclusive/minExclusive, maxInclusive/maxExclusive to FHIR. See the\n   * the function _handleRestrictions() in sdc-export.js for more details on the context.\n   * @param dataType Lforms data type, currently supporting DT, DTM, TM, REAL, and INT.\n   * @param value the value (in the lforms system, either a number or a string).\n   * @param valueKey the valueKey in FHIR minValue/maxValue extension (e.g., valueInteger)\n   * @param minMaxKey must be one of minInclusive, minExclusive, maxInclusive, maxExclusive\n   * @return The FHIR extension element. Specifically, undefined is returned if:\n   *         - the given value is null or undefined, or\n   *         - the dataType is not one of those listed above, or\n   *         - the minMaxKey is not one of those listed above\n   * @private\n   */\n  self._MIN_MAX_TYPES = ['DT', 'DTM', 'TM', 'REAL', 'INT']\n    .reduce((map, t) => {map[t] = t; return map;}, {});\n  self._MIN_MAX_KEYS = ['minExclusive', 'minInclusive', 'maxExclusive', 'maxInclusive']\n    .reduce((map, t) => {map[t] = t; return map;}, {});\n\n  self._exportMinMax = function(dataType, value, valueKey, minMaxKey) {\n    if(value === null || value === undefined\n      || ! self._MIN_MAX_TYPES[dataType] || ! self._MIN_MAX_KEYS[minMaxKey]) {\n      return undefined;\n    }\n\n    var isoDateStr = (dataType === \"DT\" || dataType === \"DTM\")? new Date(value).toISOString():\n      dataType == \"TM\"? new Date('1970-01-01T' + value + 'Z').toISOString(): null;\n\n    var fhirValue =\n      dataType === \"DT\"? isoDateStr.substring(0, 10):\n      dataType === \"DTM\"? isoDateStr:\n      dataType === \"TM\"? isoDateStr.substring(11, isoDateStr.length-1):\n      dataType === \"REAL\"? parseFloat(value): parseInt(value);\n\n    var fhirExtUrl = minMaxKey.indexOf('min') === 0?\n      'http://hl7.org/fhir/StructureDefinition/minValue':\n      'http://hl7.org/fhir/StructureDefinition/maxValue';\n\n    return {\n      url: fhirExtUrl,\n      [valueKey]: fhirValue\n    };\n  };\n\n\n  // known source data types (besides CNE/CWE) in skip logic export handling,\n  // see _createEnableWhenRulesForSkipLogicCondition below\n  self._skipLogicValueDataTypes = [\"BL\", \"REAL\", \"INT\", 'QTY', \"DT\", \"DTM\", \"TM\", \"ST\", \"TX\", \"URL\"]\n    .reduce((map, type) => {map[type] = type; return map;}, {});\n\n\n  /**\n   * @param skipLogicCondition - Lforms skip logic condition object\n   * @param sourceItem - Skip logic source item in lforms.\n   * @return {Array} FHIR enableWhen array\n   * @private\n   */\n  self._createEnableWhenRulesForSkipLogicCondition = function (skipLogicCondition, sourceItem) {\n    // dataTypes:\n    // boolean, decimal, integer, date, dateTime, instant, time, string, uri,\n    // Attachment, Coding, Quantity, Reference(Resource)\n    let sourceDataType = this._getAssumedDataTypeForExport(sourceItem);\n    let sourceValueKey = this._getValueKeyByDataType(\"answer\", sourceItem);\n    let enableWhenRules = [];\n\n    // Per lforms spec, the trigger keys can be:\n    // exists, value, minExclusive, minInclusive, maxExclusive, maxInclusive\n    Object.keys(skipLogicCondition.trigger).forEach(function(key) {\n      let operator = self._operatorMapping[key];\n      let triggerValue = skipLogicCondition.trigger[key];\n      if(! operator || triggerValue !== 0 && triggerValue !== false && ! triggerValue) {\n        throw new Error('Invalid lforms skip logic trigger: ' + JSON.stringify(skipLogicCondition.trigger, null, 4));\n      }\n\n      let rule = null;\n      if (operator === 'exists') {\n        rule = { answerBoolean: triggerValue };\n      }\n      // for Coding\n      // multiple selections, item.value is an array\n      // NO support of multiple selections in FHIR SDC, just pick one\n      else if ( sourceDataType === 'CWE' || sourceDataType === 'CNE' ) {\n        let answerCoding = self._copyTriggerCoding(triggerValue, null, true);\n        if (! answerCoding) {\n          throw new Error('Invalid CNE/CWE trigger, key=' + key + '; value=' + triggerValue);\n        }\n        rule = { answerCoding: answerCoding };\n      }\n      else if (sourceDataType && self._skipLogicValueDataTypes[sourceDataType]) {\n        let answer = triggerValue;\n        if(sourceValueKey === 'answerQuantity') {\n          answer = self._makeQuantity(answer, sourceItem.units);\n        }\n        if(answer === 0 || answer === false || answer) {\n          rule = { [sourceValueKey]: answer };\n        }\n        else {\n          throw new Error('Invalid value for trigger ' + key + ': ' + triggerValue);\n        }\n      }\n      else {\n        throw new Error('Unsupported data type for skip logic export: ' + sourceDataType);\n      }\n\n      rule.question = sourceItem.linkId;\n      rule.operator = operator;\n      enableWhenRules.push(rule);\n    });\n\n    return enableWhenRules;\n  };\n\n\n  /**\n   * Set form level attribute\n   * @param target a QuestionnaireResponse object\n   * @param noExtensions  a flag that a standard FHIR Questionnaire is to be created without any extensions.\n   *        The default is false.\n   * @param source a LForms form object\n\n   * @private\n   */\n  self._setResponseFormLevelFields = function(target, source, noExtensions) {\n\n    // resourceType\n    target.resourceType = \"QuestionnaireResponse\";\n\n    // meta\n    var profile = noExtensions ? this.stdQRProfile : this.QRProfile;\n    target.meta = target.meta ? target.meta : {};\n    target.meta.profile = target.meta.profile ? target.meta.profile : [profile];\n\n    // \"identifier\": - not including identifier in QuestionnaireResponse per LF-1183\n    //target.identifier = {\n    //  \"system\": LForms.Util.getCodeSystem(source.codeSystem),\n    //  \"value\": source.code\n    //};\n\n    // status, required\n    // \"in-progress\", \"completed\", \"amended\"\n    target.status = \"completed\";\n\n    // authored, required\n    target.authored = LForms.Util.dateToDTMString(new Date());\n\n    // questionnaire , required\n    // We do not have the ID at this point, so leave it unset for now.  Note\n    // that the fomat has also changed from Reference to canonical in R4.\n    /*\n    target.questionnaire = {\n      // questionnaireId should be an id of a related existing questionnaire resource stored in the server\n      \"reference\": \"Questionnaire/{{questionnaireId}}\"\n    };\n    */\n  };\n\n\n  /**\n   * Set unit attributes to a given FHIR quantity.\n   *\n   * @param fhirQuantity - FHIR Quantity object\n   * @param lfUnit - Lforms unit, which includes name, code and system.\n   * @private\n   */\n  self._setUnitAttributesToFhirQuantity = function(fhirQuantity, lfUnit) {\n    if(fhirQuantity && lfUnit) {\n      if(lfUnit.name) {\n        fhirQuantity.unit = lfUnit.name;\n      }\n\n      if(lfUnit.code) {\n        fhirQuantity.code = lfUnit.code;\n      }\n\n      // Unit system is optional. It was using a default system before,\n      // Now we have an defined system field, read it from data and\n      // not assume a default.\n      if(lfUnit.system) {\n        fhirQuantity.system = lfUnit.system;\n      }\n    }\n  };\n\n\n  /**\n   * Create a FHIR coding object for a unit.\n   *\n   * @param lfUnit - Lforms unit, which includes name, code and system.\n   * @returns FHIR coding object\n   * @private\n   */\n  self._createFhirUnitCoding = function(lfUnit) {\n    var ret = null;\n    if(lfUnit) {\n      ret = {};\n      if(lfUnit.code) {\n        ret.code = lfUnit.code;\n      }\n      if(lfUnit.name) {\n        ret.display = lfUnit.name;\n      }\n      if(lfUnit.system) {\n        ret.system = lfUnit.system;\n      }\n    }\n    return ret;\n  };\n\n\n  /**\n   * Converting the given item's value to FHIR QuestionaireResponse.answer (an array).\n   * This is almost straightly refactored out of the original function self._handleAnswerValues.\n   * This function only looks at the item value itself and not its sub-items, if any.\n   * Here are the details for a single value's conversion (to an element in the returned answer array)\n   * - For item data type quantity (QTY), a valueQuantity answer element will be created IF\n   *   either (or both) item value or item unit is available.\n   * - For item data types boolean, decimal, integer, date, dateTime, instant, time, string, attachment, and url,\n   *   it will be converted to a FHIR value{TYPE} entry if the value is not null, not undefined, and not\n   *   an empty string.\n   * - For CNE and CWE, a valueCoding entry is created IF at least one of the item value's code, text, or system\n   *   is available\n   * - No answer entry will be created in all other cases, e.g., for types reference, title, section, etc.\n   * @param item the item whose value is to be converted\n   * @return the converted FHIR QuestionnaireResponse answer (an array), or null if the value is not converted -\n   *         see the function description above for more details.\n   * @private\n   */\n  self._lfItemValueToFhirAnswer = function(item) {\n\n    // item could have an empty value if its sub-item has a value\n    if (item.value === undefined || item.value === null || item.value === '')\n       return null;\n\n    var dataType = this._getAssumedDataTypeForExport(item);\n    var values = this._answerRepeats(item)? item.value: [item.value];\n    var answers = [];\n    for(var i=0; i < values.length; ++i) {\n      var itemValue = values[i];\n      if(itemValue !== undefined && itemValue !== null && itemValue !== '') {\n        var answer = null;\n        // for Coding\n        if (dataType === 'CWE' || dataType === 'CNE') {\n          // for CWE, the value could be string if it is a user typed, not-on-list value\n          if (dataType === 'CWE' && typeof itemValue === 'string') {\n            answer = { \"valueString\" : itemValue };\n          }\n          else if (!jQuery.isEmptyObject(itemValue)) {\n            var answerCoding = this._setIfHasValue(null, 'system', LForms.Util.getCodeSystem(itemValue.system));\n            answerCoding = this._setIfHasValue(answerCoding, 'code', itemValue.code);\n            answerCoding = this._setIfHasValue(answerCoding, 'display', itemValue.text);\n            answer = this._setIfHasValue(null, 'valueCoding', answerCoding);\n          }\n        }\n        // for Quantity\n        else if (dataType === \"QTY\") {\n          // For now, handling only simple quantities without the comparators.\n          // [{\n          //   // from Element: extension\n          //   \"value\" : <decimal>, // Numerical value (with implicit precision)\n          //   \"comparator\" : \"<code>\", // < | <= | >= | > - how to understand the value\n          //   \"unit\" : \"<string>\", // Unit representation\n          //   \"system\" : \"<uri>\", // Code System that defines coded unit form\n          //   \"code\" : \"<code>\" // Coded form of the unit\n          // }]\n          answer = this._setIfHasValue(null, 'valueQuantity', this._makeValueQuantity(itemValue, item.unit));\n        }\n        // for boolean, decimal, integer, date, dateTime, instant, time, string, uri, attachment\n        else if (this._lformsTypesToFHIRFields[dataType]) {\n          var valueKey = this._getValueKeyByDataType(\"value\", item);\n          answer = {[valueKey]: itemValue};\n        }\n        if(answer !== null) {\n          answers.push(answer);\n        }\n      }\n    }\n\n    return answers.length === 0? null: answers;\n  };\n\n\n  /**\n   * Check if an lform item has sub-items, that is, having an \"items\" field whose value is an array with non-zero length.\n   * @param item the item to be checked for the presense of sub-items.\n   * @return {*|boolean} true if the item has sub-items, false otherwise.\n   * @private\n   */\n  self._lfHasSubItems = function(item) {\n    return item && item.items && Array.isArray(item.items) && item.items.length > 0;\n  };\n\n\n  /**\n   * Process an item of the form or the form itself - if it's the form itself, the form-level\n   * properties will not be set here and will need to be managed outside of this function.\n   * If the lforms item is repeatable, this function handles one particular occurrence of the item.\n   * @param lfItem an item in LForms form object, or the form object itself\n   * @param isForm optional, default false. If true, the given item is the form object itself.\n   * @returns {{}} the converted FHIR item\n   * @private\n   */\n  self._processResponseItem = function(lfItem, isForm) {\n    if(isForm && (typeof isForm) !== 'boolean') { // just in case some are invoking it the old way.\n      throw new Error('_processResponseItem function signature has been changed, please check/fix.');\n    }\n    var targetItem = (isForm || lfItem.dataType === 'TITLE')? {}: {\n        linkId: lfItem.linkId,\n        text: lfItem.question\n      };\n\n    // just handle/convert the current item's value, no-recursion to sub-items at this step.\n    if (!isForm && lfItem.dataType !== 'TITLE' && lfItem.dataType !== 'SECTION') {\n      this._setIfHasValue(targetItem, 'answer', this._lfItemValueToFhirAnswer(lfItem));\n    }\n\n    if(this._lfHasSubItems(lfItem)) {\n      var fhirItems = [];\n      for (var i=0; i < lfItem.items.length; ++i) {\n        var lfSubItem = lfItem.items[i];\n        if(! lfSubItem._isProcessed) {\n          var linkId = lfSubItem.linkId;\n          var repeats = lfItem._repeatingItems && lfItem._repeatingItems[linkId];\n          if(repeats) {      // Can only be questions here per _processRepeatingItemValues\n            let fhirItem = { // one FHIR item for all repeats with the same linkId\n              linkId: linkId,\n              text: lfSubItem.question,\n              answer: []\n            };\n            for(var rpt=0; rpt < repeats.length; ++rpt) {\n              var rptItem = repeats[rpt];\n              var tmpFhirItem = this._processResponseItem(rptItem);\n              if(tmpFhirItem.answer) {\n                // TODO: not sure how to handle cases when both (lforms) question and answer repeat.\n                // For now, just put all the answers from question and answer repeats into the answer (array).\n                Array.prototype.push.apply(fhirItem.answer, tmpFhirItem.answer);\n              }\n              rptItem._isProcessed = true;\n            }\n            fhirItems.push(fhirItem);\n            delete lfItem._repeatingItems[linkId]; // cleanup, no longer needed\n          }\n          else {\n            let fhirItem = this._processResponseItem(lfSubItem);\n            fhirItems.push(fhirItem);\n          }\n        }\n\n        if(lfSubItem._isProcessed) {\n          delete lfSubItem._isProcessed; // cleanup, no longer needed\n        }\n      }\n\n      if(fhirItems.length > 0) {\n        if(! isForm && lfItem.dataType !== 'SECTION') {\n          // Question repeat is handled at the \"parent level\"; TODO: not sure how to handle answer repeat here,\n          // assuming it isn't possible for an item to have answer repeat and sub-items at the same time.\n          targetItem.answer = targetItem.answer || [];\n          targetItem.answer[0] = targetItem.answer[0] || {};\n          targetItem.answer[0].item = fhirItems;\n        }\n        else {\n          targetItem.item = fhirItems;\n        }\n      }\n    }\n\n    return targetItem;\n  };\n\n\n  /**\n   * Group values of the questions that have the same linkId\n   * @param item an item in the LForms form object or a form item object\n   * @private\n   *\n   */\n  self._processRepeatingItemValues = function(item) {\n    if (item.items) {\n      for (var i=0, iLen=item.items.length; i<iLen; i++) {\n        var subItem = item.items[i];\n        // if it is a question and it repeats\n        if (subItem.dataType !== 'TITLE' && subItem.dataType !== 'SECTION' && this._questionRepeats(subItem)) {\n          var linkId = subItem.linkId;\n          item._repeatingItems = item._repeatingItems || {};\n          item._repeatingItems[linkId] = item._repeatingItems[linkId] || [];\n          item._repeatingItems[linkId].push(subItem);\n        }\n        // if it's a section or a question that has children items\n        if(this._lfHasSubItems(subItem)) {\n          this._processRepeatingItemValues(subItem);\n        }\n      }\n    }\n  };\n\n\n  /**\n   * Get the extract value for the item or the closest parent\n   * @param item an item in Questionnaire\n   */\n  self._getExtractValue = function (item) {\n    let currentItem = item;\n\n    while (true) {\n      if (currentItem._fhirExt && currentItem._fhirExt[this.fhirExtObsExtract]) {\n        return currentItem._fhirExt[this.fhirExtObsExtract][0].valueBoolean;\n      } else if (!currentItem._parentItem) {\n        return false;\n      }\n      currentItem = currentItem._parentItem;\n    }\n  };\n\n\n  /**\n   * Check if the item has a value\n   * @param {*} item  an item in lforms with attritues set by lforms\n   * @returns {boolean}\n   */\n  self._hasItemValue = function (item) {\n    // not a group item, or a display item\n    // not hidden by skip logic\n    // has values\n    return item.dataType!==\"SECTION\" && item.dataType!==\"TITLE\" &&\n           item._skipLogicStatus!== \"target-disabled\" &&\n           !LForms.Util.isItemValueEmpty(item.value) ? true : false;\n  };\n\n\n}\n\nexport default addCommonSDCExportFns;\n","/**\n * A package to handle conversion from FHIR SDC Questionnaire to LForms\n *\n * It provides the following functions:\n * convertQuestionnaireToLForms()\n * -- Convert FHIR SDC QuestionnaireResponse data into corresponding LForms data\n * mergeQuestionnaireResponseToLForms()  (defined in sdc-import-common.js)\n * -- Merge FHIR SDC QuestionnaireResponse data into corresponding LForms data\n */\nfunction addSDCImportFns(ns) {\n\"use strict\";\n\n  var self = ns;\n\n  // FHIR extension urls\n  self.fhirExtUrlOptionScore = \"http://hl7.org/fhir/StructureDefinition/ordinalValue\";\n  self.fhirExtUrlValueSetScore = self.fhirExtUrlOptionScore;\n\n\n  /**\n   * Extract contained VS (if any) from the given questionnaire resource object.\n   * @param questionnaire the FHIR questionnaire resource object\n   * @return when there are contained value sets, returns a hash from the ValueSet url to the answers\n   *         options object, which, in turn, is a hash with 4 entries:\n   *         - \"answers\" is the list of LF answers converted from the value set.\n   *         - \"systems\" is the list of code systems for each answer item; and\n   *         returns undefined if no contained value set is present.\n   * @private\n   */\n  self._extractContainedVS = function (questionnaire) {\n    var answersVS;\n\n    if(questionnaire.contained && questionnaire.contained.length > 0) {\n      answersVS = {};\n      questionnaire.contained.forEach(function (vs) {\n        if(vs.resourceType === 'ValueSet') {\n          var answers = self.answersFromVS(vs);\n          if (!answers)\n            answers = []; // continuing with previous default; not sure if needed\n\n          // Support both id and url based lookup - we are only supporting our non-standard url approach\n          // for backward-compatibility with previous LForms versions. For more details on FHIR contained\n          // resource references, please see \"http://hl7.org/fhir/references.html#canonical-fragments\"\n          var lfVS = {answers: answers};\n          if(vs.id) {\n            answersVS['#' + vs.id] = lfVS;\n          }\n          if(vs.url) {\n            answersVS[vs.url] = lfVS;\n          }\n        }\n      });\n    }\n\n    return answersVS;\n  };\n\n\n  /**\n   * Parse questionnaire object for skip logic information\n   *\n   * @param lfItem {object} - LForms item object to assign the skip logic\n   * @param qItem {object} - Questionnaire item object\n   * @param linkIdItemMap - Map of items from link ID to item from the imported resource.\n   * @private\n   */\n  self._processSkipLogic = function (lfItem, qItem, linkIdItemMap) {\n    if(qItem.enableWhen) {\n      lfItem.skipLogic = {conditions: [], action: 'show'};\n      for(var i = 0; i < qItem.enableWhen.length; i++) {\n          var dataType = self._getDataType(linkIdItemMap[qItem.enableWhen[i].question]);\n          var condition = {source: qItem.enableWhen[i].question, trigger: {}};\n          var answer = self._getFHIRValueWithPrefixKey(qItem.enableWhen[i], /^answer/);\n          var opMapping = self._operatorMapping[qItem.enableWhen[i].operator];\n          if(! opMapping) {\n            throw new Error('Unable to map FHIR enableWhen operator: ' + qItem.enableWhen[i].operator);\n          }\n\n          if(opMapping === 'exists') {\n            condition.trigger.exists = answer; // boolean value here regardless of data type\n          }\n          else if(dataType === 'CWE' || dataType === 'CNE') {\n            condition.trigger[opMapping] = self._copyTriggerCoding(answer, null, false);\n          }\n          else if(dataType === 'QTY') {\n            condition.trigger[opMapping] = answer.value;\n          }\n          else {\n            condition.trigger[opMapping] = answer;\n          }\n          lfItem.skipLogic.conditions.push(condition);\n      }\n      if(qItem.enableBehavior) {\n        lfItem.skipLogic.logic = qItem.enableBehavior.toUpperCase();\n      }\n    }\n  };\n\n\n  /**\n   * Parse questionnaire item for \"hidden\" extension\n   *\n   * @param lfItem {object} - LForms item object to be assigned the _isHiddenInDef flag if the item is to be hidden.\n   * @param qItem {object} - Questionnaire item object\n   * @private\n   * @return true if the item is hidden or if its ancestor is hidden, false otherwise\n   */\n  self._processHiddenItem = function(lfItem, qItem) {\n    var ci = LForms.Util.findObjectInArray(qItem.extension, 'url', self.fhirExtUrlHidden);\n    if(ci) {\n      lfItem._isHiddenInDef = typeof ci.valueBoolean === 'boolean'? ci.valueBoolean: ci.valueBoolean === 'true';\n    }\n    return lfItem._isHiddenInDef;\n  };\n\n\n  /**\n   * Parse questionnaire item for answers list\n   *\n   * @param lfItem {object} - LForms item object to assign answer list\n   * @param qItem {object} - Questionnaire item object\n   * @param containedVS - contained ValueSet info, see _extractContainedVS() for data format details\n   * @private\n   */\n  self._processAnswers = function (lfItem, qItem, containedVS) {\n    if(qItem.answerOption) {\n      lfItem.answers = [];\n      for(var i = 0; i < qItem.answerOption.length; i++) {\n        var answer = {};\n        var option = qItem.answerOption[i];\n        var label = LForms.Util.findObjectInArray(option.extension, 'url', self.fhirExtUrlOptionPrefix);\n        if(label) {\n          answer.label = label.valueString;\n        }\n        var score = LForms.Util.findObjectInArray(option.extension, 'url', self.fhirExtUrlOptionScore);\n        // Look for argonaut extension.\n        score = !score ? LForms.Util.findObjectInArray(option.extension, 'url', self.argonautExtUrlExtensionScore) : score;\n        if(score) {\n          answer.score = score.valueDecimal.toString();\n        }\n        var optionKey = Object.keys(option).filter(function(key) {return (key.indexOf('value') === 0);});\n        if(optionKey && optionKey.length > 0) {\n          if(optionKey[0] === 'valueCoding') { // Only one value[x] is expected\n            if(option[optionKey[0]].code    !== undefined) answer.code = option[optionKey[0]].code;\n            if(option[optionKey[0]].display !== undefined) answer.text = option[optionKey[0]].display;\n            // TBD- Lforms has answer code system at item level, expects all options to have one code system!\n            if(option[optionKey[0]].system  !== undefined) {\n              answer.system = option[optionKey[0]].system;\n            }\n          }\n          else {\n            answer.text = option[optionKey[0]].toString();\n          }\n        }\n\n        lfItem.answers.push(answer);\n      }\n    }\n    else if (qItem.answerValueSet) {\n      if (containedVS)\n        var vs = containedVS[qItem.answerValueSet];\n      if(vs) { // contained\n        lfItem.answers = vs.answers;\n      }\n      else\n        lfItem.answerValueSet = qItem.answerValueSet; // a URI for a ValueSet\n    }\n  };\n\n\n  /**\n   * Parse questionnaire item for editable\n   *\n   * @param lfItem {object} - LForms item object to assign editable\n   * @param qItem {object} - Questionnaire item object\n   * @private\n   */\n  self._processEditable = function (lfItem, qItem) {\n    if (qItem.readOnly) {\n      lfItem.editable = '0';\n    }\n  };\n\n\n  /**\n   * Process answer value\n   * @param {*} answer an entry in item.answerOption or in item.initial\n   * @param {*} vals an array that contains all default answers\n   */\n  self._processDefaultAnswerValue = function (answer, vals) {\n    answer = LForms.Util.deepCopy(answer); // Use a clone to avoid changing the original\n    var val = answer.valueCoding;\n    if (val)\n      val._type = 'Coding'\n    else\n      val = self._getFHIRValueWithPrefixKey(answer, /^value/);\n\n    if (val !== undefined && val !== null)\n      vals.push(val);\n  };\n\n\n  /**\n   * Parse questionnaire item for default answer\n   *\n   * @param lfItem {object} - LForms item object to assign default answer\n   * @param qItem {object} - Questionnaire item object\n   * @private\n   */\n  self._processDefaultAnswer = function (lfItem, qItem) {\n\n    var vals = [];\n    // check item.answerOption.initialSelected\n    if (qItem.answerOption) {\n      qItem.answerOption.forEach(function(elem) {\n        if (elem.initialSelected) {\n          self._processDefaultAnswerValue(elem, vals)\n        }\n      })\n    }\n\n    // check item.initial\n    if (qItem.initial && vals.length === 0) {\n      qItem.initial.forEach(function(elem) {\n        self._processDefaultAnswerValue(elem, vals)\n      });\n    }\n\n    // set default values\n    if (vals.length > 0)\n      this._processFHIRValues(lfItem, vals, true);\n  };\n\n\n  /**\n   *  Returns the first initial quanitity for the given Questionnaire item, or\n   *  null if there isn't one.\n   */\n  self.getFirstInitialQuantity = function(qItem) {\n    return qItem.initial && qItem.initial.length > 0 && qItem.initial[0].valueQuantity || null;\n  };\n\n\n  /**\n   * Parse 'linkId' for the LForms questionCode of a 'display' item, which does not have a 'code'\n   *\n   * @param lfItem {object} - LForms item object to assign questionCode\n   * @param qItem {object} - Questionnaire item object\n   * @private\n   */\n  self._processDisplayItemCode = function (lfItem, qItem) {\n    if (qItem.type === \"display\" && qItem.linkId) {\n      var codes = qItem.linkId.split(\"/\");\n      if (codes && codes[codes.length-1]) {\n        lfItem.questionCode = codes[codes.length-1];\n      }\n    }\n  };\n\n\n  /**\n   * Parse questionnaire item for data type\n   *\n   * @param lfItem {object} - LForms item object to assign data type\n   * @param qItem {object} - Questionnaire item object\n   * @private\n   */\n  self._processDataType = function (lfItem, qItem) {\n    var type = self._getDataType(qItem);\n    if(type === 'SECTION') {\n      lfItem.header = true;\n    }\n    lfItem.dataType = type;\n  };\n\n\n  // Quesitonnaire Response Import\n  self._mergeQR = {\n\n    /**\n     * Get structure information of a QuestionnaireResponse instance\n     * @param qr a QuestionnaireResponse instance\n     * @returns {{}} a QuestionnaireResponse data structure object\n     * @private\n     */\n    _getQRStructure : function(qr) {\n      var qrInfo = {\n        qrItemsInfo: []\n      };\n      if (qr) {\n        this._checkQRItems(qrInfo, qr);\n      }\n      return qrInfo;\n    },\n\n\n    /**\n     * Get structural info of a QuestionnaireResponse by going though each level of items\n     * @param parentQRItemInfo the structural info of a parent item\n     * @param parentItem a parent item in a QuestionnaireResponse object\n     * @private\n     */\n    _checkQRItems : function(parentQRItemInfo, parentQRItem) {\n\n      var qrItemsInfo = [];\n      var repeatingItemProcessed = {};\n\n      if (parentQRItem && parentQRItem.item) {\n        for (var i=0, iLen=parentQRItem.item.length; i<iLen; i++) {\n          var item = parentQRItem.item[i];\n          var linkId = item.linkId; //code is not necessary included in linkId\n          // first item that has the same code, either repeating or non-repeating\n          if (!repeatingItemProcessed[linkId]) {\n            var repeatingInfo = this._findTotalRepeatingNum(linkId, parentQRItem);\n\n            // create structure info for the item\n            var repeatingItems = repeatingInfo.repeatingItems;\n            for (var j=0, jLen=repeatingItems.length; j<jLen; j++) {\n              var qrItemInfo = {\n                linkId: linkId,\n                item: repeatingItems[j],\n                index: j,\n                total: repeatingInfo.total\n              };\n              // check observation instances in the sub level\n              this._checkQRItems(qrItemInfo, repeatingItems[j]);\n              self._checkQRItemAnswerItems(qrItemInfo, repeatingItems[j]);\n              qrItemsInfo.push(qrItemInfo);\n            }\n            repeatingItemProcessed[linkId] = true;\n          }\n        }\n        parentQRItemInfo.qrItemsInfo = qrItemsInfo;\n      }\n    },\n\n\n    /**\n     * Find the number of the repeating items that have the same code\n     * @param linkId an item's linkId\n     * @param parentQRItem a parent item in a QuestionnaireResponse object\n     * @returns a structural info object for a repeating item\n     * @private\n     */\n    _findTotalRepeatingNum : function(linkId, parentQRItem) {\n\n      var total = 0;\n      var repeatingItems = [];\n      for (var i=0, iLen=parentQRItem.item.length; i<iLen; i++) {\n        var item = parentQRItem.item[i];\n        if (linkId === item.linkId) {\n          repeatingItems.push(item);\n          if (Array.isArray(item.answer)) {\n            total += item.answer.length; // answers for repeating questions and repeating answers\n          }\n          else {\n            total += 1;\n          }\n        }\n      }\n\n      return {\n        total: total,\n        repeatingItems: repeatingItems\n      };\n    },\n\n\n    /**\n     * Add repeating items into LForms definition data object\n     * @param parentItem a parent item\n     * @param linkId linkId of a repeating item\n     * @param total total number of the repeating item with the same code\n     * @private\n     */\n    _addRepeatingItems : function(parentItem, linkId, total) {\n      // find the first (and the only one) item\n      var item = null;\n      if (parentItem.items) {\n        for(var i=0, iLen=parentItem.items.length; i<iLen; i++) {\n          if (linkId === parentItem.items[i].linkId) {\n            item = parentItem.items[i];\n            break;\n          }\n        }\n        // insert new items\n        if (item) {\n          while(total > 1) {\n            var newItem = LForms.Util.deepCopy(item);\n            parentItem.items.splice(i, 0, newItem);\n            total -= 1;\n          }\n        }\n      }\n    },\n\n\n    /**\n     * Find a matching repeating item by item code and the index in the items array\n     * @param parentItem a parent item\n     * @param linkId linkId of a repeating (or non-repeating) item\n     * @param index index of the item in the sub item array of the parent item\n     * @returns {{}} a matching item\n     * @private\n     */\n    _findTheMatchingItemByLinkIdAndIndex : function(parentItem, linkId, index) {\n      var item = null;\n      var idx = 0;\n      if (parentItem.items) {\n        for(var i=0, iLen=parentItem.items.length; i<iLen; i++) {\n          if (linkId === parentItem.items[i].linkId) {\n            if (idx === index) {\n              item = parentItem.items[i];\n              break;\n            }\n            else {\n              idx += 1;\n            }\n          }\n        }\n      }\n      return item;\n    },\n\n\n    /**\n     * Find a matching repeating item by item code alone\n     * When used on the LForms definition data object, there is no repeating items yet.\n     * @param parentItem a parent item\n     * @param linkId linkId of an item\n     * @returns {{}} a matching item\n     * @private\n     */\n    _findTheMatchingItemByLinkId : function(parentItem, linkId) {\n      var item = null;\n      if (parentItem.items) {\n        for(var i=0, iLen=parentItem.items.length; i<iLen; i++) {\n          if (linkId === parentItem.items[i].linkId) {\n            item = parentItem.items[i];\n            break;\n          }\n        }\n      }\n      return item;\n    }\n\n  }\n\n}\n\nexport default addSDCImportFns;\n","// A module for Observation-based pre-population.\n\n\n/**\n *  Starts the (likely asynchronous) requests to retrieve linked Observation\n *  resources for pre-population.  When the resources have been retrieved,\n *  prepoluation will be performed.\n * @param lfData the LFormsData object for the form being prepopulated.\n * @return a promise resolving after the resources have been retrieved and\n *  any prepopulation has been performed.\n */\nexport function requestLinkedObs(lfData) {\n  if (LForms.fhirContext?.client && lfData._fhir) {\n    // We will need to know what version of FHIR the server is using.  Make\n    // sure that is available before continuing.\n    if (!LForms._serverFHIRReleaseID) {\n      // Go fetch the server's FHIR version first before continuing\n      return new Promise(function(resolve, reject) {\n        LForms.Util.getServerFHIRReleaseID(function(relID) {\n          if (!relID)\n            reject(\"Unable to obtain the server's FHIR version\");\n          else\n            resolve(requestLinkedObs(lfData));\n        });\n      });\n    }\n    else {\n      var pendingPromises = [];\n      LForms.Util.validateFHIRVersion(LForms._serverFHIRReleaseID);\n      var serverFHIR = LForms.FHIR[LForms._serverFHIRReleaseID];\n      let obsLinkURI = lfData._fhir.SDC.fhirExtObsLinkPeriod;\n      for (var i=0, len=lfData.itemList.length; i<len; ++i) {\n        let item = lfData.itemList[i];\n        const obsExt = item._fhirExt && item._fhirExt[obsLinkURI];\n        if (obsExt) { // an array of at least 1 if present\n          var duration = obsExt[0].valueDuration; // optional\n          var fhirClient = LForms.fhirContext.client;\n\n          // Get a comma separated list of codes\n          const codeQuery = item.codeList.map((code) => {\n            const codeSystem = code.system === 'LOINC' ? serverFHIR.LOINC_URI : code.system;\n            return [codeSystem, code.code].join('|');\n          }).join(',');\n\n          const queryParams = {\n            code: codeQuery, _sort: '-date',\n            status: 'final,amended,corrected',\n            _count: 5  // only need one, but we need to filter out focus=true below\n          };\n          // Temporarily disabling the addition of the focus search\n          // parameter, because of support issues.  Instead, for now, we\n          // will check the focus parameter when the Observation is\n          // returned.  Later, we might query the server to find out whether\n          // :missing is supported.\n          //if (LForms._serverFHIRReleaseID != 'STU3') // STU3 does not know about \"focus\"\n          //  queryParams.focus = {$missing: true}; // TBD -- sometimes :missing is not supported\n\n          // Constrain the date range\n          if (duration && duration.value && duration.code) {\n            // Convert value to milliseconds\n            var result = LForms.ucumPkg.UcumLhcUtils.getInstance().convertUnitTo(duration.code, duration.value, 'ms');\n            if (result.status === 'succeeded') {\n              var date = new Date(new Date() - result.toVal);\n              queryParams.date = 'gt'+date.toISOString();\n            }\n          }\n          pendingPromises.push(\n            fhirClient.patient.request(lfData._buildURL(['Observation'],\n              queryParams)\n            ).then(function(successData) {\n              var bundle = successData;\n              if (bundle.entry) {\n                var foundObs;\n                for (var j=0, jLen=bundle.entry.length; j<jLen && !foundObs; ++j) {\n                  var obs = bundle.entry[j].resource;\n                  if (!obs.focus) { // in case we couldn't use focus:missing above\n                    serverFHIR.SDC.importObsValue(item, obs);\n                    if (item.value) { // obs.value[x] could be missing\n                      foundObs = true;\n                      if (item.unit)\n                        lfData._setUnitDisplay(item.unit);\n                    }\n                  }\n                }\n              }\n              return item.questionCode; // code is not needed, but useful for debugging\n            })\n          );\n        }\n      }\n      return Promise.all(pendingPromises);\n    }\n  }\n};\n\n\n\n","import {requestLinkedObs} from './obs-prepop.mjs';\n\n/**\n *  Defines SDC functions (used by both import and export, or for other\n *  SDC-related purposes) that are the same across the different FHIR versions.\n *  The function takes SDC namespace object defined in the sdc export code,\n *  and adds additional functions to it.\n */\nfunction addCommonSDCFns(ns) {\n\"use strict\";\n\n  var self = ns;\n  self.requestLinkedObs = requestLinkedObs;\n\n  // A mapping of data types of items from LHC-Forms to FHIR Questionnaire\n  self._lformsTypesToFHIRTypes = {\n    \"SECTION\": 'group',\n    \"TITLE\": 'display',\n    \"ST\": 'string',\n    \"BL\": 'boolean',\n    \"REAL\": 'decimal',\n    \"INT\": 'integer',\n    \"DT\": 'date',\n    \"DTM\": 'dateTime',\n    \"TM\": 'time',\n    \"TX\": 'text',\n    \"URL\": 'url',\n    \"CNE\": 'choice',\n    \"CWE\": 'open-choice',\n    \"QTY\": 'quantity',\n    \"attachment\": 'attachment'\n  };\n\n  // A mapping from LHC-Forms data types to the partial field names of the value fields\n  // and initial value fields in FHIR Questionnaire\n  self._lformsTypesToFHIRFields = {\n    \"attachment\": \"Attachment\",\n    \"INT\": 'Integer',\n    \"REAL\": 'Decimal',\n    \"DT\": 'Date',\n    \"DTM\": 'DateTime',\n    \"TM\": 'Time',\n    \"ST\": 'String',\n    \"TX\": 'String',\n    \"BL\": 'Boolean',\n    \"URL\": 'Url',\n    \"CNE\": 'Coding',\n    \"CWE\": 'Coding',\n    \"QTY\": 'Quantity'\n  };\n\n  self._operatorMapping = {\n    'minExclusive': '>',\n    'maxExclusive': '<',\n    'minInclusive': '>=',\n    'maxInclusive': '<=',\n    'value': '=',\n    'notEqual': '!=',\n    '>': 'minExclusive',\n    '<': 'maxExclusive',\n    '>=': 'minInclusive',\n    '<=': 'maxInclusive',\n    '=': 'value',\n    '!=': 'notEqual',\n    'exists': 'exists'\n  };\n\n  /**\n   * Check if a LForms item has repeating questions\n   * @param item a LForms item\n   * @returns {*|boolean}\n   * @private\n   */\n  self._questionRepeats = function(item) {\n    return item._questionRepeatable!==undefined ? item._questionRepeatable :\n      item.questionCardinality && item.questionCardinality.max &&\n      (item.questionCardinality.max === \"*\" || parseInt(item.questionCardinality.max) > 1);\n  };\n\n\n  /**\n   * Check if a LForms item has repeating answers\n   * @param item a LForms item\n   * @returns {*|boolean}\n   * @private\n   */\n  self._answerRepeats = function(item) {\n    return item._multipleAnswers!==undefined ? item._multipleAnswers :\n      item.answerCardinality && item.answerCardinality.max &&\n      (item.answerCardinality.max === \"*\" || parseInt(item.answerCardinality.max) > 1);\n  };\n\n\n  /**\n   * Do a shallow copy of specified fields from source to target.\n   *\n   * @param source - Source object\n   * @param target - Target object\n   * @param fieldList - Array of fields to copy from the source. If the field is\n   * not found in the source, it is ignored.\n   */\n  self.copyFields = function(source, target, fieldList) {\n    if(source && target && fieldList && fieldList.length > 0) {\n      fieldList.forEach(function(field) {\n        if(source.hasOwnProperty(field)) {\n          target[field] = source[field];\n        }\n      });\n    }\n  };\n\n\n  // Store the UCUM code system URI\n  self.UCUM_URI = 'http://unitsofmeasure.org';\n\n\n  /**\n   * Set the given key/value to the object if the value is not undefined, not null, and not an empty string.\n   * @param obj the object to set the key/value on. It can be null/undefined, and if so, a new object will\n   *        be created and returned (only if the value is valid).\n   * @param key the key for the given value to be set to the given object, required.\n   * @param value the value to be set to the given object using the given key.\n   * @return if the input object is not null/undefined, it will be returned;\n   *         if the input object is null/undefined:\n   *         - return the given object as is if the value is invalid, or\n   *         - a newly created object with the given key/value set.\n   * @private\n   */\n  self._setIfHasValue = function (obj, key, value) {\n    if(value !== undefined && value !== null && value !== '') {\n      if(! obj) {\n        obj = {};\n      }\n      obj[key] = value;\n    }\n    return obj;\n  };\n\n\n  /**\n   * Copy between lforms trigger value coding and FHIR enableWhen valueCoding. It only copies 3 fields:\n   * code, system, and display/text (called \"text\" in lforms, \"display\" in FHIR)\n   * @param srcCoding the coding object to copy from\n   * @param dstCoding the coding object to copy to, may be null/undefined, and if null/undefined, a new object\n   *        will be created but only if the srcCoding has at least one of code, system, display/text\n   * @param lforms2Fhir The direction of copying, can be true or false. The direction matters because in lforms,\n   *        the text/display field is called \"text\", while in FHIR, it's called \"display\"\n   * @return the resulting dstCoding object.\n   * @private\n   */\n  self._copyTriggerCoding = function(srcCoding, dstCoding, lforms2Fhir) {\n    let srcTextField = lforms2Fhir? 'text': 'display';\n    let dstTextField = lforms2Fhir? 'display': 'text';\n\n    dstCoding = self._setIfHasValue(dstCoding, 'code', srcCoding.code);\n    dstCoding = self._setIfHasValue(dstCoding, 'system', srcCoding.system);\n    dstCoding = self._setIfHasValue(dstCoding, dstTextField, srcCoding[srcTextField]);\n\n    return dstCoding;\n  };\n\n\n  /**\n   *  Returns true if the given item (or LFormsData) has an expression\n   *  which needs to be re-evaluated when the user changes their response.\n   * @param itemOrLFData the item or LFormsData to be checked.  It is assumed\n   *  that the relevant extensions will be in an _fhirExt hash where\n   *  the key is the URI of the extension and the values are arrays of the FHIR\n   *  extension structure.\n   */\n  self.hasResponsiveExpression = function(itemOrLFData) {\n    var ext = itemOrLFData._fhirExt;\n    return ext ? !!(ext[self.fhirExtCalculatedExp] || ext[self.fhirExtAnswerExp] ||\n       ext[self.fhirExtEnableWhenExp]) : false;\n  };\n\n\n  /**\n   *  Returns true if the given item has an expression\n   *  which sets the list.\n   * @param item the item to be checked.  It is assumed\n   *  that the relevant extensions will be in an _fhirExt hash where\n   *  the key is the URI of the extension and the values are arrays of the FHIR\n   *  extension structure.\n   */\n  self.hasListExpression = function(item) {\n    var ext = item._fhirExt;\n    // This should one day include a check for cqf-expression, when we add\n    // support for it\n    return ext ? !!(ext[self.fhirExtAnswerExp]) : false;\n  };\n\n\n  /**\n   *  Returns true if the given item (or LFormsData) has an expression\n   *  which needs to be evaluated only once, when form is first rendered.\n   * @param itemOrLFData the item or LFormsData to be checked.  It is assumed\n   *  that the relevant extensions will be in an _fhirExt hash where\n   *  the key is the URI of the extension and the values are arrays of the FHIR\n   *  extension structure.\n   */\n  self.hasInitialExpression = function(itemOrLFData) {\n    return !!(itemOrLFData._fhirExt && itemOrLFData._fhirExt[self.fhirExtInitialExp]);\n  };\n\n\n  /**\n   *  Builds a map from extension URIs to arrays of the FHIR extension\n   *  structures, and stores it on the item.  Also builds an array of all\n   *  Expression extensions.\n   *\n   * @param itemOrLFData a form item or an LFormsData which possibly contain\n   *  FHIR extensions (in an \"extension\" property).\n   */\n  self.buildExtensionMap = function(itemOrLFData) {\n    // Initialize a map for testing whether an extension is an Expression extension.\n    // The keys are the URIs, and the values are see to true.\n    if (!self.isExpressionExtension) {\n      self.isExpressionExtension = [self.fhirExtCalculatedExp,\n        self.fhirExtInitialExp, self.fhirExtAnswerExp, self.fhirExtVariable,\n        self.fhirExtEnableWhenExp].reduce((x, k)=>{x[k]=true; return x}, {});\n    }\n\n    if (itemOrLFData.extension) {\n      var m = {};\n      var exprExtensions = [];\n      for (let ext of itemOrLFData.extension) {\n        var extArray = m[ext.url];\n        if (!extArray)\n          extArray =  m[ext.url] = [];\n        extArray.push(ext);\n        if (self.isExpressionExtension[ext.url])\n          exprExtensions.push(ext);\n      }\n      itemOrLFData._fhirExt = m;\n      if (exprExtensions.length)\n        itemOrLFData._exprExtensions = exprExtensions;\n    }\n  };\n\n\n  /**\n   *  Requests launchContext resources.  Assumes LForms.Util.setFHIRContext() has\n   *  been called.\n   * @param lfData a LFormsData object for the form.\n   * @return an array of Promises which resolve when the attempt to load the\n   *  resources has completed (succesful or not, they resolve without being\n   *  rejected).\n   */\n  self.loadLaunchContext = function(lfData) {\n    // launchContext\n    var contextItems = LForms.Util.findObjectInArray(lfData.extension, 'url',\n      self.fhirExtLaunchContext, 0, true);\n    // Define a list of known, supported context variables, which we can get from the FHIR server,\n    // and they resources they are allowed to take.\n    const contextsFromServer = {patient: {Patient: 1}, encounter: {Encounter: 1},\n      user: {Patient: 1, Practitioner: 1, PractitionerRole: 1, RelatedPerson: 1}};\n    const pendingPromises = [];\n\n    /**\n     *  Checks to make sure that the type of the resource is what it should be\n     *  per FHIR's requirements, and if it is okay, assigns the resource to\n     *  the Questionnaires' variables map.\n     * @param name the name of the variable\n     * @param typeList the list of types for the name as specified in the\n     *  launchContext extension.\n     * @param resource the resource that was obtained as the value of the variable.\n     */\n    function addIfValid(name, typeList, resource) {\n      let resType = resource.resourceType;\n      // Validate the \"type\"\n      let permittedTypes = contextsFromServer[name];\n      if (permittedTypes && !permittedTypes[resType]) {\n        console.warn(\"a launch context resource of type \"+restype+\n          \" was found for name \"+name+\", but the supported types for name \"+\n          name + \" are: \"+ Object.keys(permittedTypes).join(\", \"));\n      }\n      else if (typeList.indexOf(resType) == -1) {\n        console.warn(\"Could not retrieve a resource of the requested\" +\n          \" types for launch context name \" +name);\n      }\n      else {\n        lfData._fhirVariables[name] = resource;\n      }\n    }\n\n    for (var i=0, len=contextItems.length; i<len; ++i) {\n      let contextItemExt = contextItems[i].extension;\n      let name=null, typeList=[];\n\n      for (var j=0, jLen=contextItemExt.length; j<jLen; ++j) {\n        var fieldExt = contextItemExt[j];\n        if (!name && fieldExt.url === 'name') {\n          if (fieldExt.valueId) { // Handle a change in the specification\n            console.log(\"Warning:  The type of the launchContext 'name' field should be 'Coding', not 'id'.\");\n            name = fieldExt.valueId;\n          }\n          else\n            name = fieldExt.valueCoding?.code;\n\n          lfData._checkFHIRVarName(name); // might throw if the name is not valid as a variable name\n        }\n        else if (fieldExt.url === 'type') { // there can be more than one\n          typeList.push(fieldExt.valueCode);\n        }\n      }\n      if (name && typeList.length) {\n        pendingPromises.push(new Promise(function(resolve, reject) {\n          let fromMap = LForms.fhirContext.vars?.[name];\n          let contextResource = LForms.fhirContext.client?.[name];\n          if (!fromMap && !contextResource.id) {\n            console.warn('A launch context resource of name '+name+\n              ' was requested by the form, but none was available');\n            // The loading of this resource should not be critical for the\n            // Questionnaire, because it is just for prepopulation.  Don't\n            // reject the promise.\n            resolve();\n          }\n          else {\n            if (fromMap) {\n              addIfValid(name, typeList, fromMap);\n              resolve();\n            }\n            else {\n              contextResource.read().then(function(resource) {\n                if (resource) {\n                  addIfValid(name, typeList, resource);\n                }\n                resolve();\n              },\n              function fail(reason) {\n                console.warn('A launch context of name '+name+' was requested, '+\n                  'but could not be read.');\n                console.error(reason);\n                resolve(); // per above, we are not rejecting the promise\n              });\n            }\n          }\n        }));\n      }\n    }\n    return pendingPromises;\n  };\n}\n\n\nexport default addCommonSDCFns;\n","import {importFHIRQuantity} from './import-common.js'\n\n// TBD import this path function from fhirpath.js.  When that is done, also\n// remove the regex test for /Quantity$/ below and replace it with a simple\n// equality check for a path of 'Quantity'.\n/**\n *  For a given result of a fhirpath.js evaluation, returns the path from the\n *  nearest FHIR type to the result which might be a fragement of that type.\n *  (Example:  Questionnaire.item, given a result consisting of items.)\n */\nfunction path(fhirpathRes) {\n  return fhirpathRes.__path__;\n}\n\n\n/**\n *  Defines SDC import functions that are the same across the different FHIR\n *  versions.  The function takes SDC namespace object defined in the sdc export\n *  code, and adds additional functions to it.\n */\nfunction addCommonSDCImportFns(ns) {\n\"use strict\";\n\n  var self = ns;\n\n  var errorMessages = LForms.Util._internalUtil.errorMessages;\n\n  // FHIR extension urls\n  self.fhirExtUrlCardinalityMin = \"http://hl7.org/fhir/StructureDefinition/questionnaire-minOccurs\";\n  self.fhirExtUrlCardinalityMax = \"http://hl7.org/fhir/StructureDefinition/questionnaire-maxOccurs\";\n  self.fhirExtUrlItemControl = \"http://hl7.org/fhir/StructureDefinition/questionnaire-itemControl\";\n  self.fhirExtUrlUnit = \"http://hl7.org/fhir/StructureDefinition/questionnaire-unit\";\n  self.fhirExtUrlUnitOption = \"http://hl7.org/fhir/StructureDefinition/questionnaire-unitOption\";\n  self.fhirExtUrlOptionPrefix = \"http://hl7.org/fhir/StructureDefinition/questionnaire-optionPrefix\";\n  self.fhirExtVariable = \"http://hl7.org/fhir/StructureDefinition/variable\";\n  self.fhirExtUrlMinValue = \"http://hl7.org/fhir/StructureDefinition/minValue\";\n  self.fhirExtUrlMaxValue = \"http://hl7.org/fhir/StructureDefinition/maxValue\";\n  self.fhirExtUrlMinLength = \"http://hl7.org/fhir/StructureDefinition/minLength\";\n  self.fhirExtUrlRegex = \"http://hl7.org/fhir/StructureDefinition/regex\";\n  self.fhirExtUrlAnswerRepeats = \"http://hl7.org/fhir/StructureDefinition/questionnaire-answerRepeats\";\n  self.fhirExtUrlExternallyDefined = \"http://lhcforms.nlm.nih.gov/fhir/StructureDefinition/questionnaire-externallydefined\";\n  self.argonautExtUrlExtensionScore = \"http://fhir.org/guides/argonaut-questionnaire/StructureDefinition/extension-score\";\n  self.fhirExtUrlHidden = \"http://hl7.org/fhir/StructureDefinition/questionnaire-hidden\";\n  self.fhirExtTerminologyServer = \"http://hl7.org/fhir/StructureDefinition/terminology-server\";\n  self.fhirExtUrlDataControl = \"http://lhcforms.nlm.nih.gov/fhirExt/dataControl\";\n  self.fhirExtCalculatedExp = \"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-calculatedExpression\";\n  self.fhirExtInitialExp = \"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-initialExpression\";\n  self.fhirExtObsLinkPeriod = \"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-observationLinkPeriod\";\n  self.fhirExtObsExtract = 'http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-observationExtract';\n  self.fhirExtAnswerExp = \"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-answerExpression\";\n  self.fhirExtEnableWhenExp = \"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-enableWhenExpression\";\n  self.fhirExtChoiceOrientation = \"http://hl7.org/fhir/StructureDefinition/questionnaire-choiceOrientation\";\n  self.fhirExtLaunchContext = \"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-launchContext\";\n  self.fhirExtMaxSize = \"http://hl7.org/fhir/StructureDefinition/maxSize\";\n  self.fhirExtMimeType = \"http://hl7.org/fhir/StructureDefinition/mimeType\";\n  self.fhirExtUnitOpen = \"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-unitOpen\";\n  self.fhirExtUnitSuppSystem = \"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-unitSupplementalSystem\";\n  self.fhirExtEntryFormat = \"http://hl7.org/fhir/StructureDefinition/entryFormat\";\n\n  self.fhirExtUrlRestrictionArray = [\n    self.fhirExtUrlMinValue,\n    self.fhirExtUrlMaxValue,\n    self.fhirExtUrlMinLength,\n    self.fhirExtUrlRegex\n  ];\n\n  // One way or the other, the following extensions are converted to lforms internal fields.\n  // Any extensions not listed here (there are many) are recognized as lforms extensions as they are.\n  self.handledExtensionSet = new Set([\n    self.fhirExtUrlCardinalityMin,\n    self.fhirExtUrlCardinalityMax,\n    self.fhirExtUrlItemControl,\n    self.fhirExtUrlUnit,\n    self.fhirExtUrlUnitOption,\n    self.fhirExtUrlOptionPrefix,\n    self.fhirExtUrlMinValue,\n    self.fhirExtUrlMaxValue,\n    self.fhirExtUrlMinLength,\n    self.fhirExtUrlRegex,\n    self.fhirExtUrlAnswerRepeats,\n    self.fhirExtUrlExternallyDefined,\n    self.argonautExtUrlExtensionScore,\n    self.fhirExtUrlHidden,\n    self.fhirExtTerminologyServer,\n    self.fhirExtUrlDataControl,\n    self.fhirExtChoiceOrientation\n  ]);\n\n  // Simple functions for mapping extensions to properties in the internal structure.\n  // Parameters:\n  //   extension: the FHIR extension object\n  //   item:  The LForms item to be updated\n  // Returns:  true if the extension should still be added to the LForms item\n  //   extension array, and false/undefined otherwise.\n  //\n  self.extensionHandlers = {};\n  self.extensionHandlers[self.fhirExtMaxSize] = function(extension, item) {\n    item.maxAttachmentSize = extension.valueDecimal || extension.valueInteger; // not sure why it is decimal\n  };\n  self.extensionHandlers[self.fhirExtMimeType] = function(extension, item) {\n    item.allowedAttachmentTypes || (item.allowedAttachmentTypes = []);\n    item.allowedAttachmentTypes.push(extension.valueCode);\n  };\n  self.extensionHandlers[\n    \"http://hl7.org/fhir/StructureDefinition/questionnaire-initialExpression\"] = function(extension, item) {\n    // Update the URI to the current one.\n    extension.url = 'http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-initialExpression';\n    return true; // add extension to LForms item\n  };\n  self.extensionHandlers[self.fhirExtUnitOpen] = function(extension, item) {\n    item._unitOpen = extension.valueCode;\n  }\n  self.extensionHandlers[self.fhirExtUnitSuppSystem] = function(extension, item) {\n    item._unitSuppSystem = extension.valueCanonical;\n  }\n\n  self.extensionHandlers[self.fhirExtUrlExternallyDefined] =  // (also handle old URL below)\n  self.extensionHandlers[\"http://hl7.org/fhir/StructureDefinition/questionnaire-externallydefined\"] =\n  function(extension, item) {\n    if (extension.valueUri) {\n      item.externallyDefined = extension.valueUri;\n    }\n  }\n\n  self.extensionHandlers[self.fhirExtEntryFormat] = function (extension, item) {\n    if (extension.valueString) {\n      item._entryFormat = extension.valueString;\n      return true; // add extension to LForms item\n    }    \n  }\n\n  self.formLevelFields = [\n    // Resource\n    'id',\n    'meta',\n    'implicitRules',\n    'language',\n\n\n    // Domain Resource\n    'text',\n    'contained',\n    'extension',\n    'modifiedExtension',\n\n    // Questionnaire\n    'date',\n    'version',\n    'identifier',\n    'code',  // code in FHIR clashes with previous definition in lforms. It needs special handling.\n    'subjectType',\n    'derivedFrom', // New in R4\n    'status',\n    'experimental',\n    'publisher',\n    'contact',\n    'description',\n    'useContext',\n    'jurisdiction',\n    'purpose',\n    'copyright',\n    'approvalDate',\n    'reviewDate',\n    'effectivePeriod',\n    'url'\n  ];\n\n  self.itemLevelIgnoredFields = [\n    'definition'\n  ];\n\n  /**\n   * Convert FHIR SQC Questionnaire to LForms definition\n   *\n   * @param fhirData - FHIR Questionnaire object\n   * @returns {{}} - LForms json object\n   */\n  self.convertQuestionnaireToLForms = function (fhirData) {\n    var target = null;\n\n    if(fhirData) {\n      target = LForms.Util.baseFormDef();\n      self._processFormLevelFields(target, fhirData);\n      var containedVS = self._extractContainedVS(fhirData);\n\n      if(fhirData.item && fhirData.item.length > 0) {\n        var linkIdItemMap = self._createLinkIdItemMap(fhirData);\n        target.items = [];\n        for( var i = 0; i < fhirData.item.length; i++) {\n          var item = self._processQuestionnaireItem(fhirData.item[i], containedVS, linkIdItemMap);\n          // no instructions on the questionnaire level\n          target.items.push(item);\n        }\n      }\n      target.fhirVersion = self.fhirVersion;\n    }\n    return target;\n  };\n\n\n  /**\n   * Parse form level fields from FHIR questionnaire and assign to LForms object.\n   *\n   * @param lfData - LForms object to assign the extracted fields\n   * @param questionnaire - FHIR questionnaire resource object to parse for the fields.\n   * @private\n   */\n  self._processFormLevelFields = function(lfData, questionnaire) {\n    self.copyFields(questionnaire, lfData, self.formLevelFields);\n\n    // Handle title and name.  In LForms, \"name\" is the \"title\", but FHIR\n    // defines both.\n    lfData.shortName = questionnaire.name; // computer friendly\n    lfData.name = questionnaire.title;\n\n    // Handle extensions on title\n    if (questionnaire._title)\n      lfData.obj_title = questionnaire._title;\n\n    // For backward compatibility, we keep lforms.code as it is, and use lforms.codeList\n    // for storing questionnaire.code. While exporting, merge lforms.code and lforms.codeList\n    // into questionnaire.code. While importing, convert first of questionnaire.code\n    // as lforms.code, and copy questionnaire.code to lforms.codeList.\n    if(questionnaire.code) {\n      // Rename questionnaire code to codeList\n      lfData.codeList = questionnaire.code;\n    }\n    var codeAndSystemObj = self._getCode(questionnaire);\n    if(codeAndSystemObj) {\n      lfData.code = codeAndSystemObj.code;\n      lfData.codeSystem = codeAndSystemObj.system;\n    }\n  };\n\n\n  /**\n   * Process questionnaire item recursively\n   *\n   * @param qItem - item object as defined in FHIR Questionnaire.\n   * @param containedVS - contained ValueSet info, see _extractContainedVS() for data format details\n   * @param linkIdItemMap - Map of items from link ID to item from the imported resource.\n   * @returns {{}} - Converted 'item' field object as defined by LForms definition.\n   * @private\n   */\n  self._processQuestionnaireItem = function (qItem, containedVS, linkIdItemMap) {\n\n    var targetItem = {};\n    //A lot of parsing depends on data type. Extract it first.\n    self._processExtensions(targetItem, qItem);\n    self._processDataType(targetItem, qItem);\n    self._processTextAndPrefix(targetItem, qItem);\n    self._processCodeAndLinkId(targetItem, qItem);\n    self._processDisplayItemCode(targetItem, qItem);\n    self._processEditable(targetItem, qItem);\n    self._processFHIRQuestionAndAnswerCardinality(targetItem, qItem);\n    self._processDisplayControl(targetItem, qItem);\n    self._processDataControl(targetItem, qItem);\n    self._processRestrictions(targetItem, qItem);\n    self._processHiddenItem(targetItem, qItem);\n    self._processUnitList(targetItem, qItem);\n    self._processAnswers(targetItem, qItem, containedVS);\n    self._processDefaultAnswer(targetItem, qItem);\n    self._processTerminologyServer(targetItem, qItem);\n    self._processSkipLogic(targetItem, qItem, linkIdItemMap);\n    self.copyFields(qItem, targetItem, self.itemLevelIgnoredFields);\n    self._processChildItems(targetItem, qItem, containedVS, linkIdItemMap);\n\n    return targetItem;\n  };\n\n\n  /**\n   *  Returns the number of sinificant digits in the number after, ignoring\n   *  trailing zeros.  (I am including this on \"self\" so we can have tests for it.)\n   */\n  self._significantDigits = function(x) {\n    // Based on https://stackoverflow.com/a/9539746/360782\n    // Make sure it is a number and use the builtin number -> string.\n    var s = \"\" + (+x);\n    // The following RegExp include the exponent, which we don't need\n    //var match = /(\\d+)(?:\\.(\\d+))?(?:[eE]([+-]?\\d+))?$/.exec(s);\n    var match = /(\\d+)(?:\\.(\\d+))?/.exec(s);\n    // NaN or Infinity or integer.\n    // We arbitrarily decide that Infinity is integral.\n    if (!match) { return 0; }\n    var wholeNum = match[1];\n    var fraction = match[2];\n    //var exponent = match[3];\n    return wholeNum === '0' ? 0 : wholeNum.length + (fraction ? fraction.length : 0);\n  };\n\n\n  /**\n   *  Imports an observation's values into the given LForms item.\n   * @param lfItem the LForms item to which a value will be assigned.\n   * @param obs the observation whose value will be assigned to lfItem.  It\n   *  assumed that obs has an appropriate data type for its value.\n   */\n  self.importObsValue = function(lfItem, obs) {\n    // Get the value from obs, based on lfItem's data type.  (The alternative\n    // seems to be looping through the keys on obs looking for something that\n    // starts with \"value\".\n    var val = null;\n    var lfDataType = lfItem.dataType;\n    var fhirValType = this._lformsTypesToFHIRFields[lfDataType];\n    // fhirValType is now the FHIR data type for a Questionnaire.  However,\n    // where Questionnaire uses Coding, Observation uses CodeableConcept.\n    if (fhirValType === 'Coding')\n      fhirValType = 'CodeableConcept';\n    if (fhirValType)\n      val = obs['value'+fhirValType];\n    if (!val && (lfDataType === 'REAL' || lfDataType === 'INT')) {\n      // Accept initial value of type Quantity for these types.\n      val = obs.valueQuantity;\n      if (val)\n        val._type = 'Quantity';\n    }\n\n    if (val) {\n      if (!val._type && typeof val === 'object')\n        val._type = fhirValType;\n\n      // Before importing, confirm val contains a valid unit from the\n      // item's unit list.\n      var unitOkay = true;\n      if (val._type === 'Quantity') {\n        if (lfItem.units) {\n          var matchingUnit;\n          var valSystem = val.system;\n          // On SMART sandbox, val.system might have a trailing slash (which is wrong, at least\n          // for UCUM).  For now, just remove it.\n          if (valSystem && valSystem[valSystem.length - 1] === '/')\n            valSystem = valSystem.slice(0, -1);\n          var isUCUMUnit = valSystem === self.UCUM_URI;\n          var ucumUnit;\n          for (var i=0, len=lfItem.units.length; i<len && !matchingUnit; ++i) {\n            var lfUnit = lfItem.units[i];\n            if (lfUnit.system && (lfUnit.system===valSystem && lfUnit.code===val.code) ||\n                !lfUnit.system && (lfUnit.name===val.unit)) {\n              matchingUnit = lfUnit;\n            }\n            if (isUCUMUnit && !matchingUnit && !ucumUnit && lfUnit.system === self.UCUM_URI)\n              ucumUnit = lfUnit;\n          }\n          if (!matchingUnit && ucumUnit) {\n            // See if we can convert to the ucumUnit we found\n            var result = LForms.ucumPkg.UcumLhcUtils.getInstance().convertUnitTo(val.code, val.value, ucumUnit.code);\n            if (result.status === 'succeeded') {\n              matchingUnit = ucumUnit;\n              // Round the result to the same number of significant digits as the\n              // input value.\n              var originalSD = this._significantDigits(val.value);\n              if (originalSD > 0)\n                val.value = parseFloat(result.toVal.toPrecision(originalSD));\n              else\n                val.value = result.toVal;\n              val.code = ucumUnit.code;\n              val.unit = ucumUnit.name || ucumUnit.code; // name can be undefined\n            }\n          }\n          if (!matchingUnit)\n            unitOkay = false;\n          else\n            lfItem.unit = matchingUnit;\n        }\n      }\n      if (unitOkay) {\n        this._processFHIRValues(lfItem, [val]);\n      }\n    }\n  };\n\n\n  /**\n   *   Converts FHIR values to an LForms item values, but does not assign the\n   *   values to the item.  (For a function that assigns values, call _processFHIRValues).\n   *  @param lfItem the LForms item to for which these are new values\n   *  @param fhirVals an array of FHIR values (e.g.  Quantity, Coding, string, etc.).\n   *   Complex types like Quantity should have _type set to the type, if\n   *   possible, or an attempt will be made to guess the FHIR type from the\n   *   lfItem's data type.\n   *  @param forDefault if true, the intented target of the values is the item's\n   *   default value instead of the item value.\n   *  @return an array of the processed/converted values, and an array of any error/warning/info\n   *   messages for each of those messages.  For each item in the messages\n   *   array, if there is a message there will be an object with keys \"errors\",\n   *   \"warnings\", and \"info\" (if those exist), the values of which will will be\n   *   an object with message ID keys (from error-messages.js) and message text\n   *   values in the currently selected language.  Regarding the answers, note\n   *   that Quantities will be returned as is, because those go into more than\n   *   one field on the item, but some error checking will be done for them.\n   */\n  self._convertFHIRValues = function(lfItem, fhirVals, forDefault) {\n    // Note that this is used by the import process, and so lfItem is an item\n    // from the lforms definition object in that case, not an item from LFormsData.\n    // On the other hand, it is also used by the ExpressionProcessor, an in that\n    // case lfItem is an item from LFormsData.\n    var lfDataType = lfItem.dataType;\n    var answers = [];\n    const messages = [];\n    const fhirValPath = path(fhirVals); // TBD - should be on each value, as they might vary\n    for (let i=0, len=fhirVals.length; i<len; ++i) {\n      let fhirVal = fhirVals[i];\n      if (typeof fhirVal == 'object')\n        fhirVal.__path__ = fhirValPath; // TBD - work around for getting path on individual nodes\n      var answer = undefined; // reset back to undefined each iteration\n      let errors = {};\n      let hasMessages = false;\n      if (lfDataType === 'CWE' || lfDataType === 'CNE' ) {\n        var codings = null;\n        if (fhirVal._type === 'CodeableConcept') {\n          codings = fhirVal.coding;\n        }\n        else if (fhirVal._type === 'Coding' || typeof fhirVal === 'object') {\n          codings = [fhirVal];\n        }\n        if (!codings) {\n          // the value or the default value could be a string for 'open-choice'/CWE\n          if (lfDataType === 'CWE') {\n            answer = fhirVal;\n          }\n        }\n        else {\n          // Pick a Coding that is appropriate for this list item.\n          // Note:  It could be an off list Coding.\n          if (lfItem.answers) {\n            var itemAnswers = lfItem.answers;\n            for (var k=0, kLen=codings.length; k<kLen && !answer; ++k) {\n              var coding = codings[k];\n              for (var j=0, jLen=itemAnswers.length; j<jLen && !answer; ++j) {\n                var listAnswer = itemAnswers[j];\n                var listAnswerSystem = listAnswer.system ? LForms.Util.getCodeSystem(listAnswer.system) : null;\n                if ((!coding.system && !listAnswerSystem || coding.system === listAnswerSystem) &&\n                    ((coding.hasOwnProperty('code') && listAnswer.hasOwnProperty('code') &&\n                      coding.code===listAnswer.code) ||\n                     (coding.hasOwnProperty('display') && listAnswer.hasOwnProperty('text') &&\n                      coding.display === listAnswer.text))) {\n                  answer = itemAnswers[j]; // include label in answer text\n                }\n              }\n            }\n          }\n          if (!answer && lfDataType === 'CWE') { // no match in the list.\n            answer = self._processCWECNEValueInQR({valueCoding: fhirVal}, lfItem, true);\n          }\n        }\n      }\n      else if((lfDataType === 'QTY' || lfDataType === 'REAL' || lfDataType === 'INT') &&\n              (fhirVal._type === 'Quantity' || /Quantity$/.test(path(fhirVal)))) {\n        delete fhirVal.__path__;\n        fhirVal._type = 'Quantity';\n        [answer, errors] = this._convertFHIRQuantity(lfItem, fhirVal);\n        hasMessages = !!errors;\n      }\n      // For date types, convert them to date objects, but only for values.\n      // If we're setting defaultAnswer, leave them as strings.\n      else if (!forDefault && lfItem.dataType === 'DTM' && typeof fhirVal === 'string')\n        answer = new Date(fhirVal);\n      else if (!forDefault && lfItem.dataType === 'DT' && typeof fhirVal === 'string')\n        answer = LForms.Util.stringToDTDateISO(fhirVal);\n      else {\n        answer = fhirVal;\n      }\n      answers.push(answer);\n      messages.push(hasMessages ? {errors} : null);\n    }\n    return [answers, messages];\n  };\n\n\n  /**\n   *  Checks a FHIR Quantity for suitability for the given lfItem, converts\n   *  its units as necessary, and sets error messages.\n   * @param lfItem the LForms item to for which these are new values\n   * @param quantity the FHIR Quantity value for the item\n   * @return an array of two elements:  the processed/converted value (possibly\n   *  null if there were an error), and an error/warning/info messages object\n   *  (see _convertFHIRValues for the format) if there were messages.  In the\n   *  case of an error, the converted value will be undefined.  Otherwise, the\n   *  converted value will have fields for item.unit plus a 'value' field for\n   *  the value.\n   */\n  self._convertFHIRQuantity = function(lfItem, quantity, forDefault) {\n    let answer, errors;\n    if (quantity.comparator !== undefined) {\n      errors = {};\n      errorMessages.addMsg(errors, 'comparatorInQuantity');\n    }\n    else {\n      // The unit must match one of the provided units list, or be convertible\n      // to such, unless the extensions unitOpen and unitSupplementalSystem are\n      // specified. (These are R5 features, but we are including support for any\n      // version.)\n\n      if (!lfItem.units) {\n        // In this case the quantity should not have a unit.\n        if (quantity.unit) {\n          errorMessages.addMsg(errors, 'nonMatchingQuantityUnit');\n        }\n        else\n          answer = importFHIRQuantity(quantity);\n      }\n      else {\n        // Try to find a matching unit\n        var matchingUnit;\n        var valSystem = quantity.system;\n        // On SMART sandbox, quantity.system might have a trailing slash (which is wrong, at least\n        // for UCUM).  For now, just remove it.\n        if (valSystem && valSystem[valSystem.length - 1] === '/')\n          valSystem = valSystem.slice(0, -1);\n        var isUCUMUnit = valSystem === self.UCUM_URI;\n        var ucumUnit;\n        for (var i=0, len=lfItem.units.length; i<len && !matchingUnit; ++i) {\n          var lfUnit = lfItem.units[i];\n          if (lfUnit.system && (lfUnit.system===valSystem && lfUnit.code===quantity.code) ||\n              !lfUnit.system && (lfUnit.name===quantity.unit)) {\n            matchingUnit = lfUnit;\n          }\n          if (isUCUMUnit && !matchingUnit && !ucumUnit && lfUnit.system === self.UCUM_URI)\n            ucumUnit = lfUnit;\n        }\n        quantity = LForms.Util.deepCopy(quantity); // so we don't change the input argument\n        if (!matchingUnit && ucumUnit) {\n          // See if we can convert to the ucumUnit we found\n          var result = LForms.ucumPkg.UcumLhcUtils.getInstance().convertUnitTo(\n            quantity.code, quantity.value, ucumUnit.code);\n          if (result.status === 'succeeded') {\n            matchingUnit = ucumUnit;\n            // Round the result to the same number of significant digits as the\n            // input value.\n            var originalSD = this._significantDigits(quantity.value);\n            if (originalSD > 0)\n              quantity.value = parseFloat(result.toVal.toPrecision(originalSD));\n            else\n              quantity.value = result.toVal;\n            quantity.code = ucumUnit.code;\n            quantity.unit = ucumUnit.name || ucumUnit.code; // name can be undefined\n          }\n        }\n        if (!matchingUnit) {\n          if (lfItem._unitOpen == 'optionsOrString') {\n            // Then accept the nonmatching unit, but only as a string\n            delete quantity.code;\n            delete quantity.system;\n          }\n          else if (!(lfItem._unitSuppSystem && lfItem._unitOpen == 'optionsOrType' &&\n                   lfItem._unitSuppSystem == quantity.system)) {\n            errors = {};\n            errorMessages.addMsg(errors, 'nonMatchingQuantityUnit');\n          }\n        }\n      }\n      if (!errors) {\n        answer = importFHIRQuantity(quantity);\n      }\n    }\n\n    return [answer, errors];\n  };\n\n\n  /**\n   *   Assigns FHIR values to an LForms item.\n   *  @param lfItem the LForms item to receive the values from fhirVals\n   *  @param fhirVals an array of FHIR values (e.g.  Quantity, Coding, string, etc.).\n   *   Complex types like Quantity should have _type set to the type, if\n   *   possible, or an attempt will be made to guess the FHIR type from the\n   *   lfItem's data type.\n   *  @param setDefault if true, the default value in lfItem will be set instead\n   *   of the value.\n   */\n  self._processFHIRValues = function(lfItem, fhirVals, setDefault) {\n    // Currently this is called for:\n    //   - importing an Observation value (prepop) (a single value, but could\n    //     have components referred to by child items)\n    //   - processing default answers during an import.  For default answers, we\n    //     do not assign the value here, but just put it in defaultAnswer.\n    // Note that when importing, we are creating a LForms form definition, but\n    // not and LFormsData object.\n    let [answers, messages] = this._convertFHIRValues(lfItem, fhirVals, setDefault);\n    let val = LForms.Util._hasMultipleAnswers(lfItem) ? answers : answers[0];\n    if (setDefault) {\n      lfItem.defaultAnswer = val;\n      LForms.Util._internalUtil.setItemMessagesArray(lfItem, messages, 'default answers');\n    }\n    else {\n      LForms.Util._internalUtil.assignValueToItem(lfItem, val);\n      LForms.Util._internalUtil.setItemMessagesArray(lfItem, messages, '_processFHIRValues');\n    }\n  };\n\n\n  /**\n   * Get a FHIR value from an object given a partial string of hash key.\n   * Use it where at most only one key matches.\n   *\n   * @param obj {object} - Object to search\n   * @param keyRegex {regex} - Regular expression to match a key.  This should\n   *  be the beginning part of the key up to the type (e.g., /^value/, to match\n   *  \"valueQuantity\").\n   * @returns {*} - Corresponding value of matching key.  For complex types,\n   *  such as Quantity, the type of the returned object will be present under\n   *  a _type attribute.\n   * @private\n   */\n  self._getFHIRValueWithPrefixKey = function(obj, keyRegex) {\n    var ret = null;\n    if(typeof obj === 'object') {\n      for(var key in obj) {\n        var matchData = key.match(keyRegex);\n        if (matchData) {\n          ret = obj[key];\n          if (ret && typeof ret === 'object') {\n            ret = LForms.Util.deepCopy(ret); // Work with clone\n            ret._type = key.substring(matchData[0].length);\n          }\n          break;\n        }\n      }\n    }\n\n    return ret;\n  };\n\n\n  /**\n   *  Process the text and prefix data.\n   * @param lfItem {object} - LForms item object to receive the data\n   * @param qItem {object} - Questionnaire item object (as the source)\n   */\n  self._processTextAndPrefix = function(lfItem, qItem) {\n    // prefix\n    if (qItem.prefix)\n      lfItem.prefix = qItem.prefix;\n    // text\n    lfItem.question = qItem.text;\n\n    // Copy item extensions\n    for (let extField of ['_prefix', '_text']) {\n      let extFieldData = qItem[extField];\n      if (extFieldData)\n        lfItem['obj'+extField] = extFieldData;\n    }\n  };\n\n\n  /**\n   * Parse questionnaire item for code and code system\n   * @param lfItem {object} - LForms item object to assign question code\n   * @param qItem {object} - Questionnaire item object\n   * @private\n   */\n  self._processCodeAndLinkId = function (lfItem, qItem) {\n    if(qItem.code) {\n      lfItem.codeList = qItem.code;\n    }\n    var code = self._getCode(qItem);\n    if (code) {\n      lfItem.questionCode = code.code;\n      lfItem.questionCodeSystem = code.system;\n    }\n    // use linkId as questionCode, which should not be exported as code\n    else {\n      lfItem.questionCode = qItem.linkId;\n      lfItem.questionCodeSystem = \"LinkId\";\n    }\n\n    lfItem.linkId = qItem.linkId;\n  };\n\n\n  /**\n   * Parse questionnaire item for question cardinality and answer cardinality\n   *\n   * @param lfItem {object} - LForms item object to assign question cardinality\n   * @param qItem {object} - Questionnaire item object\n   * @private\n   */\n  self._processFHIRQuestionAndAnswerCardinality = function(lfItem, qItem) {\n    var min = LForms.Util.findObjectInArray(qItem.extension, 'url', self.fhirExtUrlCardinalityMin);\n    var max = LForms.Util.findObjectInArray(qItem.extension, 'url', self.fhirExtUrlCardinalityMax);\n    var repeats = qItem.repeats;\n    var required = qItem.required;\n    var answerCardinality, questionCardinality;\n    // CNE/CWE, repeats handled by autocompleter with multiple answers in one question\n    if (lfItem.dataType === 'CNE' || lfItem.dataType === 'CWE') {\n      if (repeats) {\n        answerCardinality = max ? {max: max.valueInteger.toString()} : {max: \"*\"};\n      }\n      else {\n        answerCardinality = {max: \"1\"};\n      }\n      if (required) {\n        answerCardinality.min = min ? min.valueInteger.toString() : \"1\";\n      }\n      else {\n        answerCardinality.min = \"0\";\n      }\n    }\n    // not CNE/CWE, question repeats\n    else {\n      // repeats\n      if (repeats) {\n        questionCardinality = max ? {max: max.valueInteger.toString()} : {max: \"*\"};\n      }\n      else {\n        questionCardinality = {max: \"1\"};\n      }\n      // required\n      if (required) {\n        questionCardinality.min = min ? min.valueInteger.toString() : \"1\";\n        answerCardinality = {min: \"1\"};\n      }\n      else {\n        questionCardinality.min = \"1\";\n      }\n    }\n\n    if (questionCardinality)\n      lfItem.questionCardinality = questionCardinality;\n    if (answerCardinality)\n      lfItem.answerCardinality = answerCardinality;\n  };\n\n\n  /**\n   * Parse questionnaire item for units list\n   *\n   * @param lfItem {object} - LForms item object to assign units\n   * @param qItem {object} - Questionnaire item object\n   * @private\n   */\n  self._processUnitList = function (lfItem, qItem) {\n\n    var lformsUnits = [];\n    var lformsDefaultUnit = null;\n    // The questionnaire-unitOption extension is only for item.type = quantity\n    var unitOption = LForms.Util.findObjectInArray(qItem.extension, 'url', self.fhirExtUrlUnitOption, 0, true);\n    if(unitOption && unitOption.length > 0) {\n      if (qItem.type !== 'quantity') {\n        throw new Error('The extension '+self.fhirExtUrlUnitOption+\n          ' can only be used with type quantity.  Question \"'+\n          qItem.text+'\" is of type '+qItem.type);\n      }\n      for(var i = 0; i < unitOption.length; i++) {\n        var coding = unitOption[i].valueCoding;\n        var lUnit = {\n          name: coding.display,\n          code: coding.code,\n          system: coding.system\n        };\n        lformsUnits.push(lUnit);\n      }\n    }\n\n    // The questionnaire-unit extension is only for item.type = integer or decimal\n    var unit = LForms.Util.findObjectInArray(qItem.extension, 'url', self.fhirExtUrlUnit);\n    if (unit) {\n      if (qItem.type !== 'integer' && qItem.type !== 'decimal') {\n        throw new Error('The extension '+self.fhirExtUrlUnit+\n          ' can only be used with types integer or decimal.  Question \"'+\n          qItem.text+'\" is of type '+qItem.type);\n      }\n      lformsDefaultUnit = {\n        name: unit.valueCoding.display,\n        code: unit.valueCoding.code,\n        system: unit.valueCoding.system,\n        default: true\n      };\n      lformsUnits.push(lformsDefaultUnit);\n    }\n\n    if (qItem.type === 'quantity') {\n      let initialQ = this.getFirstInitialQuantity(qItem);\n      if (initialQ && initialQ.unit) {\n        lformsDefaultUnit = LForms.Util.findItem(lformsUnits, 'name', initialQ.unit);\n        if(lformsDefaultUnit) {\n          lformsDefaultUnit.default = true;\n        }\n        else {\n          lformsDefaultUnit = {\n            name: initialQ.unit,\n            code: initialQ.code,\n            system: initialQ.system,\n            default: true\n          };\n          lformsUnits.push(lformsDefaultUnit);\n        }\n      }\n    }\n\n    if(lformsUnits.length > 0) {\n      if (!lformsDefaultUnit) {\n        lformsUnits[0].default = true;\n      }\n      lfItem.units = lformsUnits;\n    }\n  };\n\n\n  /**\n   * Parse questionnaire item for display control\n   *\n   * @param lfItem {object} - LForms item object to assign display control\n   * @param qItem {object} - Questionnaire item object\n   * @private\n   */\n  self._processDisplayControl = function (lfItem, qItem) {\n    var itemControlType = LForms.Util.findObjectInArray(qItem.extension, 'url', self.fhirExtUrlItemControl);\n\n    if(itemControlType) {\n      var displayControl = {};\n      switch (itemControlType.valueCodeableConcept.coding[0].code) {\n        case 'Lookup': // backward-compatibility with old export\n        case 'Combo-box': // backward-compatibility with old export\n        case 'autocomplete':\n          lfItem.isSearchAutocomplete = true;\n          // continue to drop-down case\n        case 'drop-down':\n          displayControl.answerLayout = {type: 'COMBO_BOX'};\n          break;\n        case 'Checkbox': // backward-compatibility with old export\n        case 'check-box':\n        case 'Radio': // backward-compatibility with old export\n        case 'radio-button':\n          displayControl.answerLayout = {type: 'RADIO_CHECKBOX'};\n          var answerChoiceOrientation = LForms.Util.findObjectInArray(qItem.extension, 'url', self.fhirExtChoiceOrientation);\n          if (answerChoiceOrientation) {\n            if (answerChoiceOrientation.valueCode === \"vertical\") {\n              displayControl.answerLayout.columns = \"1\"\n            }\n            else if (answerChoiceOrientation.valueCode === \"horizontal\") {\n              displayControl.answerLayout.columns = \"0\"\n            }\n          }\n          break;\n        case 'Table': // backward-compatibility with old export\n        case 'gtable':  // Not in STU3, but we'll accept it\n          if(lfItem.dataType === 'SECTION') {\n            displayControl.questionLayout = \"horizontal\";\n          }\n          break;\n        case 'Matrix': // backward-compatibility with old export\n        case 'table':\n          if(lfItem.dataType === 'SECTION') {\n            displayControl.questionLayout = \"matrix\";\n          }\n          break;\n        default:\n          displayControl = null;\n      }\n\n      if(displayControl && !jQuery.isEmptyObject(displayControl)) {\n        lfItem.displayControl = displayControl;\n      }\n    }\n  };\n\n\n  /**\n   * Parse questionnaire item for data control\n   *\n   * @param lfItem {object} - LForms item object to assign data control\n   * @param qItem {object} - Questionnaire item object\n   * @private\n   */\n  self._processDataControl = function (lfItem, qItem) {\n    var dataControlType = LForms.Util.findObjectInArray(qItem.extension, 'url', self.fhirExtUrlDataControl);\n\n    if(dataControlType && dataControlType.valueString) {\n      try {\n        var dataControl = JSON.parse(dataControlType.valueString);\n        if (dataControl) {\n          lfItem.dataControl = dataControl;\n        }\n      }\n      catch(e){\n        console.log(\"Invalid dataControl data!\");\n      }\n    }\n  };\n\n\n  // ---------------- QuestionnaireResponse Import ---------------\n\n  var qrImport = self._mergeQR;\n\n  /**\n   * Merge a QuestionnaireResponse instance into an LForms form object\n   * @param formData an LForms form definition or LFormsData object.\n   * @param qr a QuestionnaireResponse instance\n   * @returns {{}} an updated LForms form definition, with answer data\n   */\n  qrImport.mergeQuestionnaireResponseToLForms = function(formData, qr) {\n    if (!(formData instanceof LForms.LFormsData)) {\n      // get the default settings in case they are missing in the form data\n      // not to set item values by default values for saved forms with user data\n      formData.hasSavedData = true;\n      formData = (new LForms.LFormsData(formData)).getFormData();\n    }\n    // The reference to _mergeQR below is here because this function gets copied to\n    // the containing object to be a part of the public API.\n    var qrInfo = qrImport._getQRStructure(qr);\n    qrImport._processQRItemAndLFormsItem(qrInfo, formData);\n    return formData;\n  };\n\n\n  /**\n   * Merge data into items on the same level\n   * @param parentQRItemInfo structural information of a parent item\n   * @param parentLFormsItem a parent item, could be a LForms form object or a form item object.\n   * @private\n   */\n  qrImport._processQRItemAndLFormsItem = function(parentQRItemInfo, parentLFormsItem) {\n\n    // note: parentQRItemInfo.qrItemInfo.length will increase when new data is inserted into the array\n    for(var i=0; i<parentQRItemInfo.qrItemsInfo.length; i++) {\n\n      var qrItemInfo = parentQRItemInfo.qrItemsInfo[i];\n      var qrItem = qrItemInfo.item;\n      if (qrItem) {\n        // first repeating qrItem\n        if (qrItemInfo.total > 1 && qrItemInfo.index === 0) {\n          var defItem = this._findTheMatchingItemByLinkId(parentLFormsItem, qrItemInfo.linkId);\n          // add repeating items in form data\n          // if it is a case of repeating questions, not repeating answers\n          if (ns._questionRepeats(defItem)) {\n            this._addRepeatingItems(parentLFormsItem, qrItemInfo.linkId, qrItemInfo.total);\n            // add missing qrItemInfo nodes for the newly added repeating LForms items (questions, not sections)\n            if (defItem.dataType !== 'SECTION' && defItem.dataType !== 'TITLE') {\n              for (var j=1; j<qrItemInfo.total; j++) {\n                var newQRItemInfo = LForms.Util.deepCopy(qrItemInfo);\n                newQRItemInfo.index = j;\n                newQRItemInfo.item.answer = [newQRItemInfo.item.answer[j]];\n                if(qrItemInfo.qrAnswersItemsInfo && qrItemInfo.qrAnswersItemsInfo[j]) {\n                  newQRItemInfo.qrAnswersItemsInfo = [qrItemInfo.qrAnswersItemsInfo[j]];\n                }\n                parentQRItemInfo.qrItemsInfo.splice(i+j, 0, newQRItemInfo);\n              }\n              // change the first qr item's answer too\n              qrItemInfo.item.answer = [qrItemInfo.item.answer[0]];\n              if(qrItemInfo.qrAnswersItemsInfo && qrItemInfo.qrAnswersItemsInfo[0]) {\n                qrItemInfo.qrAnswersItemsInfo = [qrItemInfo.qrAnswersItemsInfo[0]];\n              }\n              else {\n                delete qrItemInfo.qrAnswersItemsInfo;\n              }\n            }\n          }\n          // reset the total number of questions when it is the answers that repeats\n          else if (ns._answerRepeats(defItem)) {\n            qrItemInfo.total = 1;\n          }\n        }\n        // find the matching LForms item\n        var item = this._findTheMatchingItemByLinkIdAndIndex(parentLFormsItem, qrItemInfo.linkId, qrItemInfo.index);\n\n        // set up value and units if it is a question\n        if ((item.dataType !== 'SECTION' && item.dataType !== 'TITLE')) {\n          var qrAnswer = qrItem.answer;\n          if (qrAnswer && qrAnswer.length > 0) {\n            this._setupItemValueAndUnit(qrItem.linkId, qrAnswer, item);\n            // process item.answer.item, if applicable\n            if(qrItemInfo.qrAnswersItemsInfo) {\n              // _setupItemValueAndUnit seems to assume single-answer except for multiple choices on CNE/CWE\n              // moreover, each answer has already got its own item above if question repeats\n              if(qrItemInfo.qrAnswersItemsInfo.length > 1) {\n                throw new Error('item.answer.item with item.answer.length > 1 is not yet supported');\n              }\n              this._processQRItemAndLFormsItem(qrItemInfo.qrAnswersItemsInfo[0], item);\n            }\n          }\n        }\n\n        // process items on the sub-level\n        if (qrItemInfo.qrItemsInfo && qrItemInfo.qrItemsInfo.length>0) {\n          this._processQRItemAndLFormsItem(qrItemInfo, item);\n        }\n      }\n    }\n  };\n\n\n  /**\n   * Set value and units on a LForms item\n   * @param linkId an item's linkId\n   * @param answer value for the item\n   * @param item a LForms item\n   * @private\n   */\n  qrImport._setupItemValueAndUnit = function(linkId, answer, item) {\n\n    if (item && linkId === item.linkId && (item.dataType !== 'SECTION' && item.dataType !== 'TITLE')) {\n      var dataType = item.dataType;\n\n      // any one has a unit must be a numerical type, let use REAL for now.\n      // dataType conversion should be handled when panel data are added to lforms-service.\n      if ((!dataType || dataType===\"ST\") && item.units && item.units.length>0 ) {\n        item.dataType = dataType = \"REAL\";\n      }\n\n      var qrValue = answer[0];\n\n      switch (dataType) {\n        case \"BL\":\n          if (qrValue.valueBoolean === true || qrValue.valueBoolean === false) {\n            item.value = qrValue.valueBoolean;\n          }\n          break;\n        case \"INT\":\n          if (qrValue.valueQuantity) {\n            item.value = qrValue.valueQuantity.value;\n            if(qrValue.valueQuantity.code) {\n              item.unit = {name: qrValue.valueQuantity.code};\n            }\n          }\n          else if (qrValue.valueInteger) {\n            item.value = qrValue.valueInteger;\n          }\n          break;\n        case \"REAL\":\n        case \"QTY\":\n          if (qrValue.valueQuantity) {\n            var quantity = qrValue.valueQuantity;\n            var lformsQuantity = importFHIRQuantity(quantity);\n            LForms.Util._internalUtil.assignValueToItem(item, lformsQuantity, 'Quantity');\n          }\n          else if (qrValue.valueDecimal) {\n            item.value = qrValue.valueDecimal;\n          }\n          break;\n        case \"DT\":\n          item.value = qrValue.valueDate;\n          break;\n        case \"DTM\":\n          item.value = qrValue.valueDateTime;\n          break;\n        case \"CNE\":\n        case \"CWE\":\n          if (ns._answerRepeats(item)) {\n            var value = [];\n            for (var j=0,jLen=answer.length; j<jLen; j++) {\n              var val = ns._processCWECNEValueInQR(answer[j], item);\n              if (val) {\n                value.push(val);\n              }\n            }\n            item.value = value;\n          }\n          else {\n            var val = ns._processCWECNEValueInQR(qrValue, item);\n            if (val) {\n              item.value = val;\n            }\n          }\n          break;\n        case \"ST\":\n        case \"TX\":\n          item.value = qrValue.valueString;\n          break;\n        case \"attachment\":\n          item.value = qrValue.valueAttachment;\n          break;\n        case \"SECTION\":\n        case \"TITLE\":\n        case \"\":\n          // do nothing\n          break;\n        default:\n          item.value = qrValue.valueString;\n      }\n    }\n  }\n\n\n  /**\n   * Get LForms data type from questionnaire item\n   *\n   * @param qItem {object} - Questionnaire item object\n   * @private\n   */\n  self._getDataType = function (qItem) {\n    var type = 'string';\n\n    switch (qItem.type) {\n      case 'string':\n        type = 'ST';\n        break;\n      case 'group':\n        type = 'SECTION';\n        break;\n      case \"choice\":\n        type = 'CNE';\n        break;\n      case \"open-choice\":\n        type = 'CWE';\n        break;\n      case 'integer':\n        type = 'INT';\n        break;\n      case 'decimal':\n        type = 'REAL';\n        break;\n      case 'text':\n        type = 'TX';\n        break;\n      case \"boolean\":\n        type = 'BL';\n        break;\n      case \"date\":\n        //dataType = 'date';\n        type = 'DT';\n        break;\n      case \"dateTime\":\n        type = 'DTM';\n        break;\n      case \"time\":\n        type = 'TM';\n        break;\n      case \"display\":\n        type = 'TITLE';\n        break;\n      case \"url\":\n        type = 'URL';\n        break;\n      case \"quantity\":\n        type = 'QTY';\n        break;\n      case \"attachment\":\n        type = 'attachment';\n        break;\n    }\n    return type;\n  };\n\n\n  /**\n   * Build a map of items to linkid from a questionnaire resource.\n   * @param qResource - FHIR Questionnaire resource\n   * @returns {*} - Hash object with link id keys pointing to their respective items.\n   * @private\n   */\n  self._createLinkIdItemMap = function (qResource) {\n    var traverse = function (itemArray, collection) {\n        itemArray.forEach(function(item) {\n          collection[item.linkId] = item;\n          if(item.item) {\n            traverse(item.item, collection);\n          }\n        });\n\n      return collection;\n    };\n\n    var ret = {};\n    if(qResource.item) {\n      ret = traverse(qResource.item, ret);\n    }\n    return ret;\n  };\n\n\n  /**\n   * Get an object with code and code system\n   *\n   * @param questionnaireItemOrResource {object} - question\n   * @private\n   */\n  self._getCode = function (questionnaireItemOrResource) {\n    var code = null;\n    if(questionnaireItemOrResource &&\n      Array.isArray(questionnaireItemOrResource.code) &&\n      questionnaireItemOrResource.code.length) {\n      code = {\n        code: questionnaireItemOrResource.code[0].code,\n        system: self._toLfCodeSystem(questionnaireItemOrResource.code[0].system)\n      };\n    }\n    // If code is missing look for identifier.\n    else if(questionnaireItemOrResource &&\n      Array.isArray(questionnaireItemOrResource.identifier) &&\n      questionnaireItemOrResource.identifier.length) {\n      code = {\n        code: questionnaireItemOrResource.identifier[0].value,\n        system: self._toLfCodeSystem(questionnaireItemOrResource.identifier[0].system)\n      };\n    }\n\n    return code;\n  };\n\n\n  /**\n   *  Converts the given ValueSet into an array of answers that can be used with a prefetch autocompleter.\n   * @return the array of answers, or null if the extraction cannot be done.\n   */\n  self.answersFromVS = function (valueSet) {\n    var vs = valueSet;\n    var rtn = [];\n    if (vs.expansion && vs.expansion.contains && vs.expansion.contains.length > 0) {\n      vs.expansion.contains.forEach(function (vsItem) {\n        var answer = {code: vsItem.code, text: vsItem.display, system: vsItem.system};\n        var ordExt = LForms.Util.findObjectInArray(vsItem.extension, 'url',\n          self.fhirExtUrlValueSetScore);\n        if(ordExt) {\n          answer.score = ordExt.valueDecimal;\n        }\n        rtn.push(answer);\n      });\n    }\n    return rtn.length > 0 ? rtn : null;\n  };\n\n\n  /**\n   * Convert the given code system to LForms internal code system. Currently\n   * only converts 'http://loinc.org' to 'LOINC' and returns all other input as is.\n   * @param codeSystem\n   * @private\n   */\n  self._toLfCodeSystem = function(codeSystem) {\n    var ret = codeSystem;\n    switch(codeSystem) {\n      case 'http://loinc.org':\n        ret = 'LOINC';\n        break;\n    }\n\n    return ret;\n  };\n\n\n  // Copy the main merge function to preserve the same API usage.\n  self.mergeQuestionnaireResponseToLForms = qrImport.mergeQuestionnaireResponseToLForms;\n\n  /**\n   *  Processes the terminology server setting, if any.\n   *\n   * @param lfItem - LForms item object to assign externallyDefined\n   * @param qItem - Questionnaire item object\n   * @private\n   */\n  self._processTerminologyServer = function (lfItem, qItem) {\n    var tServer = LForms.Util.findObjectInArray(qItem.extension, 'url', self.fhirExtTerminologyServer);\n    if (tServer && tServer.valueUrl) {\n      lfItem.terminologyServer = tServer.valueUrl;\n    }\n  };\n\n\n  /**\n   * Parse Questionnaire item for externallyDefined url\n   *\n   * @param lfItem - LForms item object to assign externallyDefined\n   * @param qItem - Questionnaire item object\n   * @private\n   */\n  self._processExternallyDefined = function (lfItem, qItem) {\n    var externallyDefined = LForms.Util.findObjectInArray(qItem.extension, 'url', self.fhirExtUrlExternallyDefined);\n    if (externallyDefined && externallyDefined.valueUri) {\n      lfItem.externallyDefined = externallyDefined.valueUri;\n    }\n  };\n\n\n  /**\n   *  Finds the terminology server URL (if any) for the given item.\n   * @param item a question, title, or group in the form (in the LFormsData\n   *  structure, not the Questionnaire).\n   * @return the base terminology server URL, or undefined if there isn't one\n   *  for this item.\n   */\n  self._getTerminologyServer = function(item) {\n    var terminologyServer = item.terminologyServer;\n    var parent = item._parentItem;\n    while (!terminologyServer && parent) {\n      terminologyServer = parent.terminologyServer;\n      parent = parent._parentItem;\n    }\n    return terminologyServer;\n  };\n\n\n  /**\n   *  Returns the URL for performing a ValueSet expansion for the given item,\n   *  if the given item has a terminology server and answerValueSet\n   *  configured; otherwise it returns undefined.\n   * @param item a question, title, or group in the form\n   */\n  self._getExpansionURL = function(item) {\n    var rtn;\n    if (item.answerValueSet) {\n      var terminologyServer = this._getTerminologyServer(item);\n      if (terminologyServer)\n        rtn = terminologyServer + '/ValueSet/$expand?url='+ item.answerValueSet;\n    }\n    return rtn;\n  };\n\n  /**\n   *  Loads answerValueSets for prefetched lists.\n   * @param lfData the LFormsData for the form\n   * @return an array of promise objects which resolve when the answer valuesets\n   * have been loaded and imported.\n   */\n  self.loadAnswerValueSets = function (lfData) {\n    var pendingPromises = [];\n    var items = lfData.itemList;\n    for (var i=0, len=items.length; i<len; ++i) {\n      let item = items[i];\n      if (item.answerValueSet && !item.isSearchAutocomplete) {\n        let expURL = this._getExpansionURL(item);\n        let vsKey = expURL ? expURL : item.answerValueSet;\n        item._answerValueSetKey = vsKey;\n        if (!LForms._valueSetAnswerCache)\n          LForms._valueSetAnswerCache = {};\n        let answers = LForms._valueSetAnswerCache[vsKey];\n        if (answers) {\n          item.answers = answers;\n          lfData._updateAutocompOptions(item);\n        }\n        else { // if not already loaded\n          if (expURL) {\n            pendingPromises.push(fetch(expURL).then(function(response) {\n              return response.json();\n            }).then(function(parsedJSON) {\n              if (parsedJSON.resourceType===\"OperationOutcome\" ) {\n                var errorOrFatal = parsedJSON.issue.find(item => item.severity===\"error\" || item.severity===\"fatal\")\n                if (errorOrFatal) {\n                  throw new Error(errorOrFatal.diagnostics)\n                }\n              }\n              else {\n                answers = self.answersFromVS(parsedJSON);\n                if (answers) {\n                  LForms._valueSetAnswerCache[expURL] = answers;\n                  item.answers = answers;\n                  lfData._updateAutocompOptions(item);\n                }\n              }\n            }).catch(function(error) {\n              throw new Error(\"Unable to load ValueSet from \"+expURL);\n            }));\n          }\n          else { // use FHIR context\n            var fhirClient = LForms.fhirContext.client;\n            pendingPromises.push(fhirClient.request(lfData._buildURL(\n              ['ValueSet','$expand'], {url: item.answerValueSet})\n            ).then(function(response) {\n              var valueSet = response;\n              var answers = self.answersFromVS(valueSet);\n              if (answers) {\n                LForms._valueSetAnswerCache[vsKey] = answers;\n                item.answers = answers;\n                lfData._updateAutocompOptions(item);\n              }\n            }).catch(function(error) {\n              throw new Error(\"Unable to load ValueSet \"+item.answerValueSet+ \" from FHIR server\");\n            }));\n          }\n        }\n      }\n    }\n    return pendingPromises;\n  };\n\n\n  /**\n   * Handle the item.value in QuestionnaireResponse for CWE/CNE typed items\n   * @param qrItemValue a value of item in QuestionnaireResponse\n   * @param lfItem an item in lforms\n   * @param notOnList a flag indicates if the item's value is known to be not any of the answers \n   * in the answer list. If false or undefined, a check of the answers will be made.\n   * @returns {{code: *, text: *}}\n   * @private\n   */\n  self._processCWECNEValueInQR = function(qrItemValue, lfItem, notOnList) {\n    var retValue;\n    // a valueCoding, which is one of the answers\n    if (qrItemValue.valueCoding) {\n      var c = qrItemValue.valueCoding;\n      retValue = {};\n      if (c.code)\n        retValue.code = c.code;\n      if (c.display)\n        retValue.text = c.display;\n      if (c.system)\n        retValue.system = c.sysetm;\n\n      \n      if (notOnList) {\n        retValue._notOnList = true;\n      }\n      // compare retValue to the item.answers\n      // if not same, add \"_notOnList: true\" to retValue\n      else if (lfItem.dataType === 'CWE' && lfItem.answers) {\n        var found = false;\n        for(var i=0, len=lfItem.answers.length; i<len; i++) {\n          if (LForms.Util.areTwoAnswersSame(retValue, lfItem.answers[i], lfItem)) {\n            found = true;\n            break;\n          }\n        }\n        if (!found) {\n          retValue._notOnList = true;\n        }  \n      }\n    }\n    // a valueString, which is a user supplied value that is not in the answers\n    else if (qrItemValue.valueString) {\n      retValue = qrItemValue.valueString;\n    }\n    return retValue;\n  };\n\n\n  /**\n   * Parse questionnaire item for coding instructions\n   *\n   * @param qItem {object} - Questionnaire item object\n   * @return {{}} an object contains the coding instructions info.\n   * @private\n   */\n  self._processCodingInstructions = function(qItem) {\n    // if the qItem is a \"display\" typed item with a item-control extension, then it meant to be a help message,\n    // which in LForms is an attribute of the parent item, not a separate item.\n    let ret = null;\n    let ci = LForms.Util.findObjectInArray(qItem.extension, 'url', self.fhirExtUrlItemControl);\n    let xhtmlFormat;\n    if ( qItem.type === \"display\" && ci) {\n      // only \"redering-xhtml\" is supported. others are default to text\n      if (qItem._text) {\n        xhtmlFormat = LForms.Util.findObjectInArray(qItem._text.extension, 'url', \"http://hl7.org/fhir/StructureDefinition/rendering-xhtml\");\n      }\n\n      // there is a xhtml extension\n      if (xhtmlFormat) {\n        ret = {\n          codingInstructionsFormat: \"html\",\n          codingInstructions: xhtmlFormat.valueString,\n          codingInstructionsPlain: qItem.text  // this always contains the coding instructions in plain text\n        };\n      }\n      // no xhtml extension, default to 'text'\n      else {\n        ret = {\n          codingInstructionsFormat: \"text\",\n          codingInstructions: qItem.text,\n          codingInstructionsPlain: qItem.text // this always contains the coding instructions in plain text\n        };\n      }\n    }\n\n    return ret;\n  };\n\n\n  /**\n   *  Processes the child items of the item.\n   * @param targetItem the LForms node being populated with data\n   * @param qItem the Questionnaire (item) node being imported\n   * @param linkIdItemMap - Map of items from link ID to item from the imported resource.\n   * @param containedVS - contained ValueSet info, see _extractContainedVS() for data format details\n   */\n  self._processChildItems = function(targetItem, qItem, containedVS, linkIdItemMap) {\n    if (Array.isArray(qItem.item)) {\n      targetItem.items = [];\n      for (var i=0; i < qItem.item.length; i++) {\n        var help = self._processCodingInstructions(qItem.item[i]);\n        // pick one coding instruction if there are multiple ones in Questionnaire\n        if (help !== null) {\n          targetItem.codingInstructions = help.codingInstructions;\n          targetItem.codingInstructionsFormat = help.codingInstructionsFormat;\n          targetItem.codingInstructionsPlain = help.codingInstructionsPlain;\n        }\n        else {\n          var item = self._processQuestionnaireItem(qItem.item[i], containedVS, linkIdItemMap);\n          targetItem.items.push(item);\n        }\n      }\n    }\n  };\n\n\n  /**\n   *  Copy extensions that haven't been handled before.\n   *\n   * @param lfItem the LForms node being populated with data\n   * @param qItem the Questionnaire (item) node being imported\n   */\n  self._processExtensions = function(lfItem, qItem) {\n    var extensions = [];\n    if (Array.isArray(qItem.extension)) {\n      for (var i=0; i < qItem.extension.length; i++) {\n        var ext = qItem.extension[i];\n        var extHandler = self.extensionHandlers[ext.url];\n        if ((extHandler && extHandler(ext, lfItem)) ||\n            !self.handledExtensionSet.has(qItem.extension[i].url)) {\n          extensions.push(qItem.extension[i]);\n        }\n      }\n    }\n    if(extensions.length > 0) {\n      lfItem.extension = extensions;\n    }\n  };\n\n\n  /**\n   * If the given entity is an array, it will return the array length, return -1 otherwise.\n   * @param entity the given entity (can be anything) that needs to be tested to see if it's an array\n   * @return {number} the array length or -1 if the given entity is not an array.\n   * @private\n   */\n  self._arrayLen = function(entity) {\n    return entity && Array.isArray(entity)? entity.length: -1;\n  };\n\n\n  /**\n   * Get structural info of a QuestionnaireResponse item.answer.item in a way similar to that of item.item.\n   * If any answer entry in item.answer has items, the qrItemInfo.qrAnswersItemsInfo will be assigned, which\n   * will be an array where each element corresponds to one answer element in item.answer. When an answer entry\n   * does not have any items, null will be used to fill the position.\n   * @param qrItemInfo the structural info of the given item\n   * @param item the item in a QuestionnaireResponse object whose answer.item structure is to be created.\n   * @private\n   */\n  self._checkQRItemAnswerItems = function(qrItemInfo, item) {\n    var answerLen = self._arrayLen(item.answer);\n    if(answerLen < 1) {\n      return;\n    }\n\n    var numAnswersWithItems = 0;\n    var answersItemsInfo = []; // one entry for each answer; each entry is an qrItemsInfo array for the answer.item\n    for (var i = 0; i < answerLen; i++) {\n      if(this._arrayLen(item.answer[i].item) > 0) {\n        answersItemsInfo.push({});\n        self._mergeQR._checkQRItems(answersItemsInfo[i], item.answer[i]);\n        ++ numAnswersWithItems;\n      }\n      else {\n        answersItemsInfo.push(null);\n      }\n    }\n\n    if(numAnswersWithItems > 0) {\n      qrItemInfo.numAnswersWithItems = numAnswersWithItems;\n      qrItemInfo.qrAnswersItemsInfo = answersItemsInfo;\n    }\n  };\n\n\n  /**\n   * Parse questionnaire item for restrictions\n   *\n   * @param lfItem {object} - LForms item object to assign restrictions\n   * @param qItem {object} - Questionnaire item object\n   * @private\n   */\n   self._processRestrictions = function (lfItem, qItem) {\n    var restrictions = {};\n    if(typeof qItem.maxLength !== 'undefined') {\n      restrictions['maxLength'] = qItem.maxLength.toString();\n    }\n\n    for(var i = 0; i < self.fhirExtUrlRestrictionArray.length; i++) {\n      var restriction = LForms.Util.findObjectInArray(qItem.extension, 'url', self.fhirExtUrlRestrictionArray[i]);\n      var val = self._getFHIRValueWithPrefixKey(restriction, /^value/);\n      if (val !== undefined && val !== null) {\n\n        if(restriction.url.match(/minValue$/)) {\n          // TODO -\n          // There is no distinction between inclusive and exclusive.\n          // Lforms looses this information when converting back and forth.\n          restrictions['minInclusive'] = val;\n        }\n        else if(restriction.url.match(/maxValue$/)) {\n          restrictions['maxInclusive'] = val;\n        }\n        else if(restriction.url.match(/minLength$/)) {\n          restrictions['minLength'] = val;\n        }\n        else if(restriction.url.match(/regex$/)) {\n          restrictions['pattern'] = val;\n        }\n      }\n    }\n\n    if(!jQuery.isEmptyObject(restrictions)) {\n      lfItem.restrictions = restrictions;\n    }\n  };\n\n}\n\nexport default addCommonSDCImportFns;\n","var extURL = 'http://hl7.org/fhir/StructureDefinition/rendering-style';\n\n/**\n *  A generic API for processing an extension found on some node in the\n *  Questionnaire structure being imported.\n *  (The parameter list will likely get more complicated in the future.)\n * @param lfNode the node in the LFormsData structure on which the information\n *  from the extension will be stored.\n * @param fieldName the field name  on which the extension was found (e.g.\n *  'item' or 'title').  This forms part of the field name on lfNode where the\n *  data from the extension will be stored.\n * @param extNode the extension's structure with its data.\n */\nfunction processExtension(lfNode, fieldName, extNode) {\n  var css = extNode.valueString;\n  if (css)\n    lfNode['_'+fieldName+'CSS'] = css;\n}\n\nexport default {\n  extURL: extURL,\n  processExtension: processExtension\n};\n","import renderingStyle from './extensions/rendering-style';\nvar extProcessors = {};\nextProcessors[renderingStyle.extURL] = renderingStyle.processExtension;\n\nexport function addCommonRuntimeFns(ns) {\n  var self = ns;\n\n  /**\n   *  Processes the extensions on either lfNode, or lfNode[lfFieldName], if\n   *  lfFieldName is provided.  Only the extensions for which processors\n   *  are written (in the \"extensions\" sub-directory) are considered.\n   * @param lfNode the node in the LFormsData structure on which the information\n   *  from the extension will be stored.\n   * @param lfFieldName (optional).  Sometimes the extension information is on a\n   *  sub-node, (e.g. 'obj_text') in which case this should be the field for\n   *  retrieving that sub-node.\n   */\n  self.processExtensions = function(lfNode, lfFieldName) {\n    var fieldData = lfFieldName ? lfNode[lfFieldName] : lfNode;\n    if (fieldData) {\n      var extensions = fieldData.extension;\n      if (extensions) {\n        for (var i=0, len=extensions.length; i<len; ++i) {\n          var extData = extensions[i];\n          var extURL = extData.url;\n          var processor = extProcessors[extURL];\n          if (processor)\n            processor(lfNode, lfFieldName, extData);\n        }\n      }\n    }\n  };\n}\n","// Processes FHIR Expression Extensions\n// There are three types of expressions: FHIRPath, x-fhir-query (to a FHIR\n// server), and CQL (but we do not yet support CQL).\n// Various extensions have an Expression as a value, such as variable,\n// initialExpression, calculatedExpression, and answerExpression.  When the\n// Expression contains a name, that creates a variable which can be used by\n// other Expressions defined either on the same item or a child item.\n//\n// The general processing pattern is depth-first traversal of the \"tree\" of the\n// Questionnaire's items, and while we go through the expressions we keep track\n// of whether a field has changed and whether a variable has changed.  If there\n// are any changes, we traverse the tree again, but if the only things that\n// changed were variables, then we only have to traverse the parts of the tree\n// for which those variables are in scope.\n//\n// A further complication is that x-fhir-query Expressions require an\n// asynchronous call.  So, after each traversal, we have to wait for those to\n// complete before starting the next traversal (if one is needed).  This is also\n// why the main function, runCalculations, returns a promise that resolves\n// when the expression run has been completed.\n//\n// Also, because there is possibility of asynchronous queries, we have to handle\n// the fact that runCalculations might get called again while before the first\n// call has finished.\n\nexport let ExpressionProcessor;\nimport copy from \"fast-copy\";\nimport deepEqual from \"deep-equal\";\n\n(function() {\n  \"use strict\";\n  // A class whose instances handle the running of FHIR expressions.\n\n  /**\n   *   Constructor.\n   *  @param lfData an instance of LForms.LFormsData.  The _fhir attribute\n   *   should be set before this is called.\n   */\n  ExpressionProcessor = function(lfData) {\n    // A cache of x-fhir-query URIs to results\n    this._queryCache = {};\n\n    // An array of pending x-fhir-query results\n    this._pendingQueries = [];\n\n    // A hash of calculated values, where the keys are the part of item_.elememntId\n    // minus the final repetition number (so it is shared by instances of\n    // repeating fields).\n    this._calculatedValues = {};\n\n    // A hash of item._elementId values to \"repetition key\" values which can be used as\n    // keys in this._calcualtedValues.\n    this._repetitionKeys = {};\n\n    // Keeps track of whether a request to run the calculations has come in\n    // while we were already busy.\n    this._pendingRun = false;\n\n    // The promise returned by runCalculations, when a run is active.\n    this._currentRunPromise = undefined;\n\n    this._lfData = lfData;\n    if (!lfData._fhir)\n      throw new Error('lfData._fhir should be set');\n    this._fhir = lfData._fhir;\n    this._compiledExpressions = {};\n  };\n\n\n  ExpressionProcessor.prototype = {\n    /**\n     *   Runs the FHIR expressions in the form.  This the main function in this\n     *   module.\n     *  @param includeInitialExpr whether to include the \"initialExpression\"\n     *   expressions (which should only be run once, after asynchronous loads\n     *   from questionnaire-launchContext have been completed).\n     *  @return a Promise that resolves when the expressions have been run, and\n     *   there are no pending runs left to do.\n     */\n    runCalculations: function(includeInitialExpr) {\n      // Defer running calculations while we are waiting for earlier runs to\n      // finish.\n      if (this._currentRunPromise) // then we will just return that promise\n        this._pendingRun = true; // so we know to run them when we can\n      else {\n        this._pendingRun = false; // clear this because we are running them now\n        this._runStart = new Date();\n        // Create an export of Questionnaire for the %questionnaire variable in\n        // FHIRPath.  We only need to do this once per form.\n        var lfData = this._lfData;\n        if (!lfData._fhirVariables.questionnaire) {\n          lfData._fhirVariables.questionnaire =\n            this._fhir.SDC.convertLFormsToQuestionnaire(lfData);\n        }\n        this._regenerateQuestionnaireResp();\n        self = this;\n        this._currentRunPromise =\n          this._asyncRunCalculations(includeInitialExpr, false).then(()=>{\n            // At this point, every promise for the pending queries has been\n            // resolved, and we are done.\n            console.log(\"Ran expressions in \"+(new Date()-self._runStart)+\" ms\");\n            if (!self._firstExpressionRunComplete) // if this is the first run\n              self._firstExpressionRunComplete = true;\n            self._currentRunPromise = undefined;\n            if (self._pendingRun) {\n              return self.runCalculations(false); // will set self._currentRunPromise again\n            }\n          },\n          (failureReason) => {\n            console.log(\"Run of expressions failed; reason follows\");\n            console.log(failureReason);\n            self._currentRunPromise = undefined;\n            self._pendingRun = false;\n            self._pendingQueries = []; // reset\n            throw failureReason;\n          });\n      }\n      return this._currentRunPromise;\n    },\n\n\n    /**\n     *  Waits for any pending queries.\n     * @return a Promise the resolves when everything is finished, including any\n     *  pending re-run request.  The returned promise will be rejected if something\n     *  goes wrong.\n     * @return the same map about changes as in _evaluateExpressions.\n     */\n    _handlePendingQueries: function() {\n      const self = this;\n      return Promise.allSettled(this._pendingQueries).then(function(results) {\n        self._pendingQueries = []; // reset\n        var varsChanged=false, fieldsChanged=false;\n        for (var i=0, len=results.length;\n             (!varsChanged || !fieldsChanged) && i<len; ++i) {\n          var changes = results[i].value;\n          if (changes) {\n            varsChanged = varsChanged || changes.variables;\n            fieldsChanged = fieldsChanged || changes.fields;\n          }\n          else if (results[i].status == 'rejected')\n            return Promise.reject(results[i].reason);\n        }\n        return {fields: fieldsChanged, variables: varsChanged};\n      });\n    },\n\n\n    /**\n     *  This is conceptually a part of runCalculations, but it is this part of\n     *  it that might need to call itself if fields or variables update.\n     *  The basic algorithm is a depth-first traversal of the items to run their\n     *  expressions.  Some of those might be asynchronous (e.g. x-fhir-query\n     *  variables), so we wait for those to complete before looking at what has\n     *  changed and deciding whether to run the expressions again.\n     * @param includeInitialExpr whether to include the \"initialExpression\"\n     *  expressions (which should only be run once, after asynchronous loads\n     *  from questionnaire-launchContext have been completed).\n     * @param changesByVarsOnly whether to run all field expressions, or just the ones\n     *  that are likely to have been affected by changes from variable expressions.\n     * @return a promise that resolves when all Expressions which needed to be\n     *  processed have been processed and the values have stablized.\n     */\n    _asyncRunCalculations: function(includeInitialExpr, changesByVarsOnly) {\n      const self = this;\n      const lfData = this._lfData;\n      var changes = null; // data about what the calculations changed\n      changes = this._evaluateExpressions(lfData, includeInitialExpr, changesByVarsOnly);\n      // Wait for any asynchronous queries to complete\n      return this._handlePendingQueries().then(function(queryChanges) {\n        // Two types of reported changes are possible -- variables and field values\n        let varsChanged = changes.variables || queryChanges.variables;\n        let fieldsChanged = changes.fields || queryChanges.fields;\n        if (varsChanged || fieldsChanged) {\n          // Run again\n          if (fieldsChanged)\n            self._regenerateQuestionnaireResp();\n          let onlyVarsChanged = !fieldsChanged;\n          return self._asyncRunCalculations(includeInitialExpr, onlyVarsChanged);\n        }\n      });\n    },\n\n\n    /**\n     *  Updates the value of an item's FHIR variable.  If the variable value has changed,\n     *  item._varChanged will be set to true.\n     * @param item the item on which the variable is defined\n     * @param varName the name of the variable\n     * @param newVal the new value of the variable.\n     * @return whether the value changed.\n     */\n    _updateItemVariable: function (item, varName, newVal) {\n      var oldVal = item._fhirVariables[varName];\n      item._fhirVariables[varName] = newVal;\n      if (!deepEqual(oldVal, newVal)) {\n        item._varChanged = true; // flag for re-running expressions.\n      }\n      return item._varChanged;\n    },\n\n\n\n    /**\n     *  Evaluates the expressions for a given item.\n     * @param item an LFormsData or item from LFormsData.\n     * @param includeInitialExpr whether or not to run expressions from\n     *  initialExpression extensions (which should only be run when the form is\n     *  loaded).\n     * @param changesByVarsOnly whether to run all field expressions, or just the ones\n     *  that are likely to have been affected by changes from variable expressions.\n     * @return a map with two fields, \"variables\" and \"fields\", which will be\n     *  present and set to true if the evaluation changed variables (including\n     *  implicit variables created by named expressions of some other\n     *  non-variable type) or field values, respectively.\n     */\n    _evaluateExpressions: function(item, includeInitialExpr, changesByVarsOnly) {\n      var rtn = {};\n      // If changesByVarsOnly, for any item that has _varChanged set, we run any field\n      // expressions that are within that group (or item).\n      if (changesByVarsOnly && item.items && item._varChanged) {\n        item._varChanged = false; // clear flag\n        changesByVarsOnly = false; // clear it, so we process this and all child items\n      }\n      if (!changesByVarsOnly) { // process this and all child items\n        item._varChanged = false; // clear flag in case it was set\n        var fhirExt = item._fhirExt;\n        if (fhirExt) {\n          var sdc = this._fhir.SDC;\n          var exts = item._exprExtensions;\n          if (exts) {\n            var fieldChanged = false;\n            var self = this;\n            for (let i=0, len=exts.length; i<len; ++i) {\n              let ext = exts[i];\n              // Skip initialExpressions if we are not including those.\n              let isInitialExp = ext.url == sdc.fhirExtInitialExp;\n              if (includeInitialExpr || !isInitialExp) {\n                let isCalcExp = ext.url == sdc.fhirExtCalculatedExp;\n                // We only run initialExpression or calculatedExpression\n                // on one of the repeating items of the repeating group (the\n                // last one, because there is a flag to mark the last one).\n                if ((isCalcExp || isInitialExp) && item._questionRepeatable && !item._lastRepeatingItem)\n                  continue; // skip to next expression extension for this item\n\n                // Skip calculated expressions of editable fields for which the user has\n                // edited the value.\n                // Compare the item.value to the last calculated value (if any).  If\n                // they differ, then the user has edited the field, and in that case we\n                // skip setting the value and halt further calculations for the field.\n                var prevCalcVals = this._calculatedValues[this._getRepetitionKey(item)];\n                let currentVals;\n                if (isCalcExp && !item._userModifiedCalculatedValue && prevCalcVals) {\n                  // Get the current values for the item, which might be\n                  // repeating.\n                  currentVals = this._lfData.getItemValues(item);\n                  if (!this._equalAnswers(prevCalcVals, currentVals) && !item._answerListReset) {\n                    item._userModifiedCalculatedValue = true;\n                  }\n                }\n\n                if (!isCalcExp || !item._userModifiedCalculatedValue) {\n                  let varName = ext.valueExpression.name; // i.e., a variable name\n                  var itemVars;\n                  if (varName)\n                    itemVars = this._getItemVariables(item); // creates item._fhirVariables if necessary\n                  var oldVal;\n                  let newVal;\n                  var updateValue = false;\n                  if (ext.valueExpression.language==\"text/fhirpath\") {\n                    if (varName) {\n                      // Temporarily delete the old value, so we don't have\n                      // circular references.\n                      oldVal = itemVars[varName];\n                      delete itemVars[varName];\n                    }\n                    newVal = this._evaluateFHIRPath(item,\n                      ext.valueExpression.expression);\n                    updateValue = true;\n                    if (varName)\n                      itemVars[varName] = oldVal; // update handled below\n                  }\n                  else if (ext.valueExpression.language==\"application/x-fhir-query\") {\n                    let queryURL = ext.valueExpression.expression;\n                    // The expression might have embedded FHIRPath in the URI, inside {{...}}\n                    // Use \"undefinedExprVal\" to keep track of whether one of\n                    // the embedded FHIRPath expressions returns undefined (or\n                    // null).\n                    let undefinedExprVal = false;\n                    queryURL = queryURL.replace(/\\{\\{([^}]+)\\}\\}/g, function(match, fpExp) {\n                      // Replace the FHIRPath with the evaluated expressions\n                      let result = self._evaluateFHIRPath(item, fpExp)[0];\n                      if (result === null || result === undefined)\n                        undefinedExprVal = true; // i.e., URL likely not usable\n                      return undefinedExprVal ? '' : '' + result;\n                    });\n                    if (!item._currentFhirQueryURLs)\n                      item._currentFhirQueryURLs = {};\n                    let oldQueryURL = item._currentFhirQueryURLs[varName];\n                    // If queryURL is not a new value, we don't need to do anything\n                    if (queryURL !== oldQueryURL) {\n                      item._currentFhirQueryURLs[varName] = queryURL;\n                      if (undefinedExprVal) {\n                        newVal = undefined;\n                        updateValue = true;\n                      }\n                      else {\n                        // Look for a cached result\n                        if (this._queryCache.hasOwnProperty(queryURL)) {\n                          newVal = this._queryCache[queryURL];\n                          updateValue = true;\n                        }\n                        else { // query not cached\n                          let fetchPromise = this._fetch(queryURL);\n                          // Store the promise that handles the response. We\n                          // will have to wait for it later.\n                          this._pendingQueries.push(fetchPromise.then(function(parsedJSON) {\n                            newVal = (self._queryCache[queryURL] = parsedJSON);\n                          }, function fail(e) {\n                            console.error(\"Unable to load FHIR data from \"+queryURL);\n                          }).then(function() {\n                            // Update the item with the fetched value, and\n                            // update the variable if there was a name defined.\n                            var fChanged = self._updateItemFromExp(\n                              item, ext.url, varName, newVal, isCalcExp, currentVals);\n                            if (varName) {\n                              var vChanged = self._updateItemVariable(item, varName,\n                                newVal);\n                            }\n                            \n                            if (item._answerListReset) item._answerListReset =false; \n\n                            return {fields: fChanged, variables: vChanged};\n                          }));\n                        }\n                      }\n                    }\n                  }\n                  // else CQL (TBD)\n\n                  if (updateValue) {\n                    // Update the item with the fetched value, and\n                    // update the variable if there was a name defined.\n                    var fChanged = this._updateItemFromExp(\n                      item, ext.url, varName, newVal, isCalcExp, currentVals);\n                    fieldChanged = fieldChanged || fChanged;\n                    if (varName)\n                      this._updateItemVariable(item, varName, newVal);\n                  }\n                }\n              }\n            }\n\n            if (item._answerListReset) item._answerListReset =false; \n\n            rtn = {fields: fieldChanged, variables: item._varChanged};\n          }\n        }\n      }\n\n      // Process child items\n      if (item.items) {\n        var childChanges;\n        var childItems = item.items;\n        for (var j=0; j<childItems.length; ++j) { // childItem.length can change as we process expressions\n          // Note:  We need to process all the child items; we cannot do an\n          // early loop exit based on rtn.\n          childChanges = this._evaluateExpressions(item.items[j], includeInitialExpr, changesByVarsOnly);\n          if (childChanges.fields)\n            rtn.fields = true;\n          if (childChanges.variables)\n            rtn.variables = true;\n        }\n      }\n\n      return rtn;\n    },\n\n\n    /**\n     *  Regenerates the QuestionnaireResponse resource and the map from\n     *  LFormsData _elementIDs to items in the QuestionnaireResponse.\n     */\n    _regenerateQuestionnaireResp: function() {\n      var questResp = this._fhir.SDC.convertLFormsToQuestionnaireResponse(this._lfData);\n      this._lfData._fhirVariables.resource = questResp;\n      this._elemIDToQRItem = this._createIDtoQRItemMap(questResp);\n    },\n\n\n    /**\n     *  Returns the nearest ancestor of item (or item itelf) that has\n     *  _fhirVariables defined.\n     * @param item either an LFormsData or an item from an LFormsData.\n     */\n    _itemWithVars: function(item) {\n      var itemWithVars = item;\n      while (!itemWithVars._fhirVariables)\n        itemWithVars = itemWithVars._parentItem; // should terminate at lfData\n      return itemWithVars;\n    },\n\n\n    /**\n     *  Gets or creates if not yet initialized, the item's _fhirVariables\n     *  map (storing its variable values).  This should not be called until it is\n     *  known that the item should have a _fhirVariables map.\n     * @param item either an LFormsData or an item from an LFormsData.\n     * @return the item's _fhirVariables map\n     */\n    _getItemVariables: function(item) {\n      var rtn = item._fhirVariables;\n      if (!rtn) {\n        // Create a hash for variables that will have access to\n        // variables defined higher up in the tree.\n        rtn = item._fhirVariables = Object.create(\n          this._itemWithVars(item)._fhirVariables);\n      }\n      return rtn;\n    },\n\n\n    /**\n     *  Fetches an x-fhir-query URL.\n     * @param queryURL the URL (possibly relative) to fetch.\n     * @return a Promise that resolves to the (parsed) JSON response.\n     */\n    _fetch: function(queryURL) {\n      var fetchPromise;\n      // If the queryURL is a relative URL, then if there is a FHIR\n      // context (set via LForms.Util.setFHIRContext), use that to send\n      // the query; otherwise just use fetch.\n      // Also, set the format to JSON.\n      queryURL += (queryURL.indexOf('?')>0 ? '&' : '?')+'_format=json';\n      if (!/^https?:/.test(queryURL) && LForms.fhirContext?.client) {\n        fetchPromise = LForms.fhirContext.client.request(queryURL);\n      }\n      else {\n        fetchPromise = fetch(queryURL).then(function(response) {\n          return response.json();\n        });\n      }\n      return fetchPromise;\n    },\n\n\n    /**\n     *  Updates an item's data following the run of an expression.\n     * @param item either an LFormsData or an item from an LFormsData.\n     * @param expURL the URL of the expression\n     * @param varName variable name from the expression (if any)\n     * @param newVal the new value of the variable (if any)\n     * @param isCalcExp whether the expression was a calculated expression.\n     *  This could be detected from expURL, but the caller already knows it.\n     * @param currentVals (optional) the current values of item, if known\n     * @return true if the field value changed\n     */\n    _updateItemFromExp(item, expURL, varName, newVal, isCalcExp, currentVals) {\n      var fieldChanged = false;\n      var sdc = this._fhir.SDC;\n      if (isCalcExp || expURL != sdc.fhirExtVariable) {\n        if (expURL == sdc.fhirExtAnswerExp)\n          fieldChanged = this._setItemListFromFHIRPath(item, newVal);\n        else if (expURL == sdc.fhirExtEnableWhenExp) {\n          // The new value should be a boolean.  Coerce it to a boolean, and\n          // report a warning if it was not a boolean.\n          var actualNewVal = newVal[0];\n          newVal = !!actualNewVal;\n          if (newVal !== actualNewVal) {\n            LForms.Util.showWarning('An expression from enableWhenExpression '+\n              'did not resolve to a Boolean as required', item);\n          }\n          if (varName) { // if there is a variable name defined, a change in the value matters\n            var oldVal = !!item._enableWhenExpVal; // _enableWhenExpVal could be undefined\n            fieldChanged = oldVal != newVal;\n          }\n          item._enableWhenExpVal = newVal;\n        }\n        else // else initial or calculated expression\n          fieldChanged = this._setItemValueFromFHIRPath(item, newVal, isCalcExp, currentVals);\n      }\n      return fieldChanged;\n    },\n\n\n    /**\n     *  Evaluates the given FHIRPath expression defined in an extension on the\n     *  given item.\n     * @param item either an LFormsData or an item from an LFormsData.\n     * @param expression the FHIRPath to evaluate with the context of item's\n     *  equivalent node in the QuestionnaireResponse.\n     * @returns the result of the expression.\n     */\n    _evaluateFHIRPath: function(item, expression) {\n      var fhirPathVal;\n      // Find the item-level fhirpathVars\n      var itemVars = this._itemWithVars(item)._fhirVariables;\n      try {\n        // We need to flatten the fhirVariables chain into a simple hash of key/\n        // value pairs.\n        var fVars = {};\n        for (var k in itemVars)\n          fVars[k] = itemVars[k];\n        let contextNode, base;\n        if (item._elementId) {\n          contextNode = this._elemIDToQRItem[item._elementId];\n          contextNode ||= {}; // the item might not be present in the QR if there is no value\n          base = 'QuestionnaireResponse.item';\n        }\n        else {\n          contextNode = this._lfData._fhirVariables.resource;\n        }\n\n        var compiledExpr = this._compiledExpressions[expression];\n        if (!compiledExpr) {\n          if (base)\n            expression = {base, expression};\n          compiledExpr = this._compiledExpressions[expression] =\n            this._fhir.fhirpath.compile(expression, this._fhir.fhirpathModel);\n        }\n        fhirPathVal = compiledExpr(contextNode, fVars);\n      }\n      catch (e) {\n        // Sometimes an expression will rely on data that hasn't been filled in yet.\n        console.log(e);\n      }\n      return fhirPathVal;\n    },\n\n\n    /**\n     *  Returns a hash from the LForms _elementId of each item to the\n     *  corresponding QuestionnaireResponse item.\n     * @param qr the QuestionnaireResponse corresponding to the current\n     * LFormsData.\n     */\n    _createIDtoQRItemMap: function(qr) {\n      var map = {};\n      this._addToIDtoQRItemMap(this._lfData, qr, map);\n      return map;\n    },\n\n\n    /**\n     *  Adds to the map from LFormsData items to QuestionnaireResponse items and\n     *  returns the number of items added.\n     * @param lfItem an LFormsData, or an item within it.\n     * @param qrItem the corresponding QuestionnaireResponse or an item within\n     * it.\n     * @param map the map to which entries will be added.\n     * @return the number of items added to the map.\n     */\n    _addToIDtoQRItemMap: function(lfItem, qrItem, map) {\n      var added = 0;\n      if (lfItem.linkId === qrItem.linkId) {\n        if (lfItem.items) {\n          // lfItem.items might contain items that don't have values, but\n          // qrItem.item will not, so we need to skip the blank items.\n          //\n          // Also, for a repeating question, there will be multiple answers on an\n          // qrItem.item, but repeats of the item in lfItem.items with one answer\n          // each, unless answerCardinality is '*' (list items), in which case\n          // there can be multiple answers per lforms item.\n\n          // LForms does not currently support items that contain both answers\n          // and child items, but I am trying to accomodate that here for the\n          // future.\n          if (qrItem && qrItem.item && qrItem.item.length > 0) {\n            var lfItems = lfItem.items, qrItems = qrItem.item;\n            var numLFItems = lfItems.length;\n            for (var i=0, qrI=0, len=qrItems.length; qrI<len && i<numLFItems; ++qrI) {\n              // Answers are repeated in QR, but items are repeated in LForms\n              var qrIthItem = qrItems[qrI];\n              var lfIthItem = lfItems[i];\n              if (!qrIthItem.answer) {\n                // process item anyway to handle child items with data\n                let newlyAdded = this._addToIDtoQRItemMap(lfIthItem, qrIthItem, map);\n                if (newlyAdded === 0) {\n                  // lfIthItem was blank, so qrIthItem must be for a following\n                  // item.\n                  --qrI; // so we try qrIthItem with the next lfIthItem\n                }\n                else\n                  added += newlyAdded;\n                ++i;\n              }\n              else { // there are answers on the qrIthItem item\n                var numAnswers = qrIthItem.answer ? qrIthItem.answer.length : 0;\n                for (var a=0; a<numAnswers; ++i) {\n                  if (i >= numLFItems)\n                    throw new Error('Logic error in _addToIDtoQRITemMap; ran out of lfItems');\n                  let lfIthItem = lfItems[i];\n                  let newlyAdded = this._addToIDtoQRItemMap(lfIthItem, qrIthItem, map);\n                  if (newlyAdded != 0) { // lfItems[i] was not blank\n                    if (Array.isArray(lfIthItem.value))\n                      a += lfIthItem.value.length;\n                    else\n                      a += 1;\n                  }\n                  added += newlyAdded;\n                }\n              }\n            }\n          }\n        }\n\n        // this item has _elementId and has a value\n        if (lfItem._elementId && (added || lfItem.value !== undefined && lfItem.value !== null && lfItem.value !== \"\")) {\n          if (!qrItem) { // if there is data in lfItem, there should be a qrItem\n            throw new Error('Logic error in _addToIDtoQRItemMap; missing qrItem');\n          }\n          else {\n            map[lfItem._elementId] = qrItem;\n            added += 1;\n          }\n        }\n      }\n      return added;\n    },\n\n\n    /**\n     *  Assigns the given list result to the item.  If the list has changed, the\n     *  field is cleared.\n     * @param list an array of list items computed from a FHIRPath expression.\n     * @return true if the list changed\n     */\n    _setItemListFromFHIRPath: function(item, list) {\n      let currentList = item.answers;\n      let hasCurrentList = !!currentList && Array.isArray(currentList);\n      let listHasData = !!list && Array.isArray(list);\n      let changed = (hasCurrentList != listHasData) ||\n        listHasData && (list.length != currentList.length);\n      let newList = []; // a reformatted version of \"list\"\n      const scoreURI = this._fhir.SDC.fhirExtUrlOptionScore;\n      if (listHasData) {\n        // list should be an array of any item type, including Coding.\n        // (In R5, FHIR will start suppoing lists of types other than Coding.)\n        for (let i=0, len=list.length; i<len; ++i) {\n          // Assume type \"object\" means a coding, and that otherwise what we have\n          // is something useable as display text. It is probably necessary to\n          // convert them to strings in that case, which means that in the future\n          // (R5), we might have to save/re-create the original data type and value.\n          // Work will need to be done to autocomplete-lhc to support data objects\n          // associated with list values.\n          let entry = list[i], newEntry = (newList[i] = {});\n          if (typeof entry === 'object') {\n            let code = entry.code;\n            if (code !== undefined)\n              newEntry.code = code;\n            let display = entry.display;\n            if (display !== undefined)\n              newEntry.text = display;\n            let system = entry.system;\n            if (system !== undefined)\n              newEntry.system = system;\n            // A Coding can have the extension for scores\n            let scoreExt = item._fhirExt && item._fhirExt[scoreURI];\n            if (scoreExt)\n              newEntry.score = scoreExt[0].valueDecimal;\n          }\n          else\n            newEntry.text = '' + entry;\n          if (!changed) {\n            changed = (!hasCurrentList ||\n              !this._lfData._objectEqual(newEntry, currentList[i]));\n          }\n        }\n      }\n\n      if (changed) {\n        // reset the answer list\n        item.answers = newList;\n        // reset item.value \n        // 1) when there are user saved data from QuestionnaireResponse and \n        //    the initial loading (and fhirpath expressions) have run once\n        // 2) when there are no user saved data.\n        if (this._lfData.hasSavedData && this._firstExpressionRunComplete || !this._lfData.hasSavedData) {\n          // reset the previously selected answer (by user or by fhirpath expression)\n          item.value = null;\n          // reset the cached calculated value\n          this._calculatedValues[this._getRepetitionKey(item)] = [];\n          // user selected/typed value will be reset when the answer list has changed\n          item._userModifiedCalculatedValue = false;\n        }\n        this._lfData._updateAutocompOptions(item, true);\n        this._lfData._resetItemValueWithAnswers(item);\n        \n        item._answerListReset = true;\n      }\n      return changed;\n    },\n\n\n    /**\n     *  Assigns the given FHIRPath result to the given item.\n     * @param item the item from the LFormsData object that is receiving the new\n     *  value.\n     * @param fhirPathRes the result of a FHIRPath evaluation.\n     * @param isCalcExp whether this is from a calculated expression, in which\n     *  case a decision will be made whether to skip setting the value.\n     * @param oldVal (optional) the item current item values, if known\n     * @return true if the value changed\n     */\n    _setItemValueFromFHIRPath: function(item, fhirPathRes, isCalcExp, oldVal) {\n      if (oldVal === undefined)\n        oldVal = this._lfData.getItemValues(item);\n      // If the FHIRPath expression resulted in an error, fhirPathRes is\n      // undefined.  TBD - show an error to the user.  I think the safest thing\n      // to do here is to leave the item untouched.\n      var changed = false;\n      if (fhirPathRes !== undefined) {\n        var [newVal, messages] = this._fhir.SDC._convertFHIRValues(item, fhirPathRes);\n        var nonEmptyNewVal = newVal.filter(x=>!LForms.Util.isItemValueEmpty(x));\n        const msgSource = 'FHIRPath value expression';\n        changed = !deepEqual(oldVal, nonEmptyNewVal);\n        // If this is the first run of the expressions, and there is\n        // saved user data, then we check whether the calculated value matches\n        // what the user entered (or erased) and if it doesn't, we halt further\n        // calculations for this field and restore the saved value.\n        if (changed && isCalcExp && !this._firstExpressionRunComplete\n            && this._lfData.hasSavedData) {\n          item._userModifiedCalculatedValue = true;\n          changed = false;\n        }\n        else if (changed) {\n          var newLastItem = this._lfData.setRepeatingItems(item, newVal, messages, msgSource);\n        }\n        else { // the messages might have changed\n          this._lfData.setRepeatingItemMessages(item, messages, msgSource);\n        }\n\n        // Store the calculated value.\n        this._calculatedValues[this._getRepetitionKey(item)] = nonEmptyNewVal;\n      }\n      return changed;\n    },\n\n\n    /**\n     *  Returns the key used to store/retrieve the calculated value for a given\n     *  item's repetitions.\n     * @param item an instance of a repeating item.\n     */\n    _getRepetitionKey: function(item) {\n      var rtn = this._repetitionKeys[item._elementId];\n      if (!rtn && item._elementId) {\n        var found = item._elementId.match(/\\/\\d+$/);\n        if (found) {\n          rtn = this._repetitionKeys[item._elementId] = item._elementId.substring(0, found.index);\n        }\n      }\n      return rtn;\n    },\n\n\n    /**\n     * Check if two answers or two arrays of answers have the same value, \n     * ignoring any fields starting with \"_\"\n     * @param {*} answer1 an array of answer values/objects\n     * @param {*} answer2 an array of answer values/objects\n     */\n    _equalAnswers(answer1, answer2) {\n\n      let ans1 = copy(answer1), ans2 = copy(answer2);\n\n      // answer1 is an array\n      if (Array.isArray(ans1)) {\n        ans1.forEach(answer => { this._filterAnswerFields(answer) })\n      }          \n\n      // answer2 is an array\n      if (Array.isArray(ans2)) {\n        ans2.forEach(answer => { this._filterAnswerFields(answer) })\n      }          \n\n      let rtn = deepEqual(ans1, ans2)\n      return rtn;\n    },\n\n\n    /**\n     * a function to remove fields starting with \"_\" in an answer object\n     * @param {*} answer an answer value/object\n     */\n    _filterAnswerFields(answer) {\n      if (typeof answer === 'object' && !(answer instanceof Date)) {\n        Object.keys(answer).forEach(key => {\n          if (key && key[0]===\"_\") {\n            delete answer[key]\n          }\n        })  \n      }\n    }\n\n  };\n\n})();\n","// Initializes the FHIR structure for R4\nlet fhirVersion = 'R4';\nif (!LForms.FHIR)\n  LForms.FHIR = {};\nimport {LOINC_URI} from '../fhir-common';\nvar fhir = LForms.FHIR[fhirVersion] = {\n  LOINC_URI: LOINC_URI\n};\nfhir.fhirpath = require('fhirpath');\nfhir.fhirpathModel = require('fhirpath/fhir-context/r4');\nimport dr from '../diagnostic-report.js';\n// Because we are assigning ./export.js to dr below, we need our own copy of the\n// dr object.\nconst drCopy = Object.assign({}, dr);\nfhir.DiagnosticReport = drCopy;\nimport commonExport from './export.js';\nfhir.DiagnosticReport._commonExport = commonExport;\nimport fhir_sdc from './sdc-export.js';\nfhir.SDC = fhir_sdc;\nfhir.SDC._commonExport = commonExport;\nimport addCommonSDCExportFns from '../sdc-export-common.js';\naddCommonSDCExportFns(fhir.SDC);\nimport addSDCImportFns from './sdc-import.js';\naddSDCImportFns(fhir.SDC);\nimport addCommonSDCFns from '../sdc-common.js';\naddCommonSDCFns(fhir.SDC);\nimport addCommonSDCImportFns from '../sdc-import-common.js';\naddCommonSDCImportFns(fhir.SDC);\nimport { addCommonRuntimeFns } from '../runtime-common.js';\naddCommonRuntimeFns(fhir.SDC);\nimport { ExpressionProcessor } from '../expression-processor.js';\nfhir.SDC.ExpressionProcessor = ExpressionProcessor;\nfhir.SDC.fhirVersion = fhirVersion; // Needed by lfData for fhirpath, etc.\n\nfhir.reservedVarNames = {};\n['context', 'resource'].forEach(function(name) {\n  fhir.reservedVarNames[name] = true;\n});\n","// Definitions for things needed by both importing and exporting.\n\nexport let LOINC_URI = 'http://loinc.org';\n"],"names":["Token","require","Lexer","Interval","BufferedTokenStream","tokenSource","tokens","index","fetchedEOF","marker","this","seek","lazyInit","adjustSeekIndex","length","LA","EOF","sync","i","n","fetch","t","nextToken","tokenIndex","push","type","start","stop","types","undefined","subset","contains","LT","k","LB","setup","channel","token","nextOnChannel","nextTokenOnChannel","DEFAULT_TOKEN_CHANNEL","from_","to","filterForChannel","prevOnChannel","previousTokenOnChannel","left","right","hidden","getSourceName","interval","fill","s","text","TokenStream","module","exports","CommonToken","CommonTokenFactory","copyText","source","line","column","getText","TokenFactory","DEFAULT","CommonTokenStream","lexer","DEFAULT_CHANNEL","InputStream","data","decodeToUnicodeCodePoints","name","strdata","_index","codePoint","codePointAt","Array","codeUnit","charCodeAt","_size","offset","pos","Math","min","result","String","fromCodePoint","slice","item","toString","IntervalSet","intervals","readOnly","v","INVALID_TYPE","addInterval","l","h","toAdd","clone","existing","splice","max","reduce","other","forEach","current","next","toRemove","removeRange","removeOne","x","value","replace","literalNames","symbolicNames","elemsAreChar","toTokenString","toCharString","toIndexString","names","fromCharCode","join","j","elementName","EPSILON","map","acc","val","Set","BitSet","ATNConfig","RuleStopState","RuleTransition","NotSetTransition","WildcardTransition","AbstractPredicateTransition","predictionContextFromRuleContext","PredictionContext","SingletonPredictionContext","LL1Analyzer","atn","count","transitions","look","alt","lookBusy","_LOOK","transition","target","EMPTY","HIT_PRED","stopState","ctx","r","lookContext","calledRuleStack","seeThruPreds","addEOF","c","state","context","add","addOne","isEmpty","removed","ruleIndex","remove","returnState","states","getReturnState","getParent","constructor","newContext","create","followState","stateNumber","isEpsilon","addRange","MIN_USER_TOKEN_TYPE","maxTokenType","set","label","complement","addSet","Recognizer","RecognitionException","LexerNoViableAltException","input","_input","_factory","_tokenFactorySourcePair","_interp","_token","_tokenStartCharIndex","_tokenStartLine","_tokenStartColumn","_hitEOF","_channel","_type","_modeStack","_mode","DEFAULT_MODE","_text","reset","tokenStartMarker","mark","emitEOF","continueOuter","ttype","SKIP","match","e","console","log","stack","notifyListeners","recover","MORE","emit","release","m","debug","mode","pop","getCharIndex","emitToken","cpos","lpos","eof","msg","getErrorDisplay","getErrorListenerDispatch","syntaxError","d","getErrorDisplayForChar","re","consume","sourceName","HIDDEN","HIDDEN_CHANNEL","MIN_CHAR_VALUE","MAX_CHAR_VALUE","ParseTreeListener","TerminalNode","ErrorNode","DefaultErrorStrategy","ATNDeserializer","ATNDeserializationOptions","TraceListener","parser","ruleNames","node","symbol","_ctx","Parser","_errHandler","_precedenceStack","buildParseTrees","_tracer","_parseListeners","_syntaxErrors","setInputStream","setTrace","getCurrentToken","reportMatch","recoverInline","addErrorNode","_buildParseTrees","listener","idx","indexOf","enterEveryRule","enterRule","reverse","exitRule","exitEveryRule","factory","serializedAtn","getSerializedATN","bypassAltsAtnCache","deserializationOptions","generateRuleBypassTransitions","deserialize","pattern","patternRuleIndex","getTokenStream","ParseTreePatternMatcher","compile","setTokenStream","offendingToken","err","o","getInputStream","hasListener","inErrorRecoveryMode","addTokenNode","invokingState","isErrorNode","visitErrorNode","visitTerminal","parentCtx","addChild","localctx","addContextToParseTree","triggerEnterRuleEvent","triggerExitRuleEvent","altNum","setAltNumber","removeLastChild","precedence","previous","retCtx","parseListeners","getParseListeners","following","nextTokens","rt","getExpectedTokens","ruleName","getRuleIndexMap","p","decisionToDFA","seenOne","dfa","printer","println","decision","print","trace","removeParseListener","addParseListener","RuleContext","Tree","INVALID_INTERVAL","TerminalNodeImpl","ErrorNodeImpl","ParserRuleContext","parent","invokingStateNumber","children","exception","child","badToken","ctxType","getChild","contexts","Hash","Map","equalArrays","cachedHashCode","EMPTY_RETURN_STATE","hash","update","globalNodeCount","id","PredictionContextCache","cache","get","put","hashCode","finish","equals","up","EmptyPredictionContext","ArrayPredictionContext","parents","returnStates","merge","a","b","rootIsWildcard","mergeCache","rootMerge","payloads","mergeRoot","spc","singleParent","apc","a_","mergeSingletons","mergedReturnStates","mergedParents","a_parent","b_parent","payload","M","uniqueParents","containsKey","q","combineCommonParents","mergeArrays","outerContext","getCachedPredictionContext","contextCache","visited","changed","updated","ConsoleErrorListener","ProxyErrorListener","_listeners","INSTANCE","_stateNumber","toolVersion","runtimeVersion","Object","getPrototypeOf","tokenNames","getLiteralNames","getSymbolicNames","getTokenNames","tokenTypeMapCache","ruleIndexMapCache","tokenName","getTokenTypeMap","getOffendingToken","actionIndex","RuleNode","Trees","getChildCount","altNumber","visitor","visitChildren","recog","toStringTree","ri","EMPTY_SOURCE","txt","size","valueToString","arrayToString","isArray","standardEqualsFunction","standardHashCodeFunction","prototype","seed","round","random","pow","h1b","k1","key","remainder","bytes","h1","c1","c2","hashFunction","equalsFunction","values","concat","bits","keys","apply","hashKey","entries","entry","oldValue","AltDict","DoubleDict","defaultMapCtor","cacheMap","arguments","updateHashCode","hashStuff","escapeWhitespace","escapeSpaces","titleCase","str","charAt","toUpperCase","substr","ATN","grammarType","decisionToState","ruleToStartState","ruleToStopState","modeNameToStartState","ruleToTokenType","lexerActions","modeToStartState","LOOK","nextTokenWithinRule","nextTokensInContext","nextTokensNoContext","expected","INVALID_ALT_NUMBER","DecisionState","SemanticContext","checkParams","params","isCfg","semanticContext","reachesIntoOuterContext","props","precedenceFilterSuppressed","config","checkContext","NONE","LexerATNConfig","lexerActionExecutor","passedThroughNonGreedyDecision","checkNonGreedyDecision","hashCodeForConfigSet","equalsForConfigSet","nonGreedy","Utils","hashATNConfig","equalATNConfigs","ATNConfigSet","fullCtx","configLookup","configs","uniqueAlt","conflictingAlts","hasSemanticContext","dipsIntoOuterContext","merged","preds","interpreter","getCachedContext","coll","containsFast","OrderedATNConfigSet","copyFrom","verifyATN","defaultOptions","ATNType","ATNState","BasicState","BlockStartState","BlockEndState","LoopEndState","RuleStartState","TokensStartState","PlusLoopbackState","StarLoopbackState","StarLoopEntryState","PlusBlockStartState","StarBlockStartState","BasicBlockStartState","Transition","AtomTransition","SetTransition","RangeTransition","ActionTransition","EpsilonTransition","PredicateTransition","PrecedencePredicateTransition","LexerActionType","LexerSkipAction","LexerChannelAction","LexerCustomAction","LexerMoreAction","LexerTypeAction","LexerPushModeAction","LexerPopModeAction","LexerModeAction","ADDED_UNICODE_SMP","SUPPORTED_UUIDS","SERIALIZED_UUID","initArray","tmp","options","stateFactories","actionFactories","feature","actualUuid","idx1","checkVersion","checkUUID","readATN","readStates","readRules","readModes","sets","readSets","readInt","bind","isFeatureSupported","uuid","readInt32","readEdges","readDecisions","readLexerActions","markPrecedenceDecisions","PARSER","temp","split","version","readUUID","pair","loopBackStateNumbers","endStateNumbers","nstates","stype","stateFactory","LOOP_END","loopBackStateNumber","endStateNumber","addState","loopBackState","endState","numNonGreedyStates","numPrecedenceStates","isPrecedenceRule","nrules","LEXER","tokenType","nmodes","readUnicode","iset","i1","i2","trans","nedges","src","trg","arg1","arg2","arg3","edgeFactory","addTransition","outermostPrecedenceReturn","startState","ndecisions","decState","actionType","data1","data2","lexerActionFactory","generateRuleBypassTransition","bypassStart","bypassStop","defineDecisionState","excludeTransition","stateIsEndStateFor","matchState","maybeLoopEndState","epsilonOnlyTransitions","isPrecedenceDecision","checkCondition","condition","message","bb","int","byteToHex","RANGE","RULE","PREDICATE","PRECEDENCE","ATOM","ACTION","SET","NOT_SET","WILDCARD","sf","BASIC","RULE_START","BLOCK_START","PLUS_BLOCK_START","STAR_BLOCK_START","TOKEN_START","RULE_STOP","BLOCK_END","STAR_LOOP_BACK","STAR_LOOP_ENTRY","PLUS_LOOP_BACK","af","CHANNEL","CUSTOM","MODE","POP_MODE","PUSH_MODE","TYPE","bth","createByteToHex","DFAState","ATNSimulator","sharedContextCache","ERROR","INVALID_STATE_NUMBER","stateType","serializationNames","LexerActionExecutor","resetSimState","sim","dfaState","SimState","LexerATNSimulator","startIndex","prevAccept","simulator","match_calls","s0","matchATN","execATN","old_mode","s0_closure","computeStartState","suppressEdge","addDFAState","predict","toLexerString","ds0","isAcceptState","captureSimState","getExistingTargetState","computeTargetState","failOrAccept","edges","MIN_DFA_EDGE","MAX_DFA_EDGE","reach","getReachableConfigSet","items","addDFAEdge","accept","prediction","closure","skipAlt","cfg","currentAltReachedAcceptState","getTokenName","getReachableTarget","fixOffsetBeforeMatch","treatEofAsEpsilon","charPos","execute","matches","initialContext","speculative","hasEmptyPath","getEpsilonTarget","serializationType","predIndex","evaluatePredicate","append","sempred","savedcolumn","savedLine","settings","tk","cfgs","proposed","firstConfigWithRuleStopState","newState","setReadonly","tt","dfa_debug","LexerAction","action","isPositionDependent","skip","pushMode","popMode","more","LexerIndexedCustomAction","lexerAction","updatedLexerActions","requiresSeek","stopIndex","numActions","PredPrediction","PredictionMode","NoViableAltException","ParserATNSimulator","predictionMode","LL","_startIndex","_outerContext","_dfa","debug_closure","debug_add","debug_list_atn_decisions","retry_debug","getLookaheadName","precedenceDfa","getPrecedenceStartState","getPrecedence","atnStartState","applyPrecedenceFilter","setPrecedenceStartState","previousD","D","noViableAlt","getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule","requiresFullContext","SLL","predicates","conflictIndex","evalSemanticContext","minValue","reportAttemptingFullContext","execATNWithFullContext","alts","reportAmbiguity","computeReachSet","predictedAlt","getUniqueAlt","altSubSets","getConflictingAltSubsets","allSubsetsConflict","getConflictingAlts","hasSLLConflictTerminatingPrediction","predicateDFAState","getDecisionState","decisionState","nalts","altsToCollectPredsFrom","getConflictingAltsOrUniqueAlt","altToPred","getPredsForAmbigAlts","getPredicatePredictions","foundExactAmbig","resolvesToJustOneViableAlt","LL_EXACT_AMBIG_DETECTION","allSubsetsEqual","getSingleViableAlt","reportContextSensitivity","intermediate","skippedStopStates","closureBusy","removeAllConfigsNotInRuleStopState","hasConfigInRuleStopState","lookToEndOfRule","allConfigsInRuleStopStates","endOfRuleState","statesFromAlt1","configSet","updatedContext","evalPrecedence","ambigAlts","orContext","nPredAlts","pred","pairs","containsPredicate","splitAccordingToSemanticValidity","semValidConfigs","semInvalidConfigs","getAltThatFinishedDecisionEntryRule","succeeded","failed","evaluate","predPredictions","complete","predictions","predicateEvaluationResult","collectPredicates","closureCheckingStopState","depth","parms","getRuleName","closure_","canDropLoopEntryEdgeInLeftRecursiveRule","continueCollecting","newDepth","numCtxs","blockEndStateNum","blockEndState","returnStateNumber","returnStateTarget","inContext","ruleTransition","precedenceTransition","predTransition","actionTransition","pt","getRuleInvocationStack","currentPosition","predSucceeds","getPredicate","newSemCtx","andContext","isCtxDependent","altsets","getAlts","getTokens","nvae","decs","getDeadEndConfigs","error","optimizeConfigs","exact","dup","hasConflictingAltSet","hasStateAssociatedWithOneAlt","hasNonConflictingAltSet","first","all","or","configToAlts","getValues","getStateToAltMap","minAlt","AND","opnds","OR","Predicate","PrecedencePredicate","precpred","operands","precedencePredicates","filterPrecedencePredicates","reduced","from","differs","evaluated","sort","compareTo","serializationTypes","label_","makeLabel","minVocabSymbol","maxVocabSymbol","ruleStart","DFASerializer","LexerDFASerializer","DFA","_states","precedenceState","buf","sortedStates","getStateString","getEdgeLabel","baseStateStr","ErrorListener","DiagnosticErrorListener","exactOnly","recognizer","getDecisionDescription","notifyErrorListeners","reportedAlts","offendingSymbol","delegates","InputMismatchException","FailedPredicateException","ParseCancellationException","errorRecoveryMode","lastErrorIndex","lastErrorStates","nextTokensContext","nextTokenState","endErrorCondition","beginErrorCondition","reportNoViableAlternative","reportInputMismatch","reportFailedPredicate","getMessage","followSet","getErrorRecoverySet","consumeUntil","la","nextTokensState","singleTokenDeletion","reportUnwantedToken","expecting","whatFollowsLoopIterationOrRule","startToken","escapeWSAndQuote","getTokenErrorDisplay","matchedSymbol","singleTokenInsertion","getMissingSymbol","currentSymbolType","reportMissingToken","nextTokenType","tokenText","currentSymbol","expectedTokenType","lookback","getTokenFactory","recoverSet","follow","ErrorStrategy","BailErrorStrategy","Error","captureStackTrace","offendingState","deadEndConfigs","formatMessage","predicate","predicateIndex","defineProperty","object","$defineProperty","position","TypeError","string","Number","second","stringFromCharCode","floor","_","highSurrogate","lowSurrogate","MAX_SIZE","codeUnits","isFinite","RangeError","ParseTree","SyntaxTree","ParseTreeVisitor","visit","ParseTreeWalker","walk","getRuleContext","tree","getNodeText","res","getAltNumber","getPayload","getChildren","list","getAncestors","ancestors","findAllTokenNodes","findAllNodes","findAllRuleNodes","findTokens","nodes","_findAllNodes","descendants","GetIntrinsic","callBind","$indexOf","allowMissing","intrinsic","$apply","$call","$reflectApply","call","$gOPD","$max","originalFunction","func","desc","configurable","applyBind","dirtyDate","date","Date","getTime","baseTimezoneOffset","getTimezoneOffset","setSeconds","parse","dirtyAmount","amount","setDate","getDate","addMilliseconds","timestamp","getDaysInMonth","desiredMonth","getMonth","dateWithDesiredMonth","setFullYear","getFullYear","setHours","daysInMonth","setMonth","addDays","addMonths","year","monthIndex","lastDayOfMonth","argument","getTimezoneOffsetInMilliseconds","isDate","MILLISECONDS_IN_HOUR","MILLISECONDS_IN_MINUTE","parseTokenDateTimeDelimeter","parseTokenPlainTime","parseTokenYY","parseTokensYYY","parseTokenYYYY","parseTokensYYYYY","parseTokenMM","parseTokenDDD","parseTokenMMDD","parseTokenWww","parseTokenWwwD","parseTokenHH","parseTokenHHMM","parseTokenHHMMSS","parseTokenTimezone","parseTokenTimezoneZ","parseTokenTimezoneHH","parseTokenTimezoneHHMM","dayOfISOYear","isoYear","week","day","setUTCFullYear","diff","getUTCDay","setUTCDate","getUTCDate","dirtyOptions","additionalDigits","dateStrings","dateString","timeString","array","test","exec","time","timezone","splitDateString","parseYearResult","parseTokenYYY","parseTokenYYYYY","yearString","parseInt","restDateString","centuryString","parseYear","month","dayOfYear","parseDate","hours","minutes","parseFloat","seconds","parseTime","timezoneString","absoluteOffset","parseTimezone","fullTime","fullTimeDate","fullTimeDateNextDay","offsetDiff","objectKeys","isArguments","is","isRegex","flags","whichBoxedPrimitive","callBound","whichCollection","getIterator","getSideChannel","whichTypedArray","assign","$getTime","gPO","$objToString","$Set","$mapHas","$mapGet","$mapSize","$setAdd","$setDelete","$setHas","$setSize","setHasEqualElement","val1","opts","done","internalDeepEqual","findLooseMatchingPrimitives","prim","mapMightHaveLoosePrim","altValue","curB","looseOpts","strict","setMightHaveLoosePrim","mapHasEqualEntry","key1","item1","key2","actual","sentinel","hasActual","has","hasExpected","aIsArray","bIsArray","aIsError","bIsError","aIsRegex","bIsRegex","aIsDate","bIsDate","aIsBuffer","isBuffer","bIsBuffer","ka","kb","aCollection","bCollection","resultA","resultB","iA","iB","setEquiv","item2","mapEquiv","objEquiv","copy","arr","hasSymbols","Symbol","toStr","origDefineProperty","hasPropertyDescriptors","supportsDescriptors","fn","enumerable","writable","defineProperties","getOwnPropertySymbols","toStringFunction","Function","getOwnPropertyDescriptor","getOwnPropertyNames","hasOwnProperty","propertyIsEnumerable","SYMBOL_PROPERTIES","WEAK_MAP","WeakMap","createCache","_keys","_values","Cache","getCleanClone","realm","__proto__","Constructor","getObjectCloneLoose","handleCopy","symbols","getObjectCloneStrict","properties","property","descriptor","GLOBAL_THIS","globalThis","self","window","g","isStrict","getObjectClone","regExp","RegExp","global","ignoreCase","multiline","unicode","sticky","lastIndex","Blob","Buffer","allocUnsafe","ArrayBuffer","isView","buffer","then","WeakSet","default","choiceTypePaths","pathsDefinedElsewhere","engine","math","equality","util","aggregateMacro","expr","initialValue","total","$index","$total","countFn","sumFn","$this","plus","arraify","minFn","curr","lt","maxFn","gt","avgFn","div","deepEqual","containsImpl","JSON","stringify","in","combineFns","distinctFn","hashObject","union","coll1","coll2","combineFn","intersect","coll1Length","uncheckedLength","coll2hash","nowDate","today","now","timeOfDay","localTimezoneOffset","constants","FP_DateTime","FP_Time","isoStr","isoDateTime","isoDate","isoTime","FP_Type","numbers","pSlice","isString","myVar","isNumber","isNaN","normalizeStr","valDataConverted","fuzzy","isEquivalent","isEqual","actualIsFPT","expectedIsFPT","equivalentTo","fpt","nonFPT","rtn","checkString","isUndefinedOrNull","y","equivalence","typecheck","assertAtMostOne","lClass","rClass","raiseError","equal","unequal","eq","equival","unequival","a0","b0","compare","lte","gte","whereMacro","misc","subsetOf","c2Hash","some","emptyFn","notFn","singleton","existsMacro","vec","allMacro","len","isTrue","allTrueFn","assertType","anyTrueFn","allFalseFn","anyFalseFn","subsetOfFn","supersetOfFn","isDistinctFn","existence","filtering","aggregate","combining","collections","strings","navigation","datetime","logic","FP_Quantity","ResourceNode","TypeInfo","makeResNode","makeParam","parentData","param","doEval","dataRoot","TypeSpecifier","isNullable","infixInvoke","fnName","rawParams","invoc","invocationTable","paramsNumber","argTypes","arity","tp","pr","nullable","path","applyParsedPath","resource","parsedPath","model","vars","ucum","restoredContext","__path__","firstRtn","valData","resolveInternalTypes","expression","fhirData","inObjPath","base","empty","not","exists","allTrue","anyTrue","allFalse","anyFalse","supersetOf","isDistinct","distinct","where","extension","select","selectMacro","sum","avg","single","singleFn","firstFn","last","lastFn","typeFn","ofType","ofTypeFn","isFn","tail","tailFn","take","takeFn","skipFn","combine","iif","iifMacro","traceFn","toInteger","toDecimal","toDateTime","toTime","toBoolean","toQuantity","convertsToBoolean","createConvertsToFn","convertsToInteger","convertsToDecimal","convertsToString","convertsToDateTime","convertsToTime","convertsToQuantity","substring","startsWith","endsWith","containsFn","upper","lower","replaceMatches","toChars","abs","ceiling","exp","ln","power","sqrt","truncate","repeat","repeatMacro","amp","minus","mul","mod","intdiv","orOp","andOp","xorOp","impliesOp","InvocationExpression","ch","TermExpression","resourceType","PolarityExpression","sign","terminalNodeText","namespace","identifiers","ExternalConstantTerm","identifier","varName","Identifier","LiteralTerm","term","StringLiteral","submatch","BooleanLiteral","QuantityLiteral","valueNode","unitNode","unit","DateTimeLiteral","dateStr","TimeLiteral","timeStr","NumberLiteral","InvocationTerm","MemberInvocation","isCapitalized","filter","_toAdd","childPath","defPath","actualTypes","field","_data","isSome","IndexerExpression","coll_node","idx_node","idxNum","Functn","realizeParams","args","FunctionInvocation","shift","unshift","doInvoke","ParamList","UnionExpression","ThisInvocation","TotalInvocation","IndexInvocation","OpExpression","AliasOpExpression","op","alias","NullLiteral","ParenthesizedTerm","evalTable","EqualityExpression","InequalityExpression","AdditiveExpression","MultiplicativeExpression","TypeExpression","MembershipExpression","EntireExpression","OrExpression","ImpliesExpression","AndExpression","XorExpression","evaluator","ucumUtils","flatten","url","extensions","unique","newItems","isUnique","$status","$error","num","typeInfo","fromValue","uniqueHash","xObj","xStr","roundToMaxPrecision","prepareObject","toISOString","magnitude","_yearMonthConversionFactor","ucumQuantity","toUcumQuantity","getSpecifiedUnit","property_","magnitude_","obj","FP_TimeBase","ensureNumberSingleton","xs","ys","ceil","num2","degree","trunc","cond","ok","fail","intRegex","isInteger","quantityRegex","quantityRegexMap","toUnit","mapTimeUnitsToUCUMCode","quantityRegexRes","convUnitTo","numRegex","defineTimeConverter","timeType","timeName","trueStrings","falseStrings","lowerCaseValue","toLowerCase","toFunction","singletonEvalByType","toSingleton","prop","numberFns","decimalPlaces","fraction","exponent","roundToDecimalPlaces","scale","prec","codepointat","fromcodepoint","pc","antlr4","serializedATN","decisionsToDFA","ds","FHIRPathLexer","T__0","T__1","T__2","T__3","T__4","T__5","T__6","T__7","T__8","T__9","T__10","T__11","T__12","T__13","T__14","T__15","T__16","T__17","T__18","T__19","T__20","T__21","T__22","T__23","T__24","T__25","T__26","T__27","T__28","T__29","T__30","T__31","T__32","T__33","T__34","T__35","T__36","T__37","T__38","T__39","T__40","T__41","T__42","T__43","T__44","T__45","T__46","T__47","T__48","T__49","T__50","T__51","T__52","T__53","DATETIME","TIME","IDENTIFIER","DELIMITEDIDENTIFIER","STRING","NUMBER","WS","COMMENT","LINE_COMMENT","FHIRPathListener","FHIRPathParser","expression_sempred","EntireExpressionContext","RULE_entireExpression","enterOuterAlt","reportError","_p","_parentctx","_parentState","ExpressionContext","enterRecursionRule","RULE_expression","_la","TermExpressionContext","PolarityExpressionContext","_alt","adaptivePredict","MultiplicativeExpressionContext","pushNewRecursionContext","AdditiveExpressionContext","UnionExpressionContext","InequalityExpressionContext","EqualityExpressionContext","MembershipExpressionContext","AndExpressionContext","OrExpressionContext","ImpliesExpressionContext","InvocationExpressionContext","invocation","IndexerExpressionContext","TypeExpressionContext","typeSpecifier","unrollRecursionContexts","TermContext","RULE_term","InvocationTermContext","LiteralTermContext","literal","ExternalConstantTermContext","externalConstant","ParenthesizedTermContext","LiteralContext","RULE_literal","NullLiteralContext","BooleanLiteralContext","StringLiteralContext","NumberLiteralContext","DateTimeLiteralContext","TimeLiteralContext","QuantityLiteralContext","quantity","ExternalConstantContext","RULE_externalConstant","InvocationContext","RULE_invocation","MemberInvocationContext","FunctionInvocationContext","functn","ThisInvocationContext","IndexInvocationContext","TotalInvocationContext","FunctnContext","RULE_functn","paramList","ParamListContext","RULE_paramList","QuantityContext","RULE_quantity","UnitContext","RULE_unit","dateTimePrecision","pluralDateTimePrecision","DateTimePrecisionContext","RULE_dateTimePrecision","PluralDateTimePrecisionContext","RULE_pluralDateTimePrecision","TypeSpecifierContext","RULE_typeSpecifier","qualifiedIdentifier","QualifiedIdentifierContext","RULE_qualifiedIdentifier","IdentifierContext","RULE_identifier","getTypedRuleContext","getToken","enterEntireExpression","exitEntireExpression","getTypedRuleContexts","enterIndexerExpression","exitIndexerExpression","enterPolarityExpression","exitPolarityExpression","enterAdditiveExpression","exitAdditiveExpression","enterMultiplicativeExpression","exitMultiplicativeExpression","enterUnionExpression","exitUnionExpression","enterOrExpression","exitOrExpression","enterAndExpression","exitAndExpression","enterMembershipExpression","exitMembershipExpression","enterInequalityExpression","exitInequalityExpression","enterInvocationExpression","exitInvocationExpression","enterEqualityExpression","exitEqualityExpression","enterImpliesExpression","exitImpliesExpression","enterTermExpression","exitTermExpression","enterTypeExpression","exitTypeExpression","enterExternalConstantTerm","exitExternalConstantTerm","enterLiteralTerm","exitLiteralTerm","enterParenthesizedTerm","exitParenthesizedTerm","enterInvocationTerm","exitInvocationTerm","enterTimeLiteral","exitTimeLiteral","enterNullLiteral","exitNullLiteral","enterDateTimeLiteral","exitDateTimeLiteral","enterStringLiteral","exitStringLiteral","enterBooleanLiteral","exitBooleanLiteral","enterNumberLiteral","exitNumberLiteral","enterQuantityLiteral","exitQuantityLiteral","enterExternalConstant","exitExternalConstant","enterTotalInvocation","exitTotalInvocation","enterThisInvocation","exitThisInvocation","enterIndexInvocation","exitIndexInvocation","enterFunctionInvocation","exitFunctionInvocation","enterMemberInvocation","exitMemberInvocation","enterFunctn","exitFunctn","enterParamList","exitParamList","enterQuantity","exitQuantity","enterUnit","exitUnit","enterDateTimePrecision","exitDateTimePrecision","enterPluralDateTimePrecision","exitPluralDateTimePrecision","enterTypeSpecifier","exitTypeSpecifier","enterQualifiedIdentifier","exitQualifiedIdentifier","enterIdentifier","exitIdentifier","Listener","errors","rec","sym","col","chars","removeErrorListeners","addErrorListener","entireExpression","PathListener","ast","parentStack","parentNode","nodeType","errMsgs","searchString","subjectString","includes","nextSource","nextKey","cachedRegExp","prefix","postfix","dotAllIsSupported","dotAll","regex","entirePattern","cleanPrecedingPart","escaped","lastIndexOfOpenBracket","lastIndexOf","lastIndexOfCloseBracket","repl","reg","escapeStringForRegExp","addMinutes","timeFormat","timeRE","dateTimeRE","asStr","otherQuantity","compareYearsAndMonths","_compareYearsAndMonths","thisQuantity","normalizedOtherQuantity","convResult","convertUnitTo","status","toVal","ucumUnitCode","getEquivalentUcumUnitCode","otherUcumUnitCode","magnitude1","magnitude2","surroundingApostrophesRegex","_calendarDuration2Seconds","fromUnit","fromYearMonthMagnitude","toYearMonthMagnitude","fromMagnitude","toMagnitude","arithmeticDurationUnits","mapUCUMCodeToTimeUnits","timeQuantity","timeUnit","cls","unitPrecision","_timeUnitToDatePrecision","qVal","isTime","_getPrecision","neededUnit","_datePrecisionToTimeUnit","newQuantity","newDate","timeUnitToAddFn","_getDateObj","precision","newDateStr","otherDateTime","thisPrec","otherPrec","commonPrec","thisUTCStr","otherUTCStr","thisAdj","_getTimeParts","otherAdj","otherTime","thisPrecision","otherPrecision","thisTimeInt","_dateAtPrecision","otherTimeInt","_getMatchData","regEx","maxPrecision","timeMatchData","timeParts","timeZone","sec","ms","dateObj","hour","timezoneOffset","localTimezoneMinutes","timezoneMinutes","timezoneParts","_createDate","getHours","getMinutes","setYear","formatNum","tzOffset","tzSign","tzMin","getSeconds","getMilliseconds","FHIR","createByValueInNamespace","system","code","comparator","System","getTypeInfo","collection","errorMsgPrefix","typeList","isFalse","convertData","isCallable","forEachArray","iterator","receiver","forEachString","forEachObject","thisArg","ERROR_MESSAGE","funcType","that","bound","binder","boundLength","boundArgs","Empty","implementation","functionsHaveNames","gOPD","functionsHaveConfigurableNames","$bind","boundFunctionsHaveNames","$SyntaxError","SyntaxError","$Function","$TypeError","getEvalledConstructor","expressionSyntax","throwTypeError","ThrowTypeError","calleeThrows","gOPDthrows","getProto","needsEval","TypedArray","Uint8Array","INTRINSICS","AggregateError","Atomics","BigInt","Boolean","DataView","decodeURI","decodeURIComponent","encodeURI","encodeURIComponent","eval","EvalError","Float32Array","Float64Array","FinalizationRegistry","Int8Array","Int16Array","Int32Array","Promise","Proxy","ReferenceError","Reflect","SharedArrayBuffer","Uint8ClampedArray","Uint16Array","Uint32Array","URIError","WeakRef","gen","LEGACY_ALIASES","hasOwn","$concat","$spliceApply","$replace","$strSlice","$exec","rePropName","reEscapeChar","stringToPath","number","quote","subString","getBaseIntrinsic","intrinsicName","parts","intrinsicBaseName","intrinsicRealName","skipFurtherCaching","isOwn","part","$BigInt","hasArrayLengthDefineBug","origSymbol","hasSymbolSham","symObj","syms","toStringTag","hasToStringTag","$toString","isStandardArguments","isLegacyArguments","callee","supportsStandardArguments","bigIntValueOf","valueOf","tryBigInt","$boolToStr","tryBooleanObject","badArrayLike","isCallableMarker","fnToStr","reflectApply","constructorRegex","isES6ClassFn","fnStr","tryFunctionObject","isDDA","document","strClass","getDay","tryDateObject","exported","$Map","numToStr","tryNumberObject","isRegexMarker","badStringifier","throwRegexMarker","toPrimitive","strValue","tryStringObject","symToStr","symStringRegex","isSymbolObject","availableTypedArrays","typedArrays","$slice","toStrTags","typedArray","proto","superProto","tag","getter","tryTypedArrays","$WeakMap","$WeakSet","hasMap","mapSizeDescriptor","mapSize","mapForEach","hasSet","setSizeDescriptor","setSize","setForEach","weakMapHas","weakSetHas","weakRefDeref","deref","booleanValueOf","objectToString","functionToString","$match","$toUpperCase","$toLowerCase","$test","$join","$arrSlice","$floor","gOPS","symToString","hasShammedSymbols","isEnumerable","O","addNumericSeparator","Infinity","sepRegex","intStr","dec","utilInspect","inspectCustom","custom","inspectSymbol","isSymbol","wrapQuotes","defaultStyle","quoteChar","quoteStyle","isRegExp","inspect_","seen","maxStringLength","customInspect","indent","numericSeparator","inspectString","bigIntStr","maxDepth","baseIndent","prev","getIndent","inspect","noIndent","newOpts","f","nameOf","arrObjKeys","symString","markBoxed","HTMLElement","nodeName","getAttribute","isElement","attrs","attributes","childNodes","singleLineValues","indentedJoin","isError","cause","isMap","mapParts","collectionOf","isSet","setParts","isWeakMap","weakCollectionOf","isWeakSet","isWeakRef","isBigInt","isBoolean","isPlainObject","protoTag","stringTag","remaining","trailer","lowbyte","lineJoiner","isArr","symMap","numberIsNaN","define","getPolyfill","shim","polyfill","keysShim","isArgs","hasDontEnumBug","hasProtoEnumBug","dontEnums","equalsConstructorPrototype","ctor","excludedKeys","$applicationCache","$console","$external","$frame","$frameElement","$frames","$innerHeight","$innerWidth","$onmozfullscreenchange","$onmozfullscreenerror","$outerHeight","$outerWidth","$pageXOffset","$pageYOffset","$parent","$scrollLeft","$scrollTop","$scrollX","$scrollY","$self","$webkitIndexedDB","$webkitStorageInfo","$window","hasAutomationEqualityBug","isObject","isFunction","theKeys","skipProto","skipConstructor","equalsConstructorPrototypeIfNotBuggy","origKeys","originalKeys","keysWorksWithArguments","toObject","$push","$propIsEnumerable","originalGetSymbols","source1","getSymbols","propValue","letters","lacksProperEnumerationOrder","preventExtensions","thrower","assignHasPendingExceptions","$Object","hasIndices","flagsBound","calls","TypeErr","$weakMapGet","$weakMapSet","$weakMapHas","$mapSet","listGetNode","$wm","$m","$o","assert","objects","listGet","listHas","listSet","isTypedArray","foundName","LForms","ucumPkg","possibleNames","out","$iterator","iterable","$arrayPush","$charCodeAt","$stringSlice","getArrayIterator","arraylike","getNonCollectionIterator","noPrimordialCollections","nextIndex","S","advanceStringIndex","$mapForEach","$setForEach","process","versions","$mapIterator","$setIterator","getStopIterationIterator","$mapAtAtIterator","$setAtAtIterator","getCollectionIterator","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","__esModule","definition","importFHIRQuantity","unitOrCode","_OBX_REF_PREFIX","_getFormattedDate","Util","dateToDTMString","_createDiagnosticReportContent","contained","content","resultObj","iLen","subItem","obx","_commonExport","_createObservation","related","ret","jLen","subObxRef","reference","lLen","_convertFromContainedToBundle","dr","bundleType","bundleDr","_convertContainedToTransactionBundle","_convertContainedToCollectionBundle","ref","request","method","kLen","targetObservation","createDiagnosticReport","formData","subject","inBundle","formAndUserData","getFormData","drContent","_getUniqueId","_addVersionTag","createLocalFHIRReference","pruneNulls","_findObxById","refId","_setupItemValueAndUnit","coding","questionCode","dataType","units","valueInteger","qty","valueQuantity","stringToDTDateISO","valueDate","stringToDate","valueDateTime","itemValue","valueCodeableConcept","display","valueString","answerCardinality","_findTotalRepeatingNum","refIdList","refIds","_checkRepeatingItems","parentObxInfo","parentRefId","diagnosticReport","obxInfoList","repeatingItemInfo","obxIdList","parentObx","itemCode","repeatingInfo","repeatingRefIds","obxInfo","_getReportStructure","reportStructure","_findTheMatchingItemByCodeAndIndex","parentItem","_addRepeatingItems","newItem","deepCopy","_processObxAndItem","_convertFromBundleToContained","containedDr","mergeDiagnosticReportToLForms","LFormsData","hasSavedData","_versionTagStr","setId","_createObsIntValue","valValue","_setFHIRQuantityUnit","itemValues","codeSystem","getCodeSystem","obxs","codeList","question","header","_idCtr","_resTags","meta","_setVersionTag","tags","lformsVersion","commonExport","sdcVersion","SDCVersion","QProfile","QRProfile","stdQProfile","stdQRProfile","convertLFormsToQRAndExtracFHIRData","lfData","noExtensions","qr","convertLFormsToQuestionnaireResponse","qrRef","itemList","_getExtractValue","_hasItemValue","obs","basedOn","partOf","encounter","authored","effectiveDateTime","issued","author","performer","derivedFrom","_processQuestionCardinality","targetItem","questionCardinality","repeats","_handleSpecialConstraints","required","_handleRestrictions","restrictions","extValue","_getAssumedDataTypeForExport","valueKey","_getValueKeyByDataType","_exportMinMax","maxLength","_handleChoiceField","externallyDefined","_handleExternallyDefined","answers","answerValueSet","_fhirExt","fhirExtAnswerExp","answerOption","_handleAnswers","optionArray","answer","option","ext","score","valueCoding","defaultAnswer","defaultAnswers","_answerRepeats","areTwoAnswersSame","initialSelected","_handleInitialValues","initial","_makeQuantity","dateValue","dateToDTStringISO","_handleLFormsUnits","fhirExtUrlUnit","_createFhirUnitCoding","defUnit","_getDefaultUnit","_setUnitAttributesToFhirQuantity","fhirUnitExt","fhirExtUrlUnitOption","_handleSkipLogic","skipLogic","enableWhen","rangeFound","conditions","sourceItem","_getSkipLogicSourceItem","enableWhenRules","_createEnableWhenRulesForSkipLogicCondition","enableBehavior","ns","_processRepeatingItemValues","_setResponseFormLevelFields","_processResponseItem","convertLFormsToQuestionnaire","_removeRepeatingItems","_setFormLevelFields","_processItem","_getFhirDataType","_answerRequired","minOccurInt","_processQuestionAndAnswerCardinality","_handleItemControl","_isHiddenInDef","valueBoolean","linkId","extField","extFieldData","editable","_handleTerminologyServer","_handleDataControl","codingInstructions","helpItem","codingInstructionsPlain","codingInstructionsFormat","maxAttachmentSize","exts","fhirExtMaxSize","valueDecimal","allowedAttachmentTypes","fhirExtMimeType","valueCode","copyFields","itemLevelIgnoredFields","maxOccurs","qCard","aCard","qCardMax","aCardMax","intQCardMax","intACardMax","fhirExtUrlCardinalityMax","fhirExtUrlExternallyDefined","dataControl","_id","formLevelFields","shortName","title","obj_title","_title","profile","itemControlDisplay","answerChoiceOrientation","itemControlType","jQuery","isEmptyObject","displayControl","answerLayout","questionLayout","isSearchAutocomplete","columns","terminologyServer","fhirExtTerminologyServer","_lformsTypesToFHIRTypes","_makeValueQuantity","itemUnit","unitSystem","fhirQuantity","floatValue","itemUnits","defaultUnit","lformsUnits","_lformsTypesToFHIRFields","_MIN_MAX_TYPES","_MIN_MAX_KEYS","minMaxKey","isoDateStr","fhirValue","_skipLogicValueDataTypes","skipLogicCondition","sourceDataType","sourceValueKey","trigger","operator","_operatorMapping","triggerValue","rule","answerBoolean","answerCoding","_copyTriggerCoding","lfUnit","_lfItemValueToFhirAnswer","_setIfHasValue","_lfHasSubItems","lfItem","isForm","fhirItems","lfSubItem","_isProcessed","_repeatingItems","fhirItem","rpt","rptItem","tmpFhirItem","_questionRepeats","currentItem","fhirExtObsExtract","_parentItem","_skipLogicStatus","isItemValueEmpty","fhirExtUrlOptionScore","fhirExtUrlValueSetScore","_extractContainedVS","questionnaire","answersVS","vs","answersFromVS","lfVS","_processSkipLogic","qItem","linkIdItemMap","_getDataType","_getFHIRValueWithPrefixKey","opMapping","_processHiddenItem","ci","findObjectInArray","fhirExtUrlHidden","_processAnswers","containedVS","fhirExtUrlOptionPrefix","argonautExtUrlExtensionScore","optionKey","_processEditable","_processDefaultAnswerValue","vals","_processDefaultAnswer","elem","_processFHIRValues","getFirstInitialQuantity","_processDisplayItemCode","codes","_processDataType","_mergeQR","_getQRStructure","qrInfo","qrItemsInfo","_checkQRItems","parentQRItemInfo","parentQRItem","repeatingItemProcessed","repeatingItems","qrItemInfo","_checkQRItemAnswerItems","_findTheMatchingItemByLinkIdAndIndex","_findTheMatchingItemByLinkId","requestLinkedObs","fhirContext","client","_fhir","_serverFHIRReleaseID","pendingPromises","validateFHIRVersion","serverFHIR","obsLinkURI","SDC","fhirExtObsLinkPeriod","obsExt","duration","valueDuration","fhirClient","queryParams","LOINC_URI","_sort","_count","UcumLhcUtils","getInstance","patient","_buildURL","successData","bundle","foundObs","focus","importObsValue","_setUnitDisplay","resolve","reject","getServerFHIRReleaseID","relID","_questionRepeatable","_multipleAnswers","fieldList","UCUM_URI","srcCoding","dstCoding","lforms2Fhir","srcTextField","dstTextField","hasResponsiveExpression","itemOrLFData","fhirExtCalculatedExp","fhirExtEnableWhenExp","hasListExpression","hasInitialExpression","fhirExtInitialExp","buildExtensionMap","isExpressionExtension","fhirExtVariable","exprExtensions","extArray","_exprExtensions","loadLaunchContext","contextItems","fhirExtLaunchContext","contextsFromServer","Patient","Encounter","user","Practitioner","PractitionerRole","RelatedPerson","addIfValid","resType","permittedTypes","warn","restype","_fhirVariables","contextItemExt","fieldExt","valueId","_checkFHIRVarName","fromMap","contextResource","read","reason","fhirpathRes","errorMessages","_internalUtil","fhirExtUrlCardinalityMin","fhirExtUrlItemControl","fhirExtUrlMinValue","fhirExtUrlMaxValue","fhirExtUrlMinLength","fhirExtUrlRegex","fhirExtUrlAnswerRepeats","fhirExtUrlDataControl","fhirExtChoiceOrientation","fhirExtUnitOpen","fhirExtUnitSuppSystem","fhirExtEntryFormat","fhirExtUrlRestrictionArray","handledExtensionSet","extensionHandlers","_unitOpen","_unitSuppSystem","valueCanonical","valueUri","_entryFormat","convertQuestionnaireToLForms","baseFormDef","_processFormLevelFields","_createLinkIdItemMap","_processQuestionnaireItem","fhirVersion","codeAndSystemObj","_getCode","_processExtensions","_processTextAndPrefix","_processCodeAndLinkId","_processFHIRQuestionAndAnswerCardinality","_processDisplayControl","_processDataControl","_processRestrictions","_processUnitList","_processTerminologyServer","_processChildItems","_significantDigits","wholeNum","lfDataType","fhirValType","unitOkay","matchingUnit","valSystem","ucumUnit","isUCUMUnit","originalSD","toPrecision","_convertFHIRValues","fhirVals","forDefault","messages","fhirValPath","fhirVal","hasMessages","codings","itemAnswers","listAnswer","listAnswerSystem","_processCWECNEValueInQR","_convertFHIRQuantity","addMsg","setDefault","_hasMultipleAnswers","setItemMessagesArray","assignValueToItem","keyRegex","matchData","questionCodeSystem","lformsDefaultUnit","unitOption","lUnit","initialQ","findItem","dataControlType","qrImport","mergeQuestionnaireResponseToLForms","_processQRItemAndLFormsItem","parentLFormsItem","qrItem","defItem","newQRItemInfo","qrAnswersItemsInfo","qrAnswer","qrValue","lformsQuantity","valueAttachment","qResource","traverse","itemArray","questionnaireItemOrResource","_toLfCodeSystem","valueSet","expansion","vsItem","ordExt","tServer","valueUrl","_processExternallyDefined","_getTerminologyServer","_getExpansionURL","loadAnswerValueSets","expURL","vsKey","_answerValueSetKey","_valueSetAnswerCache","_updateAutocompOptions","response","json","parsedJSON","errorOrFatal","issue","find","severity","diagnostics","catch","qrItemValue","notOnList","retValue","sysetm","_notOnList","found","_processCodingInstructions","xhtmlFormat","help","extHandler","_arrayLen","entity","answerLen","numAnswersWithItems","answersItemsInfo","restriction","lfNode","fieldName","extNode","css","extProcessors","renderingStyle","ExpressionProcessor","_queryCache","_pendingQueries","_calculatedValues","_repetitionKeys","_pendingRun","_currentRunPromise","_lfData","_compiledExpressions","runCalculations","includeInitialExpr","_runStart","_regenerateQuestionnaireResp","_asyncRunCalculations","_firstExpressionRunComplete","failureReason","_handlePendingQueries","allSettled","results","varsChanged","fieldsChanged","changes","variables","fields","changesByVarsOnly","_evaluateExpressions","queryChanges","onlyVarsChanged","_updateItemVariable","newVal","oldVal","_varChanged","sdc","fieldChanged","isInitialExp","currentVals","isCalcExp","_lastRepeatingItem","prevCalcVals","_getRepetitionKey","_userModifiedCalculatedValue","getItemValues","_equalAnswers","_answerListReset","valueExpression","itemVars","_getItemVariables","updateValue","language","_evaluateFHIRPath","queryURL","undefinedExprVal","fpExp","_currentFhirQueryURLs","oldQueryURL","fetchPromise","_fetch","fChanged","_updateItemFromExp","vChanged","childChanges","childItems","questResp","_elemIDToQRItem","_createIDtoQRItemMap","_itemWithVars","itemWithVars","_setItemListFromFHIRPath","actualNewVal","showWarning","_enableWhenExpVal","_setItemValueFromFHIRPath","fhirPathVal","contextNode","fVars","_elementId","compiledExpr","fhirpath","fhirpathModel","_addToIDtoQRItemMap","added","lfItems","qrItems","numLFItems","qrI","qrIthItem","lfIthItem","numAnswers","newlyAdded","currentList","hasCurrentList","listHasData","newList","scoreURI","newEntry","scoreExt","_objectEqual","_resetItemValueWithAnswers","fhirPathRes","nonEmptyNewVal","msgSource","setRepeatingItems","setRepeatingItemMessages","answer1","answer2","ans1","ans2","_filterAnswerFields","fhir","drCopy","DiagnosticReport","fhir_sdc","addCommonSDCExportFns","addSDCImportFns","addCommonSDCFns","addCommonSDCImportFns","processExtensions","lfFieldName","fieldData","extData","extURL","processor","reservedVarNames"],"sourceRoot":""}