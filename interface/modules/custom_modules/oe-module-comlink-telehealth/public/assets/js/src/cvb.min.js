function t(t, i) {
    if (!t) throw new Error(i)
}

function i(t) {
    try {
        t()
    } catch (t) {
        console.log("Ignoring exception in user callback: " + t)
    }
}

class s {
    constructor(t, i) {
        this.t = t, this.i = 1, this.h = i
    }

    get() {
        return this.t
    }

    incRef() {
        ++this.i
    }

    decRef() {
        0 == --this.i && (this.h(this.t), this.h = null, this.t = null)
    }
}

class e {
    constructor(t) {
        this.o = t, this.l = "", this.u = new TextDecoder("utf-8"), this._ = !1
    }

    cancel() {
        this.o.cancel()
    }

    eof() {
        return this._
    }

    v() {
        const t = this.l.indexOf("\r\n");
        if (-1 == t) return null;
        const i = this.l.substr(0, t);
        return this.l = this.l.substr(t + 2), i
    }

    p() {
        return this.o.read().then((t => {
            if (t.done) return this._ = !0, Promise.resolve(this.l);
            this.l += this.u.decode(t.value);
            const i = this.v();
            return i ? Promise.resolve(i) : this.p()
        }))
    }

    readEvent() {
        if (this._) return Promise.reject();
        const t = this.v();
        return t ? Promise.resolve(t) : this.p()
    }
}

class h {
    constructor(t) {
        this.g = t
    }

    I(t, i) {
        return fetch(this.g + t, {
            method: "POST",
            cache: "no-cache",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify(i)
        }).then((t => t.ok ? t.json() : Promise.reject(t.status)))
    }

    C(t, i) {
        return fetch(this.g + t, {
            method: "POST",
            cache: "no-cache",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify(i)
        })
    }

    createBridge(t, i, s) {
        const e = {userId: t, passwordHash: i, type: s};
        return fetch(this.g + "/client/createBridge", {
            method: "POST",
            cache: "no-cache",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify(e)
        })
    }

    invite(t) {
        return this.C("/client/invite", {callId: t})
    }

    call(t, i, s) {
        return this.I("/client/call", {callerId: t, calleeId: i, isScreenSharing: s})
    }

    accept(t, i) {
        return this.C("/client/accept", {callId: t, token: i})
    }

    reject(t, i) {
        return this.C("/client/reject", {callId: t, token: i})
    }

    offer(t, i, s) {
        return this.C("/client/offer", {callId: t, sdp: s, token: i})
    }

    answer(t, i, s) {
        return this.C("/client/answer", {callId: t, sdp: s, token: i})
    }

    ice(t, i, s) {
        return this.C("/client/ice", {callId: t, candidate: i, token: s})
    }

    end(t, i) {
        return this.C("/client/end", {callId: t, token: i})
    }
}

const n = new class {
    constructor() {
        this.m = [], this.k = 0, this.S = -1
    }

    P() {
        this.m.forEach((t => t.func()))
    }

    T() {
        this.S = setInterval((() => this.P()), 500)
    }

    V() {
        clearInterval(this.S), this.S = -1
    }

    addTask(t) {
        const i = this.k++, s = {id: i, func: t};
        return this.m.push(s), 1 == this.m.length && this.T(), i
    }

    removeTask(t) {
        const i = this.m.findIndex((i => i.id == t));
        -1 != i && (this.m.splice(i, 1), 0 == this.m.length && this.V())
    }
}, r = new class {
    newAudioContext() {
        return new (window.AudioContext || window.webkitAudioContext)
    }
};

class a {
    constructor() {
        this.L = -1, this.A = r.newAudioContext(), this.j = this.A.createAnalyser(), this.j.fftSize = 2048, this.j.minDecibels = -100, this.j.maxDecibels = 0, this.j.smoothingTimeConstant = .8, this.B = new Uint8Array(this.j.frequencyBinCount), this.R = null, this.db = 0, this.ondbthresholdexceeded = t => {
        }, this.dbthreshold = -50
    }

    connect(t) {
        let i;
        try {
            i = this.A.createMediaStreamSource(t), i.connect(this.j), this.j.connect(this.A.destination)
        } catch (t) {
            return
        }
        -1 == this.L && (this.L = n.addTask((() => this.O()))), this.R && this.R.disconnect(), this.R = i
    }

    disconnect() {
        -1 != this.L && (n.removeTask(this.L), this.R.disconnect(), this.R = null, this.L = -1)
    }

    O() {
        this.j.getByteFrequencyData(this.B);
        let t = -100;
        for (let i = 0; i < this.B.length; ++i) t = Math.max(t, this.B[i]);
        this.db = .3921568627 * t - 100, this.db >= this.dbthreshold && i((() => this.ondbthresholdexceeded(this)))
    }
}

const o = "Copyright (c) 2023 Comlink Inc.";

function c() {
    return "1.1.6"
}

class l {
    constructor(t) {
        this.U = t.isInbound, this.N = t.isScreenSharing, t.basedOnCall && (this.M = t.basedOnCall.M, this.M.incRef()), this.D = t.remotePartyId, this.J = t.bridge, this.H = t.callId, this.K = t.config, this.F = t.token, this.G = null, this.W = null, this.q = null, this.o = null, this.X = null, this.Y = null, this.Z = [], t.isInbound ? this.$ = 1 : this.$ = 0, this.oncallstarted = t => this.tt("Unhandled event: call started: " + t.H), this.oncallrejected = t => this.tt("Unhandled event: call rejected: " + t.H), this.oncallended = t => this.tt("Unhandled event: call ended: " + t.H), this.onstreamupdated = (t, i) => this.tt("Unhandled event: stream updated: " + t.H), this.onparticipantlistupdated = (t, i) => this.tt("Unhandled event: participant list updated: " + t.H), this.onviewportlayoutupdated = (t, i) => this.tt("Unahndled event: viewport layout updated: " + i), this.onfacialrecognizerresults = (t, i) => this.tt("Unhandled event: facial recognizer results: " + i)
    }

    it(t) {
        console.log("VC/" + this.H + ": " + t)
    }

    st(t) {
        console.error("VC/" + this.H + ": " + t)
    }

    tt(t) {
        console.warn("VC/" + this.H + ": " + t)
    }

    et() {
        return this.G = new RTCPeerConnection(this.K), this.G.onicecandidate = t => this.ht(t), this.G.ontrack = t => this.nt(t), this.G.onremovetrack = t => this.rt(t), this.N ? this.U ? Promise.resolve(this) : this.ot() : this.ct()
    }

    lt(t, i) {
        this.G.addTrack(t, i), t.addEventListener("ended", (() => this.dt(t)))
    }

    ut(t) {
        t.getTracks().forEach((i => this.lt(i, t)))
    }

    ct() {
        return this.J.getLocalMediaStream().then((t => {
            this.ut(t)
        }))
    }

    ot() {
        if (!this.M) {
            const t = {video: {cursor: "always"}, audio: !0};
            return navigator.mediaDevices.getDisplayMedia(t).then((t => {
                this.ut(t), this.M = new s(t, (t => {
                    t.getTracks().forEach((t => t.stop()))
                })), i((() => this.onstreamupdated(this, t)))
            }))
        }
        {
            const t = this.M.get();
            this.ut(t), i((() => this.onstreamupdated(this, t)))
        }
    }

    _t() {
        6 != this.$ && (this.$ = 6, this.J.vt(this), this.q && (this.q.disconnect(), this.q = null), this.M && this.M.decRef(), this.G.close(), this.G = null)
    }

    gt(t) {
        return 6 != this.$ && 4 != this.$ ? (this._t(), i((() => this.oncallended(this))), t ? this.J.ft.end(this.H, this.F).then((() => this)) : this) : Promise.resolve(this)
    }

    bt(i) {
        switch (t("CALL" == i.type, 'Bad event type. "CALL" expected.'), i.name) {
            case"accept":
                this.wt();
                break;
            case"end":
                this.It();
                break;
            case"reject":
                this.yt();
                break;
            case"sdp":
                this.Ct(i.sdp, i.action);
                break;
            case"ice":
                this.kt(i.iceCandidate);
                break;
            case"participants":
                this.St(i.userIds);
                break;
            case"viewportLayout":
                this.Et({frameWidth: i.frameWidth, frameHeight: i.frameHeight, viewports: i.viewports});
                break;
            case"facialRecognition":
                this.Pt({callId: i.tagCallId, tag: i.tag, confidence: i.confidence});
                break;
            default:
                throw new Error("Bad call state")
        }
    }

    St(t) {
        this.X = t, i((() => this.onparticipantlistupdated(this, this.X)))
    }

    Et(t) {
        this.Y = t, i((() => this.onviewportlayoutupdated(this, this.Y)))
    }

    Pt(t) {
        i((() => this.onfacialrecognizerresults(this, t)))
    }

    kt(t) {
        this.G.remoteDescription ? this.G.addIceCandidate(t) : this.Z.push(t)
    }

    nt(t) {
        this.o = t.streams[0], this.q && this.q.connect(this.o), i((() => this.onstreamupdated(this, this.o)))
    }

    rt(t) {
    }

    dt(t) {
        this.gt(!0)
    }

    It() {
        this.gt(!1)
    }

    wt() {
        this.G.createOffer({
            offerToReceiveVideo: !0,
            offerToReceiveAudio: !0
        }).then((t => this.G.setLocalDescription(t))).then((() => this.J.ft.offer(this.H, this.F, this.G.localDescription.sdp))).catch((t => {
            throw this.Tt(t), t
        })), i((() => this.oncallstarted(this)))
    }

    yt() {
        this.J.vt(this), this.$ = 4, i((() => this.oncallrejected(this)))
    }

    Ct(t, i) {
        const s = new RTCSessionDescription({type: i, sdp: t});
        "offer" == i ? this.G.setRemoteDescription(s).then((() => (this.Vt(), this.G.createAnswer()))).then((t => this.G.setLocalDescription(t))).then((() => this.J.ft.answer(this.H, this.F, this.G.localDescription.sdp))).then((t => (this.$ = 3, t))).catch((t => {
            throw this.Tt(t), t
        })) : "answer" == i && this.G.setRemoteDescription(s).then((() => {
            this.Vt(), this.$ = 3
        })).catch((t => {
            throw this.Tt(t), t
        }))
    }

    Vt() {
        this.Z.forEach((t => {
            this.G.addIceCandidate(t)
        })), this.Z = []
    }

    ht(t) {
        if (t.candidate) try {
            this.J.ft.ice(this.H, t.candidate, this.F)
        } catch (t) {
            this.tt("failed to transmit ICE candidate")
        }
    }

    Tt(t) {
        this.$ = 4, this.st("panic: " + t.message)
    }

    getParticipantList() {
        return this.X
    }

    getViewportLayout() {
        return this.Y
    }

    getCallId() {
        return this.H
    }

    getVideoBridge() {
        return this.J
    }

    getRemotePartyId() {
        return this.D
    }

    isInbound() {
        return this.U
    }

    setUserData(t) {
        this.W = t
    }

    getUserData() {
        return this.W
    }

    isScreenSharing() {
        return this.N
    }

    attachActivityMonitor(s, e) {
        t(null == this.q, "Activity notifier already attached"), t(null != e, "Activity monitor callback not defined"), this.q = new a, this.q.dbthreshold = s, this.q.ondbthresholdexceeded = t => i((() => e(this))), this.o && this.q.connect(this.o)
    }

    getSoundLevel() {
        return this.q ? this.q.db : NaN
    }

    start() {
        return t(0 == this.$, "Call already initialized"), this.$ = 1, this.it("starting"), this.J.ft.call(this.J.getUserId(), this.D, this.N).then((t => (this.H = t.callId, this.K = t.config, this.F = t.token, this.et()))).then((() => this.J.ft.invite(this.H))).then((() => (this.$ = 2, this.J.Lt(this), this))).catch((t => {
            throw this.Tt(t), t
        }))
    }

    accept() {
        return t(1 == this.$, "Invalid call state"), t(this.U, "Not an inbound call"), this.it("accepting"), this.et().then((() => this.J.ft.accept(this.H, this.F))).then((t => (this.$ = 2, this))).catch((t => {
            throw this.Tt(t), t
        }))
    }

    reject() {
        return t(1 == this.$, "Invalid call state"), t(this.U, "Not an inbound call"), this.it("rejecting"), this.J.ft.reject(this.H, this.F).then((t => (this.$ = 5, this.J.vt(this), this))).catch((t => {
            throw this.Tt(t), t
        }))
    }

    stop() {
        return this.gt(!0)
    }

    muteRemoteAudio(i) {
        t("boolean" == typeof i, "Expected a boolean value"), this.G.getReceivers().forEach((t => {
            "audio" == t.track.kind && (t.track.enabled = i)
        }))
    }
}

class d {
    constructor(t) {
        this.At = t.userId, this.jt = t.type, this.Bt = t.passwordHash, this.ft = new h(t.serviceUrl || ""), this.Rt = !1, this.Ot = {}, this.Ut = !1, this.Nt = !1, this.xt = null, this.Mt = null, this.onbridgeactive = t => console.log("onbridgeactive event not handled"), this.onbridgeinactive = t => console.log("onbridgeinactive event not handled"), this.onbridgefailure = t => console.log("onbridgefailure event not handled"), this.onincomingcall = t => {
            console.log("Inbound call event not handled; call rejected."), t.reject()
        }
    }

    Tt(t) {
        console.log("Catastrophic bridge failure: " + t), i((() => this.onbridgefailure(this))), this.shutdown()
    }

    Dt() {
        this.Rt ? this.Tt(new Error("Event stream closed unexpectedly")) : i((() => this.onbridgeinactive(this)))
    }

    Jt() {
        this.xt.readEvent().then((t => {
            if (this.xt.eof()) this.Dt(); else {
                try {
                    const i = JSON.parse(t);
                    this.bt(i)
                } catch (t) {
                    return void this.Tt(t)
                }
                this.Jt()
            }
        }))
    }

    zt(t) {
        const i = this.Ot[t.callId];
        i ? i.bt(t) : console.log("Invalid call identifier in the event stream: " + t.callId)
    }

    Ht(t) {
        const s = new l({
            bridge: this,
            callId: t.callId,
            isInbound: !0,
            isScreenSharing: t.isScreenSharing,
            remotePartyId: t.callerId,
            config: t.config,
            token: t.token
        });
        this.Lt(s), i((() => this.onincomingcall(s)))
    }

    Kt(t) {
        this.Rt || (this.Rt = !0, i((() => this.onbridgeactive(this))))
    }

    bt(t) {
        switch (console.log(t), t.type) {
            case"INCOMING":
                this.Ht(t);
                break;
            case"KEEPALIVE":
                this.Kt(t);
                break;
            case"CALL":
                this.zt(t);
                break;
            default:
                this.Tt(new Error("Bad event type: " + t.type + ". Corrupt stream?"))
        }
    }

    Ft() {
        Object.values(this.Ot).forEach((t => t._t())), this.Ot = {}
    }

    Lt(t) {
        this.Ot[t.getCallId()] = t
    }

    vt(t) {
        const i = t.getCallId();
        this.Ot.hasOwnProperty(i) && delete this.Ot[i]
    }

    getUserId() {
        return this.At
    }

    getCalls() {
        return Object.values(this.Ot)
    }

    hasCamera() {
        return this.Ut
    }

    hasMicrophone() {
        return this.Nt
    }

    getCallById(t) {
        return this.Ot[t]
    }

    isActive() {
        return this.Rt
    }

    getLocalMediaStream() {
        return t(this.Rt, "VideoBridge not active"), this.Mt ? Promise.resolve(this.Mt) : navigator.mediaDevices.enumerateDevices().then((t => {
            var i = {};
            return null != t.find((t => "videoinput" == t.kind)) && (this.Ut = !0, i.video = {
                width: 800,
                height: 600
            }), null != t.find((t => "audioinput" == t.kind)) && (this.Nt = !0, i.audio = {channels: 1}), navigator.mediaDevices.getUserMedia(i)
        })).then((t => (this.Mt = t, t)))
    }

    closeLocalMediaStream() {
        t(this.Rt, "VideoBridge not active"), this.Mt && (this.Mt.getTracks().forEach((t => t.stop())), this.Mt = null, this.Nt = !1, this.Ut = !1)
    }

    enableCamera(i) {
        t(this.Rt, "Video bridge not active"), t("boolean" == typeof i, "Expected a boolean value"), this.Ut && this.Mt.getTracks().forEach((t => {
            "live" == t.readyState && "video" === t.kind && (t.enabled = i)
        }))
    }

    enableMicrophone(i) {
        t(this.Rt, "Video bridge not active"), t("boolean" == typeof i, "Expected a boolean value"), this.Nt && this.Mt.getTracks().forEach((t => {
            "live" == t.readyState && "audio" === t.kind && (t.enabled = i)
        }))
    }

    start() {
        t(!this.Rt, "Video bridge already active"), console.log("CVB v1.1.6. " + o), this.ft.createBridge(this.At, this.Bt, this.jt).then((t => t.body)).then((t => {
            this.xt = new e(t.getReader()), this.Jt()
        })).catch((t => {
            console.error("Video bridge creation failure: " + t), i((() => this.onbridgefailure(this))), this.Tt(t)
        }))
    }

    shutdown() {
        t(this.Rt, "Video bridge not active"), console.log("CVB v1.1.6. " + o), Object.values(this.Ot).slice().forEach((t => t.stop())), this.closeLocalMediaStream(), this.Rt = !1, this.xt.cancel()
    }

    createVideoCall(i) {
        return t(this.Rt, "Video bridge not active"), new l({
            bridge: this,
            isInbound: !1,
            isScreenSharing: !1,
            remotePartyId: i
        })
    }

    createScreenSharingCall(i, s) {
        return t(this.Rt, "Video bridge not active"), new l({
            bridge: this,
            isInboud: !1,
            isScreenSharing: !0,
            remotePartyId: i,
            basedOnCall: s
        })
    }
}

export {d as VideoBridge, l as VideoCall, c as getVersion};
