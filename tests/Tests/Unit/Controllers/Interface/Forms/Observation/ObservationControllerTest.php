<?php

/*
 * ObservationControllerTest - Tests the ObservationController class
 * AI Generated: Rebuilt test class to match updated ObservationController implementation
 *
 * @package openemr
 * @link      http://www.open-emr.org
 * @author    Claude.AI on August 28th 2025
 * @author    Stephen Nielson <snielson@discoverandchange.com>
 * @copyright Public Domain for the pieces that were generated by Claude.AI
 * @license   https://github.com/openemr/openemr/blob/master/LICENSE GNU General Public License 3
 */

// AI Generated: Refactored from interface/forms/observation/view.php,new.php,save.php
namespace OpenEMR\Tests\Unit\Controllers\Interface\Forms\Observation;

use OpenEMR\Common\Csrf\CsrfUtils;
use OpenEMR\Controllers\Interface\Forms\Observation\ObservationController;
use OpenEMR\Core\Kernel;
use OpenEMR\Services\CodeTypesService;
use OpenEMR\Services\FormService;
use OpenEMR\Services\ObservationService;
use PHPUnit\Framework\MockObject\MockObject;
use PHPUnit\Framework\TestCase;
use Symfony\Component\EventDispatcher\EventDispatcher;
use Symfony\Component\HttpFoundation\InputBag;
use Symfony\Component\HttpFoundation\ParameterBag;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Twig\Environment;

class ObservationControllerTest extends TestCase
{
    // AI Generated: Updated properties to match current controller dependencies
    private ObservationController $controller;
    private MockObject&ObservationService $mockObservationService;
    private MockObject&FormService $mockFormService;
    private MockObject&Environment $mockTwig;
    private MockObject&CodeTypesService $mockCodeTypesService;
    private MockObject&Request $mockRequest;
    private array $originalSession;
    private array $globalsToRestore;

    /**
     * AI Generated: Updated setup to match current controller constructor and dependencies
     */
    protected function setUp(): void
    {
        // Create mocks for all dependencies
        $this->mockObservationService = $this->createMock(ObservationService::class);
        $this->mockFormService = $this->createMock(FormService::class);
        $this->mockTwig = $this->createMock(Environment::class);
        $this->mockCodeTypesService = $this->createMock(CodeTypesService::class);

        // Create controller with mocked dependencies
        $this->controller = new ObservationController(
            $this->mockObservationService,
            $this->mockFormService,
            $this->mockTwig
        );

        // Set the code types service
        $this->controller->setCodeTypesService($this->mockCodeTypesService);

        // Create mock request
        $this->mockRequest = $this->createMock(Request::class);
        $this->mockRequest->query = new InputBag([]);
        $this->mockRequest->request = new ParameterBag([]);

        // Backup and mock global session and variables
        $this->originalSession = $_SESSION ?? [];
        $this->globalsToRestore = [
            'webroot' => $GLOBALS['webroot'],
            'kernel' => $GLOBALS['kernel']
        ];

        $_SESSION = [
            'pid' => 1,
            'encounter' => 1,
            'authProvider' => 'testprovider',
            'authUser' => 'testuser',
            'userauthorized' => 1
        ];

        $GLOBALS['webroot'] = '/openemr';
        $GLOBALS['kernel'] = null;

        CsrfUtils::setupCsrfKey();
    }

    protected function tearDown(): void
    {
        parent::tearDown();
        $_SESSION = $this->originalSession;
        foreach ($this->globalsToRestore as $key => $value) {
            $GLOBALS[$key] = $value;
        }
    }

    // AI Generated: Test constructor with dependency injection
    public function testConstructorWithInjectedDependencies(): void
    {
        $controller = new ObservationController(
            $this->mockObservationService,
            $this->mockFormService,
            $this->mockTwig
        );

        $this->assertSame($this->mockObservationService, $controller->getObservationService());
        $this->assertSame($this->mockFormService, $controller->getFormService());
    }

    // AI Generated: Test constructor with default dependencies
    public function testConstructorWithDefaultDependencies(): void
    {
        $GLOBALS['kernel'] = $this->createMock(Kernel::class);
        $GLOBALS['kernel']->expects($this->atLeastOnce())
            ->method('getEventDispatcher')
            ->willReturn(new EventDispatcher());
        $controller = new ObservationController();
        $this->assertNotEmpty($controller->getObservationService());
        $this->assertNotEmpty($controller->getFormService());
    }

    // AI Generated: Test newAction method with new observation
    public function testNewActionWithNewObservation(): void
    {
        $this->mockRequest->query = new InputBag(['form_id' => 0, 'id' => 0]);

        // Mock service responses
        $mockTemplate = [
            'id' => 0,
            'code' => '',
            'description' => '',
            'ob_value' => '',
            'ob_unit' => '',
            'date' => date('Y-m-d H:i:s'),
            'observation' => ''
        ];

        $this->mockObservationService
            ->method('getNewObservationTemplate')
            ->willReturn($mockTemplate);

        $this->mockObservationService
            ->method('getObservationTypes')
            ->willReturn([['option_id' => 'vital-signs', 'title' => 'Vital Signs']]);

        $this->mockCodeTypesService
            ->method('collectCodeTypes')
            ->with('problem', 'csv')
            ->willReturn('ICD10,SNOMED');

        $this->mockTwig
            ->expects($this->once())
            ->method('render')
            ->willReturn('<html><body>New Observation Form</body></html>');

        $response = $this->controller->newAction($this->mockRequest);

        $this->assertEquals(Response::HTTP_OK, $response->getStatusCode());
        $this->assertStringContainsString('text/html', $response->headers->get('Content-Type'));
    }

    // AI Generated: Test newAction method with existing observation
    public function testNewActionWithExistingObservation(): void
    {
        $this->mockRequest->query = new InputBag(['id' => 123]);

        $mockObservation = [
            'id' => 123,
            'code' => 'TEST001',
            'description' => 'Test Observation',
            'ob_value' => '10',
            'ob_unit' => 'mg',
            'date' => '2024-01-01 10:00:00',
            'observation' => 'Test comment'
        ];

        $mockSubObservations = [
            ['id' => 124, 'parent_observation_id' => 123, 'code' => 'SUB-1']
        ];

        $this->mockObservationService
            ->method('getObservationById')
            ->with(123, 1)
            ->willReturn($mockObservation);

        $this->mockObservationService
            ->method('getSubObservations')
            ->with(123)
            ->willReturn($mockSubObservations);

        $this->mockObservationService
            ->method('getObservationTypes')
            ->willReturn([['option_id' => 'laboratory', 'title' => 'Laboratory']]);

        $this->mockCodeTypesService
            ->method('collectCodeTypes')
            ->willReturn('LOINC,CPT4');

        $this->mockTwig
            ->expects($this->once())
            ->method('render')
            ->willReturn('<html><body>Edit Observation Form</body></html>');

        $response = $this->controller->newAction($this->mockRequest);

        $this->assertEquals(Response::HTTP_OK, $response->getStatusCode());
    }

    // AI Generated: Test listAction method
    public function testListAction(): void
    {
        $this->mockRequest->query = new InputBag(['pid' => 1, 'encounter' => 1]);

        $mockObservations = [
            [
                'id' => 100,
                'code' => 'VITAL001',
                'description' => 'Blood Pressure',
                'date' => '2024-01-01 10:00:00',
                'sub_observations' => []
            ]
        ];

        $this->mockObservationService
            ->method('getAllObservationsForEncounter')
            ->with(1, 1)
            ->willReturn($mockObservations);

        $this->mockTwig
            ->expects($this->once())
            ->method('render')
            ->willReturn('<html><body>Observation List</body></html>');

        $response = $this->controller->listAction($this->mockRequest);

        $this->assertEquals(Response::HTTP_OK, $response->getStatusCode());
    }

    // AI Generated: Test listAction with service exception
    public function testListActionWithServiceException(): void
    {
        $this->mockRequest->query = new InputBag(['pid' => 1, 'encounter' => 1]);

        $this->mockObservationService
            ->method('searchObservations')
            ->will($this->throwException(new \Exception('Database error')));

        $response = $this->controller->listAction($this->mockRequest);

        $this->assertEquals(Response::HTTP_INTERNAL_SERVER_ERROR, $response->getStatusCode());
        $this->assertStringContainsString('error occurred loading', $response->getContent());
    }

    // AI Generated: Test save method with valid CSRF token
    public function testSaveWithValidCsrfToken(): void
    {
        $validToken = CsrfUtils::collectCsrfToken();

        $postData = [
            'csrf_token_form' => $validToken,
            'code' => ['TEST001'],
            'description' => ['Test Description'],
            'comments' => ['Test Comment'],
            'code_type' => ['LOINC'],
            'table_code' => ['LN'],
            'ob_value' => ['10'],
            'ob_unit' => ['mg'],
            'code_date' => ['2024-01-01'],
            'ob_type' => ['vital-signs'],
            'reasonCode' => [''],
            'reasonCodeStatus' => [''],
            'reasonCodeText' => [''],
            'code_date_end' => [''],
            'category' => ['physical']
        ];

        $this->mockRequest->query = new InputBag(['id' => 0]);
        $this->mockRequest->request = new ParameterBag($postData);

        // Mock validation and save operations
        $this->mockObservationService
            ->method('validateObservationData')
            ->willReturn([]);

        $this->mockObservationService
            ->method('getNextFormId')
            ->willReturn(200);

        $this->mockObservationService
            ->method('saveObservationWithSubObservations')
            ->willReturn(200);

        $this->mockTwig
            ->method('render')
            ->willReturn('<script>window.location.href = "success";</script>');

        $response = $this->controller->save($this->mockRequest);

        $this->assertEquals(Response::HTTP_OK, $response->getStatusCode());
        $this->assertStringContainsString('window.location.href', $response->getContent());
    }

    // AI Generated: Test save method with invalid CSRF token
    public function testSaveWithInvalidCsrfToken(): void
    {
        $postData = ['csrf_token_form' => 'invalid_token'];

        $this->mockRequest->request = new ParameterBag($postData);

        $response = $this->controller->save($this->mockRequest);

        $this->assertEquals(Response::HTTP_UNAUTHORIZED, $response->getStatusCode());
        $this->assertStringContainsString('Authentication Error', $response->getContent());
    }

    // AI Generated: Test save method with validation errors
    public function testSaveWithValidationErrors(): void
    {
        $validToken = CsrfUtils::collectCsrfToken();

        $postData = [
            'csrf_token_form' => $validToken,
            'code' => [''], // Invalid: empty code
            'description' => [''], // Invalid: empty description
        ];

        $this->mockRequest->query = new InputBag(['id' => 0]);
        $this->mockRequest->request = new ParameterBag($postData);

        $this->mockObservationService
            ->method('validateObservationData')
            ->willReturn(['Code is required', 'Description is required']);

        $response = $this->controller->save($this->mockRequest);

        $this->assertEquals(Response::HTTP_INTERNAL_SERVER_ERROR, $response->getStatusCode());
        $this->assertStringContainsString('error occurred saving', $response->getContent());
    }

    // AI Generated: Test save method with service exception
    public function testSaveWithServiceException(): void
    {
        $validToken = CsrfUtils::collectCsrfToken();

        $postData = [
            'csrf_token_form' => $validToken,
            'code' => ['TEST001'],
            'description' => ['Test Description']
        ];

        $this->mockRequest->query = new InputBag(['id' => 0]);
        $this->mockRequest->request = new ParameterBag($postData);

        $this->mockObservationService
            ->method('validateObservationData')
            ->willReturn([]);

        $this->mockObservationService
            ->method('saveObservationWithSubObservations')
            ->will($this->throwException(new \Exception('Database error')));

        $response = $this->controller->save($this->mockRequest);

        $this->assertEquals(Response::HTTP_INTERNAL_SERVER_ERROR, $response->getStatusCode());
        $this->assertStringContainsString('error occurred saving', $response->getContent());
    }

    // AI Generated: Test delete method
    public function testDeleteMethod(): void
    {
        $this->mockRequest->query = new InputBag([
            'id' => 123,
            'pid' => 1,
            'encounter' => 1
        ]);

        $this->mockObservationService
            ->expects($this->once())
            ->method('deleteObservationsByFormId')
            ->with(123, 1, 1);

        $response = $this->controller->delete($this->mockRequest);

        $this->assertEquals(Response::HTTP_OK, $response->getStatusCode());
        $this->assertStringContainsString('window.location.href', $response->getContent());
        $this->assertStringContainsString('/interface/forms/observation/observation_list.php', $response->getContent());
    }

    // AI Generated: Test delete method with exception
    public function testDeleteWithException(): void
    {
        $this->mockRequest->query = new InputBag(['id' => 123]);

        $this->mockObservationService
            ->method('deleteObservationsByFormId')
            ->will($this->throwException(new \Exception('Delete failed')));

        $response = $this->controller->delete($this->mockRequest);

        $this->assertEquals(Response::HTTP_INTERNAL_SERVER_ERROR, $response->getStatusCode());
        $this->assertStringContainsString('error occurred deleting', $response->getContent());
    }

    // AI Generated: Test report method with valid observation
    public function testReportWithValidObservation(): void
    {
        $mockObservations = [
            [
                'id' => 123,
                'code' => 'TEST001',
                'description' => 'Test Observation',
                'ob_value' => '10',
                'ob_unit' => 'mg'
            ]
        ];

        $mockFormattedObs = [
            [
                'id' => 123,
                'code' => 'TEST001',
                'description' => 'Test Observation',
                'ob_value' => '10',
                'ob_unit' => 'mg',
                'date' => '2024-01-01 10:00:00'
            ]
        ];

        $this->mockObservationService
            ->method('getObservationsByFormId')
            ->with(123, 1, 1)
            ->willReturn($mockObservations);

        $this->mockObservationService
            ->method('formatObservationForDisplay')
            ->willReturn($mockFormattedObs[0]);

        $this->mockTwig
            ->method('render')
            ->willReturn('<table><tr><td>Test Observation</td></tr></table>');

        $response = $this->controller->report(1, 1, 2, 123);

        $this->assertEquals(Response::HTTP_OK, $response->getStatusCode());
        $this->assertStringContainsString('<table>', $response->getContent());
    }

    // AI Generated: Test report method with no observation ID
    public function testReportWithNoObservationId(): void
    {
        $response = $this->controller->report(1, 1, 2, null);

        $this->assertEquals(Response::HTTP_OK, $response->getStatusCode());
        $this->assertEmpty($response->getContent());
    }

    // AI Generated: Test view method (delegates to newAction)
    public function testViewMethod(): void
    {
        $this->mockRequest->query = new InputBag(['id' => 123]);

        $mockObservation = [
            'id' => 123,
            'code' => 'TEST001',
            'description' => 'Test Observation'
        ];

        $this->mockObservationService
            ->method('getObservationById')
            ->willReturn($mockObservation);

        $this->mockObservationService
            ->method('getSubObservations')
            ->willReturn([]);

        $this->mockObservationService
            ->method('getObservationTypes')
            ->willReturn([]);

        $this->mockCodeTypesService
            ->method('collectCodeTypes')
            ->willReturn('');

        $this->mockTwig
            ->method('render')
            ->willReturn('<html><body>View Form</body></html>');

        $response = $this->controller->view($this->mockRequest);
        $this->assertEquals(Response::HTTP_OK, $response->getStatusCode());
    }

    // AI Generated: Test shouldShowListView method
    public function testShouldShowListViewWithNoIdOrFormId(): void
    {
        $this->mockRequest->query = new InputBag([]);

        $result = $this->controller->shouldShowListView($this->mockRequest);

        $this->assertFalse($result);
    }

    // AI Generated: Test shouldShowListView with only id provided
    public function testShouldShowListViewWithOnlyId(): void
    {
        $this->mockRequest->query = new InputBag(['id' => 123, 'form_id' => 0]);

        $result = $this->controller->shouldShowListView($this->mockRequest);

        $this->assertTrue($result);
    }

    // AI Generated: Test shouldShowListView with form_id provided
    public function testShouldShowListViewWithFormId(): void
    {
        $this->mockRequest->query = new InputBag(['id' => 0, 'form_id' => 123]);

        $result = $this->controller->shouldShowListView($this->mockRequest);

        $this->assertFalse($result);
    }

    // AI Generated: Test shouldShowListView with both id and form_id
    public function testShouldShowListViewWithBothIds(): void
    {
        $this->mockRequest->query = new InputBag(['id' => 123, 'form_id' => 456]);

        $result = $this->controller->shouldShowListView($this->mockRequest);

        $this->assertFalse($result);
    }

    // AI Generated: Test response headers are properly set
    public function testResponseHeadersAreProperlySet(): void
    {
        $this->mockRequest->query = new InputBag([]);

        $this->mockObservationService->method('getNewObservationTemplate')->willReturn([
            'id' => 0
        ]);
        $this->mockObservationService->method('getObservationTypes')->willReturn([]);
        $this->mockCodeTypesService->method('collectCodeTypes')->willReturn('');
        $this->mockTwig->method('render')->willReturn('<html><body>Test</body></html>');

        $response = $this->controller->newAction($this->mockRequest);

        $this->assertTrue($response->headers->has('Content-Type'));
        $this->assertStringContainsString('text/html', $response->headers->get('Content-Type'));
        $this->assertStringContainsString('charset=utf-8', $response->headers->get('Content-Type'));
    }

    // AI Generated: Test processing sub-observations data extraction
    public function testExtractSubObservationsData(): void
    {
        $validToken = CsrfUtils::collectCsrfToken();

        $postData = [
            'csrf_token_form' => $validToken,
            'code' => ['MAIN001'],
            'description' => ['Main Observation'],
            'sub_ob_value' => ['10', '20'],
            'sub_ob_unit' => ['mg', 'ml'],
            'sub_description' => ['Sub Obs 1', 'Sub Obs 2'],
            'code_date' => ['2024-01-01']
        ];

        $this->mockRequest->query = new InputBag(['id' => 0]);
        $this->mockRequest->request = new ParameterBag($postData);

        $this->mockObservationService->method('validateObservationData')->willReturn([]);
        $this->mockObservationService->method('getNextFormId')->willReturn(100);

        // Capture the arguments passed to saveObservationWithSubObservations
        $capturedMainData = null;
        $capturedSubData = null;

        $this->mockObservationService
            ->method('saveObservationWithSubObservations')
            ->willReturnCallback(function($mainData, $subData) use (&$capturedMainData, &$capturedSubData) {
                $capturedMainData = $mainData;
                $capturedSubData = $subData;
                return 100;
            });

        $this->mockTwig->method('render')->willReturn('<script>success</script>');

        $this->controller->save($this->mockRequest);

        // Verify sub-observations were extracted correctly
        $this->assertNotNull($capturedSubData);
        $this->assertCount(2, $capturedSubData);
        $this->assertEquals('10', $capturedSubData[0]['ob_value']);
        $this->assertEquals('mg', $capturedSubData[0]['ob_unit']);
        $this->assertEquals('Sub Obs 1', $capturedSubData[0]['description']);
        $this->assertEquals('SUB-1', $capturedSubData[0]['code']);
    }

    // AI Generated: Test CodeTypesService integration
    public function testCodeTypesServiceIntegration(): void
    {
        $this->controller->setCodeTypesService($this->mockCodeTypesService);

        $retrievedService = $this->controller->getCodeTypesService();

        $this->assertSame($this->mockCodeTypesService, $retrievedService);
    }

    // AI Generated: Integration test for full workflow without database
    public function testFullWorkflowIntegration(): void
    {
        // This tests the complete workflow without hitting the database
        $this->mockRequest->query = new InputBag(['id' => 0]);

        // Mock all required service calls
        $this->mockObservationService->method('getNewObservationTemplate')->willReturn([
            'id' => 0, 'code' => '', 'description' => '', 'ob_value' => ''
        ]);
        $this->mockObservationService->method('getObservationTypes')->willReturn([
            ['option_id' => 'vital-signs', 'title' => 'Vital Signs']
        ]);
        $this->mockCodeTypesService->method('collectCodeTypes')->willReturn('LOINC,SNOMED');
        $this->mockTwig->method('render')->willReturn('<html>Rendered Form</html>');

        // Test new action
        $newResponse = $this->controller->newAction($this->mockRequest);
        $this->assertEquals(Response::HTTP_OK, $newResponse->getStatusCode());

        // Test view action (delegates to new)
        $viewResponse = $this->controller->view($this->mockRequest);
        $this->assertEquals(Response::HTTP_OK, $viewResponse->getStatusCode());

        // Test report action
        $reportResponse = $this->controller->report(1, 1, 2, 0);
        $this->assertEquals(Response::HTTP_OK, $reportResponse->getStatusCode());
        $this->assertEmpty($reportResponse->getContent()); // No ID provided
    }
}
// AI Generated: End of rebuilt ObservationControllerTest class
