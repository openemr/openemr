<?php

/*
 * ObservationControllerTest Tests the ObservationController class
 *
 * @package openemr
 * @link      http://www.open-emr.org
 * @author    Claude.AI on August 21st 2025
 * @author    Stephen Nielson <snielson@discoverandchange.com>
 * @copyright Public Domain for the pieces that were generated by Claude.AI (refactor from interface/forms/observation) view.php,new.php,save.php
 * @license   https://github.com/openemr/openemr/blob/master/LICENSE GNU General Public License 3
 */

// AI Generated: Refactored from interface/forms/observation/view.php,new.php,save.php
namespace OpenEMR\Tests\Unit\Controllers\Interface\Forms\Observation;

use OpenEMR\Common\Csrf\CsrfUtils;
use PHPUnit\Framework\TestCase;
use PHPUnit\Framework\MockObject\MockObject;
use OpenEMR\Controllers\Interface\Forms\Observation\ObservationController;
use OpenEMR\Services\ObservationService;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpFoundation\InputBag;
use Symfony\Component\HttpFoundation\Request;
use PHPUnit\Framework\MockObject\Exception;

class ObservationControllerTest extends TestCase
{
    private ObservationController $controller;
    private MockObject&ObservationService $mockService;
    private MockObject&Request $mockRequest;

    private array $originalSession;

    /**
     * @return void
     * @throws Exception
     */
    protected function setUp(): void
    {
        $this->mockService = $this->createMock(ObservationService::class);
        $this->controller = new ObservationController($this->mockService);
        $this->mockRequest = $this->createMock(Request::class);
        $this->mockRequest->query = new InputBag([]);

        // TODO: @adunsulag change this when we have the ability to mock global session
        $this->originalSession = $_SESSION;
        // Mock global session data that would normally be set by OpenEMR
        $_SESSION = [
            'pid' => 1,
            'encounter' => 1,
            'authProvider' => 'testprovider',
            'authUser' => 'testuser'
        ];
        CsrfUtils::setupCsrfKey();
    }

    protected function tearDown(): void
    {
        parent::tearDown();
        // restore session...
        $_SESSION = $this->originalSession;
    }

    public function testNewWithoutFormId(): void
    {
        // make sure no form ID is set
        $this->mockRequest->query = new InputBag([]);

        // Mock service to return empty observations
        $this->mockService->method('getObservationsByFormId')
            ->willReturn([]);

        $this->mockService->method('getObservationTypes')
            ->willReturn([
                ['option_id' => 'type1', 'title' => 'Type 1'],
                ['option_id' => 'type2', 'title' => 'Type 2']
            ]);

        $response = $this->controller->new($this->mockRequest);

        $this->assertEquals(200, $response->getStatusCode());
        $this->assertStringContainsString('text/html', $response->headers->get('Content-Type'));
    }

    public function testNewWithFormId(): void
    {
        $formId = 123;
        $mockObservations = [
            [
                'id' => 1,
                'code' => 'TEST001',
                'description' => 'Test Description',
                'ob_value' => 'Test Value',
                'ob_unit' => 'mg',
                'date' => '2024-01-01'
            ]
        ];

        // Mock request with form ID
        $this->mockRequest->query = new InputBag(['id' => $formId]);

        // Mock service to return observations
        $this->mockService->expects($this->once())
            ->method('getObservationsByFormId')
            ->with($formId, 1, 1)
            ->willReturn($mockObservations);

        $this->mockService->method('getObservationTypes')
            ->willReturn([]);

        $response = $this->controller->new($this->mockRequest);
        $this->assertEquals(200, $response->getStatusCode());
    }

    public function testViewDelegatesToNew(): void
    {
        $this->mockService->method('getObservationsByFormId')->willReturn([]);
        $this->mockService->method('getObservationTypes')->willReturn([]);

        $newResponse = $this->controller->new($this->mockRequest);
        $viewResponse = $this->controller->view($this->mockRequest);
        $this->assertEquals($newResponse->getStatusCode(), $viewResponse->getStatusCode());
    }

    public function testReportWithValidId(): void
    {
        $mockObservations = [
            [
                'id' => 1,
                'code' => 'TEST001',
                'description' => 'Test Description',
                'code_type' => 'LOINC',
                'table_code' => 'LN',
                'ob_value' => 'Test Value',
                'ob_unit' => 'mg',
                'date' => '2024-01-01'
            ]
        ];

        $this->mockRequest->query = new InputBag([
            'id' => 1,
            'cols' => 'all'
        ]);

        $this->mockService->expects($this->once())
            ->method('getObservationsByFormId')
            ->with(1, 1, 1)
            ->willReturn($mockObservations);

        $this->mockService->expects($this->once())
            ->method('formatObservationForDisplay')
            ->with($mockObservations[0])
            ->willReturn($mockObservations[0]);

        $response = $this->controller->report(1, 1, 2, 1);

        $this->assertEquals(200, $response->getStatusCode());

        $content = $response->getContent();
        $this->assertStringContainsString('<table', $content);
        $this->assertStringContainsString('TEST001', $content);
    }

    public function testReportWithoutId(): void
    {
        // Service methods should not be called when no ID is provided
        $this->mockService->expects($this->never())->method('getObservationsByFormId');
        $this->mockService->expects($this->never())->method('formatObservationForDisplay');

        $response = $this->controller->report(1, 1, 2, null);

        $this->assertEquals(200, $response->getStatusCode());

        $content = $response->getContent();
        $this->assertEmpty($content);
    }

    public function testSaveNewForm(): void
    {
        global $encounter, $userauthorized, $attendant_type;
        $attendant_type = 'pid';
        $encounter = 1;
        $userauthorized = 1;

        $postData = [
            'csrf_token_form' => CsrfUtils::collectCsrfToken(),
            'code' => ['TEST001'],
            'description' => ['Test Description'],
            'comments' => ['Test Comment'],
            'code_type' => ['LOINC'],
            'table_code' => ['LN'],
            'ob_value' => ['Test Value'],
            'ob_unit' => ['mg'],
            'code_date' => ['2024-01-01'],
            'ob_type' => ['type1'],
            'reasonCode' => [''],
            'reasonCodeStatus' => [''],
            'reasonCodeText' => [''],
            'code_date_end' => [''],
            'ob_value_phin' => ['']
        ];

        $this->mockRequest->query = new InputBag(['id' => 0]);
        $this->mockRequest->method('getPayload')->willReturn(new InputBag($postData));

        // Mock the next form ID
        $this->mockService->expects($this->once())
            ->method('getNextFormId')
            ->willReturn(123);

        // Mock the save operation
        $this->mockService->expects($this->once())
            ->method('saveObservation')
            ->with($this->callback(function ($data) {
                return $data['id'] === 123
                    && $data['code'] === 'TEST001'
                    && $data['description'] === 'Test Description';
            }));

        // We need to mock the CSRF verification and global functions
        // In a real test environment, these would be properly mocked

        $response = $this->controller->save($this->mockRequest);

        $this->assertEquals(Response::HTTP_OK, $response->getStatusCode(), "Status should have been successful");
    }

    public function testSaveExistingForm(): void
    {
        global $encounter, $userauthorized;
        $encounter = 1;
        $userauthorized = 1;

        $formId = 456;
        $postData = [
            'csrf_token_form' => CsrfUtils::collectCsrfToken(),
            'code' => ['TEST002'],
            'description' => ['Updated Description'],
            'comments' => ['Updated Comment'],
            'code_type' => ['LOINC'],
            'table_code' => ['LN'],
            'ob_value' => ['Updated Value'],
            'ob_unit' => ['kg'],
            'code_date' => ['2024-01-02'],
            'ob_type' => ['type2'],
            'reasonCode' => [''],
            'reasonCodeStatus' => [''],
            'reasonCodeText' => [''],
            'code_date_end' => [''],
            'ob_value_phin' => ['']
        ];

        $this->mockRequest->query = new InputBag(['id' => $formId]);
        $this->mockRequest->method('getPayload')->willReturn(new InputBag($postData));

        // Mock the delete operation for existing form
        $this->mockService->expects($this->once())
            ->method('deleteObservationsByFormId')
            ->with($formId, 1, 1);

        // Mock the save operation
        $this->mockService->expects($this->once())
            ->method('saveObservation')
            ->with($this->callback(function ($data) use ($formId) {
                return $data['id'] === $formId
                    && $data['code'] === 'TEST002'
                    && $data['description'] === 'Updated Description';
            }));

        $response = $this->controller->save($this->mockRequest);
        $this->assertEquals(Response::HTTP_OK, $response->getStatusCode(), "Status should have been successful");
    }

    public function testProcessObservationUnitSS003(): void
    {
        $postData = [
            'csrf_token_form' => 'valid_token',
            'code' => ['SS003'],
            'description' => ['SS003 Description'],
            'comments' => ['SS003 Comment'],
            'code_type' => ['PHINQUESTION'],
            'table_code' => ['PHINQUESTION'],
            'ob_value' => ['should_be_ignored'],
            'ob_unit' => ['should_be_empty'],
            'code_date' => ['2024-01-01'],
            'ob_type' => ['type1'],
            'reasonCode' => [''],
            'reasonCodeStatus' => [''],
            'reasonCodeText' => [''],
            'code_date_end' => [''],
            'ob_value_phin' => ['261QE0002X']
        ];

        // Mock service methods that would be called during processing
        $this->mockService->method('processObservationUnit')
            ->with('SS003', $postData['ob_unit'], $postData['ob_value_phin'], 0)
            ->willReturn('');

        $this->mockService->method('processObservationValue')
            ->with('SS003', $postData['ob_value'], $postData['ob_value_phin'], 0)
            ->willReturn('261QE0002X');

        // Test that the service methods are called with correct parameters
        $result1 = $this->mockService->processObservationUnit('SS003', $postData['ob_unit'], $postData['ob_value_phin'], 0);
        $result2 = $this->mockService->processObservationValue('SS003', $postData['ob_value'], $postData['ob_value_phin'], 0);

        $this->assertEquals('', $result1);
        $this->assertEquals('261QE0002X', $result2);
    }

    public function testProcessObservation21612(): void
    {
        $postData = [
            'code' => ['21612-7'],
            'ob_unit' => ['d', 'mo'],
            'ob_value' => ['5', '10'],
            'ob_value_phin' => ['', '']
        ];

        // Mock service methods
        $this->mockService->method('processObservationUnit')
            ->with('21612-7', $postData['ob_unit'], $postData['ob_value_phin'], 1)
            ->willReturn('mo');

        $this->mockService->method('processObservationValue')
            ->with('21612-7', $postData['ob_value'], $postData['ob_value_phin'], 1)
            ->willReturn('10');

        $result1 = $this->mockService->processObservationUnit('21612-7', $postData['ob_unit'], $postData['ob_value_phin'], 1);
        $result2 = $this->mockService->processObservationValue('21612-7', $postData['ob_value'], $postData['ob_value_phin'], 1);

        $this->assertEquals('mo', $result1);
        $this->assertEquals('10', $result2);
    }

    public function testGetValueFieldStyleSS003(): void
    {
        // Use reflection to test private method
        $reflection = new \ReflectionClass($this->controller);
        $method = $reflection->getMethod('getValueFieldStyle');
        $method->setAccessible(true);

        $result = $method->invoke($this->controller, 'SS003');
        $this->assertEquals('display: none;', $result);
    }

    public function testGetValueFieldStyleRegular(): void
    {
        $reflection = new \ReflectionClass($this->controller);
        $method = $reflection->getMethod('getValueFieldStyle');
        $method->setAccessible(true);

        $result = $method->invoke($this->controller, 'REGULAR');
        $this->assertEquals('display: block;', $result);
    }

    public function testGetUnitFieldStyleSS003(): void
    {
        $reflection = new \ReflectionClass($this->controller);
        $method = $reflection->getMethod('getUnitFieldStyle');
        $method->setAccessible(true);

        $result = $method->invoke($this->controller, 'SS003');
        $this->assertEquals('display: none;', $result);
    }

    public function testGetUnitFieldStyle8661(): void
    {
        $reflection = new \ReflectionClass($this->controller);
        $method = $reflection->getMethod('getUnitFieldStyle');
        $method->setAccessible(true);

        $result = $method->invoke($this->controller, '8661-1');
        $this->assertEquals('display: none;', $result);
    }

    public function testGetUnitFieldStyleRegular(): void
    {
        $reflection = new \ReflectionClass($this->controller);
        $method = $reflection->getMethod('getUnitFieldStyle');
        $method->setAccessible(true);

        $result = $method->invoke($this->controller, 'REGULAR');
        $this->assertEquals('display: block;', $result);
    }

    public function testResponseHeaders(): void
    {
        $this->mockService->method('getObservationsByFormId')->willReturn([]);
        $this->mockService->method('getObservationTypes')->willReturn([]);

        $response = $this->controller->new($this->mockRequest);

        $this->assertTrue($response->headers->has('Content-Type'));
        $this->assertStringContainsString('text/html', $response->headers->get('Content-Type'));
        $this->assertStringContainsString('charset=utf-8', $response->headers->get('Content-Type'));
    }

    public function testResponseBodyContent(): void
    {
        $this->mockService->method('getObservationsByFormId')->willReturn([]);
        $this->mockService->method('getObservationTypes')->willReturn([
            ['option_id' => 'test_type', 'title' => 'Test Type']
        ]);

        $response = $this->controller->new($this->mockRequest);
        $content = $response->getContent();

        // Verify HTML structure
        $this->assertStringContainsString('<html>', $content);
        $this->assertStringContainsString('<head>', $content);
        $this->assertStringContainsString('<body>', $content);
        $this->assertStringContainsString('<form', $content);
        $this->assertStringContainsString('Observation', $content);
    }

    public function testControllerConstructorWithoutService(): void
    {
        // Test constructor without injected service (uses default)
        $controller = new ObservationController();
        $this->assertNotEmpty($controller->getObservationService());
        $this->assertNotEmpty($controller->getFormService());
    }

    /**
     * Integration-style test to verify the full workflow
     */
    public function testFullWorkflowStructure(): void
    {
        // This would be an integration test in a real environment
        // For now, we just verify the methods exist and can be called

        $this->mockRequest->method('getPayload')->willReturn(new InputBag([
            'csrf_token_form' => 'test_token',
            'code' => [],
            'description' => []
        ]));

        $this->mockService->method('getObservationsByFormId')->willReturn([]);
        $this->mockService->method('getObservationTypes')->willReturn([]);

        // Test that all controller methods return Response
        $newResponse = $this->controller->new($this->mockRequest);
        $viewResponse = $this->controller->view($this->mockRequest);
        $reportResponse = $this->controller->report(1, 1, 2, 1);

        $this->assertEquals(Response::HTTP_OK, $newResponse->getStatusCode());
        $this->assertEquals(Response::HTTP_OK, $viewResponse->getStatusCode());
        $this->assertEquals(Response::HTTP_OK, $reportResponse->getStatusCode());
    }
}
// End of AI Generated Code
